import { div, mod } from "./helpers.js";
const defaultYear = 2020;
const defaultMonth = 1;
const defaultDay = 1;
export function newDateTime(args) {
    constraintDayOfMonth(args.year ?? defaultYear, args.month ?? defaultMonth, args.day ?? defaultDay);
    const tmp = normalizeSecond(args.year ?? defaultYear, args.month ?? defaultMonth, args.day ?? defaultDay, args.hour ?? 0, args.minute ?? 0, args.second ?? 0, args.fraction ?? "");
    return {
        year: args.year === null || args.year === undefined ? undefined : tmp.year,
        month: args.month === null || args.month === undefined ? undefined : tmp.month,
        day: args.day === null || args.day === undefined ? undefined : tmp.day,
        hour: args.hour === null || args.hour === undefined ? undefined : tmp.hour,
        minute: args.minute === null || args.minute === undefined ? undefined : tmp.minute,
        second: args.second === null || args.second === undefined ? undefined : tmp.second,
        fraction: args.fraction === null || args.fraction === undefined ? undefined : tmp.fraction,
        timezone: args.timezone ?? undefined,
    };
}
function constraintDayOfMonth(year, month, day) {
    if (day > 30 && [4, 6, 9, 11].includes(month)) {
        throw RangeError(`Day ${day} is not valid in month ${month}.`);
    }
    const divisible = (y) => mod(year, y) === 0;
    if ((day > 28 && month === 2 && (!divisible(4) || (divisible(100) && !divisible(400)))) ||
        (day > 29 && month === 2 && (divisible(400) || (divisible(4) && !divisible(100))))) {
        throw RangeError(`Day ${day} is not valid in year/month ${year}-${month}.`);
    }
    return;
}
function daysInMonth(year, month) {
    const divisible = (y) => mod(year, y) === 0;
    if (month === 2 && (!divisible(4) || (divisible(100) && !divisible(400)) || !year)) {
        return 28;
    }
    else if (month === 2 && (divisible(400) || (divisible(4) && !divisible(100)))) {
        return 29;
    }
    else if ([4, 6, 9, 11].includes(month)) {
        return 30;
    }
    else {
        return 31;
    }
}
function normalizeDay(year, month, day) {
    let [_year, _month] = normalizeMonth(year, month);
    while (day < 0 || day > daysInMonth(_year, _month)) {
        const _daysInMonth = daysInMonth(_year, _month);
        if (day > _daysInMonth) {
            day -= _daysInMonth;
            const tmp = normalizeMonth(_year, ++_month);
            _year = tmp[0];
            _month = tmp[1];
        }
        if (day <= 0) {
            day += _daysInMonth;
            const tmp = normalizeMonth(_year, --_month);
            _year = tmp[0];
            _month = tmp[1];
        }
    }
    return {
        year: _year,
        month: _month,
        day: day,
    };
}
function normalizeMinute(year, month, day, hour, minute) {
    const _hour = hour + div(minute, 60);
    return {
        ...normalizeDay(year, month, day + div(_hour, 24)),
        hour: mod(_hour, 24),
        minute: mod(minute, 60),
    };
}
function normalizeMonth(year, month) {
    return [year + div(month - 1, 12), mod(month - 1, 12) + 1];
}
function normalizeSecond(year, month, day, hour, minute, second, fraction) {
    return {
        ...normalizeMinute(year, month, day, hour, minute + div(second, 60)),
        second: mod(second, 60),
        fraction,
    };
}
export function unsignedTwoDigitFragmentToCanonical(i) {
    return digit(div(i, 10)) + digit(mod(i, 10));
}
function digit(i) {
    switch (i) {
        case 0:
            return "0";
        case 1:
            return "1";
        case 2:
            return "2";
        case 3:
            return "3";
        case 4:
            return "4";
        case 5:
            return "5";
        case 6:
            return "6";
        case 7:
            return "7";
        case 8:
            return "8";
        case 9:
            return "9";
        default:
            throw new Error(`Unanticipated value: i=${i}.`);
    }
}
//# sourceMappingURL=dateTimeHelpers.js.map