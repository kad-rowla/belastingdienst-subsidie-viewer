import { Lexer, EmbeddedActionsParser, TokenType } from "chevrotain";
type GeometryTypeInfo = Pick<Geometry, "hasZ" | "hasMeasurement">;
export declare class WktParser extends EmbeddedActionsParser {
    geometryTypeInfo: GeometryTypeInfo;
    private pointToken;
    private geometryTypeToken;
    private geometry_tagged_text_list;
    constructor(opts: {
        geometryTypeInfo: GeometryTypeInfo;
        pointToken: TokenType;
        geometryTypeToken: TokenType | undefined;
    });
    geometry: import("chevrotain").ParserMethod<[], Geometry>;
    private crs_def;
    private point;
    private geometry_tagged_text;
    private point_tagged_text;
    private linestring_tagged_text;
    private polygon_tagged_text;
    private polyhedralsurface_tagged_text;
    private triangle_tagged_text;
    private tin_tagged_text;
    private multipoint_tagged_text;
    private multilinestring_tagged_text;
    private multipolygon_tagged_text;
    private geometrycollection_tagged_text;
    private point_text;
    private linestring_text;
    private polygon_text;
    private polyhedralsurface_text;
    private multipoint_text;
    private multilinestring_text;
    private multipolygon_text;
    private geometrycollection_text;
}
export declare const parser_3d_m: {
    lexer: Lexer;
    parser: WktParser;
};
export declare const parser_3d: {
    lexer: Lexer;
    parser: WktParser;
};
export declare const parser_m: {
    lexer: Lexer;
    parser: WktParser;
};
export declare const parser_2d: {
    lexer: Lexer;
    parser: WktParser;
};
export declare function getParserForLexicalValue(lexicalValue: string): {
    lexer: Lexer;
    parser: WktParser;
};
export declare const WktLiteralDatatype = "http://www.opengis.net/ont/geosparql#wktLiteral";
export type Geometry = Point | LineString | Polygon | Triangle | PolyhedralSurface | Tin | MultiPoint | MultiPolygon | MultiLineString | GeometryCollection;
export type GeometryWithoutCrs = Omit<Point, "crs"> | Omit<LineString, "crs"> | Omit<Polygon, "crs"> | Omit<Triangle, "crs"> | Omit<PolyhedralSurface, "crs"> | Omit<Tin, "crs"> | Omit<MultiPoint, "crs"> | Omit<MultiPolygon, "crs"> | Omit<GeometryCollection, "crs">;
export type Coordinates = [number, number, number?, number?];
export interface Point {
    type: "Point";
    hasMeasurement?: true;
    hasZ?: true;
    crs: string;
    coordinates: Coordinates | [];
}
export interface LineString {
    type: "LineString";
    hasMeasurement?: true;
    hasZ?: true;
    crs: string;
    coordinates: Array<Coordinates>;
}
export interface Polygon {
    type: "Polygon";
    hasMeasurement?: true;
    hasZ?: true;
    crs: string;
    coordinates: Array<LineString["coordinates"]>;
}
export interface PolyhedralSurface {
    type: "PolyhedralSurface";
    hasMeasurement?: true;
    hasZ?: true;
    crs: string;
    coordinates: Array<Polygon["coordinates"]>;
}
export interface Triangle {
    type: "Triangle";
    hasMeasurement?: true;
    hasZ?: true;
    crs: string;
    coordinates: Array<LineString["coordinates"]>;
}
export interface MultiPoint {
    type: "MultiPoint";
    hasMeasurement?: true;
    hasZ?: true;
    crs: string;
    coordinates: Array<Coordinates>;
}
export interface MultiLineString {
    type: "MultiLineString";
    hasMeasurement?: true;
    hasZ?: true;
    crs: string;
    coordinates: Array<LineString["coordinates"]>;
}
export interface MultiPolygon {
    type: "MultiPolygon";
    hasMeasurement?: true;
    hasZ?: true;
    crs: string;
    coordinates: Array<Polygon["coordinates"]>;
}
export interface Tin {
    type: "Tin";
    hasMeasurement?: true;
    hasZ?: true;
    crs: string;
    coordinates: Array<Polygon["coordinates"]>;
}
export interface GeometryCollection {
    type: "GeometryCollection";
    hasMeasurement?: true;
    hasZ?: true;
    crs: string;
    geometries: Array<GeometryWithoutCrs>;
}
export declare const DEFAULT_CRS = "http://www.opengis.net/def/crs/OGC/1.3/CRS84";
export declare function lexicalToValue(lexicalValue: string): Geometry;
export declare function valueToLexical(geometry: Geometry | GeometryWithoutCrs): string;
declare const parseAndSerialize: {
    "http://www.opengis.net/ont/geosparql#wktLiteral": {
        parse: typeof lexicalToValue;
        serialize: typeof valueToLexical;
    };
};
export default parseAndSerialize;
//# sourceMappingURL=wkt.d.ts.map