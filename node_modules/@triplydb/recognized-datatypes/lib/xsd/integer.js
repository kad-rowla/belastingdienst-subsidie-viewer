import { EmbeddedActionsParser, Lexer } from "chevrotain";
import { Digit, Sign, Dot } from "./tokens.js";
import { ValueRangeError } from "../Errors.js";
const tokens = [Sign, Digit, Dot];
export class IntegerParser extends EmbeddedActionsParser {
    constructor() {
        super(tokens, { maxLookahead: 2 });
        this.performSelfAnalysis();
    }
    noDecimalPtNumeral = this.RULE("noDecimalPtNumeral", () => {
        let value = this.OPTION(() => this.CONSUME(Sign))?.image ?? "";
        this.AT_LEAST_ONE(() => (value += this.CONSUME(Digit).image));
        return value;
    });
    byte = this.RULE("byte", () => {
        const result = this.SUBRULE(this.noDecimalPtNumeral);
        this.ACTION(() => validateByte(result));
        return result;
    });
    integer = this.RULE("integer", () => {
        const result = this.SUBRULE(this.noDecimalPtNumeral);
        this.ACTION(() => validateInteger(result));
        return result;
    });
    int = this.RULE("int", () => {
        const result = this.SUBRULE(this.noDecimalPtNumeral);
        this.ACTION(() => validateInt(result));
        return result;
    });
    long = this.RULE("long", () => {
        const result = this.SUBRULE(this.noDecimalPtNumeral);
        this.ACTION(() => validateLong(result));
        return result;
    });
    negativeInteger = this.RULE("negativeInteger", () => {
        const result = this.SUBRULE(this.noDecimalPtNumeral);
        this.ACTION(() => validateNegativeInteger(result));
        return result;
    });
    nonNegativeInteger = this.RULE("nonNegativeInteger", () => {
        const result = this.SUBRULE(this.noDecimalPtNumeral);
        this.ACTION(() => validateNonNegativeInteger(result));
        return result;
    });
    nonPositiveInteger = this.RULE("nonPositiveInteger", () => {
        const result = this.SUBRULE(this.noDecimalPtNumeral);
        this.ACTION(() => validateNonPositiveInteger(result));
        return result;
    });
    positiveInteger = this.RULE("positiveInteger", () => {
        const result = this.SUBRULE(this.noDecimalPtNumeral);
        this.ACTION(() => validatePositiveInteger(result));
        return result;
    });
    short = this.RULE("short", () => {
        const result = this.SUBRULE(this.noDecimalPtNumeral);
        this.ACTION(() => validateShort(result));
        return result;
    });
    unsignedByte = this.RULE("unsignedByte", () => {
        const result = this.SUBRULE(this.noDecimalPtNumeral);
        this.ACTION(() => validateUnsignedByte(result));
        return result;
    });
    unsignedInt = this.RULE("unsignedInt", () => {
        const result = this.SUBRULE(this.noDecimalPtNumeral);
        this.ACTION(() => validateUnsignedInt(result));
        return result;
    });
    unsignedLong = this.RULE("unsignedLong", () => {
        const result = this.SUBRULE(this.noDecimalPtNumeral);
        this.ACTION(() => validateUnsignedLong(result));
        return result;
    });
    unsignedShort = this.RULE("unsignedShort", () => {
        const result = this.SUBRULE(this.noDecimalPtNumeral);
        this.ACTION(() => validateUnsignedShort(result));
        return result;
    });
}
export const lexer = new Lexer(tokens, {
    ensureOptimizations: true,
    positionTracking: "onlyOffset",
});
export const parser = new IntegerParser();
const BYTE_MAX = 127;
const BYTE_MIN = -128;
const INT_MAX = 2147483647;
const INT_MIN = -2147483648;
const LONG_MAX = BigInt("9223372036854775807");
const LONG_MIN = BigInt("-9223372036854775808");
const SHORT_MAX = 32767;
const SHORT_MIN = -32768;
const UNSIGNED_BYTE_MAX = 255;
const UNSIGNED_INT_MAX = 4294967295;
const UNSIGNED_LONG_MAX = BigInt("18446744073709551615");
const UNSIGNED_SHORT_MAX = 65535;
function validateInteger(value) {
    if (!Number.isInteger(+value))
        throw new ValueRangeError({ value: value });
}
function validateLong(value) {
    validateInteger(value);
    if (!(BigInt(value) <= LONG_MAX && BigInt(value) >= LONG_MIN))
        throw new ValueRangeError({ value: value });
}
function validateInt(value) {
    validateLong(value);
    if (!(+value <= INT_MAX && +value >= INT_MIN))
        throw new ValueRangeError({ value: value });
}
function validateShort(value) {
    validateInt(value);
    if (!(+value <= SHORT_MAX && +value >= SHORT_MIN))
        throw new ValueRangeError({ value: value });
}
function validateByte(value) {
    validateShort(value);
    if (!(+value <= BYTE_MAX && +value >= BYTE_MIN))
        throw new ValueRangeError({ value: value });
}
function validateNonNegativeInteger(value) {
    validateInteger(value);
    if (!(+value >= 0))
        throw new ValueRangeError({ value: value });
}
function validatePositiveInteger(value) {
    validateNonNegativeInteger(value);
    if (!(+value !== 0))
        throw new ValueRangeError({ value: value });
}
function validateUnsignedInt(value) {
    validateNonNegativeInteger(value);
    if (!(+value <= UNSIGNED_INT_MAX))
        throw new ValueRangeError({ value: value });
}
function validateUnsignedShort(value) {
    validateUnsignedInt(value);
    if (!(+value <= UNSIGNED_SHORT_MAX))
        throw new ValueRangeError({ value: value });
}
function validateUnsignedByte(value) {
    validateUnsignedShort(value);
    if (!(+value <= UNSIGNED_BYTE_MAX))
        throw new ValueRangeError({ value: value });
}
function validateUnsignedLong(value) {
    validateNonNegativeInteger(value);
    if (!(+value <= UNSIGNED_LONG_MAX))
        throw new ValueRangeError({ value: value });
}
function validateNonPositiveInteger(value) {
    validateInteger(value);
    if (!(+value <= 0))
        throw new ValueRangeError({ value: value });
}
function validateNegativeInteger(value) {
    validateNonPositiveInteger(value);
    if (!(+value !== 0))
        throw new ValueRangeError({ value: value });
}
//# sourceMappingURL=integer.js.map