import { EmbeddedActionsParser, Lexer } from "chevrotain";
import { Digit, Sign, Dot, Exponential, Inf, Nan } from "./tokens.js";
const tokens = [Sign, Digit, Dot, Exponential, Inf, Nan];
export class DecimalParser extends EmbeddedActionsParser {
    constructor() {
        super(tokens, { maxLookahead: 2 });
        this.performSelfAnalysis();
    }
    decimalLexicalRep = this.RULE("decimalLexicalRep", () => {
        let returnValue = this.OPTION1(() => this.CONSUME(Sign))?.image || "";
        this.OR([
            {
                ALT: () => {
                    returnValue += this.CONSUME1(Dot).image;
                    this.AT_LEAST_ONE1(() => (returnValue += this.CONSUME1(Digit).image));
                },
            },
            {
                ALT: () => {
                    this.AT_LEAST_ONE2(() => (returnValue += this.CONSUME2(Digit).image));
                    this.OPTION2(() => {
                        returnValue += this.CONSUME2(Dot).image;
                        this.MANY(() => (returnValue += this.CONSUME3(Digit).image));
                    });
                },
            },
        ]);
        return returnValue;
    });
    sharedFloatAndDouble = this.RULE("sharedFloatAndDouble", () => {
        let returnValue = this.OPTION1(() => this.CONSUME1(Sign))?.image || "";
        let infinityOrNan = "";
        this.OR([
            {
                ALT: () => {
                    this.AT_LEAST_ONE1(() => (infinityOrNan += this.CONSUME(Inf).image));
                },
            },
            {
                ALT: () => {
                    this.AT_LEAST_ONE2(() => (infinityOrNan += this.CONSUME(Nan).image));
                },
            },
            {
                ALT: () => {
                    returnValue += this.CONSUME1(Dot).image;
                    this.AT_LEAST_ONE3(() => (returnValue += this.CONSUME1(Digit).image));
                },
            },
            {
                ALT: () => {
                    this.AT_LEAST_ONE4(() => (returnValue += this.CONSUME2(Digit).image));
                    this.OPTION(() => {
                        returnValue += this.CONSUME2(Dot).image;
                        this.MANY2(() => (returnValue += this.CONSUME3(Digit).image));
                    });
                },
            },
        ]);
        this.OPTION3(() => {
            returnValue += this.CONSUME(Exponential).image;
            this.OPTION2(() => (returnValue += this.CONSUME2(Sign)?.image));
            this.AT_LEAST_ONE5(() => (returnValue += this.CONSUME4(Digit).image));
        });
        if (infinityOrNan === "INF") {
            return returnValue + Infinity;
        }
        else if (infinityOrNan === "NaN") {
            return infinityOrNan;
        }
        else {
            return returnValue;
        }
    });
    floatRep = this.RULE("floatRep", () => {
        return this.SUBRULE(this.sharedFloatAndDouble);
    });
    doubleRep = this.RULE("doubleRep", () => {
        return this.SUBRULE(this.sharedFloatAndDouble);
    });
}
export const lexer = new Lexer(tokens, {
    ensureOptimizations: true,
    positionTracking: "onlyOffset",
});
export const parser = new DecimalParser();
export function decimalToCanonical(d) {
    const sign = d[0] === "-" ? "-" : "";
    const stripStart = ["0", "+", "-"];
    const [large, small] = d.split(".");
    let start;
    for (start = 0; stripStart.includes(large[start]); start++)
        ;
    const startPart = large.slice(start) || "0";
    let end;
    if (small !== undefined) {
        for (end = small.length - 1; "0" === small[end]; end--)
            ;
        if (end >= 0) {
            return sign + startPart + "." + small.slice(0, end + 1);
        }
    }
    if (startPart === "0")
        return "0";
    return sign + startPart;
}
export function doubleToCanonical(s) {
    const n = +s;
    if (Number.isNaN(n))
        return "NaN";
    if (n === Infinity)
        return "INF";
    if (-n === Infinity)
        return "-INF";
    if (n === 0 && s[0] === "-")
        return "-0.0E0";
    const str = n.toExponential().toUpperCase();
    const [mantissa, exponent] = str.split("E");
    return `${mantissa}${mantissa.includes(".") ? "" : ".0"}E${+exponent}`;
}
export function floatToCanonical(value) {
    return doubleToCanonical(value);
}
//# sourceMappingURL=decimal.js.map