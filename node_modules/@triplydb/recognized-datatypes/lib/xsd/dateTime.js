import { EmbeddedActionsParser, Lexer } from "chevrotain";
import { Plus, Z, Colon, Digit, T, Dot, Dash } from "./tokens.js";
import { div, mod } from "../utils/helpers.js";
import { newDateTime, unsignedTwoDigitFragmentToCanonical, } from "../utils/dateTimeHelpers.js";
import { decimalToCanonical } from "./decimal.js";
const tokens = [Dash, Plus, Digit, Z, Colon, Dot, T];
export class DateParser extends EmbeddedActionsParser {
    constructor() {
        super(tokens, { maxLookahead: 2 });
        this.performSelfAnalysis();
    }
    dateTimeLexicalRep = this.RULE("dateTimeLexicalRep", () => {
        const year = this.SUBRULE(this.yearFrag);
        this.CONSUME(Dash);
        const month = this.SUBRULE(this.monthFrag);
        this.CONSUME1(Dash);
        const day = this.SUBRULE(this.dayFrag);
        this.CONSUME(T);
        const time = this.SUBRULE(this._timeUtc);
        const timezone = this.OPTION(() => this.SUBRULE(this.timezoneFrag));
        return newDateTime({
            year,
            month,
            day,
            ...time,
            timezone,
        });
    });
    dateTimeStampLexicalRep = this.RULE("dateTimeStampLexicalRep", () => {
        const year = this.SUBRULE(this.yearFrag);
        this.CONSUME1(Dash);
        const month = this.SUBRULE(this.monthFrag);
        this.CONSUME2(Dash);
        const day = this.SUBRULE(this.dayFrag);
        this.CONSUME(T);
        const time = this.SUBRULE(this._timeUtc);
        const timezone = this.SUBRULE(this.timezoneFrag);
        return newDateTime({
            year,
            month,
            day,
            ...time,
            timezone,
        });
    });
    _timeUtc = this.RULE("_timeUtc", () => {
        let time;
        const hour = this.SUBRULE(this.hourFrag, { ARGS: [true] });
        this.CONSUME1(Colon);
        const minute = this.SUBRULE(this.minuteFrag);
        this.CONSUME2(Colon);
        const { second, fraction } = this.SUBRULE(this.secondFrag);
        this.ACTION(() => {
            if (hour === 24) {
                if (minute !== 0 || second !== 0 || fraction.replaceAll("0", "") !== "") {
                    throw new RangeError("Invalid end-of-day");
                }
            }
        });
        time = { hour, minute, second, fraction };
        return time;
    });
    dateLexicalRep = this.RULE("dateLexicalRep", () => {
        const year = this.SUBRULE(this.yearFrag);
        this.CONSUME1(Dash);
        const month = this.SUBRULE(this.monthFrag);
        this.CONSUME2(Dash);
        const day = this.SUBRULE(this.dayFrag);
        const timezone = this.OPTION(() => this.SUBRULE(this.timezoneFrag));
        return newDateTime({
            year,
            month,
            day,
            timezone,
        });
    });
    gYearMonthLexicalRep = this.RULE("gYearMonthLexicalRep", () => {
        const year = this.SUBRULE(this.yearFrag);
        this.CONSUME(Dash);
        const month = this.SUBRULE(this.monthFrag);
        const timezone = this.OPTION(() => this.SUBRULE(this.timezoneFrag));
        return newDateTime({
            year,
            month,
            timezone,
        });
    });
    gYearLexicalRep = this.RULE("gYearLexicalRep", () => {
        const year = this.SUBRULE1(this.yearFrag);
        const timezone = this.OPTION(() => this.SUBRULE6(this.timezoneFrag));
        return newDateTime({
            year,
            timezone,
        });
    });
    gMonthDayLexicalRep = this.RULE("gMonthDayLexicalRep", () => {
        this.CONSUME1(Dash);
        this.CONSUME2(Dash);
        const month = this.SUBRULE(this.monthFrag);
        this.CONSUME3(Dash);
        const day = this.SUBRULE(this.dayFrag);
        const timezone = this.OPTION(() => this.SUBRULE(this.timezoneFrag));
        return newDateTime({
            month,
            day,
            timezone,
        });
    });
    gDayLexicalRep = this.RULE("gDayLexicalRep", () => {
        this.CONSUME(Dash);
        this.CONSUME1(Dash);
        this.CONSUME2(Dash);
        const day = this.SUBRULE(this.dayFrag);
        const timezone = this.OPTION(() => this.SUBRULE(this.timezoneFrag));
        return newDateTime({
            day,
            timezone,
        });
    });
    gMonthLexicalRep = this.RULE("gMonthLexicalRep", () => {
        this.CONSUME(Dash);
        this.CONSUME1(Dash);
        const month = this.SUBRULE(this.monthFrag);
        const timezone = this.OPTION(() => this.SUBRULE(this.timezoneFrag));
        return newDateTime({
            month,
            timezone,
        });
    });
    timeLexicalRep = this.RULE("timeLexicalRep", () => {
        const hour = this.SUBRULE(this.hourFrag, { ARGS: [true] });
        this.CONSUME1(Colon);
        const minute = this.SUBRULE(this.minuteFrag);
        this.CONSUME2(Colon);
        const { second, fraction } = this.SUBRULE(this.secondFrag);
        const timezone = this.OPTION(() => this.SUBRULE(this.timezoneFrag));
        return newDateTime({
            hour,
            minute,
            second,
            fraction,
            timezone,
        });
    });
    yearFrag = this.RULE("yearFrag", () => {
        let year = this.OPTION(() => this.CONSUME(Dash).image) ?? "";
        const firstNumber = this.CONSUME(Digit).image;
        year += firstNumber;
        this.OR([
            {
                GATE: () => firstNumber !== "0",
                ALT: () => {
                    year += this.CONSUME4(Digit).image + this.CONSUME5(Digit).image;
                    this.AT_LEAST_ONE(() => (year += this.CONSUME6(Digit).image));
                },
            },
            {
                GATE: () => firstNumber === "0",
                ALT: () => {
                    year += this.CONSUME1(Digit).image + this.CONSUME2(Digit).image + this.CONSUME3(Digit).image;
                },
            },
        ]);
        return +year;
    });
    monthFrag = this.RULE("monthFrag", () => {
        const monthLex = this.CONSUME(Digit).image + this.CONSUME1(Digit).image;
        const month = +monthLex;
        this.ACTION(() => {
            if (month < 1 || month > 12)
                throw new RangeError(`Invalid month ${monthLex}`);
        });
        return month;
    });
    dayFrag = this.RULE("dayFrag", () => {
        const dayLex = this.CONSUME(Digit).image + this.CONSUME1(Digit).image;
        const day = +dayLex;
        this.ACTION(() => {
            if (day < 1 || day > 31)
                throw new RangeError(`Invalid day ${dayLex}`);
        });
        return day;
    });
    hourFrag = this.RULE("hourFrag", (include24) => {
        const hourLex = this.CONSUME(Digit).image + this.CONSUME1(Digit).image;
        const hour = +hourLex;
        this.ACTION(() => {
            if (hour === 24 && include24)
                return;
            if (hour > 23)
                throw new RangeError(`Invalid hour ${hourLex}`);
        });
        return hour;
    });
    minuteFrag = this.RULE("minuteFrag", () => {
        const minuteLex = this.CONSUME(Digit).image + this.CONSUME1(Digit).image;
        const minute = +minuteLex;
        this.ACTION(() => {
            if (minute > 59)
                throw new RangeError(`Invalid minute ${minuteLex}`);
        });
        return minute;
    });
    secondFrag = this.RULE("secondFrag", () => {
        const secondLex = this.CONSUME(Digit).image + this.CONSUME1(Digit).image;
        const second = +secondLex;
        this.ACTION(() => {
            if (second > 59)
                throw new RangeError(`Invalid second ${secondLex}`);
        });
        const fraction = this.OPTION(() => {
            this.CONSUME3(Dot);
            let decimalPtLex = "";
            this.AT_LEAST_ONE(() => {
                decimalPtLex += this.CONSUME4(Digit).image;
            });
            return decimalPtLex;
        }) ?? "";
        return { second, fraction };
    });
    timezoneFrag = this.RULE("timezoneFrag", () => {
        return this.OR([
            {
                ALT: () => {
                    this.CONSUME(Z);
                    return 0;
                },
            },
            {
                ALT: () => {
                    this.CONSUME(Plus);
                    return this.SUBRULE(this.timezoneFrag_absolute);
                },
            },
            {
                ALT: () => {
                    this.CONSUME(Dash);
                    return -this.SUBRULE1(this.timezoneFrag_absolute);
                },
            },
        ]);
    });
    timezoneFrag_absolute = this.RULE("timezoneFrag_absolute", () => {
        const hoursLex = this.CONSUME(Digit).image + this.CONSUME1(Digit).image;
        const hours = +hoursLex;
        this.CONSUME(Colon);
        let minutesLex = this.CONSUME2(Digit).image + this.CONSUME3(Digit).image;
        const minutes = +minutesLex;
        const timezoneAbs = hours * 60 + minutes;
        this.ACTION(() => {
            if (timezoneAbs > 14 * 60)
                throw new RangeError(`Invalid time zone ${hoursLex}:${minutesLex}`);
        });
        return timezoneAbs;
    });
}
export const lexer = new Lexer(tokens, {
    ensureOptimizations: true,
    positionTracking: "onlyOffset",
});
export const parser = new DateParser();
export function dateToCanonical(da) {
    return (yearFragmentToCanonical(da.year) +
        "-" +
        monthFragmentToCanonical(da.month) +
        "-" +
        dayFragmentToCanonical(da.day) +
        (da.timezone === undefined ? "" : timezoneFragmentToCanonical(da.timezone)));
}
export function timeToCanonical(ti) {
    return (hourFragmentToCanonical(ti.hour) +
        ":" +
        minuteFragmentToCanonical(ti.minute) +
        ":" +
        secondFragmentToCanonical(ti.second, ti.fraction) +
        (ti.timezone === undefined ? "" : timezoneFragmentToCanonical(ti.timezone)));
}
export function timezoneFragmentToCanonical(t) {
    if (!t) {
        return "Z";
    }
    else if (t < 0) {
        return ("-" + unsignedTwoDigitFragmentToCanonical(div(-t, 60)) + ":" + unsignedTwoDigitFragmentToCanonical(mod(-t, 60)));
    }
    else {
        return ("+" + unsignedTwoDigitFragmentToCanonical(div(t, 60)) + ":" + unsignedTwoDigitFragmentToCanonical(mod(t, 60)));
    }
}
function hourFragmentToCanonical(h) {
    return unsignedTwoDigitFragmentToCanonical(h);
}
export function gDayToCanonical(gD) {
    return ("---" + dayFragmentToCanonical(gD.day) + (gD.timezone === undefined ? "" : timezoneFragmentToCanonical(gD.timezone)));
}
export function gMonthToCanonical(gM) {
    return ("--" +
        monthFragmentToCanonical(gM.month) +
        (gM.timezone === undefined ? "" : timezoneFragmentToCanonical(gM.timezone)));
}
export function gMonthDayToCanonical(md) {
    return ("--" +
        monthFragmentToCanonical(md.month) +
        "-" +
        dayFragmentToCanonical(md.day) +
        (md.timezone === undefined ? "" : timezoneFragmentToCanonical(md.timezone)));
}
export function gYearToCanonical(gy) {
    return yearFragmentToCanonical(gy.year) + (gy.timezone === undefined ? "" : timezoneFragmentToCanonical(gy.timezone));
}
export function gYearMonthToCanonical(ym) {
    return (yearFragmentToCanonical(ym.year) +
        "-" +
        monthFragmentToCanonical(ym.month) +
        (ym.timezone === undefined ? "" : timezoneFragmentToCanonical(ym.timezone)));
}
function monthFragmentToCanonical(m) {
    return unsignedTwoDigitFragmentToCanonical(m);
}
function yearFragmentToCanonical(y) {
    if (Math.abs(y) === 0)
        throw RangeError(`Value ${y} is not valid for years representation .`);
    return Math.abs(y) > 9999 ? decimalToCanonical(y.toString()) : fourDigitFragmentToCanonical(y);
}
function minuteFragmentToCanonical(m) {
    return unsignedTwoDigitFragmentToCanonical(m);
}
export function dateTimeToCanonical(dt) {
    const datetimeString = yearFragmentToCanonical(dt.year) +
        "-" +
        monthFragmentToCanonical(dt.month) +
        "-" +
        dayFragmentToCanonical(dt.day) +
        "T" +
        hourFragmentToCanonical(dt.hour) +
        ":" +
        minuteFragmentToCanonical(dt.minute) +
        ":" +
        secondFragmentToCanonical(dt.second, dt.fraction) +
        (dt.timezone === undefined ? "" : timezoneFragmentToCanonical(dt.timezone));
    if (dt.timezone === undefined)
        return datetimeString;
    return datetimeTimeZonedToUTC(datetimeString, dt.second, dt.fraction);
}
function datetimeTimeZonedToUTC(datetime, seconds, fraction) {
    let datetimeUTCString = "";
    if (datetime.startsWith("-")) {
        let datetimeArray = datetime.split("-");
        datetimeArray[1] = datetimeArray[1].padStart(6, "0");
        datetimeUTCString = new Date(datetimeArray.join("-")).toISOString();
        while (datetimeUTCString.charAt(1) === "0" && datetimeUTCString.split("-")[1].length > 4)
            datetimeUTCString = datetimeUTCString.replace("0", "");
    }
    else {
        datetimeUTCString = new Date(datetime).toISOString();
    }
    return secondFragmentToCanonical(seconds, fraction).includes(".")
        ? datetimeUTCString
        : datetimeUTCString.replace(".000", "");
}
function dayFragmentToCanonical(d) {
    return unsignedTwoDigitFragmentToCanonical(d);
}
function fourDigitFragmentToCanonical(i) {
    const isNegative = i < 0;
    if (isNegative)
        i = -i;
    return (isNegative ? "-" : "") + i.toString().padStart(4, "0");
}
function secondFragmentToCanonical(s, fraction) {
    const before = s.toString().padStart(2, "0");
    const after = fraction.replace(/0+$/, "");
    if (after)
        return before + "." + after;
    else
        return before;
}
//# sourceMappingURL=dateTime.js.map