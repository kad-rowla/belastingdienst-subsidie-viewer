import { EmbeddedActionsParser, Lexer } from "chevrotain";
import { Digit, Dot, Dash, P, Y, M, D, H, S, T } from "./tokens.js";
import { div, mod } from "../utils/helpers.js";
import { decimalToCanonical } from "./decimal.js";
const tokens = [Digit, Dot, Dash, P, Y, M, D, H, S, T];
export class DurationParser extends EmbeddedActionsParser {
    constructor() {
        super(tokens, { maxLookahead: 2 });
        this.performSelfAnalysis();
    }
    unsignedNoDecimalPtNumeral = this.RULE("unsignedNoDecimalPtNumeral", () => {
        let value = "";
        this.AT_LEAST_ONE(() => (value += this.CONSUME(Digit).image));
        return value;
    });
    seconds = this.RULE("seconds", (seconds) => {
        const fraction = this.OPTION(() => {
            this.CONSUME(Dot);
            return this.SUBRULE(this.unsignedNoDecimalPtNumeral);
        });
        this.CONSUME(S);
        if (fraction)
            return { seconds, fraction };
        return { seconds };
    });
    minutesOnwards = this.RULE("minutesOnwards", (minutes) => {
        this.CONSUME(M);
        const duration = this.OPTION(() => {
            const someNumber = this.SUBRULE(this.unsignedNoDecimalPtNumeral);
            return this.SUBRULE(this.seconds, { ARGS: [someNumber] });
        });
        return { ...duration, minutes };
    });
    hoursOnwards = this.RULE("hoursOnwards", (hours) => {
        this.CONSUME(H);
        const duration = this.OPTION(() => {
            const someNumber = this.SUBRULE(this.unsignedNoDecimalPtNumeral);
            return this.OR([
                { ALT: () => this.SUBRULE(this.minutesOnwards, { ARGS: [someNumber] }) },
                { ALT: () => this.SUBRULE(this.seconds, { ARGS: [someNumber] }) },
            ]);
        });
        return { ...duration, hours };
    });
    duTimeFrag = this.RULE("duTimeFrag", () => {
        this.CONSUME(T);
        const someNumber = this.SUBRULE(this.unsignedNoDecimalPtNumeral);
        const { fraction, ...strDuration } = this.OR([
            { ALT: () => this.SUBRULE(this.hoursOnwards, { ARGS: [someNumber] }) },
            { ALT: () => this.SUBRULE(this.minutesOnwards, { ARGS: [someNumber] }) },
            { ALT: () => this.SUBRULE(this.seconds, { ARGS: [someNumber] }) },
        ]);
        const { hours, minutes, seconds } = {
            hours: strDuration.hours ? +strDuration.hours : 0,
            minutes: strDuration.minutes ? +strDuration.minutes : 0,
            seconds: strDuration.seconds ? +strDuration.seconds : 0,
        };
        return {
            seconds: 3600 * hours + 60 * minutes + seconds,
            fraction: fraction ?? "",
        };
    });
    day = this.RULE("day", (day) => {
        this.CONSUME(D);
        return { day };
    });
    monthOnwards = this.RULE("monthOnwards", (month) => {
        this.CONSUME(M);
        const day = this.OPTION(() => {
            const day = this.SUBRULE(this.unsignedNoDecimalPtNumeral);
            return this.SUBRULE(this.day, { ARGS: [day] });
        });
        if (day)
            return { ...day, month };
        return { month };
    });
    yearOnwards = this.RULE("yearOnwards", (year) => {
        this.CONSUME(Y);
        const monthAndOrDay = this.OPTION(() => {
            const someNumber = this.SUBRULE(this.unsignedNoDecimalPtNumeral);
            return this.OR([
                { ALT: () => this.SUBRULE(this.monthOnwards, { ARGS: [someNumber] }) },
                { ALT: () => this.SUBRULE(this.day, { ARGS: [someNumber] }) },
            ]);
        });
        return { ...monthAndOrDay, year };
    });
    durationLexicalRep = this.RULE("durationLexicalRep", (only) => {
        const isNegative = !!this.OPTION(() => this.CONSUME(Dash).image);
        this.CONSUME(P);
        return this.OR([
            {
                ALT: () => {
                    const someNumber = this.SUBRULE(this.unsignedNoDecimalPtNumeral);
                    const date = this.OR1([
                        { ALT: () => this.SUBRULE(this.yearOnwards, { ARGS: [someNumber] }) },
                        { ALT: () => this.SUBRULE(this.monthOnwards, { ARGS: [someNumber] }) },
                        { ALT: () => this.SUBRULE(this.day, { ARGS: [someNumber] }) },
                    ]);
                    this.ACTION(() => {
                        if ((only === "yearMonthDurationLexicalRep" && date.day !== undefined) ||
                            (only === "dayTimeDurationLexicalRep" && (date.year ?? date.month) !== undefined))
                            throw new RangeError("Invalid");
                    });
                    let time = { seconds: 0, fraction: "" };
                    if (only !== "yearMonthDurationLexicalRep")
                        time = { ...time, ...this.OPTION1(() => this.SUBRULE1(this.duTimeFrag)) };
                    return {
                        isNegative,
                        months: Number(date.year ?? 0) * 12 + Number(date.month ?? 0),
                        seconds: time.seconds + Number(date.day ?? 0) * 86400,
                        fraction: time.fraction,
                    };
                },
            },
            {
                GATE: () => only !== "yearMonthDurationLexicalRep",
                ALT: () => ({ isNegative, months: 0, ...this.SUBRULE(this.duTimeFrag) }),
            },
        ]);
    });
    yearMonthDurationLexicalRep = this.RULE("yearMonthDurationLexicalRep", () => this.SUBRULE(this.durationLexicalRep, { ARGS: ["yearMonthDurationLexicalRep"] }));
    dayTimeDurationLexicalRep = this.RULE("dayTimeDurationLexicalRep", () => this.SUBRULE(this.durationLexicalRep, { ARGS: ["dayTimeDurationLexicalRep"] }));
}
export const lexer = new Lexer(tokens, {
    ensureOptimizations: true,
    positionTracking: "onlyOffset",
});
export const parser = new DurationParser();
export function durationToCanonical(duration) {
    const start = (duration.isNegative ? "-" : "") + "P";
    if (duration.months) {
        if (duration.seconds) {
            return (start +
                yearMonthDurationFragmentToCanonical(duration.months) +
                dayTimeDurationFragmentToCanonical(duration.seconds, duration.fraction));
        }
        return start + yearMonthDurationFragmentToCanonical(duration.months);
    }
    return start + dayTimeDurationFragmentToCanonical(duration.seconds, duration.fraction);
}
export function yearMonthDurationToCanonical(duration) {
    const value = durationToCanonical(duration);
    if (value === "PT0S")
        return "P0M";
    return value;
}
function dayTimeDurationFragmentToCanonical(ss, fraction) {
    if (!ss && !fraction) {
        return "T0S";
    }
    else {
        const d = div(ss, 86400);
        const h = div(mod(ss, 86400), 3600);
        const m = div(mod(ss, 3600), 60);
        const s = mod(ss, 60);
        return dayDurationFragmentToCanonical(d) + timeDurationFragmentToCanonical(h, m, s, fraction);
    }
}
function timeDurationFragmentToCanonical(h, m, s, fraction) {
    if (!h && !m && !s && !fraction) {
        return "";
    }
    else {
        return ("T" +
            hourDurationFragmentToCanonical(h) +
            minuteDurationFragmentToCanonical(m) +
            secondDurationFragmentToCanonical(s, fraction));
    }
}
function secondDurationFragmentToCanonical(s, fraction) {
    if (!s && !fraction) {
        return "";
    }
    else {
        return decimalToCanonical(s.toString() + "." + fraction + "0") + "S";
    }
}
function minuteDurationFragmentToCanonical(m) {
    return m ? decimalToCanonical(m.toString()) + "M" : "";
}
function hourDurationFragmentToCanonical(h) {
    return h ? decimalToCanonical(h.toString()) + "H" : "";
}
function dayDurationFragmentToCanonical(d) {
    return d ? decimalToCanonical(d.toString()) + "D" : "";
}
function yearMonthDurationFragmentToCanonical(ym) {
    const y = div(ym, 12);
    const m = mod(ym, 12);
    if (y && m) {
        return decimalToCanonical(y.toString()) + "Y" + decimalToCanonical(m.toString()) + "M";
    }
    else if (y) {
        return decimalToCanonical(y.toString()) + "Y";
    }
    else {
        return decimalToCanonical(m.toString()) + "M";
    }
}
//# sourceMappingURL=duration.js.map