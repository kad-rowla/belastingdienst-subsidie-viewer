import { EmbeddedActionsParser, Lexer, createToken } from "chevrotain";
const B64charPattern = "[A-Za-z0-9+/]";
const B64finalquadPattern = `${B64charPattern} ?${B64charPattern} ?${B64charPattern} ?${B64charPattern}`;
const B16charPattern = "[AEIMQUYcgkosw048]";
const B04charPattern = "[AQgw]";
export const B64quadWithTrailingSpace = createToken({
    name: "B64quad",
    pattern: new RegExp(B64finalquadPattern + " "),
});
export const B64quadWithoutTrailingSpace = createToken({
    name: "B64finalquad",
    pattern: new RegExp(B64finalquadPattern),
});
export const Padded16 = createToken({
    name: "Padded16",
    pattern: new RegExp(`${B64charPattern} ?${B64charPattern} ?${B16charPattern} ?=`),
});
export const Padded8 = createToken({
    name: "Padded8",
    pattern: new RegExp(`${B64charPattern} ?${B04charPattern} ?= ?=`),
});
const tokens = [B64quadWithTrailingSpace, B64quadWithoutTrailingSpace, Padded16, Padded8];
export class Base64Parser extends EmbeddedActionsParser {
    constructor() {
        super(tokens, {
            maxLookahead: 2,
        });
        this.performSelfAnalysis();
    }
    base64Binary = this.RULE("Base64Binary", () => {
        let result = "";
        this.MANY(() => {
            result += this.OR([
                { ALT: () => this.CONSUME(B64quadWithTrailingSpace) },
                { ALT: () => this.CONSUME(B64quadWithoutTrailingSpace) },
            ]).image;
        });
        this.OPTION(() => {
            result += this.OR2([{ ALT: () => this.CONSUME(Padded16) }, { ALT: () => this.CONSUME(Padded8) }]).image;
        });
        this.ACTION(() => {
            if (result.endsWith(" "))
                throw new RangeError("No trailing space allowed for Base64Binary");
        });
        return result.replaceAll(" ", "");
    });
}
export const lexer = new Lexer(tokens, {
    ensureOptimizations: true,
    positionTracking: "onlyOffset",
});
export const parser = new Base64Parser();
//# sourceMappingURL=base64Binary.js.map