import { StandardParseError, ValueRangeError } from "./Errors.js";
import { parser as integerParser, lexer as integerLexer } from "./xsd/integer.js";
import { parser as datetimeParser, lexer as datetimeLexer, dateTimeToCanonical, dateToCanonical, gDayToCanonical, gMonthDayToCanonical, gMonthToCanonical, gYearMonthToCanonical, gYearToCanonical, timeToCanonical, } from "./xsd/dateTime.js";
import { parser as durationParser, lexer as durationLexer, durationToCanonical, yearMonthDurationToCanonical, } from "./xsd/duration.js";
import { parser as base64BinaryParser, lexer as base64BinaryLexer } from "./xsd/base64Binary.js";
import { parser as hexBinaryParser, lexer as hexBinaryLexer } from "./xsd/hexBinary.js";
import { parser as booleanParser, lexer as booleanLexer } from "./xsd/boolean.js";
import { parser as decimalParser, lexer as decimalLexer, decimalToCanonical, doubleToCanonical, floatToCanonical, } from "./xsd/decimal.js";
import { rdf, xsd } from "./utils/constants.js";
function getParserAndSerializer({ parser, lexer, parseMethod, serialize, }) {
    return {
        parse: (lexicalValue) => {
            const lexResult = lexer.tokenize(lexicalValue);
            if (lexResult.errors.length) {
                throw new StandardParseError({
                    lexicalValue: lexicalValue,
                    offset: lexResult.errors[0].column,
                    cause: new Error(lexResult.errors[0].message),
                });
            }
            parser.input = lexResult.tokens;
            try {
                let value;
                try {
                    value = parser[parseMethod]();
                }
                catch (e) {
                    if (e instanceof RangeError) {
                        throw new StandardParseError({
                            lexicalValue: lexicalValue,
                            offset: parser.errors[0]?.token?.startOffset,
                            cause: e,
                        });
                    }
                    throw e;
                }
                if (parser.errors.length) {
                    throw new StandardParseError({
                        lexicalValue: lexicalValue,
                        offset: parser.errors[0].token.startOffset,
                        cause: parser.errors[0],
                    });
                }
                return value;
            }
            finally {
                parser.reset();
            }
        },
        serialize: serialize,
    };
}
const UNICODE_STRING_WITH_ONLY_PAIRED_SURROGATES = /^[^\uFFFE\uFFFF\uD800-\uDFFF]*$/u;
const stringParserAndSerializer = {
    parse: (lexicalValue) => {
        if (!UNICODE_STRING_WITH_ONLY_PAIRED_SURROGATES.test(lexicalValue))
            throw new ValueRangeError({ value: lexicalValue });
        return lexicalValue;
    },
    serialize: (value) => value,
};
const parsersAndSerializers = {
    [xsd("byte")]: getParserAndSerializer({
        parseMethod: "byte",
        lexer: integerLexer,
        parser: integerParser,
        serialize: decimalToCanonical,
    }),
    [xsd("base64Binary")]: getParserAndSerializer({
        parseMethod: "base64Binary",
        lexer: base64BinaryLexer,
        parser: base64BinaryParser,
        serialize: (value) => value,
    }),
    [xsd("boolean")]: getParserAndSerializer({
        parseMethod: "boolean",
        lexer: booleanLexer,
        parser: booleanParser,
        serialize: (bool) => (bool ? "true" : "false"),
    }),
    [xsd("dayTimeDuration")]: getParserAndSerializer({
        parseMethod: "dayTimeDurationLexicalRep",
        lexer: durationLexer,
        parser: durationParser,
        serialize: durationToCanonical,
    }),
    [xsd("date")]: getParserAndSerializer({
        parseMethod: "dateLexicalRep",
        lexer: datetimeLexer,
        parser: datetimeParser,
        serialize: dateToCanonical,
    }),
    [xsd("dateTime")]: getParserAndSerializer({
        parseMethod: "dateTimeLexicalRep",
        lexer: datetimeLexer,
        parser: datetimeParser,
        serialize: dateTimeToCanonical,
    }),
    [xsd("dateTimeStamp")]: getParserAndSerializer({
        parseMethod: "dateTimeStampLexicalRep",
        lexer: datetimeLexer,
        parser: datetimeParser,
        serialize: dateTimeToCanonical,
    }),
    [xsd("decimal")]: getParserAndSerializer({
        parseMethod: "decimalLexicalRep",
        lexer: decimalLexer,
        parser: decimalParser,
        serialize: decimalToCanonical,
    }),
    [xsd("double")]: getParserAndSerializer({
        parseMethod: "doubleRep",
        lexer: decimalLexer,
        parser: decimalParser,
        serialize: doubleToCanonical,
    }),
    [xsd("duration")]: getParserAndSerializer({
        parseMethod: "durationLexicalRep",
        lexer: durationLexer,
        parser: durationParser,
        serialize: durationToCanonical,
    }),
    [xsd("float")]: getParserAndSerializer({
        parseMethod: "floatRep",
        lexer: decimalLexer,
        parser: decimalParser,
        serialize: floatToCanonical,
    }),
    [xsd("gDay")]: getParserAndSerializer({
        parseMethod: "gDayLexicalRep",
        lexer: datetimeLexer,
        parser: datetimeParser,
        serialize: gDayToCanonical,
    }),
    [xsd("gMonth")]: getParserAndSerializer({
        parseMethod: "gMonthLexicalRep",
        lexer: datetimeLexer,
        parser: datetimeParser,
        serialize: gMonthToCanonical,
    }),
    [xsd("gMonthDay")]: getParserAndSerializer({
        parseMethod: "gMonthDayLexicalRep",
        lexer: datetimeLexer,
        parser: datetimeParser,
        serialize: gMonthDayToCanonical,
    }),
    [xsd("gYearMonth")]: getParserAndSerializer({
        parseMethod: "gYearMonthLexicalRep",
        lexer: datetimeLexer,
        parser: datetimeParser,
        serialize: gYearMonthToCanonical,
    }),
    [xsd("gYear")]: getParserAndSerializer({
        parseMethod: "gYearLexicalRep",
        lexer: datetimeLexer,
        parser: datetimeParser,
        serialize: gYearToCanonical,
    }),
    [xsd("hexBinary")]: getParserAndSerializer({
        parseMethod: "hexBinary",
        lexer: hexBinaryLexer,
        parser: hexBinaryParser,
        serialize: (value) => value,
    }),
    [xsd("int")]: getParserAndSerializer({
        parseMethod: "int",
        lexer: integerLexer,
        parser: integerParser,
        serialize: decimalToCanonical,
    }),
    [xsd("integer")]: getParserAndSerializer({
        parseMethod: "integer",
        lexer: integerLexer,
        parser: integerParser,
        serialize: decimalToCanonical,
    }),
    [rdf("langString")]: stringParserAndSerializer,
    [xsd("long")]: getParserAndSerializer({
        parseMethod: "long",
        lexer: integerLexer,
        parser: integerParser,
        serialize: decimalToCanonical,
    }),
    [xsd("negativeInteger")]: getParserAndSerializer({
        parseMethod: "negativeInteger",
        lexer: integerLexer,
        parser: integerParser,
        serialize: decimalToCanonical,
    }),
    [xsd("nonNegativeInteger")]: getParserAndSerializer({
        parseMethod: "nonNegativeInteger",
        lexer: integerLexer,
        parser: integerParser,
        serialize: decimalToCanonical,
    }),
    [xsd("nonPositiveInteger")]: getParserAndSerializer({
        parseMethod: "nonPositiveInteger",
        lexer: integerLexer,
        parser: integerParser,
        serialize: decimalToCanonical,
    }),
    [xsd("positiveInteger")]: getParserAndSerializer({
        parseMethod: "positiveInteger",
        lexer: integerLexer,
        parser: integerParser,
        serialize: decimalToCanonical,
    }),
    [xsd("short")]: getParserAndSerializer({
        parseMethod: "short",
        lexer: integerLexer,
        parser: integerParser,
        serialize: decimalToCanonical,
    }),
    [xsd("string")]: stringParserAndSerializer,
    [xsd("time")]: getParserAndSerializer({
        parseMethod: "timeLexicalRep",
        lexer: datetimeLexer,
        parser: datetimeParser,
        serialize: timeToCanonical,
    }),
    [xsd("unsignedByte")]: getParserAndSerializer({
        parseMethod: "unsignedByte",
        lexer: integerLexer,
        parser: integerParser,
        serialize: decimalToCanonical,
    }),
    [xsd("unsignedInt")]: getParserAndSerializer({
        parseMethod: "unsignedInt",
        lexer: integerLexer,
        parser: integerParser,
        serialize: decimalToCanonical,
    }),
    [xsd("unsignedLong")]: getParserAndSerializer({
        parseMethod: "unsignedLong",
        lexer: integerLexer,
        parser: integerParser,
        serialize: decimalToCanonical,
    }),
    [xsd("unsignedShort")]: getParserAndSerializer({
        parseMethod: "unsignedShort",
        lexer: integerLexer,
        parser: integerParser,
        serialize: decimalToCanonical,
    }),
    [xsd("yearMonthDuration")]: getParserAndSerializer({
        parseMethod: "yearMonthDurationLexicalRep",
        lexer: durationLexer,
        parser: durationParser,
        serialize: yearMonthDurationToCanonical,
    }),
};
export default parsersAndSerializers;
//# sourceMappingURL=parseAndSerialize.js.map