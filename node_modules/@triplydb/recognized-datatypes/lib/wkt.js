import { createToken, Lexer, EmbeddedActionsParser } from "chevrotain";
import { compact } from "lodash-es";
import { StandardParseError } from "./Errors.js";
const Empty_Set = createToken({ name: "Empty_Set", pattern: /empty/i });
const Left_Paren = createToken({ name: "Left_Paren", pattern: "(" });
const Right_Paren = createToken({ name: "Right_Paren", pattern: ")" });
const Comma = createToken({ name: "Comma", pattern: /[ \t]*,[ \t]*/ });
const Point_2 = createToken({ name: "Point_2", pattern: /[ \t]*[\.,0-9e-]+[ \t]+[\.,0-9e-]+[ \t]*(?=[,\)])/ });
const Point_3 = createToken({
    name: "Point_3",
    pattern: /[ \t]*[\.,0-9e-]+[ \t]+[\.,0-9e-]+[ \t]+[\.,0-9e-]+[ \t]*(?=[,\)])/,
});
const Point_4 = createToken({
    name: "Point_4",
    pattern: /[ \t]*[\.,0-9e-]+[ \t]+[\.,0-9e-]+[ \t]+[\.,0-9e-]+[ \t]+[\.,0-9e-]+[ \t]*(?=[,\)])/,
});
const Point_Tag = createToken({ name: "Point_Tag", pattern: /point[\t ]*/i });
const Linestring_Tag = createToken({ name: "Linestring_Tag", pattern: /linestring[\t ]*/i });
const Polygon_Tag = createToken({ name: "Polygon_Tag", pattern: /polygon[\t ]*/i });
const Polyhedralsurface_Tag = createToken({ name: "Polyhedralsurface_Tag", pattern: /polyhedralsurface[\t ]*/i });
const Triangle_Tag = createToken({ name: "Triangle_Tag", pattern: /triangle[\t ]*/i });
const Tin_Tag = createToken({ name: "Tin_Tag", pattern: /tin[\t ]*/i });
const Multipoint_Tag = createToken({ name: "Multipoint_Tag", pattern: /multipoint[\t ]*/i });
const Multilinestring_Tag = createToken({ name: "Multilinestring_Tag", pattern: /multilinestring[\t ]*/i });
const Multipolygon_Tag = createToken({ name: "Multipolygon_Tag", pattern: /multipolygon[\t ]*/i });
const Geometrycollection_Tag = createToken({ name: "Geometrycollection_Tag", pattern: /geometrycollection[\t ]*/i });
const ZM = createToken({ name: "ZM", pattern: /zm[ \t]*/i });
const M = createToken({ name: "M", pattern: /m[ \t]*/i });
const Z = createToken({ name: "Z", pattern: /z[ \t]*/i });
const WS = createToken({ name: "WS", pattern: /[ \t\n\r]+/ });
const Crs_Uri = createToken({
    name: "Crs_Uri",
    pattern: /<[^:^/^?^#^>]+:\/\/[^/^?^#^>]+[^>]*>/,
});
const allTokensExceptPoints = [
    Empty_Set,
    Left_Paren,
    Right_Paren,
    Point_Tag,
    Linestring_Tag,
    Polygon_Tag,
    Polyhedralsurface_Tag,
    Triangle_Tag,
    Tin_Tag,
    Multipoint_Tag,
    Multilinestring_Tag,
    Multipolygon_Tag,
    Geometrycollection_Tag,
    ZM,
    M,
    Z,
    WS,
    Crs_Uri,
    Comma,
];
export class WktParser extends EmbeddedActionsParser {
    geometryTypeInfo;
    pointToken;
    geometryTypeToken;
    geometry_tagged_text_list = undefined;
    constructor(opts) {
        super([...allTokensExceptPoints, opts.pointToken], { maxLookahead: 2 });
        this.geometryTypeInfo = opts.geometryTypeInfo;
        this.pointToken = opts.pointToken;
        this.geometryTypeToken = opts.geometryTypeToken;
        this.performSelfAnalysis();
    }
    geometry = this.RULE("geometry", () => {
        this.OPTION1(() => this.CONSUME1(WS));
        const crs = this.OPTION(() => this.SUBRULE(this.crs_def));
        const geometry = this.SUBRULE(this.geometry_tagged_text);
        this.OPTION2(() => this.CONSUME2(WS));
        return { ...geometry, crs: crs || DEFAULT_CRS };
    });
    crs_def = this.RULE("crs_def", () => {
        const crs = this.CONSUME(Crs_Uri);
        this.MANY(() => this.CONSUME(WS));
        let returnValue = "";
        this.ACTION(() => (returnValue = crs.image.slice(1, crs.image.length - 1)));
        return returnValue;
    });
    point = this.RULE("point", () => {
        const optionalLeadingComma = this.OPTION(() => this.CONSUME(Comma))?.image || "";
        const pointString = this.CONSUME(this.pointToken).image;
        return this.ACTION(() => {
            return (optionalLeadingComma + pointString)
                .trim()
                .split(/[\s]+/)
                .map((s) => {
                const number = Number(s.replaceAll(",", "."));
                if (isNaN(number))
                    throw new RangeError("Invalid coordinate " + s);
                return number;
            });
        });
    });
    geometry_tagged_text = this.RULE("geometry_tagged_text", () => {
        return this.OR(this.geometry_tagged_text_list ??
            (this.geometry_tagged_text_list = [
                { ALT: () => this.SUBRULE(this.point_tagged_text) },
                { ALT: () => this.SUBRULE(this.multipolygon_tagged_text) },
                { ALT: () => this.SUBRULE(this.linestring_tagged_text) },
                { ALT: () => this.SUBRULE(this.polygon_tagged_text) },
                { ALT: () => this.SUBRULE(this.triangle_tagged_text) },
                { ALT: () => this.SUBRULE(this.polyhedralsurface_tagged_text) },
                { ALT: () => this.SUBRULE(this.tin_tagged_text) },
                { ALT: () => this.SUBRULE(this.multipoint_tagged_text) },
                { ALT: () => this.SUBRULE(this.multilinestring_tagged_text) },
                { ALT: () => this.SUBRULE(this.geometrycollection_tagged_text) },
            ]));
    });
    point_tagged_text = this.RULE("point_tagged_text", () => {
        this.CONSUME(Point_Tag);
        if (this.geometryTypeToken) {
            this.CONSUME(this.geometryTypeToken);
        }
        const coordinates = this.SUBRULE(this.point_text);
        return { type: "Point", coordinates, ...this.geometryTypeInfo };
    });
    linestring_tagged_text = this.RULE("linestring_tagged_text", () => {
        this.CONSUME(Linestring_Tag);
        if (this.geometryTypeToken)
            this.CONSUME(this.geometryTypeToken);
        const coordinates = this.SUBRULE(this.linestring_text);
        return { type: "LineString", coordinates, ...this.geometryTypeInfo };
    });
    polygon_tagged_text = this.RULE("polygon_tagged_text", () => {
        this.CONSUME(Polygon_Tag);
        if (this.geometryTypeToken)
            this.CONSUME(this.geometryTypeToken);
        const coordinates = this.SUBRULE(this.polygon_text);
        return { type: "Polygon", coordinates, ...this.geometryTypeInfo };
    });
    polyhedralsurface_tagged_text = this.RULE("polyhedralsurface_tagged_text", () => {
        this.CONSUME(Polyhedralsurface_Tag);
        if (this.geometryTypeToken)
            this.CONSUME(this.geometryTypeToken);
        const coordinates = this.SUBRULE(this.polyhedralsurface_text);
        return { type: "PolyhedralSurface", coordinates, ...this.geometryTypeInfo };
    });
    triangle_tagged_text = this.RULE("triangle_tagged_text", () => {
        this.CONSUME(Triangle_Tag);
        if (this.geometryTypeToken)
            this.CONSUME(this.geometryTypeToken);
        const coordinates = this.SUBRULE(this.polygon_text);
        return { type: "Triangle", coordinates, ...this.geometryTypeInfo };
    });
    tin_tagged_text = this.RULE("tin_tagged_text", () => {
        this.CONSUME(Tin_Tag);
        if (this.geometryTypeToken)
            this.CONSUME(this.geometryTypeToken);
        const coordinates = this.SUBRULE(this.polyhedralsurface_text);
        return { type: "Tin", coordinates, ...this.geometryTypeInfo };
    });
    multipoint_tagged_text = this.RULE("multipoint_tagged_text", () => {
        this.CONSUME(Multipoint_Tag);
        if (this.geometryTypeToken)
            this.CONSUME(this.geometryTypeToken);
        const coordinates = this.SUBRULE(this.multipoint_text);
        return { type: "MultiPoint", coordinates, ...this.geometryTypeInfo };
    });
    multilinestring_tagged_text = this.RULE("multilinestring_tagged_text", () => {
        this.CONSUME(Multilinestring_Tag);
        if (this.geometryTypeToken)
            this.CONSUME(this.geometryTypeToken);
        const coordinates = this.SUBRULE(this.multilinestring_text);
        return { type: "MultiLineString", coordinates, ...this.geometryTypeInfo };
    });
    multipolygon_tagged_text = this.RULE("multipolygon_tagged_text", () => {
        this.CONSUME(Multipolygon_Tag);
        if (this.geometryTypeToken)
            this.CONSUME(this.geometryTypeToken);
        const coordinates = this.SUBRULE(this.multipolygon_text);
        return { type: "MultiPolygon", coordinates, ...this.geometryTypeInfo };
    });
    geometrycollection_tagged_text = this.RULE("geometrycollection_tagged_text", () => {
        this.CONSUME(Geometrycollection_Tag);
        if (this.geometryTypeToken)
            this.CONSUME(this.geometryTypeToken);
        const geometries = this.SUBRULE(this.geometrycollection_text);
        return { type: "GeometryCollection", geometries, ...this.geometryTypeInfo };
    });
    point_text = this.RULE("point_text", () => {
        return this.OR([
            {
                ALT: () => {
                    this.CONSUME(Empty_Set);
                    return [];
                },
            },
            {
                ALT: () => {
                    this.CONSUME(Left_Paren);
                    const point = this.SUBRULE(this.point);
                    this.CONSUME(Right_Paren);
                    return point;
                },
            },
        ]);
    });
    linestring_text = this.RULE("linestring_text", () => {
        return this.OR([
            {
                ALT: () => {
                    this.CONSUME(Empty_Set);
                    return [];
                },
            },
            {
                ALT: () => {
                    this.CONSUME(Left_Paren);
                    let coordinates = [];
                    coordinates.push(this.SUBRULE(this.point));
                    this.MANY(() => {
                        this.CONSUME(Comma);
                        coordinates.push(this.SUBRULE1(this.point));
                    });
                    this.CONSUME(Right_Paren);
                    return coordinates;
                },
            },
        ]);
    });
    polygon_text = this.RULE("polygon_text", () => {
        return this.OR([
            {
                ALT: () => {
                    this.CONSUME(Empty_Set);
                    return [];
                },
            },
            {
                ALT: () => {
                    this.CONSUME(Left_Paren);
                    let linestrings = [];
                    linestrings.push(this.SUBRULE(this.linestring_text));
                    this.MANY(() => {
                        this.CONSUME(Comma);
                        linestrings.push(this.SUBRULE1(this.linestring_text));
                    });
                    this.CONSUME(Right_Paren);
                    return linestrings;
                },
            },
        ]);
    });
    polyhedralsurface_text = this.RULE("polyhedralsurface_text", () => {
        return this.OR([
            {
                ALT: () => {
                    this.CONSUME(Empty_Set);
                    return [];
                },
            },
            {
                ALT: () => {
                    this.CONSUME(Left_Paren);
                    let polygons = [];
                    polygons.push(this.SUBRULE(this.polygon_text));
                    this.MANY(() => {
                        this.CONSUME(Comma);
                        polygons.push(this.SUBRULE1(this.polygon_text));
                    });
                    this.CONSUME(Right_Paren);
                    return polygons;
                },
            },
        ]);
    });
    multipoint_text = this.RULE("multipoint_text", () => {
        return this.OR([
            {
                ALT: () => {
                    this.CONSUME(Empty_Set);
                    return [];
                },
            },
            {
                ALT: () => {
                    this.CONSUME(Left_Paren);
                    let points = [];
                    const point = this.OR1([
                        {
                            ALT: () => this.SUBRULE1(this.point_text),
                        },
                        {
                            ALT: () => this.SUBRULE1(this.point),
                        },
                    ]);
                    if (point.length !== 0)
                        points.push(point);
                    this.MANY(() => {
                        this.CONSUME(Comma);
                        const point = this.OR2([
                            {
                                ALT: () => this.SUBRULE2(this.point_text),
                            },
                            {
                                ALT: () => this.SUBRULE2(this.point),
                            },
                        ]);
                        if (point.length !== 0)
                            points.push(point);
                    });
                    this.CONSUME(Right_Paren);
                    return points;
                },
            },
        ]);
    });
    multilinestring_text = this.RULE("multilinestring_text", () => {
        return this.OR([
            {
                ALT: () => {
                    this.CONSUME(Empty_Set);
                    return [];
                },
            },
            {
                ALT: () => {
                    this.CONSUME(Left_Paren);
                    let lines = [];
                    lines.push(this.SUBRULE(this.linestring_text));
                    this.MANY(() => {
                        this.CONSUME(Comma);
                        lines.push(this.SUBRULE1(this.linestring_text));
                    });
                    this.CONSUME(Right_Paren);
                    return lines;
                },
            },
        ]);
    });
    multipolygon_text = this.RULE("multipolygon_text", () => {
        return this.OR([
            {
                ALT: () => {
                    this.CONSUME(Empty_Set);
                    return [];
                },
            },
            {
                ALT: () => {
                    this.CONSUME(Left_Paren);
                    let multipolygons = [];
                    multipolygons.push(this.SUBRULE2(this.polygon_text));
                    this.MANY({
                        DEF: () => {
                            this.CONSUME(Comma);
                            multipolygons.push(this.SUBRULE(this.polygon_text));
                        },
                    });
                    this.CONSUME(Right_Paren);
                    return multipolygons;
                },
            },
        ]);
    });
    geometrycollection_text = this.RULE("geometrycollection_text", () => {
        return this.OR([
            {
                ALT: () => {
                    this.CONSUME(Empty_Set);
                    return [];
                },
            },
            {
                ALT: () => {
                    this.CONSUME(Left_Paren);
                    let geometries = [];
                    geometries.push(this.SUBRULE(this.geometry_tagged_text));
                    this.MANY(() => {
                        this.CONSUME(Comma);
                        geometries.push(this.SUBRULE1(this.geometry_tagged_text));
                    });
                    this.CONSUME(Right_Paren);
                    return geometries;
                },
            },
        ]);
    });
}
function getParserAndLexer(geometryType) {
    let pointToken;
    let geometryTypeInfo;
    let geometryTypeToken;
    switch (geometryType) {
        case "z":
            pointToken = Point_3;
            geometryTypeInfo = { hasZ: true };
            geometryTypeToken = Z;
            break;
        case "m":
            pointToken = Point_3;
            geometryTypeInfo = { hasMeasurement: true };
            geometryTypeToken = M;
            break;
        case "zm":
            pointToken = Point_4;
            geometryTypeInfo = { hasZ: true, hasMeasurement: true };
            geometryTypeToken = ZM;
            break;
        default:
            pointToken = Point_2;
            geometryTypeInfo = {};
    }
    const tokens = [...allTokensExceptPoints, pointToken];
    const parser = new WktParser({ geometryTypeInfo, pointToken, geometryTypeToken });
    return {
        lexer: new Lexer(tokens, {
            ensureOptimizations: true,
            positionTracking: "onlyOffset",
        }),
        parser: parser,
    };
}
export const parser_3d_m = getParserAndLexer("zm");
export const parser_3d = getParserAndLexer("z");
export const parser_m = getParserAndLexer("m");
export const parser_2d = getParserAndLexer(undefined);
export function getParserForLexicalValue(lexicalValue) {
    if (lexicalValue.match(/[ \t]*zm[ \t]*(empty|\()/i))
        return parser_3d_m;
    if (lexicalValue.match(/[ \t]*m[ \t]*(empty|\()/i))
        return parser_m;
    if (lexicalValue.match(/[ \t]*z[ \t]*(empty|\()/i))
        return parser_3d;
    return parser_2d;
}
export const WktLiteralDatatype = "http://www.opengis.net/ont/geosparql#wktLiteral";
export const DEFAULT_CRS = "http://www.opengis.net/def/crs/OGC/1.3/CRS84";
export function lexicalToValue(lexicalValue) {
    if (lexicalValue.trim().length === 0) {
        return {
            type: "Point",
            coordinates: [],
            crs: DEFAULT_CRS,
        };
    }
    const { parser, lexer } = getParserForLexicalValue(lexicalValue);
    const lexResult = lexer.tokenize(lexicalValue);
    if (lexResult.errors.length)
        throw new StandardParseError({
            lexicalValue: lexicalValue,
            cause: lexResult.errors[0],
        });
    parser.input = lexResult.tokens;
    try {
        let value;
        try {
            value = parser.geometry();
        }
        catch (e) {
            if (e instanceof RangeError) {
                throw new StandardParseError({
                    lexicalValue: lexicalValue,
                    offset: parser.errors[0].token.startOffset,
                    cause: e,
                });
            }
            throw e;
        }
        if (parser.errors.length) {
            throw new StandardParseError({
                lexicalValue: lexicalValue,
                offset: parser.errors[0].token.startOffset,
                cause: parser.errors[0],
            });
        }
        return value;
    }
    finally {
        parser.reset();
    }
}
function toCoordinateString(coordinates) {
    if (!Array.isArray(coordinates[0])) {
        return coordinates.join(" ");
    }
    else {
        return "(" + coordinates.map(toCoordinateString).join(", ") + ")";
    }
}
export function valueToLexical(geometry) {
    const crs = !("crs" in geometry) || geometry.crs === DEFAULT_CRS ? undefined : `<${geometry.crs}>`;
    let ordinateValue;
    if (geometry.hasMeasurement && geometry.hasZ) {
        ordinateValue = "zm";
    }
    else if (geometry.hasZ) {
        ordinateValue = "z";
    }
    else if (geometry.hasMeasurement) {
        ordinateValue = "m";
    }
    if (("coordinates" in geometry && !geometry.coordinates.length) ||
        ("geometries" in geometry && !geometry.geometries.length)) {
        return compact([crs, geometry.type, ordinateValue, "empty"]).join(" ");
    }
    switch (geometry.type) {
        case "Point":
            return compact([crs, geometry.type, ordinateValue, "(" + toCoordinateString(geometry.coordinates) + ")"]).join(" ");
        case "MultiPoint":
            return compact([
                crs,
                geometry.type,
                ordinateValue,
                "(" +
                    geometry.coordinates.map((coordinates) => {
                        return `(${toCoordinateString(coordinates)})`;
                    }) +
                    ")",
            ]).join(" ");
        case "GeometryCollection":
            return compact([
                crs,
                geometry.type,
                ordinateValue,
                "(" + geometry.geometries.map(valueToLexical).join(", ") + ")",
            ]).join(" ");
        default:
            return compact([crs, geometry.type, ordinateValue, toCoordinateString(geometry.coordinates)]).join(" ");
    }
}
const parseAndSerialize = {
    [WktLiteralDatatype]: {
        parse: lexicalToValue,
        serialize: valueToLexical,
    },
};
export default parseAndSerialize;
//# sourceMappingURL=wkt.js.map