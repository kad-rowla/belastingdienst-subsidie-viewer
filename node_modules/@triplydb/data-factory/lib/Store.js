import { DefaultGraph } from "./Terms.js";
import { factory as defaultFactory } from "./DataFactory.js";
import _forkedN3Store from "./forked/N3Store.js";
const forkedN3Store = _forkedN3Store;
export class Store extends forkedN3Store {
    factory;
    validationStatuses = {};
    constructor(triplesOrOpts, possibleOptions) {
        let options = possibleOptions || {};
        if (triplesOrOpts && !Array.isArray(triplesOrOpts)) {
            options = triplesOrOpts;
        }
        const factory = options.factory || defaultFactory;
        super({
            ...options,
            factory,
            termToId: (term) => this.termToId(term),
            termFromId: (id) => this.termFromId(id),
        });
        this.factory = factory;
        if (Array.isArray(triplesOrOpts))
            this.addQuads(triplesOrOpts);
    }
    getQuads(subjectOrPattern, predicate, object, graph) {
        if (subjectOrPattern === undefined ||
            subjectOrPattern === null ||
            typeof subjectOrPattern === "string" ||
            "termType" in subjectOrPattern) {
            const subject = subjectOrPattern;
            return super.getQuads((subject ?? null), (predicate ?? null), (object ?? null), (graph ?? null));
        }
        else {
            return super.getQuads((subjectOrPattern.subject ?? null), (subjectOrPattern.predicate ?? null), (subjectOrPattern.object ?? null), (subjectOrPattern.graph ?? null));
        }
    }
    trackValidationStatus(id, validationStatus) {
        if (!this.validationStatuses[id] || this.validationStatuses[id] === "disabled") {
            this.validationStatuses[id] = validationStatus;
        }
    }
    getValidationStatus(id) {
        if (!this.validationStatuses[id])
            throw new Error("Missing validation status for " + id);
        return this.validationStatuses[id];
    }
    termToId = (_term) => {
        if (typeof _term === "string")
            return _term;
        if (!_term)
            return DefaultGraph.id;
        const term = this.factory.fromTerm(_term);
        if (term.termType === "Quad")
            throw new Error("RDF* not supported");
        if (term.termType === "NamedNode" || term.termType === "Literal") {
            this.trackValidationStatus(term.id, term.validationStatus);
            if (term.termType === "Literal") {
                this.trackValidationStatus(term.datatype.id, term.datatype.validationStatus);
            }
        }
        return term.id;
    };
    termFromId = (id) => {
        if (!id)
            return this.factory.defaultGraph();
        switch (id[0]) {
            case "?":
                return this.factory.variable(id.substring(1));
            case "_":
                return this.factory.blankNode(id.substring(2));
            case '"':
                const lexicalValueEndPos = id.lastIndexOf('"');
                return this.factory.literal(id.substring(1, lexicalValueEndPos), id[lexicalValueEndPos + 1] === "@"
                    ? id.substring(lexicalValueEndPos + 2)
                    : this.factory.namedNode(id.substring(lexicalValueEndPos + 4, id.length - 1), {
                        validationStatus: this.getValidationStatus(id.substring(lexicalValueEndPos + 3, id.length)),
                    }), { validationStatus: this.getValidationStatus(id) });
            case "<":
                const iriEndPos = id.lastIndexOf(">");
                return this.factory.namedNode(id.substring(1, iriEndPos), {
                    validationStatus: this.getValidationStatus(id),
                });
            default:
                throw new Error("Unrecognized ID " + id);
        }
    };
}
//# sourceMappingURL=Store.js.map