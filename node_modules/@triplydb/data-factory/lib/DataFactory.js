import { v4 as randomUUID } from "uuid";
import { isRecognized, lexicalToCanonical } from "@triplydb/recognized-datatypes";
import { BaseParseError } from "@triplydb/recognized-datatypes/Errors.js";
import memoizee from "memoizee";
import { validate } from "@triplydb/iri";
import _LruCache from "mnemonist/lru-cache.js";
import { BlankNode, DefaultGraph, Literal, NamedNode, Quad, Variable, BASE_QUAD_TERM_TYPES, } from "./Terms.js";
import { assertIsValidQuad, isValidTerm } from "./assertionUtils.js";
import { parseLanguageTag } from "@sozialhelden/ietf-language-tags";
import { memoize } from "lodash-es";
const LruCache = _LruCache;
export const ParseError = BaseParseError;
export class IriParseError extends ParseError {
}
export class LanguageTagParseError extends ParseError {
    languageTag;
    constructor(opts) {
        super(opts);
        this.languageTag = opts.languageTag;
    }
}
export const isValidLanguageTag = memoizee((languageTag) => {
    return !!parseLanguageTag(languageTag, true, null);
}, { primitive: true, max: 100 });
export function getFactory(factoryOpts) {
    const lruCache = new LruCache(1000);
    const allowedQuadPositions = factoryOpts?.quadTerms || BASE_QUAD_TERM_TYPES;
    let blankNodeCounter = 0;
    let bnodePrefix = factoryOpts?.bnodePrefix || randomUUID().substring(0, 4);
    function _namedNode(iri, opts) {
        let validationStatus = opts?.validationStatus;
        if (!validationStatus && factoryOpts?.skipValidation)
            validationStatus = "disabled";
        if (!validationStatus) {
            try {
                validate(iri);
                validationStatus = "canonical";
            }
            catch (error) {
                const replacement = factoryOpts?.onInvalidIri?.({ error, value: iri })?.replaceWith;
                if (replacement)
                    return replacement;
                throw new IriParseError({
                    message: error.message,
                    lexicalValue: iri,
                    cause: error,
                });
            }
        }
        return new NamedNode(iri, validationStatus);
    }
    const namedNode = memoize(_namedNode, (iri, opts) => `${iri}|${opts?.validationStatus}`);
    namedNode.cache = lruCache;
    const xsdString = namedNode("http://www.w3.org/2001/XMLSchema#string");
    const langTagString = namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#langString");
    function blankNode(name) {
        return new BlankNode(name || `${bnodePrefix}-${blankNodeCounter++}`);
    }
    function createLiteral(value, languageOrDataType, opts) {
        value = typeof value === "string" ? value : `${value}`;
        let language;
        let datatype;
        if (typeof languageOrDataType === "string") {
            if (!opts?.validationStatus && !factoryOpts?.skipValidation && !isValidLanguageTag(languageOrDataType)) {
                throw new LanguageTagParseError({
                    languageTag: languageOrDataType,
                    lexicalValue: value,
                    message: `Invalid language tag '${languageOrDataType}'`,
                });
            }
            language = languageOrDataType.toLowerCase();
            datatype = langTagString;
        }
        else {
            datatype = languageOrDataType ? fromTerm(languageOrDataType) : xsdString;
        }
        let validationStatus = opts?.validationStatus;
        if (!validationStatus && factoryOpts?.skipValidation)
            validationStatus = "disabled";
        if (!validationStatus) {
            if (isRecognized(datatype)) {
                value = lexicalToCanonical(value, datatype);
                validationStatus = "canonical";
            }
            else {
                validationStatus = "unrecognized";
            }
        }
        const returnedLiteral = new Literal(value, validationStatus, datatype, language);
        if (validationStatus === "unrecognized")
            factoryOpts?.onUnsupportedTerm?.(returnedLiteral);
        return returnedLiteral;
    }
    function literal(value, languageOrDataType, opts) {
        if (!factoryOpts?.onInvalidLiteral)
            return createLiteral(value, languageOrDataType, opts);
        try {
            return createLiteral(value, languageOrDataType, opts);
        }
        catch (e) {
            let language, datatype;
            if (typeof languageOrDataType === "string") {
                language = languageOrDataType;
            }
            else {
                datatype = languageOrDataType;
            }
            const { replaceWith } = factoryOpts.onInvalidLiteral({ error: e, value, language, datatype });
            return replaceWith;
        }
    }
    function variable(name) {
        return new Variable(name);
    }
    const DEFAULT_GRAPH = new DefaultGraph();
    function defaultGraph() {
        return DEFAULT_GRAPH;
    }
    function fromTerm(term, opts) {
        if ("validationStatus" in term)
            return term;
        switch (term.termType) {
            case "BlankNode":
                return blankNode(term.value);
            case "DefaultGraph":
                return defaultGraph();
            case "Literal":
                return literal(term.value, term.language || fromTerm(term.datatype, opts));
            case "NamedNode":
                return namedNode(term.value, opts);
            case "Variable":
                return variable(term.value);
            case "Quad":
                return fromQuad(term);
        }
    }
    function fromQuad(term) {
        if (term instanceof Quad)
            return term;
        return quad(fromTerm(term.subject), fromTerm(term.predicate), fromTerm(term.object), fromTerm(term.graph));
    }
    function isValidSubject(term) {
        return isValidTerm(term, allowedQuadPositions.subject);
    }
    function isValidPredicate(term) {
        return isValidTerm(term, allowedQuadPositions.predicate);
    }
    function isValidObject(term) {
        return isValidTerm(term, allowedQuadPositions.object);
    }
    function isValidGraph(term) {
        return isValidTerm(term, allowedQuadPositions.graph);
    }
    function quad(subject, predicate, object, graph) {
        assertIsValidQuad(factoryOpts?.quadTerms, subject, predicate, object, graph);
        return new Quad(subject, predicate, object, graph || DEFAULT_GRAPH);
    }
    function resetBnodeCounter() {
        blankNodeCounter = 0;
    }
    function prefixer(base) {
        const baseString = typeof base === "string" ? base : base.value;
        return function prefix(local) {
            return namedNode(`${baseString}${local}`);
        };
    }
    const baseFactory = {
        literal,
        namedNode,
        blankNode,
        defaultGraph,
        quad,
        variable,
    };
    return {
        ...baseFactory,
        fromTerm,
        fromQuad,
        resetBnodeCounter,
        prefixer,
        isValidSubject,
        isValidPredicate,
        isValidObject,
        isValidGraph,
    };
}
export const factory = getFactory();
//# sourceMappingURL=DataFactory.js.map