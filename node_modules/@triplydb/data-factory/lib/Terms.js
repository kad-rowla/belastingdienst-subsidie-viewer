import { SUB_TYPES, isNumericDatatype, } from "@triplydb/recognized-datatypes/utils/constants.js";
import { lexicalToValue } from "@triplydb/recognized-datatypes";
export function padLeftTwo(value) {
    return `${value}`.padStart(2, "0");
}
function normalizeTimeZone(timezone) {
    return timezone === undefined ? "" : padLeftTwo(timezone);
}
export const BASE_QUAD_TERM_TYPES = {
    subject: ["NamedNode", "BlankNode", "Variable", "Quad"],
    predicate: ["NamedNode", "Variable"],
    object: ["NamedNode", "BlankNode", "Variable", "Literal", "Quad"],
    graph: ["NamedNode", "BlankNode", "Variable", "DefaultGraph"],
};
export class NamedNode {
    static termType = "NamedNode";
    termType = NamedNode.termType;
    value;
    get unsafeMutable() {
        return this;
    }
    validationStatus;
    constructor(iri, validationStatus) {
        this.validationStatus = validationStatus;
        this.value = iri;
    }
    get id() {
        return `<${this.value}>`;
    }
    equals(other) {
        return !!other && this.termType === other.termType && this.value === other.value;
    }
    get cmpString() {
        return "i\x01" + this.value.replace(/\x01/g, "\x02");
    }
}
function zeroPad(num, untilLength, sideToPad) {
    let value = `${num}`;
    while (value.length < untilLength) {
        if (sideToPad === "left")
            value = "0" + value;
        else if (sideToPad === "right")
            value = value + "0";
    }
    return value;
}
function invert(digits) {
    return digits
        .split("")
        .map((k) => 9 - parseInt(k))
        .join("");
}
export function lexSerializeNumericString(numericString) {
    const val = Number(numericString);
    const exponent = parseInt(val.toExponential().split("e")[1]);
    const valueIsZero = val === 0;
    const valueIsPositive = val > 0;
    const valueIsNegative = val < 0;
    const exponentIsZero = exponent === 0;
    const exponentIsPositive = exponent > 0;
    const exponentIsNegative = exponent < 0;
    const mantissaLex = zeroPad(Math.abs(parseInt(val.toExponential().split("e")[0].replace(".", ""))), 20, "right");
    const exponentLex = zeroPad(Math.abs(exponent), 4, "left");
    if (valueIsNegative && exponentIsPositive) {
        return `++${invert(exponentLex)}${invert(mantissaLex)}`;
    }
    if (valueIsNegative && exponentIsZero) {
        return `+,${exponentLex}${invert(mantissaLex)}`;
    }
    if (valueIsNegative && exponentIsNegative) {
        return `+-${exponentLex}${invert(mantissaLex)}`;
    }
    if (valueIsZero) {
        return `,,${exponentLex}${mantissaLex}`;
    }
    if (valueIsPositive && exponentIsNegative) {
        return `-+${invert(exponentLex)}${mantissaLex}`;
    }
    if (valueIsPositive && exponentIsZero) {
        return `-,${exponentLex}${mantissaLex}`;
    }
    if (valueIsPositive && exponentIsPositive) {
        return `--${exponentLex}${mantissaLex}`;
    }
    throw new Error("Impossible");
}
export class Literal {
    static termType = "Literal";
    termType = Literal.termType;
    validationStatus;
    value;
    get unsafeMutable() {
        return this;
    }
    language = "";
    datatype;
    constructor(value, validationStatus, datatype, language) {
        this.validationStatus = validationStatus;
        this.value = value;
        this.datatype = datatype;
        if (language)
            this.language = language;
    }
    get id() {
        if (this.language) {
            return `"${this.value}"@${this.language}`;
        }
        else {
            return `"${this.value}"^^${this.datatype.id}`;
        }
    }
    equals(other) {
        return (other?.termType === "Literal" &&
            this.value === other.value &&
            this.language === other.language &&
            this.datatype.value === other.datatype.value);
    }
    get cmpString() {
        if (SUB_TYPES.RDF_LANG_STRING.includes(this.datatype.value)) {
            return `l\x01${this.value.replace(/\x01/g, "\x02")}\x01${this.datatype.value.replace(/\x01/g, "\x02")}-${this.language}`;
        }
        if (SUB_TYPES.XSD_DATE_TIME.includes(this.datatype.value)) {
            const canonicalDate = lexicalToValue(this.value, this.datatype.value);
            const serializedYear = lexSerializeNumericString("" + canonicalDate.year);
            const serializedMonth = padLeftTwo(canonicalDate.month);
            const serializedDay = padLeftTwo(canonicalDate.day);
            const serializedHours = padLeftTwo(canonicalDate.hour);
            const serializedMinutes = padLeftTwo(canonicalDate.minute);
            const serializedSeconds = padLeftTwo(canonicalDate.second);
            const concatDate = serializedYear +
                serializedMonth +
                serializedDay +
                serializedHours +
                serializedMinutes +
                serializedSeconds +
                canonicalDate.fraction +
                normalizeTimeZone(canonicalDate.timezone);
            return `l\x01${concatDate}\x01${this.datatype.value}`;
        }
        if (SUB_TYPES.XSD_G_YEAR.includes(this.datatype.value)) {
            const canonicalDate = lexicalToValue(this.value, this.datatype.value);
            const serializedYear = lexSerializeNumericString("" + canonicalDate.year);
            const concatgYear = serializedYear + normalizeTimeZone(canonicalDate.timezone);
            return `l\x01${concatgYear}\x01${this.datatype.value}`;
        }
        if (SUB_TYPES.XSD_G_YEAR_MONTH.includes(this.datatype.value)) {
            const canonicalDate = lexicalToValue(this.value, this.datatype.value);
            const serializedYear = lexSerializeNumericString("" + canonicalDate.year);
            const serializedMonth = padLeftTwo(canonicalDate.month);
            const concatgYearMonth = serializedYear + serializedMonth + normalizeTimeZone(canonicalDate.timezone);
            return `l\x01${concatgYearMonth}\x01${this.datatype.value}`;
        }
        if (SUB_TYPES.XSD_DATE.includes(this.datatype.value)) {
            const canonicalDate = lexicalToValue(this.value, this.datatype.value);
            const serializedYear = lexSerializeNumericString("" + canonicalDate.year);
            const serializedMonth = padLeftTwo(canonicalDate.month);
            const serializedDay = padLeftTwo(canonicalDate.day);
            const concatgYearMonthDay = serializedYear + serializedMonth + serializedDay + normalizeTimeZone(canonicalDate.timezone);
            return `l\x01${concatgYearMonthDay}\x01${this.datatype.value}`;
        }
        if (SUB_TYPES.XSD_DURATION.includes(this.datatype.value)) {
            const canonicalDuration = lexicalToValue(this.value, this.datatype.value);
            const monthsToSeconds = canonicalDuration.months * 2629800;
            const totalTime = monthsToSeconds + canonicalDuration.seconds;
            const serializedSeconds = lexSerializeNumericString(`${canonicalDuration.isNegative ? "-" : ""}${totalTime}.${canonicalDuration.fraction}`);
            return `l\x01${serializedSeconds}\x01${this.datatype.value}`;
        }
        if (!isNumericDatatype(this.datatype)) {
            return `l\x01${this.value.replace(/\x01/g, "\x02")}\x01${this.datatype.value.replace(/\x01/g, "\x02")}`;
        }
        if (this.value === "-INF") {
            return "l\x01++/";
        }
        else if (this.value === "INF") {
            return "l\x01--\\";
        }
        else if (this.value === "NaN") {
            return "l\x01NaN";
        }
        return `l\x01${lexSerializeNumericString(this.value)}\x01${this.datatype.cmpString}`;
    }
}
export class BlankNode {
    static termType = "BlankNode";
    termType = BlankNode.termType;
    value;
    get unsafeMutable() {
        return this;
    }
    validationStatus = "canonical";
    constructor(name) {
        this.value = name;
    }
    get id() {
        return `_:${this.value}`;
    }
    equals(other) {
        return this.termType === other?.termType && this.value === other.value;
    }
    get cmpString() {
        return "b\x01" + this.value;
    }
}
export class Variable {
    static termType = "Variable";
    termType = Variable.termType;
    value;
    get unsafeMutable() {
        return this;
    }
    validationStatus = "canonical";
    constructor(name) {
        this.value = name;
    }
    get id() {
        return `?${this.value}`;
    }
    equals(other) {
        return this.termType === other?.termType && this.value === other.value;
    }
    get cmpString() {
        return "v\x01" + this.value.replace(/\x01/g, "\x02");
    }
}
export class DefaultGraph {
    static termType = "DefaultGraph";
    static id = "";
    termType = DefaultGraph.termType;
    value = "";
    id = DefaultGraph.id;
    cmpString = "";
    get unsafeMutable() {
        return this;
    }
    validationStatus = "canonical";
    equals(other) {
        return this.termType === other?.termType;
    }
}
export class Quad {
    static termType = "Quad";
    termType = Quad.termType;
    cmpString = "q\x01undefined";
    value = "";
    get unsafeMutable() {
        return this;
    }
    subject;
    predicate;
    object;
    graph;
    validationStatus;
    constructor(subject, predicate, object, graph) {
        this.subject = subject;
        this.predicate = predicate;
        this.object = object;
        this.graph = graph;
        const allTermsAreCanonical = [this.subject, this.predicate, this.object, this.graph].every((t) => t.validationStatus === "canonical");
        this.validationStatus = allTermsAreCanonical ? "canonical" : "unrecognized";
    }
    get id() {
        return `${this.subject.id} ${this.predicate.id} ${this.object.id} ${this.graph.id} .`;
    }
    equals(other) {
        return (other?.termType === "Quad" &&
            this.subject.equals(other.subject) &&
            this.predicate.equals(other.predicate) &&
            this.object.equals(other.object) &&
            this.graph.equals(other.graph));
    }
}
//# sourceMappingURL=Terms.js.map