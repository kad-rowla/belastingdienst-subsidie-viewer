/// <reference types="node" resolution-mode="require"/>
import * as n3 from "n3";
import { AnyTdbDataFactory } from "./DataFactory.js";
import { Quad } from "./Terms.js";
import { Transform, Duplex } from "stream";
export interface ParseOptions {
    format?: "turtle" | "trig" | "n-triples" | "n-quads" | "n3";
    factory?: AnyTdbDataFactory;
    baseIri?: string;
}
export declare function resetParserBlanknodeCounter(): void;
export declare function parse<F extends AnyTdbDataFactory>(inputString: string, opts?: ParseOptions): ReturnType<F["quad"]>[];
export interface ParsingContext {
    line: number;
    lines?: {
        [line: number]: string;
    };
    token?: Token;
    previousToken?: Token;
}
export interface StreamParser<Q extends Quad> extends Duplex {
    on(event: "data", cb: (quad: Q) => void): this;
    on(event: string, cb: Function): this;
}
interface N3Error extends Error {
    context: ParsingContext;
}
export interface Token {
    line: number;
    prefix: string;
    type: string;
    value: string;
}
export declare class StreamParser<Q extends Quad> extends Transform {
    parser: n3.Parser;
    onData?: (data: any) => void;
    onEnd?: () => void;
    lineCount: number;
    remainderLastChunk: string;
    currentChunk?: string;
    constructor(options?: n3.ParserOptions);
    _transform(chunk: any, _encoding: any, done: Function): void;
    _processError(e: N3Error): N3Error;
    _flush(done: Function): void;
}
export declare function getStreamParser<Q extends Quad>(options?: ParseOptions): StreamParser<Q>;
export {};
//# sourceMappingURL=parse.d.ts.map