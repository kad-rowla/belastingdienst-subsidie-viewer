import * as n3 from "n3";
import { factory } from "./DataFactory.js";
import Pumpify from "pumpify";
import { Transform } from "stream";
import { sortBy, pickBy, omit } from "lodash-es";
export function resetParserBlanknodeCounter() {
    n3.Parser._resetBlankNodePrefix();
}
function parseOptionsToN3Options(opts) {
    return {
        format: opts?.format,
        factory: opts?.factory || factory,
        baseIRI: opts?.baseIri,
    };
}
function getParser(options) {
    const parser = new n3.Parser(options);
    parser._lexer._iri = /^<((?:[^<>\\]|\\[uU])+)>[ \t]*/;
    parser._lexer._unescapedIri = /^<([^<>\\]*)>[ \t]*/;
    return parser;
}
export function parse(inputString, opts) {
    const parser = getParser(parseOptionsToN3Options(opts));
    return parser.parse(inputString);
}
function wrapDatafactoryFunction(func) {
    return (...args) => {
        for (const arg of args) {
            if (arg instanceof Error)
                return args[0];
        }
        try {
            return func(...args);
        }
        catch (e) {
            return e;
        }
    };
}
function wrapDatafactory(datafactory) {
    return {
        ...datafactory,
        literal: wrapDatafactoryFunction(datafactory.literal),
        namedNode: wrapDatafactoryFunction(datafactory.namedNode),
        quad: (...args) => {
            for (const arg of args) {
                if (arg instanceof Error)
                    return arg;
            }
            try {
                return datafactory.quad(...args);
            }
            catch (e) {
                return e;
            }
        },
    };
}
const contextSize = 5;
const maxLineLength = 500;
export class StreamParser extends Transform {
    parser;
    onData;
    onEnd;
    lineCount = 0;
    remainderLastChunk = "";
    currentChunk;
    constructor(options) {
        super({ decodeStrings: true, readableObjectMode: true });
        this.parser = getParser(options);
        this.parser.parse({
            on: (event, cb) => {
                switch (event) {
                    case "data":
                        this.onData = cb;
                        break;
                    case "end":
                        this.onEnd = cb;
                        break;
                    case "error":
                    default:
                        break;
                }
            },
        }, (error, t) => {
            if (error) {
                this.emit("error", this._processError(error));
            }
            else if (t) {
                this.push(t);
            }
        });
    }
    _transform(chunk, _encoding, done) {
        this.lineCount = this.parser._lexer._line;
        this.remainderLastChunk = this.parser._lexer._input || "";
        this.currentChunk = chunk;
        this.onData?.(chunk);
        done();
    }
    _processError(e) {
        const chunk = this.remainderLastChunk + this.currentChunk;
        const lines = chunk.split("\n");
        if (this.lineCount > 1) {
            lines.shift();
            this.lineCount++;
        }
        if (e.context.line !== lines.length + this.lineCount - 1)
            lines.pop();
        const numberedSlice = {};
        lines.forEach((val, key) => {
            numberedSlice[key + this.lineCount] = val;
        });
        const lineNumbers = sortBy(Object.keys(numberedSlice).map((key) => +key));
        const start = lineNumbers[0];
        const end = lineNumbers[lineNumbers.length - 1];
        const selectedSlice = pickBy(numberedSlice, (val, key) => {
            return key >= e.context.line - contextSize && key <= e.context.line + contextSize && val.length < maxLineLength;
        });
        const removeKeys = [];
        var remove = false;
        for (var i = e.context.line; i >= start; i--) {
            if (remove) {
                removeKeys.push(i);
            }
            else {
                if (selectedSlice[i] === undefined) {
                    remove = true;
                }
            }
        }
        var remove = false;
        for (var i = e.context.line; i <= end; i++) {
            if (remove)
                removeKeys.push(i);
            if (!selectedSlice[i]) {
                remove = true;
            }
        }
        const sequentialSlice = omit(selectedSlice, removeKeys);
        e.context.lines = sequentialSlice[e.context.line] ? sequentialSlice : undefined;
        return e;
    }
    _flush(done) {
        this.onEnd?.();
        done();
    }
}
export function getStreamParser(options) {
    const n3Options = parseOptionsToN3Options(options);
    n3Options.factory = wrapDatafactory(n3Options.factory);
    return new Pumpify.obj(new StreamParser(n3Options), new Transform({
        objectMode: true,
        transform: (quad, _encoding, cb) => {
            if (quad instanceof Error)
                return cb(quad);
            return cb(null, quad);
        },
    }));
}
//# sourceMappingURL=parse.js.map