import _namespaces from "n3/lib/IRIs.js";
const namespaces = _namespaces.default;
import _N3DataFactory, { Term } from "n3/lib/N3DataFactory.js";
const N3DataFactory = _N3DataFactory.default;
import { isDefaultGraph } from "n3/lib/N3Util.js";
const DEFAULTGRAPH = N3DataFactory.defaultGraph();
const { rdf, xsd } = namespaces;
const escape = /["\\\t\n\r\b\f\u0000-\u0019\ud800-\udbff]/, escapeAll = /["\\\t\n\r\b\f\u0000-\u0019]|[\ud800-\udbff][\udc00-\udfff]/g, escapedCharacters = {
    "\\": "\\\\",
    '"': '\\"',
    "\t": "\\t",
    "\n": "\\n",
    "\r": "\\r",
    "\b": "\\b",
    "\f": "\\f",
};
class SerializedTerm extends Term {
    equals() {
        return false;
    }
}
export default class N3Writer {
    constructor(outputStream, options) {
        this._prefixRegex = /$0^/;
        if (outputStream && typeof outputStream.write !== "function")
            (options = outputStream), (outputStream = null);
        if (!options)
            throw new Error("Options are required");
        if (!options.handleGraphNames)
            throw new Error("Option 'handleGraphNames' is required");
        this.handleGraphNames = options.handleGraphNames;
        this._lists = options.lists;
        if (!outputStream) {
            let output = "";
            this._outputStream = {
                write(chunk, encoding, done) {
                    output += chunk;
                    done && done();
                },
                end: (done) => {
                    done && done(null, output);
                },
            };
            this._endStream = true;
        }
        else {
            this._outputStream = outputStream;
            this._endStream = options.end === undefined ? true : !!options.end;
        }
        this._subject = null;
        if (!/triple|quad/i.test(options.format)) {
            this._lineMode = false;
            this._graph = DEFAULTGRAPH;
            this._prefixIRIs = Object.create(null);
            options.prefixes && this.addPrefixes(options.prefixes);
            if (options.baseIRI) {
                this._baseMatcher = new RegExp(`^${escapeRegex(options.baseIRI)}${options.baseIRI.endsWith("/") ? "" : "[#?]"}`);
                this._baseLength = options.baseIRI.length;
            }
        }
        else {
            this._lineMode = true;
            this._writeQuad = this._writeQuadLine;
        }
    }
    get _inDefaultGraph() {
        return DEFAULTGRAPH.equals(this._graph);
    }
    _write(string, callback) {
        this._outputStream.write(string, "utf8", callback);
    }
    _writeQuad(subject, predicate, object, graph, done) {
        try {
            if (this.handleGraphNames === "keep" && !graph.equals(this._graph)) {
                this._write((this._subject === null ? "" : this._inDefaultGraph ? ".\n" : "\n}\n") +
                    (DEFAULTGRAPH.equals(graph) ? "" : `${this._encodeIriOrBlank(graph)} {\n`));
                this._graph = graph;
                this._subject = null;
            }
            if (subject.equals(this._subject)) {
                if (predicate.equals(this._predicate))
                    this._write(`, ${this._encodeObject(object)}`, done);
                else
                    this._write(`;\n    ${this._encodePredicate((this._predicate = predicate))} ${this._encodeObject(object)}`, done);
            }
            else
                this._write(`${(this._subject === null ? "" : ".\n") + this._encodeSubject((this._subject = subject))} ${this._encodePredicate((this._predicate = predicate))} ${this._encodeObject(object)}`, done);
        }
        catch (error) {
            done && done(error);
        }
    }
    _writeQuadLine(subject, predicate, object, graph, done) {
        delete this._prefixMatch;
        this._write(this.quadToString(subject, predicate, object, graph), done);
    }
    quadToString(subject, predicate, object, graph) {
        return `${this._encodeSubject(subject)} ${this._encodeIriOrBlank(predicate)} ${this._encodeObject(object)}${this.handleGraphNames === "keep" && graph && graph.value ? ` ${this._encodeIriOrBlank(graph)} .\n` : " .\n"}`;
    }
    quadsToString(quads) {
        return quads
            .map((t) => {
            return this.quadToString(t.subject, t.predicate, t.object, t.graph);
        })
            .join("");
    }
    _encodeSubject(entity) {
        return entity.termType === "Quad" ? this._encodeQuad(entity) : this._encodeIriOrBlank(entity);
    }
    _encodeIriOrBlank(entity) {
        if (entity.termType !== "NamedNode") {
            if (this._lists && entity.value in this._lists)
                entity = this.list(this._lists[entity.value]);
            return "id" in entity ? entity.id : `_:${entity.value}`;
        }
        let iri = entity.value;
        if (this._baseMatcher && this._baseMatcher.test(iri))
            iri = iri.substr(this._baseLength);
        if (escape.test(iri))
            iri = iri.replace(escapeAll, characterReplacer);
        const prefixMatch = this._prefixRegex.exec(iri);
        return !prefixMatch ? `<${iri}>` : !prefixMatch[1] ? iri : this._prefixIRIs[prefixMatch[1]] + prefixMatch[2];
    }
    _encodeLiteral(literal) {
        let value = literal.value;
        if (escape.test(value))
            value = value.replace(escapeAll, characterReplacer);
        if (literal.language)
            return `"${value}"@${literal.language}`;
        if (this._lineMode) {
            if (literal.datatype.value === xsd.string)
                return `"${value}"`;
        }
        else {
            switch (literal.datatype.value) {
                case xsd.string:
                    return `"${value}"`;
                case xsd.boolean:
                    if (value === "true" || value === "false")
                        return value;
                    break;
                case xsd.integer:
                    if (/^[+-]?\d+$/.test(value))
                        return value;
                    break;
                case xsd.decimal:
                    if (/^[+-]?\d*\.\d+$/.test(value))
                        return value;
                    break;
                case xsd.double:
                    if (/^[+-]?(?:\d+\.\d*|\.?\d+)[eE][+-]?\d+$/.test(value))
                        return value;
                    break;
            }
        }
        return `"${value}"^^${this._encodeIriOrBlank(literal.datatype)}`;
    }
    _encodePredicate(predicate) {
        return predicate.value === rdf.type ? "a" : this._encodeIriOrBlank(predicate);
    }
    _encodeObject(object) {
        switch (object.termType) {
            case "Quad":
                return this._encodeQuad(object);
            case "Literal":
                return this._encodeLiteral(object);
            default:
                return this._encodeIriOrBlank(object);
        }
    }
    _encodeQuad({ subject, predicate, object, graph }) {
        return `<<${this._encodeSubject(subject)} ${this._encodePredicate(predicate)} ${this._encodeObject(object)}${isDefaultGraph(graph) ? "" : ` ${this._encodeIriOrBlank(graph)}`}>>`;
    }
    _blockedWrite() {
        throw new Error("Cannot write because the writer has been closed.");
    }
    addQuad(subject, predicate, object, graph, done) {
        if (object === undefined)
            this._writeQuad(subject.subject, subject.predicate, subject.object, subject.graph, predicate);
        else if (typeof graph === "function")
            this._writeQuad(subject, predicate, object, DEFAULTGRAPH, graph);
        else
            this._writeQuad(subject, predicate, object, graph || DEFAULTGRAPH, done);
    }
    addQuads(quads) {
        for (let i = 0; i < quads.length; i++)
            this.addQuad(quads[i]);
    }
    addPrefix(prefix, iri, done) {
        const prefixes = {};
        prefixes[prefix] = iri;
        this.addPrefixes(prefixes, done);
    }
    addPrefixes(prefixes, done) {
        if (!this._prefixIRIs)
            return done && done();
        let hasPrefixes = false;
        for (let prefix in prefixes) {
            let iri = prefixes[prefix];
            if (typeof iri !== "string")
                iri = iri.value;
            hasPrefixes = true;
            if (this._subject !== null) {
                this._write(this._inDefaultGraph ? ".\n" : "\n}\n");
                (this._subject = null), (this._graph = "");
            }
            this._prefixIRIs[iri] = prefix += ":";
            this._write(`@prefix ${prefix} <${iri}>.\n`);
        }
        if (hasPrefixes) {
            let IRIlist = "", prefixList = "";
            for (const prefixIRI in this._prefixIRIs) {
                IRIlist += IRIlist ? `|${prefixIRI}` : prefixIRI;
                prefixList += (prefixList ? "|" : "") + this._prefixIRIs[prefixIRI];
            }
            IRIlist = escapeRegex(IRIlist, /[\]\/\(\)\*\+\?\.\\\$]/g, "\\$&");
            this._prefixRegex = new RegExp(`^(?:${prefixList})[^\/]*$|` + `^(${IRIlist})([_a-zA-Z][\\-_a-zA-Z0-9]*)$`);
        }
        this._write(hasPrefixes ? "\n" : "", done);
    }
    blank(predicate, object) {
        let children = predicate, child, length;
        if (predicate === undefined)
            children = [];
        else if (predicate.termType)
            children = [{ predicate: predicate, object: object }];
        else if (!("length" in predicate))
            children = [predicate];
        switch ((length = children.length)) {
            case 0:
                return new SerializedTerm("[]");
            case 1:
                child = children[0];
                if (!(child.object instanceof SerializedTerm))
                    return new SerializedTerm(`[ ${this._encodePredicate(child.predicate)} ${this._encodeObject(child.object)} ]`);
            default:
                let contents = "[";
                for (let i = 0; i < length; i++) {
                    child = children[i];
                    if (child.predicate.equals(predicate))
                        contents += `, ${this._encodeObject(child.object)}`;
                    else {
                        contents += `${(i ? ";\n  " : "\n  ") + this._encodePredicate(child.predicate)} ${this._encodeObject(child.object)}`;
                        predicate = child.predicate;
                    }
                }
                return new SerializedTerm(`${contents}\n]`);
        }
    }
    list(elements) {
        const length = (elements && elements.length) || 0, contents = new Array(length);
        for (let i = 0; i < length; i++)
            contents[i] = this._encodeObject(elements[i]);
        return new SerializedTerm(`(${contents.join(" ")})`);
    }
    end(done) {
        if (this._subject !== null) {
            this._write(this._inDefaultGraph ? ".\n" : "\n}\n");
            this._subject = null;
        }
        this._write = this._blockedWrite;
        let singleDone = done &&
            ((error, result) => {
                (singleDone = null), done(error, result);
            });
        if (this._endStream) {
            try {
                return this._outputStream.end(singleDone);
            }
            catch (error) {
            }
        }
        singleDone && singleDone();
    }
}
function characterReplacer(character) {
    let result = escapedCharacters[character];
    if (result === undefined) {
        if (character.length === 1) {
            result = character.charCodeAt(0).toString(16);
            result = "\\u0000".substr(0, 6 - result.length) + result;
        }
        else {
            result = ((character.charCodeAt(0) - 0xd800) * 0x400 + character.charCodeAt(1) + 0x2400).toString(16);
            result = "\\U00000000".substr(0, 10 - result.length) + result;
        }
    }
    return result;
}
function escapeRegex(regex) {
    return regex.replace(/[\]\/\(\)\*\+\?\.\\\$]/g, "\\$&");
}
//# sourceMappingURL=N3Writer.js.map