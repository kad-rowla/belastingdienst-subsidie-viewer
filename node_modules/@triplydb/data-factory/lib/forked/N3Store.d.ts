export default class N3Store {
    constructor(quads: any, options: any);
    _size: number;
    _graphs: any;
    _id: number;
    _ids: any;
    _entities: any;
    _blankNodeIndex: number;
    _factory: any;
    _termFromId: any;
    _termToId: any;
    get size(): number;
    _addToIndex(index0: any, key0: any, key1: any, key2: any): boolean;
    _removeFromIndex(index0: any, key0: any, key1: any, key2: any): void;
    _findInIndex(index0: any, key0: any, key1: any, key2: any, name0: any, name1: any, name2: any, graphId: any): Generator<any, void, unknown>;
    _loop(index0: any, callback: any): void;
    _loopByKey0(index0: any, key0: any, callback: any): void;
    _loopByKey1(index0: any, key1: any, callback: any): void;
    _loopBy2Keys(index0: any, key0: any, key1: any, callback: any): void;
    _countInIndex(index0: any, key0: any, key1: any, key2: any): number;
    _getGraphs(graph: any): any;
    _uniqueEntities(callback: any): (id: any) => void;
    add(quad: any): this;
    addQuad(subject: any, predicate: any, object: any, graph: any): boolean;
    addQuads(quads: any): void;
    delete(quad: any): this;
    has(subjectOrQuad: any, predicate: any, object: any, graph: any): boolean;
    import(stream: any): any;
    removeQuad(subject: any, predicate: any, object: any, graph: any): boolean;
    removeQuads(quads: any): void;
    remove(stream: any): any;
    removeMatches(subject: any, predicate: any, object: any, graph: any): any;
    deleteGraph(graph: any): any;
    getQuads(subject: any, predicate: any, object: any, graph: any): any[];
    readQuads(subject: any, predicate: any, object: any, graph: any): Generator<any, void, unknown>;
    match(subject: any, predicate: any, object: any, graph: any): DatasetCoreAndReadableStream;
    countQuads(subject: any, predicate: any, object: any, graph: any): number;
    forEach(callback: any, subject: any, predicate: any, object: any, graph: any): void;
    every(callback: any, subject: any, predicate: any, object: any, graph: any): boolean;
    some(callback: any, subject: any, predicate: any, object: any, graph: any): boolean;
    getSubjects(predicate: any, object: any, graph: any): any[];
    forSubjects(callback: any, predicate: any, object: any, graph: any): void;
    getPredicates(subject: any, object: any, graph: any): any[];
    forPredicates(callback: any, subject: any, object: any, graph: any): void;
    getObjects(subject: any, predicate: any, graph: any): any[];
    forObjects(callback: any, subject: any, predicate: any, graph: any): void;
    getGraphs(subject: any, predicate: any, object: any): any[];
    forGraphs(callback: any, subject: any, predicate: any, object: any): void;
    createBlankNode(suggestedName: any): any;
    extractLists({ remove, ignoreErrors }?: {
        remove?: boolean | undefined;
        ignoreErrors?: boolean | undefined;
    }): {};
    [Symbol.iterator](): Generator<any, void, unknown>;
}
declare class DatasetCoreAndReadableStream {
    constructor(n3Store: any, subject: any, predicate: any, object: any, graph: any);
    get filtered(): N3Store;
    _filtered: N3Store | undefined;
    get size(): number;
    _read(): void;
    add(quad: any): N3Store;
    delete(quad: any): N3Store;
    has(quad: any): boolean;
    match(subject: any, predicate: any, object: any, graph: any): DatasetCoreAndReadableStream;
    [Symbol.iterator](): Generator<any, void, any>;
}
export {};
//# sourceMappingURL=N3Store.d.ts.map