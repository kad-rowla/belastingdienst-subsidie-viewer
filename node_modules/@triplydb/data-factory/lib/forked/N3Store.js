import _N3DataFactory, { termToId, termFromId } from "n3/lib/N3DataFactory.js";
const N3DataFactory = _N3DataFactory.default;
import { Readable } from "readable-stream";
import _namespaces from "n3/lib/IRIs.js";
const namespaces = _namespaces.default;
export default class N3Store {
    constructor(quads, options) {
        this._size = 0;
        this._graphs = Object.create(null);
        this._id = 0;
        this._ids = Object.create(null);
        this._ids["><"] = 0;
        this._entities = Object.create(null);
        this._blankNodeIndex = 0;
        if (!options && quads && !quads[0])
            (options = quads), (quads = null);
        options = options || {};
        this._factory = options.factory || N3DataFactory;
        this._termFromId = options.termFromId || termFromId;
        this._termToId = options.termToId || termToId;
        if (quads)
            this.addQuads(quads);
    }
    get size() {
        let size = this._size;
        if (size !== null)
            return size;
        size = 0;
        const graphs = this._graphs;
        let subjects, subject;
        for (const graphKey in graphs)
            for (const subjectKey in (subjects = graphs[graphKey].subjects))
                for (const predicateKey in (subject = subjects[subjectKey]))
                    size += Object.keys(subject[predicateKey]).length;
        return (this._size = size);
    }
    _addToIndex(index0, key0, key1, key2) {
        const index1 = index0[key0] || (index0[key0] = {});
        const index2 = index1[key1] || (index1[key1] = {});
        const existed = key2 in index2;
        if (!existed)
            index2[key2] = null;
        return !existed;
    }
    _removeFromIndex(index0, key0, key1, key2) {
        const index1 = index0[key0], index2 = index1[key1];
        delete index2[key2];
        for (const key in index2)
            return;
        delete index1[key1];
        for (const key in index1)
            return;
        delete index0[key0];
    }
    *_findInIndex(index0, key0, key1, key2, name0, name1, name2, graphId) {
        let tmp, index1, index2;
        const entityKeys = this._entities;
        const graph = this._termFromId(graphId, this._factory);
        const parts = { subject: null, predicate: null, object: null };
        if (key0)
            ((tmp = index0), (index0 = {}))[key0] = tmp[key0];
        for (const value0 in index0) {
            if ((index1 = index0[value0])) {
                parts[name0] = this._termFromId(entityKeys[value0], this._factory);
                if (key1)
                    ((tmp = index1), (index1 = {}))[key1] = tmp[key1];
                for (const value1 in index1) {
                    if ((index2 = index1[value1])) {
                        parts[name1] = this._termFromId(entityKeys[value1], this._factory);
                        const values = key2 ? (key2 in index2 ? [key2] : []) : Object.keys(index2);
                        for (let l = 0; l < values.length; l++) {
                            parts[name2] = this._termFromId(entityKeys[values[l]], this._factory);
                            yield this._factory.quad(parts.subject, parts.predicate, parts.object, graph);
                        }
                    }
                }
            }
        }
    }
    _loop(index0, callback) {
        for (const key0 in index0)
            callback(key0);
    }
    _loopByKey0(index0, key0, callback) {
        let index1, key1;
        if ((index1 = index0[key0])) {
            for (key1 in index1)
                callback(key1);
        }
    }
    _loopByKey1(index0, key1, callback) {
        let key0, index1;
        for (key0 in index0) {
            index1 = index0[key0];
            if (index1[key1])
                callback(key0);
        }
    }
    _loopBy2Keys(index0, key0, key1, callback) {
        let index1, index2, key2;
        if ((index1 = index0[key0]) && (index2 = index1[key1])) {
            for (key2 in index2)
                callback(key2);
        }
    }
    _countInIndex(index0, key0, key1, key2) {
        let count = 0, tmp, index1, index2;
        if (key0)
            ((tmp = index0), (index0 = {}))[key0] = tmp[key0];
        for (const value0 in index0) {
            if ((index1 = index0[value0])) {
                if (key1)
                    ((tmp = index1), (index1 = {}))[key1] = tmp[key1];
                for (const value1 in index1) {
                    if ((index2 = index1[value1])) {
                        if (key2)
                            key2 in index2 && count++;
                        else
                            count += Object.keys(index2).length;
                    }
                }
            }
        }
        return count;
    }
    _getGraphs(graph) {
        if (!isString(graph))
            return this._graphs;
        const graphs = {};
        graphs[graph] = this._graphs[graph];
        return graphs;
    }
    _uniqueEntities(callback) {
        const uniqueIds = Object.create(null);
        return (id) => {
            if (!(id in uniqueIds)) {
                uniqueIds[id] = true;
                callback(this._termFromId(this._entities[id], this._factory));
            }
        };
    }
    add(quad) {
        this.addQuad(quad);
        return this;
    }
    addQuad(subject, predicate, object, graph) {
        if (!predicate)
            (graph = subject.graph), (object = subject.object), (predicate = subject.predicate), (subject = subject.subject);
        subject = this._termToId(subject);
        predicate = this._termToId(predicate);
        object = this._termToId(object);
        graph = this._termToId(graph);
        let graphItem = this._graphs[graph];
        if (!graphItem) {
            graphItem = this._graphs[graph] = { subjects: {}, predicates: {}, objects: {} };
            Object.freeze(graphItem);
        }
        const ids = this._ids;
        const entities = this._entities;
        subject = ids[subject] || (ids[(entities[++this._id] = subject)] = this._id);
        predicate = ids[predicate] || (ids[(entities[++this._id] = predicate)] = this._id);
        object = ids[object] || (ids[(entities[++this._id] = object)] = this._id);
        const changed = this._addToIndex(graphItem.subjects, subject, predicate, object);
        this._addToIndex(graphItem.predicates, predicate, object, subject);
        this._addToIndex(graphItem.objects, object, subject, predicate);
        this._size = null;
        return changed;
    }
    addQuads(quads) {
        for (let i = 0; i < quads.length; i++)
            this.addQuad(quads[i]);
    }
    delete(quad) {
        this.removeQuad(quad);
        return this;
    }
    has(subjectOrQuad, predicate, object, graph) {
        if (subjectOrQuad && subjectOrQuad.subject)
            ({ subject: subjectOrQuad, predicate, object, graph } = subjectOrQuad);
        return !this.readQuads(subjectOrQuad, predicate, object, graph).next().done;
    }
    import(stream) {
        stream.on("data", (quad) => {
            this.addQuad(quad);
        });
        return stream;
    }
    removeQuad(subject, predicate, object, graph) {
        if (!predicate)
            (graph = subject.graph), (object = subject.object), (predicate = subject.predicate), (subject = subject.subject);
        subject = this._termToId(subject);
        predicate = this._termToId(predicate);
        object = this._termToId(object);
        graph = this._termToId(graph);
        const ids = this._ids, graphs = this._graphs;
        let graphItem, subjects, predicates;
        if (!(subject = ids[subject]) ||
            !(predicate = ids[predicate]) ||
            !(object = ids[object]) ||
            !(graphItem = graphs[graph]) ||
            !(subjects = graphItem.subjects[subject]) ||
            !(predicates = subjects[predicate]) ||
            !(object in predicates))
            return false;
        this._removeFromIndex(graphItem.subjects, subject, predicate, object);
        this._removeFromIndex(graphItem.predicates, predicate, object, subject);
        this._removeFromIndex(graphItem.objects, object, subject, predicate);
        if (this._size !== null)
            this._size--;
        for (subject in graphItem.subjects)
            return true;
        delete graphs[graph];
        return true;
    }
    removeQuads(quads) {
        for (let i = 0; i < quads.length; i++)
            this.removeQuad(quads[i]);
    }
    remove(stream) {
        stream.on("data", (quad) => {
            this.removeQuad(quad);
        });
        return stream;
    }
    removeMatches(subject, predicate, object, graph) {
        const stream = new Readable({ objectMode: true });
        stream._read = () => {
            for (const quad of this.readQuads(subject, predicate, object, graph))
                stream.push(quad);
            stream.push(null);
        };
        return this.remove(stream);
    }
    deleteGraph(graph) {
        return this.removeMatches(null, null, null, graph);
    }
    getQuads(subject, predicate, object, graph) {
        return [...this.readQuads(subject, predicate, object, graph)];
    }
    *readQuads(subject, predicate, object, graph) {
        subject = subject && this._termToId(subject);
        predicate = predicate && this._termToId(predicate);
        object = object && this._termToId(object);
        graph = graph && this._termToId(graph);
        const graphs = this._getGraphs(graph), ids = this._ids;
        let content, subjectId, predicateId, objectId;
        if ((isString(subject) && !(subjectId = ids[subject])) ||
            (isString(predicate) && !(predicateId = ids[predicate])) ||
            (isString(object) && !(objectId = ids[object])))
            return;
        for (const graphId in graphs) {
            if ((content = graphs[graphId])) {
                if (subjectId) {
                    if (objectId)
                        yield* this._findInIndex(content.objects, objectId, subjectId, predicateId, "object", "subject", "predicate", graphId);
                    else
                        yield* this._findInIndex(content.subjects, subjectId, predicateId, null, "subject", "predicate", "object", graphId);
                }
                else if (predicateId)
                    yield* this._findInIndex(content.predicates, predicateId, objectId, null, "predicate", "object", "subject", graphId);
                else if (objectId)
                    yield* this._findInIndex(content.objects, objectId, null, null, "object", "subject", "predicate", graphId);
                else
                    yield* this._findInIndex(content.subjects, null, null, null, "subject", "predicate", "object", graphId);
            }
        }
    }
    match(subject, predicate, object, graph) {
        return new DatasetCoreAndReadableStream(this, subject, predicate, object, graph);
    }
    countQuads(subject, predicate, object, graph) {
        subject = subject && this._termToId(subject);
        predicate = predicate && this._termToId(predicate);
        object = object && this._termToId(object);
        graph = graph && this._termToId(graph);
        const graphs = this._getGraphs(graph), ids = this._ids;
        let count = 0, content, subjectId, predicateId, objectId;
        if ((isString(subject) && !(subjectId = ids[subject])) ||
            (isString(predicate) && !(predicateId = ids[predicate])) ||
            (isString(object) && !(objectId = ids[object])))
            return 0;
        for (const graphId in graphs) {
            if ((content = graphs[graphId])) {
                if (subject) {
                    if (object)
                        count += this._countInIndex(content.objects, objectId, subjectId, predicateId);
                    else
                        count += this._countInIndex(content.subjects, subjectId, predicateId, objectId);
                }
                else if (predicate) {
                    count += this._countInIndex(content.predicates, predicateId, objectId, subjectId);
                }
                else {
                    count += this._countInIndex(content.objects, objectId, subjectId, predicateId);
                }
            }
        }
        return count;
    }
    forEach(callback, subject, predicate, object, graph) {
        this.some((quad) => {
            callback(quad);
            return false;
        }, subject, predicate, object, graph);
    }
    every(callback, subject, predicate, object, graph) {
        let some = false;
        const every = !this.some((quad) => {
            some = true;
            return !callback(quad);
        }, subject, predicate, object, graph);
        return some && every;
    }
    some(callback, subject, predicate, object, graph) {
        for (const quad of this.readQuads(subject, predicate, object, graph))
            if (callback(quad))
                return true;
        return false;
    }
    getSubjects(predicate, object, graph) {
        const results = [];
        this.forSubjects((s) => {
            results.push(s);
        }, predicate, object, graph);
        return results;
    }
    forSubjects(callback, predicate, object, graph) {
        predicate = predicate && this._termToId(predicate);
        object = object && this._termToId(object);
        graph = graph && this._termToId(graph);
        const ids = this._ids, graphs = this._getGraphs(graph);
        let content, predicateId, objectId;
        callback = this._uniqueEntities(callback);
        if ((isString(predicate) && !(predicateId = ids[predicate])) || (isString(object) && !(objectId = ids[object])))
            return;
        for (graph in graphs) {
            if ((content = graphs[graph])) {
                if (predicateId) {
                    if (objectId)
                        this._loopBy2Keys(content.predicates, predicateId, objectId, callback);
                    else
                        this._loopByKey1(content.subjects, predicateId, callback);
                }
                else if (objectId)
                    this._loopByKey0(content.objects, objectId, callback);
                else
                    this._loop(content.subjects, callback);
            }
        }
    }
    getPredicates(subject, object, graph) {
        const results = [];
        this.forPredicates((p) => {
            results.push(p);
        }, subject, object, graph);
        return results;
    }
    forPredicates(callback, subject, object, graph) {
        subject = subject && this._termToId(subject);
        object = object && this._termToId(object);
        graph = graph && this._termToId(graph);
        const ids = this._ids, graphs = this._getGraphs(graph);
        let content, subjectId, objectId;
        callback = this._uniqueEntities(callback);
        if ((isString(subject) && !(subjectId = ids[subject])) || (isString(object) && !(objectId = ids[object])))
            return;
        for (graph in graphs) {
            if ((content = graphs[graph])) {
                if (subjectId) {
                    if (objectId)
                        this._loopBy2Keys(content.objects, objectId, subjectId, callback);
                    else
                        this._loopByKey0(content.subjects, subjectId, callback);
                }
                else if (objectId)
                    this._loopByKey1(content.predicates, objectId, callback);
                else
                    this._loop(content.predicates, callback);
            }
        }
    }
    getObjects(subject, predicate, graph) {
        const results = [];
        this.forObjects((o) => {
            results.push(o);
        }, subject, predicate, graph);
        return results;
    }
    forObjects(callback, subject, predicate, graph) {
        subject = subject && this._termToId(subject);
        predicate = predicate && this._termToId(predicate);
        graph = graph && this._termToId(graph);
        const ids = this._ids, graphs = this._getGraphs(graph);
        let content, subjectId, predicateId;
        callback = this._uniqueEntities(callback);
        if ((isString(subject) && !(subjectId = ids[subject])) || (isString(predicate) && !(predicateId = ids[predicate])))
            return;
        for (graph in graphs) {
            if ((content = graphs[graph])) {
                if (subjectId) {
                    if (predicateId)
                        this._loopBy2Keys(content.subjects, subjectId, predicateId, callback);
                    else
                        this._loopByKey1(content.objects, subjectId, callback);
                }
                else if (predicateId)
                    this._loopByKey0(content.predicates, predicateId, callback);
                else
                    this._loop(content.objects, callback);
            }
        }
    }
    getGraphs(subject, predicate, object) {
        const results = [];
        this.forGraphs((g) => {
            results.push(g);
        }, subject, predicate, object);
        return results;
    }
    forGraphs(callback, subject, predicate, object) {
        for (const graph in this._graphs) {
            this.some((quad) => {
                callback(quad.graph);
                return true;
            }, subject, predicate, object, graph);
        }
    }
    createBlankNode(suggestedName) {
        let name, index;
        if (suggestedName) {
            (name = suggestedName = `_:${suggestedName}`), (index = 1);
            while (this._ids[name])
                name = suggestedName + index++;
        }
        else {
            do {
                name = `_:b${this._blankNodeIndex++}`;
            } while (this._ids[name]);
        }
        this._ids[name] = ++this._id;
        this._entities[this._id] = name;
        return this._factory.blankNode(name.substr(2));
    }
    extractLists({ remove = false, ignoreErrors = false } = {}) {
        const lists = {};
        const onError = ignoreErrors
            ? () => true
            : (node, message) => {
                throw new Error(`${node.value} ${message}`);
            };
        const tails = this.getQuads(null, namespaces.rdf.rest, namespaces.rdf.nil, null);
        const toRemove = remove ? [...tails] : [];
        tails.forEach((tailQuad) => {
            const items = [];
            let malformed = false;
            let head;
            let headPos;
            const graph = tailQuad.graph;
            let current = tailQuad.subject;
            while (current && !malformed) {
                const objectQuads = this.getQuads(null, null, current, null);
                const subjectQuads = this.getQuads(current, null, null, null);
                let quad, first = null, rest = null, parent = null;
                for (let i = 0; i < subjectQuads.length && !malformed; i++) {
                    quad = subjectQuads[i];
                    if (!quad.graph.equals(graph))
                        malformed = onError(current, "not confined to single graph");
                    else if (head)
                        malformed = onError(current, "has non-list arcs out");
                    else if (quad.predicate.value === namespaces.rdf.first) {
                        if (first)
                            malformed = onError(current, "has multiple rdf:first arcs");
                        else
                            toRemove.push((first = quad));
                    }
                    else if (quad.predicate.value === namespaces.rdf.rest) {
                        if (rest)
                            malformed = onError(current, "has multiple rdf:rest arcs");
                        else
                            toRemove.push((rest = quad));
                    }
                    else if (objectQuads.length)
                        malformed = onError(current, "can't be subject and object");
                    else {
                        head = quad;
                        headPos = "subject";
                    }
                }
                for (let i = 0; i < objectQuads.length && !malformed; ++i) {
                    quad = objectQuads[i];
                    if (head)
                        malformed = onError(current, "can't have coreferences");
                    else if (quad.predicate.value === namespaces.rdf.rest) {
                        if (parent)
                            malformed = onError(current, "has incoming rdf:rest arcs");
                        else
                            parent = quad;
                    }
                    else {
                        head = quad;
                        headPos = "object";
                    }
                }
                if (!first)
                    malformed = onError(current, "has no list head");
                else
                    items.unshift(first.object);
                current = parent && parent.subject;
            }
            if (malformed)
                remove = false;
            else if (head)
                lists[head[headPos].value] = items;
        });
        if (remove)
            this.removeQuads(toRemove);
        return lists;
    }
    *[Symbol.iterator]() {
        yield* this.readQuads();
    }
}
function isString(s) {
    return typeof s === "string" || s instanceof String;
}
class DatasetCoreAndReadableStream extends Readable {
    constructor(n3Store, subject, predicate, object, graph) {
        super({ objectMode: true });
        Object.assign(this, { n3Store, subject, predicate, object, graph });
    }
    get filtered() {
        if (!this._filtered) {
            const { n3Store, graph, object, predicate, subject } = this;
            const newStore = (this._filtered = new N3Store({ factory: n3Store._factory }));
            for (const quad of n3Store.readQuads(subject, predicate, object, graph))
                newStore.addQuad(quad);
        }
        return this._filtered;
    }
    get size() {
        return this.filtered.size;
    }
    _read() {
        for (const quad of this)
            this.push(quad);
        this.push(null);
    }
    add(quad) {
        return this.filtered.add(quad);
    }
    delete(quad) {
        return this.filtered.delete(quad);
    }
    has(quad) {
        return this.filtered.has(quad);
    }
    match(subject, predicate, object, graph) {
        return new DatasetCoreAndReadableStream(this.filtered, subject, predicate, object, graph);
    }
    *[Symbol.iterator]() {
        yield* this._filtered || this.n3Store.readQuads(this.subject, this.predicate, this.object, this.graph);
    }
}
//# sourceMappingURL=N3Store.js.map