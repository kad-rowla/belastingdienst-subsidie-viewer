import * as RdfJs from "rdf-js";
import { BaseParseError } from "@triplydb/recognized-datatypes/Errors.js";
import memoizee from "memoizee";
import { BlankNode, ValidationStatus, DefaultGraph, BaseQuad, Literal, NamedNode, Quad, Term, Variable, TermTypeToTerm } from "./Terms.js";
export declare const ParseError: typeof BaseParseError;
export declare class IriParseError extends ParseError {
}
export declare class LanguageTagParseError extends ParseError {
    languageTag: string;
    constructor(opts: {
        lexicalValue: string;
        message: string;
        languageTag: string;
    });
}
export interface FactoryOpts<S extends BaseQuad["subject"]["termType"], P extends BaseQuad["predicate"]["termType"], O extends BaseQuad["object"]["termType"], G extends BaseQuad["graph"]["termType"]> {
    skipValidation?: boolean;
    bnodePrefix?: string;
    onInvalidIri?: (opts: {
        error: Error;
        value: string;
    }) => {
        replaceWith: NamedNode<string>;
    };
    onInvalidLiteral?: (opts: {
        error: Error;
        value: string | number | boolean;
        datatype?: RdfJs.NamedNode;
        language?: string;
    }) => {
        replaceWith: Literal;
    };
    onUnsupportedTerm?: (term: Term) => void;
    quadTerms?: {
        subject: Array<S>;
        predicate: Array<P>;
        object: Array<O>;
        graph: Array<G>;
    };
}
export declare const isValidLanguageTag: ((languageTag: string) => boolean) & memoizee.Memoized<(languageTag: string) => boolean>;
export declare function getFactory<S extends BaseQuad["subject"]["termType"], P extends BaseQuad["predicate"]["termType"], O extends BaseQuad["object"]["termType"], G extends BaseQuad["graph"]["termType"]>(factoryOpts?: FactoryOpts<S, P, O, G>): {
    fromTerm: <T extends RdfJs.Term>(term: T, opts?: {
        validationStatus?: ValidationStatus;
    }) => TermTypeToTerm[T["termType"]];
    fromQuad: (term: RdfJs.Quad) => Quad<{
        subject: TermTypeToTerm[S];
        predicate: TermTypeToTerm[P];
        object: TermTypeToTerm[O];
        graph: TermTypeToTerm[G];
    }>;
    resetBnodeCounter: () => void;
    prefixer: <Prefix extends string>(base: Prefix | NamedNode<Prefix>) => <Suffix extends string>(local: Suffix) => NamedNode<`${Prefix}${Suffix}`>;
    isValidSubject: (term: Term) => term is TermTypeToTerm[S];
    isValidPredicate: (term: Term) => term is TermTypeToTerm[P];
    isValidObject: (term: Term) => term is TermTypeToTerm[O];
    isValidGraph: (term: Term) => term is TermTypeToTerm[G];
    literal: {
        (value: string, languageOrDataType?: string | RdfJs.NamedNode, opts?: {
            validationStatus?: ValidationStatus;
        }): Literal;
        (value: number | boolean, languageTagOrDatatype: string | RdfJs.NamedNode, opts?: {
            validationStatus?: ValidationStatus;
        }): Literal;
    };
    namedNode: (<Iri extends string = string>(iri: Iri, opts?: {
        validationStatus?: ValidationStatus;
    }) => NamedNode<Iri>) & import("lodash").MemoizedFunction;
    blankNode: (name?: string) => BlankNode;
    defaultGraph: () => DefaultGraph;
    quad: (subject: TermTypeToTerm[S], predicate: TermTypeToTerm[P], object: TermTypeToTerm[O], graph?: TermTypeToTerm[G]) => Quad<{
        subject: TermTypeToTerm[S];
        predicate: TermTypeToTerm[P];
        object: TermTypeToTerm[O];
        graph: TermTypeToTerm[G];
    }>;
    variable: (name: string) => Variable;
};
export declare const factory: {
    fromTerm: <T extends RdfJs.Term>(term: T, opts?: {
        validationStatus?: ValidationStatus | undefined;
    } | undefined) => TermTypeToTerm[T["termType"]];
    fromQuad: (term: RdfJs.Quad) => Quad<{
        subject: BlankNode | Variable | NamedNode<string> | Quad<BaseQuad>;
        predicate: Variable | NamedNode<string>;
        object: BlankNode | Variable | NamedNode<string> | Quad<BaseQuad> | Literal<string>;
        graph: BlankNode | DefaultGraph | Variable | NamedNode<string>;
    }>;
    resetBnodeCounter: () => void;
    prefixer: <Prefix extends string>(base: Prefix | NamedNode<Prefix>) => <Suffix extends string>(local: Suffix) => NamedNode<`${Prefix}${Suffix}`>;
    isValidSubject: (term: Term) => term is BlankNode | Variable | NamedNode<string> | Quad<BaseQuad>;
    isValidPredicate: (term: Term) => term is Variable | NamedNode<string>;
    isValidObject: (term: Term) => term is BlankNode | Variable | NamedNode<string> | Quad<BaseQuad> | Literal<string>;
    isValidGraph: (term: Term) => term is BlankNode | DefaultGraph | Variable | NamedNode<string>;
    literal: {
        (value: string, languageOrDataType?: string | RdfJs.NamedNode, opts?: {
            validationStatus?: ValidationStatus | undefined;
        } | undefined): Literal;
        (value: number | boolean, languageTagOrDatatype: string | RdfJs.NamedNode, opts?: {
            validationStatus?: ValidationStatus | undefined;
        } | undefined): Literal;
    };
    namedNode: (<Iri extends string = string>(iri: Iri, opts?: {
        validationStatus?: ValidationStatus | undefined;
    } | undefined) => NamedNode<Iri>) & import("lodash").MemoizedFunction;
    blankNode: (name?: string) => BlankNode;
    defaultGraph: () => DefaultGraph;
    quad: (subject: BlankNode | Variable | NamedNode<string> | Quad<BaseQuad>, predicate: Variable | NamedNode<string>, object: BlankNode | Variable | NamedNode<string> | Quad<BaseQuad> | Literal<string>, graph?: BlankNode | DefaultGraph | Variable | NamedNode<string> | undefined) => Quad<{
        subject: BlankNode | Variable | NamedNode<string> | Quad<BaseQuad>;
        predicate: Variable | NamedNode<string>;
        object: BlankNode | Variable | NamedNode<string> | Quad<BaseQuad> | Literal<string>;
        graph: BlankNode | DefaultGraph | Variable | NamedNode<string>;
    }>;
    variable: (name: string) => Variable;
};
export type DefaultFactory = ReturnType<typeof getFactory>;
export type AnyTdbDataFactory = ReturnType<typeof getFactory<any, any, any, any>>;
//# sourceMappingURL=DataFactory.d.ts.map