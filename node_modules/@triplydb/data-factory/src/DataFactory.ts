import * as RdfJs from "rdf-js";
// We're not using the built-in randomUUID from `crypto`,
// because that crypto function is not yet polyfilled by crypto-browserified (https://github.com/crypto-browserify/crypto-browserify)
// As a result, the browser playground won't run properly.
// We can start using the native `crypto` again when `crypto-browserified` supports randomUUID
import { v4 as randomUUID } from "uuid";
import { isRecognized, lexicalToCanonical } from "@triplydb/recognized-datatypes";
import { BaseParseError } from "@triplydb/recognized-datatypes/Errors.js";
import memoizee from "memoizee";
import { validate } from "@triplydb/iri";
import _LruCache from "mnemonist/lru-cache.js";
import {
  BlankNode,
  ValidationStatus,
  DefaultGraph,
  BaseQuad,
  Literal,
  NamedNode,
  Quad,
  Term,
  Variable,
  BASE_QUAD_TERM_TYPES,
  TermTypeToTerm,
} from "./Terms.js";
import { assertIsValidQuad, isValidTerm } from "./assertionUtils.js";
import { parseLanguageTag } from "@sozialhelden/ietf-language-tags";
import { memoize } from "lodash-es";

const LruCache = _LruCache as any as typeof _LruCache.default;
type LruCache<K, V> = _LruCache.default<K, V>;

// Treating the `BaseParseError` of recognized datatypes as the main parse error that we're extending from when validating
// terms and their properties (including e.g. language tags)
export const ParseError = BaseParseError;
export class IriParseError extends ParseError {}

export class LanguageTagParseError extends ParseError {
  public languageTag: string;
  constructor(opts: { lexicalValue: string; message: string; languageTag: string }) {
    super(opts);
    this.languageTag = opts.languageTag;
  }
}
export interface FactoryOpts<
  S extends BaseQuad["subject"]["termType"],
  P extends BaseQuad["predicate"]["termType"],
  O extends BaseQuad["object"]["termType"],
  G extends BaseQuad["graph"]["termType"]
> {
  skipValidation?: boolean;
  /** by default a 5 char UUID */
  bnodePrefix?: string;
  /**
   * This callback fires when we have an invalid IRI. If replaceWith is returned, we will return that instead.
   */
  onInvalidIri?: (opts: { error: Error; value: string }) => { replaceWith: NamedNode<string> };

  /**
   * This callback fires when we have an invalid Literal. We may either substitute the literal (returning the values for the new one),
   * or we may want to re-throw the error
   */
  onInvalidLiteral?: (opts: {
    error: Error;
    value: string | number | boolean;
    datatype?: RdfJs.NamedNode;
    language?: string;
  }) => { replaceWith: Literal };
  /**
   * This callback fires when we don't have validation/canonicalization for a term.
   * E.g., a literal with datatype `https://something.org/datatype`
   */
  onUnsupportedTerm?: (term: Term) => void;
  /**
   * Specify the supported quad term types. Passing term types other than these will result in assertion errors
   * By default, the `BaseQuad` term types are used
   */
  quadTerms?: {
    subject: Array<S>;
    predicate: Array<P>;
    object: Array<O>;
    graph: Array<G>;
  };
}
/**
 * Check whether a language tag is valid. We're memoizing this, as the language-tags lib
 * does not seem very performant, and considering we don't expect datasets to contain many different languages
 */
export const isValidLanguageTag = memoizee(
  (languageTag: string) => {
    return !!parseLanguageTag(
      languageTag,
      // Make the lib return undefined if it's invalid
      true,
      // Don't print anything to the console
      null
    );
  },
  { primitive: true, max: 100 }
);

export function getFactory<
  S extends BaseQuad["subject"]["termType"],
  P extends BaseQuad["predicate"]["termType"],
  O extends BaseQuad["object"]["termType"],
  G extends BaseQuad["graph"]["termType"]
>(factoryOpts?: FactoryOpts<S, P, O, G>) {
  const lruCache = new LruCache(1_000); // keep 1,000 most recently processed iris
  const allowedQuadPositions = factoryOpts?.quadTerms || BASE_QUAD_TERM_TYPES;
  let blankNodeCounter = 0;
  let bnodePrefix = factoryOpts?.bnodePrefix || randomUUID().substring(0, 4);
  type QuadTerms = {
    subject: TermTypeToTerm[S];
    predicate: TermTypeToTerm[P];
    object: TermTypeToTerm[O];
    graph: TermTypeToTerm[G];
  };

  function _namedNode<Iri extends string = string>(iri: Iri, opts?: { validationStatus?: ValidationStatus }) {
    let validationStatus = opts?.validationStatus;
    if (!validationStatus && factoryOpts?.skipValidation) validationStatus = "disabled";
    if (!validationStatus) {
      try {
        validate(iri);
        validationStatus = "canonical";
      } catch (error: any) {
        const replacement = factoryOpts?.onInvalidIri?.({ error, value: iri })?.replaceWith;
        if (replacement) return replacement as NamedNode<Iri>;
        throw new IriParseError({
          message: error.message,
          lexicalValue: iri,
          cause: error,
        });
      }
    }
    return new NamedNode<Iri>(iri, validationStatus);
  }

  // If you want to debug without memoization, you can simply replace the next line with `const namedNode = _namedNode`.
  const namedNode = memoize(_namedNode, (iri, opts) => `${iri}|${opts?.validationStatus}`);
  (namedNode as any).cache = lruCache;

  const xsdString = namedNode("http://www.w3.org/2001/XMLSchema#string");
  const langTagString = namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#langString");

  function blankNode(name?: string) {
    return new BlankNode(name || `${bnodePrefix}-${blankNodeCounter++}`);
  }

  /**
   * Internal function for creating a literal. We're wrapping this in the actual literal function to provide a fallback mechanism
   * in case the original literal was invalid.
   */
  function createLiteral(
    value: string | number | boolean,
    languageOrDataType: string | RdfJs.NamedNode | undefined,
    opts?: { validationStatus?: ValidationStatus }
  ): Literal {
    value = typeof value === "string" ? value : `${value}`;
    let language: string | undefined;
    let datatype: NamedNode;
    if (typeof languageOrDataType === "string") {
      if (!opts?.validationStatus && !factoryOpts?.skipValidation && !isValidLanguageTag(languageOrDataType)) {
        throw new LanguageTagParseError({
          languageTag: languageOrDataType,
          lexicalValue: value,
          message: `Invalid language tag '${languageOrDataType}'`,
        });
      }
      // @DECISION We're treating language tags as lower-case, even though the SPARQL spec doesn't mandate this. It
      // simplifies comparisons in the engine, and gets closer to a "canonical" form.
      language = languageOrDataType.toLowerCase();
      datatype = langTagString;
    } else {
      datatype = languageOrDataType ? fromTerm(languageOrDataType) : xsdString;
    }
    let validationStatus = opts?.validationStatus;
    if (!validationStatus && factoryOpts?.skipValidation) validationStatus = "disabled";
    if (!validationStatus) {
      if (isRecognized(datatype)) {
        value = lexicalToCanonical(value, datatype);
        validationStatus = "canonical";
      } else {
        validationStatus = "unrecognized";
      }
    }
    const returnedLiteral = new Literal(value, validationStatus, datatype, language);

    if (validationStatus === "unrecognized") factoryOpts?.onUnsupportedTerm?.(returnedLiteral);
    return returnedLiteral;
  }

  function literal(
    value: string,
    languageOrDataType?: string | RdfJs.NamedNode,
    opts?: { validationStatus?: ValidationStatus }
  ): Literal;
  function literal(
    value: number | boolean,
    languageTagOrDatatype: string | RdfJs.NamedNode,
    opts?: { validationStatus?: ValidationStatus }
  ): Literal;
  function literal(
    value: string | number | boolean,
    languageOrDataType?: string | RdfJs.NamedNode,
    opts?: { validationStatus?: ValidationStatus }
  ) {
    if (!factoryOpts?.onInvalidLiteral) return createLiteral(value, languageOrDataType, opts);
    try {
      return createLiteral(value, languageOrDataType, opts);
    } catch (e: any) {
      let language, datatype;
      if (typeof languageOrDataType === "string") {
        language = languageOrDataType;
      } else {
        datatype = languageOrDataType;
      }
      const { replaceWith } = factoryOpts.onInvalidLiteral({ error: e, value, language, datatype });
      return replaceWith;
    }
  }

  function variable(name: string) {
    return new Variable(name);
  }
  const DEFAULT_GRAPH = new DefaultGraph();
  function defaultGraph() {
    return DEFAULT_GRAPH;
  }

  function fromTerm<T extends RdfJs.Term>(
    term: T,
    opts?: { validationStatus?: ValidationStatus }
  ): TermTypeToTerm[T["termType"]];
  function fromTerm(term: RdfJs.Term | Term, opts?: { validationStatus?: ValidationStatus }): Term {
    // Assuming that when a term has the field validationStatus, that it is one of our terms.
    // Decided not to do instanceOf checks, as these may result in false negatives, when we're dealing with multiple datafactory dependencies with different versions
    if ("validationStatus" in term) return term;
    switch (term.termType) {
      case "BlankNode":
        return blankNode(term.value);
      case "DefaultGraph":
        return defaultGraph();
      case "Literal":
        return literal(term.value, term.language || fromTerm(term.datatype, opts));
      case "NamedNode":
        return namedNode(term.value, opts);
      case "Variable":
        return variable(term.value);
      case "Quad":
        return fromQuad(term as RdfJs.Quad);
    }
  }

  function fromQuad(term: RdfJs.Quad): Quad<QuadTerms> {
    if (term instanceof Quad) return term;
    return quad(
      fromTerm(term.subject) as any,
      fromTerm(term.predicate) as any,
      fromTerm(term.object) as any,
      fromTerm(term.graph) as any
    );
  }
  function isValidSubject(term: Term): term is TermTypeToTerm[S] {
    return isValidTerm(term, allowedQuadPositions.subject);
  }
  function isValidPredicate(term: Term): term is TermTypeToTerm[P] {
    return isValidTerm(term, allowedQuadPositions.predicate);
  }
  function isValidObject(term: Term): term is TermTypeToTerm[O] {
    return isValidTerm(term, allowedQuadPositions.object);
  }
  function isValidGraph(term: Term): term is TermTypeToTerm[G] {
    return isValidTerm(term, allowedQuadPositions.graph);
  }

  function quad(
    subject: TermTypeToTerm[S],
    predicate: TermTypeToTerm[P],
    object: TermTypeToTerm[O],
    graph?: TermTypeToTerm[G]
  ) {
    assertIsValidQuad<S, P, O, G>(factoryOpts?.quadTerms, subject, predicate, object, graph);
    return new Quad<QuadTerms>(subject, predicate, object, graph || DEFAULT_GRAPH);
  }
  function resetBnodeCounter() {
    blankNodeCounter = 0;
  }

  function prefixer<Prefix extends string>(base: NamedNode<Prefix> | Prefix) {
    const baseString = typeof base === "string" ? base : base.value;
    return function prefix<Suffix extends string>(local: Suffix) {
      return namedNode(`${baseString}${local}`);
    };
  }

  const baseFactory = {
    literal,
    namedNode,
    blankNode,
    defaultGraph,
    quad,
    variable,
  } satisfies RdfJs.DataFactory;
  return {
    ...baseFactory,
    // Additional functionality we expose, on top of the DataFactory spec
    fromTerm,
    fromQuad,
    resetBnodeCounter,
    prefixer,
    isValidSubject,
    isValidPredicate,
    isValidObject,
    isValidGraph,
  };
}
/**
 * Default factory instance
 */
export const factory = getFactory();
/**
 * The interface of our default factory
 */
export type DefaultFactory = ReturnType<typeof getFactory>;
/**
 * We sometimes want a package to consume (as argument) any kind of factory, as long as it's _our_ datafactory
 */
export type AnyTdbDataFactory = ReturnType<typeof getFactory<any, any, any, any>>;
