import { Store as N3StoreInterface } from "./forked/N3StoreInterface.js";
import * as RdfJs from "rdf-js";
import { Quad, Term, DefaultGraph, ValidationStatus } from "./Terms.js";
import { factory as defaultFactory, DefaultFactory, AnyTdbDataFactory } from "./DataFactory.js";
import _forkedN3Store from "./forked/N3Store.js"; // Store that supports custom termToId and termFromId config
// Explicitly typed as any, as we dont want derived ts info about this js file
// Instead, we can re-use the types from `@types/n3`
const forkedN3Store = _forkedN3Store as any as { new (...args: any): N3StoreInterface };
interface StoreOptions {
  factory?: AnyTdbDataFactory;
}

export type PatternTerm = RdfJs.Term | null;

export interface Pattern {
  subject?: PatternTerm;
  predicate?: PatternTerm;
  object?: PatternTerm;
  graph?: PatternTerm;
}

export interface Store extends N3StoreInterface {}
export class Store extends forkedN3Store {
  // This factory is used to migrate store IDs (strings) back to terms
  readonly factory: DefaultFactory;
  // Keeping track of validation statuses per ID. This avoids having to re-validate terms when fetching items from the store.
  // We cannot store this information inside the ID, as the ID should only contain RDF-specific info (lexical value, datatype etc)
  private validationStatuses: { [id: string]: ValidationStatus } = {};
  constructor(triples: Quad[], options?: StoreOptions);
  constructor(options?: StoreOptions);
  constructor(triplesOrOpts?: Quad[] | StoreOptions, possibleOptions?: StoreOptions) {
    let options = possibleOptions || {};
    if (triplesOrOpts && !Array.isArray(triplesOrOpts)) {
      options = triplesOrOpts;
    }
    const factory = options.factory || defaultFactory;

    super({
      ...options,
      factory,
      // Use own term[To|From]Id, to persist the validation status.
      // This avoids having to re-validate terms that are already validated
      termToId: (term: Term | string) => this.termToId(term),
      termFromId: (id: string) => this.termFromId(id),
    });
    this.factory = factory;
    if (Array.isArray(triplesOrOpts)) this.addQuads(triplesOrOpts);
  }

  public getQuads(pattern: Pattern): Quad[];
  public getQuads(
    subject: PatternTerm,
    predicate: PatternTerm,
    object: PatternTerm | PatternTerm[],
    graph: PatternTerm
  ): Quad[];
  public getQuads(
    subjectOrPattern: PatternTerm | Pattern,
    predicate?: PatternTerm,
    object?: any,
    graph?: PatternTerm
  ): Quad[] {
    if (
      subjectOrPattern === undefined ||
      subjectOrPattern === null ||
      typeof subjectOrPattern === "string" ||
      "termType" in subjectOrPattern
    ) {
      const subject = subjectOrPattern as PatternTerm;
      return super.getQuads(
        (subject ?? null) as any,
        (predicate ?? null) as any,
        (object ?? null) as any,
        (graph ?? null) as any
      );
    } else {
      return super.getQuads(
        (subjectOrPattern.subject ?? null) as any,
        (subjectOrPattern.predicate ?? null) as any,
        (subjectOrPattern.object ?? null) as any,
        (subjectOrPattern.graph ?? null) as any
      );
    }
  }

  private trackValidationStatus(id: string, validationStatus: ValidationStatus) {
    // comment
    if (!this.validationStatuses[id] || this.validationStatuses[id] === "disabled") {
      this.validationStatuses[id] = validationStatus;
    }
  }
  private getValidationStatus(id: string) {
    if (!this.validationStatuses[id]) throw new Error("Missing validation status for " + id);
    return this.validationStatuses[id];
  }

  // ### Constructs an internal string ID from the given term or ID string
  private termToId = (_term: Term | string | undefined) => {
    /**
     * We cannot be fully certain that a term is created by us. For example, we've had a situation where
     * the shacl validation library added rdf:list items to the store that were not created by our factory
     * (even though we explicitly pass that factory as an argument to the validator)
     * As a result, IDs may be incorrect, causing atypical behaviour
     * To avoid this, always run the factory.fromTerm (this is a cheap function, as we escape early)
     */
    if (typeof _term === "string") return _term; // it's already an ID
    // The term can be undefined when we're e.g. adding a graph with `undefined` as graphname
    if (!_term) return DefaultGraph.id;
    const term = this.factory.fromTerm(_term);
    if (term.termType === "Quad") throw new Error("RDF* not supported");

    // We keep track of the validation for these terms,
    // so that we can re-use this when recreating a term from an ID
    if (term.termType === "NamedNode" || term.termType === "Literal") {
      this.trackValidationStatus(term.id, term.validationStatus);
      if (term.termType === "Literal") {
        this.trackValidationStatus(term.datatype.id, term.datatype.validationStatus);
      }
    }
    return term.id;
  };

  // ### Constructs a term from the given internal string ID
  private termFromId = (id: string) => {
    // Falsy value or empty string indicate the default graph
    if (!id) return this.factory.defaultGraph();

    // Identify the term type based on the first character
    switch (id[0]) {
      case "?":
        return this.factory.variable(id.substring(1));
      case "_":
        return this.factory.blankNode(id.substring(2));
      case '"':
        // Literal with datatype or language
        const lexicalValueEndPos = id.lastIndexOf('"');
        return this.factory.literal(
          id.substring(1, lexicalValueEndPos),
          id[lexicalValueEndPos + 1] === "@"
            ? id.substring(lexicalValueEndPos + 2)
            : this.factory.namedNode(id.substring(lexicalValueEndPos + 4, id.length - 1), {
                validationStatus: this.getValidationStatus(id.substring(lexicalValueEndPos + 3, id.length)),
              }),
          { validationStatus: this.getValidationStatus(id) }
        );
      case "<":
        const iriEndPos = id.lastIndexOf(">");
        return this.factory.namedNode(id.substring(1, iriEndPos), {
          validationStatus: this.getValidationStatus(id),
        });
      default:
        throw new Error("Unrecognized ID " + id);
    }
  };
}
