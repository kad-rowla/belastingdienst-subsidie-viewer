/**
 * Where the `N3Store.js` file is mostly a copy of the store implementation,
 * this file is a partial copy from the `@types/n3` package.
 * It's loosely based though, removing some generics, and always assuming that our quads are used.
 */
import * as RDF from "rdf-js";
import { EventEmitter } from "events";
import { BlankNode, Quad, Term } from "../Terms.js";
export type OTerm = null | Term;
export interface Store extends RDF.Store<Quad>, RDF.DatasetCore<Quad, Quad> {
  readonly size: number;
  add(quad: Quad): this;
  addQuad(
    subject: Quad["subject"],
    predicate: Quad["predicate"],
    object: Quad["object"] | Array<Quad["object"]>,
    graph?: Quad["graph"],
    done?: () => void
  ): void;
  addQuad(quad: Quad): void;
  addQuads(quads: Quad[]): void;
  delete(quad: Quad): this;
  has(quad: Quad): boolean;
  import(stream: RDF.Stream<Quad>): EventEmitter;
  removeQuad(
    subject: Quad["subject"],
    predicate: Quad["predicate"],
    object: Quad["object"] | Array<Quad["object"]>,
    graph?: Quad["graph"],
    done?: () => void
  ): void;
  removeQuad(quad: Quad): void;
  removeQuads(quads: Quad[]): void;
  remove(stream: RDF.Stream<Quad>): EventEmitter;
  removeMatches(
    subject?: Term | null,
    predicate?: Term | null,
    object?: Term | null,
    graph?: Term | null
  ): EventEmitter;
  deleteGraph(graph: Quad["graph"] | string): EventEmitter;
  getQuads(subject: OTerm, predicate: OTerm, object: OTerm | OTerm[], graph: OTerm): Quad[];
  match(
    subject?: Term | null,
    predicate?: Term | null,
    object?: Term | null,
    graph?: Term | null
  ): RDF.Stream<Quad> & RDF.DatasetCore<Quad, Quad>;
  countQuads(subject: OTerm, predicate: OTerm, object: OTerm, graph: OTerm): number;
  forEach(callback: (result: Quad) => void, subject: OTerm, predicate: OTerm, object: OTerm, graph: OTerm): void;
  every(callback: (result: Quad) => boolean, subject: OTerm, predicate: OTerm, object: OTerm, graph: OTerm): boolean;
  some(callback: (result: Quad) => boolean, subject: OTerm, predicate: OTerm, object: OTerm, graph: OTerm): boolean;
  getSubjects(predicate: OTerm, object: OTerm, graph: OTerm): Array<Quad["subject"]>;
  forSubjects(callback: (result: Quad["subject"]) => void, predicate: OTerm, object: OTerm, graph: OTerm): void;
  getPredicates(subject: OTerm, object: OTerm, graph: OTerm): Array<Quad["predicate"]>;
  forPredicates(callback: (result: Quad["predicate"]) => void, subject: OTerm, object: OTerm, graph: OTerm): void;
  getObjects(subject: OTerm, predicate: OTerm, graph: OTerm): Array<Quad["object"]>;
  forObjects(callback: (result: Quad["object"]) => void, subject: OTerm, predicate: OTerm, graph: OTerm): void;
  getGraphs(subject: OTerm, predicate: OTerm, object: OTerm): Array<Quad["graph"]>;
  forGraphs(callback: (result: Quad["graph"]) => void, subject: OTerm, predicate: OTerm, object: OTerm): void;
  createBlankNode(suggestedName?: string): BlankNode;
  extractLists(options?: { remove?: boolean; ignoreErrors?: boolean }): Record<string, RDF.Term[]>;
  [Symbol.iterator](): Iterator<Quad>;
}
