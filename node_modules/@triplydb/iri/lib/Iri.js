export function parse(iri, opts) {
    return new Iri(new ElementPositions(iri, opts?.base));
}
export function validate(iri, opts) {
    parse(iri, opts);
}
export function resolve(_iri, _opts) {
    throw new Error(' Function "resolve" is not implemented yet.');
}
class Iri {
    positions;
    constructor(positions) {
        this.positions = positions;
    }
    get iri() {
        return this.positions.iri;
    }
    get scheme() {
        if (this.positions.schemeEnd === 0)
            return;
        return this.iri.substring(0, this.positions.schemeEnd - 1);
    }
    get authority() {
        if (this.positions.schemeEnd + 2 > this.positions.authorityEnd)
            return;
        return this.iri.substring(this.positions.schemeEnd + 2, this.positions.authorityEnd);
    }
    get path() {
        if (this.positions.authorityEnd >= this.positions.pathEnd)
            return;
        return this.iri.substring(this.positions.authorityEnd, this.positions.pathEnd);
    }
    get query() {
        if (this.positions.pathEnd >= this.positions.queryEnd)
            return;
        return this.iri.substring(this.positions.pathEnd + 1, this.positions.queryEnd);
    }
    get fragment() {
        if (this.positions.queryEnd >= this.iri.length)
            return;
        return this.iri.substring(this.positions.queryEnd + 1);
    }
}
class ParserInput {
    value;
    letterPosition = 0;
    constructor(value) {
        this.value = value;
    }
    front() {
        return this.value[0];
    }
    startsWith(c) {
        return this.value[this.letterPosition] === c;
    }
    startsWithSlash() {
        return this.value[this.letterPosition] === "/";
    }
}
const hostRegexp = /(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))/;
class ElementPositions {
    iri;
    base;
    input;
    output = "";
    inputSchemeEnd = 0;
    schemeEnd = 0;
    authorityEnd = 0;
    pathEnd = 0;
    queryEnd = 0;
    constructor(iri, base) {
        this.iri = iri;
        if (base)
            this.base = new ElementPositions(base);
        this.input = new ParserInput(iri);
        this.parse();
        if (this.schemeEnd === 0)
            throw new Error(`Unable to parse relative IRI without a base IRI: <${iri}>`);
    }
    parse() {
        const c = this.input.front();
        if (c === ":") {
            throw new Error(`The IRI does not have a schema.`);
        }
        else if (onlyLatinCharacters(c)) {
            this.parseScheme();
        }
        else {
            this.parseRelative();
        }
    }
    parsePathOrAuthority() {
        if (this.input.startsWithSlash()) {
            ++this.input.letterPosition;
            this.output += "/";
            this.parseAuthority();
            return;
        }
        else {
            this.authorityEnd = this.output.length - 1;
            this.parsePath();
            return;
        }
    }
    parseScheme() {
        while (true) {
            const c = this.input.value[this.input.letterPosition++];
            if (is_ascii_alphanumeric(c) || c === "+" || c === "-" || c === ".") {
                this.output += c;
            }
            else if (c === ":") {
                this.output += ":";
                this.schemeEnd = this.output.length;
                this.inputSchemeEnd = this.input.letterPosition;
                if (this.input.startsWithSlash()) {
                    ++this.input.letterPosition;
                    this.output += "/";
                    this.parsePathOrAuthority();
                    return;
                }
                else {
                    this.authorityEnd = this.output.length;
                    this.parsePath();
                    return;
                }
            }
            else {
                this.input = new ParserInput(this.iri);
                this.output = "";
                this.parseRelative();
                return;
            }
        }
    }
    parseRelative() {
        if (this.base) {
            switch (this.input.front()) {
                case undefined: {
                    this.output += this.base.iri.substring(0, this.base.queryEnd);
                    this.schemeEnd = this.base.schemeEnd;
                    this.authorityEnd = this.base.authorityEnd;
                    this.pathEnd = this.base.pathEnd;
                    this.queryEnd = this.base.queryEnd;
                    return;
                }
                case "/": {
                    ++this.input.letterPosition;
                    this.parseRelativeSlash(this.base);
                    return;
                }
                case "?": {
                    ++this.input.letterPosition;
                    this.output += this.base.iri.substring(0, this.base.pathEnd) + "?";
                    this.schemeEnd = this.base.schemeEnd;
                    this.authorityEnd = this.base.authorityEnd;
                    this.pathEnd = this.base.pathEnd;
                    this.parseQuery();
                    return;
                }
                case "#": {
                    ++this.input.letterPosition;
                    this.output += this.base.iri.substring(0, this.base.queryEnd) + "#";
                    this.schemeEnd = this.base.schemeEnd;
                    this.authorityEnd = this.base.authorityEnd;
                    this.pathEnd = this.base.pathEnd;
                    this.queryEnd = this.base.queryEnd;
                    this.parseFragment();
                    return;
                }
                default: {
                    this.schemeEnd = this.base.schemeEnd;
                    this.authorityEnd = this.base.authorityEnd;
                    this.pathEnd = this.base.pathEnd;
                    this.removeLastSegment();
                    if (this.output.length > this.base.schemeEnd) {
                        this.output += "/";
                    }
                    this.parsePath();
                    return;
                }
            }
        }
        else {
            this.schemeEnd = 0;
            this.inputSchemeEnd = 0;
            if (this.input.startsWithSlash()) {
                ++this.input.letterPosition;
                this.output += "/";
                this.parsePathOrAuthority();
                return;
            }
            else {
                this.authorityEnd = 0;
                this.parsePath();
                return;
            }
        }
    }
    parseRelativeSlash(base) {
        if (this.input.startsWithSlash()) {
            ++this.input.letterPosition;
            this.output += base.iri.substring(0, base.schemeEnd).split("") + "//";
            this.schemeEnd = base.schemeEnd;
            this.parseAuthority();
            return;
        }
        else {
            this.output += base.iri.substring(0, base.authorityEnd) + "/";
            this.schemeEnd = base.schemeEnd;
            this.authorityEnd = base.authorityEnd;
            this.parsePath();
            return;
        }
    }
    parseAuthority() {
        while (true) {
            const c = this.input.value[this.input.letterPosition++];
            switch (c) {
                case "/":
                case "#":
                case "?":
                case "[":
                case undefined: {
                    this.input = new ParserInput(this.iri);
                    this.input.letterPosition = this.inputSchemeEnd + 2;
                    this.output = this.output.slice(0, this.schemeEnd + 2);
                    this.parseHost();
                    return;
                }
                case "@": {
                    this.output += c;
                    this.parseHost();
                    return;
                }
                default: {
                    this.readUrlCodepointOrEchar(c);
                }
            }
        }
    }
    parseHost() {
        if (this.input.startsWith("[")) {
            const start_position = this.input.letterPosition;
            let c = this.input.value[this.input.letterPosition++];
            while (c) {
                this.output += c;
                if (c === "]") {
                    const ip = this.input.value.slice(start_position + 1, this.input.letterPosition - 1);
                    if (!hostRegexp.test(ip))
                        throw new Error(`The IRI includes the invalid host "${ip}".`);
                    c = this.input.value[this.input.letterPosition++];
                    if (c === ":") {
                        this.output += c;
                        this.parsePort();
                        return;
                    }
                    else if (c === "/" || c === "?" || c === "#" || c === undefined) {
                        this.authorityEnd = this.output.length;
                        this.parsePathStart(c);
                        return;
                    }
                    else {
                        throw new Error(`The IRI includes the invalid host character '${c}'.)`);
                    }
                }
                c = this.input.value[this.input.letterPosition++];
            }
            throw new Error(`The IRI includes the invalid host character '['.`);
        }
        else {
            while (true) {
                const c = this.input.value[this.input.letterPosition++];
                switch (c) {
                    case ":": {
                        this.output += ":";
                        this.parsePort();
                        return;
                    }
                    case undefined:
                    case "/":
                    case "?":
                    case "#": {
                        this.authorityEnd = this.output.length;
                        this.parsePathStart(c);
                        return;
                    }
                    default: {
                        this.readUrlCodepointOrEchar(c);
                    }
                }
            }
        }
    }
    parsePort() {
        while (true) {
            const c = this.input.value[this.input.letterPosition++];
            if (isHexaDigit(c)) {
                this.output += c;
            }
            else if (c === "/" || c === "?" || c === "#" || c === undefined) {
                this.authorityEnd = this.output.length;
                this.parsePathStart(c);
                return;
            }
            else {
                throw new Error(`The IRI includes the invalid port character '${c}'.`);
            }
        }
    }
    parsePathStart(c) {
        if (c === undefined) {
            this.pathEnd = this.output.length;
            this.queryEnd = this.output.length;
            return;
        }
        else if (c === "?") {
            this.pathEnd = this.output.length;
            this.output += "?";
            this.parseQuery();
            return;
        }
        else if (c === "#") {
            this.pathEnd = this.output.length;
            this.queryEnd = this.output.length;
            this.output += "#";
            this.parseFragment();
            return;
        }
        else if (c === "/") {
            this.output += "/";
            this.parsePath();
            return;
        }
        else {
            this.readUrlCodepointOrEchar(c);
            this.parsePath();
            return;
        }
    }
    parsePath() {
        while (true) {
            const c = this.input.value[this.input.letterPosition++];
            switch (c) {
                case undefined:
                case "/":
                case "?":
                case "#":
                    if (this.output.endsWith("/..")) {
                        this.removeLastSegment();
                        this.removeLastSegment();
                        this.output += "/";
                    }
                    else if (this.output.endsWith("/.")) {
                        this.removeLastSegment();
                        this.output += "/";
                    }
                    else if (c === "/") {
                        this.output += "/";
                        break;
                    }
                    if (c === "?") {
                        this.pathEnd = this.output.length;
                        this.output += "?";
                        this.parseQuery();
                        return;
                    }
                    else if (c === "#") {
                        this.pathEnd = this.output.length;
                        this.queryEnd = this.output.length;
                        this.output += "#";
                        this.parseFragment();
                        return;
                    }
                    else if (c === undefined) {
                        this.pathEnd = this.output.length;
                        this.queryEnd = this.output.length;
                        return;
                    }
                    break;
                default: {
                    this.readUrlCodepointOrEchar(c);
                }
            }
        }
    }
    parseQuery() {
        let c = this.input.value[this.input.letterPosition++];
        while (c) {
            if (c === "#") {
                this.queryEnd = this.output.length;
                this.output += "#";
                this.parseFragment();
                return;
            }
            else {
                this.readUrlCodepointOrQuerry(c);
            }
            c = this.input.value[this.input.letterPosition++];
        }
        this.queryEnd = this.output.length;
        return;
    }
    parseFragment() {
        let c;
        while ((c = this.input.value[this.input.letterPosition++])) {
            this.readUrlCodepointOrEchar(c);
        }
        return;
    }
    removeLastSegment() {
        const last_slash_position = this.output.lastIndexOf("/");
        if (last_slash_position > 0) {
            this.output = this.output.slice(0, last_slash_position + this.authorityEnd);
        }
    }
    readUrlCodepointOrEchar(c) {
        if (c === "%") {
            this.readEchar();
            return;
        }
        else if (isUrlCodePoint(c)) {
            this.output += c;
            return;
        }
        else {
            throw new Error(`The IRI includes the invalid character '${c}'.`);
        }
    }
    readUrlCodepointOrQuerry(c) {
        if (c === "%") {
            this.readEchar();
            return;
        }
        else if (isUrlQueryCodePoint(c)) {
            this.output += c;
            return;
        }
        else {
            throw new Error(`The IRI includes the invalid character '${c}'.`);
        }
    }
    readEchar() {
        const c1 = this.input.value[this.input.letterPosition++];
        const c2 = this.input.value[this.input.letterPosition++];
        if (isHexaDigit(c1) && isHexaDigit(c2)) {
            this.output += "%" + c1 + c2;
            return;
        }
        else {
            throw new Error(`The IRI includes the invalid percent-encoding \`%${c1}${c2}\`.`);
        }
    }
}
function onlyLatinCharacters(c) {
    return (c >= "a" && c <= "z") || (c >= "A" && c <= "Z");
}
function is_ascii_alphanumeric(c) {
    return (c >= "a" && c <= "z") || (c >= "A" && c <= "Z") || (c >= "0" && c <= "9");
}
const r1 = /[\u{A0}-\u{D7FF}]+/u;
const r2 = /[\u{F900}-\u{FDCF}]+/u;
const r3 = /[\u{FDF0}-\u{FFEF}]+/u;
const r4 = /[\u{10000}-\u{1FFFD}]+/u;
const r5 = /[\u{20000}-\u{2FFFD}]+/u;
const r6 = /[\u{30000}-\u{3FFFD}]+/u;
const r7 = /[\u{40000}-\u{4FFFD}]+/u;
const r8 = /[\u{50000}-\u{5FFFD}]+/u;
const r9 = /[\u{60000}-\u{6FFFD}]+/u;
const r10 = /[\u{70000}-\u{7FFFD}]+/u;
const r11 = /[\u{80000}-\u{8FFFD}]+/u;
const r12 = /[\u{90000}-\u{9FFFD}]+/u;
const r13 = /[\u{A0000}-\u{AFFFD}]+/u;
const r14 = /[\u{B0000}-\u{BFFFD}]+/u;
const r15 = /[\u{C0000}-\u{CFFFD}]+/u;
const r16 = /[\u{D0000}-\u{DFFFD}]+/u;
const r17 = /[\u{E1000}-\u{EFFFD}]+/u;
function isUrlCodePoint(c) {
    return ((c >= "a" && c <= "z") ||
        (c >= "?" && c <= "Z") ||
        (c >= "&" && c <= ";") ||
        c === "!" ||
        c === "$" ||
        c === "=" ||
        c === "_" ||
        c === "~" ||
        r1.test(c) ||
        r2.test(c) ||
        r3.test(c) ||
        r4.test(c) ||
        r5.test(c) ||
        r6.test(c) ||
        r7.test(c) ||
        r8.test(c) ||
        r9.test(c) ||
        r10.test(c) ||
        r11.test(c) ||
        r12.test(c) ||
        r13.test(c) ||
        r14.test(c) ||
        r15.test(c) ||
        r16.test(c) ||
        r17.test(c));
}
const r18 = /[\u{E000}-\u{F8FF}]+/u;
const r19 = /[\u{F0000}-\u{FFFFD}]+/u;
const r20 = /[\u{100000}-\u{10FFFD}]+/u;
const r21 = /[\u{A0}-\u{10FFFD}]+/u;
function isUrlQueryCodePoint(c) {
    return isUrlCodePoint(c) || r18.test(c) || r19.test(c) || r20.test(c) || r21.test(c);
}
function isHexaDigit(c) {
    return (c >= "0" && c <= "9") || (c >= "a" && c <= "f") || (c >= "A" && c <= "F");
}
//# sourceMappingURL=Iri.js.map