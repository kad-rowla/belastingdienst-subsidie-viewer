import { SimpleTriplePattern, TriplePattern } from "@triplydb/engine/Algebra/Operation.js";
import ResultContext, { ResultContexts } from "@triplydb/engine/ResultContext.js";
import { Executor } from "@triplydb/engine/Execution.js";
import { QueryContext } from "@triplydb/engine/QueryContext.js";
import { Term, dataFactory } from "@triplydb/engine/constants.js";
import { Store } from "@triplydb/data-factory";
import { executeOrderByInMemory } from "@triplydb/engine/executeOrderBy.js";
import { AbortSignalError, FatalError } from "@triplydb/engine/Errors.js";
import { NamedNode } from "@triplydb/data-factory/Terms.js";
import { SparqlEngine } from "@triplydb/engine/SparqlEngine.js";

export * from "@triplydb/engine/Errors.js";

export function newEngine(store: Store) {
  return new SparqlEngine(newExecutor(store), {
    store,
    optimize: false,
  });
}

export function newExecutor(store: Store) {
  // We have to be a bit hacky here because rdfjs is annoying and we
  // don't want to clutter the types for the hdt implementation.
  function defaultRdfDataset() {
    return {
      // Using a named node with an empty string value is a dirty hack
      // that will make sure we can detect that no-one overrode the
      // default graph and we should pass `null` to `store.match`,
      // because we want the default default graph (not a typo) to
      // contain all the triples in the store.
      defaultGraph: [dataFactory.namedNode("", { validationStatus: "disabled" })],
      namedGraphs: store.getGraphs(null, null, null).flatMap((g) => (g.termType === "NamedNode" ? [g] : [])),
    };
  }
  return new Executor<Term>({
    executeTriplePattern: (...args) => executeTriplePatternAgainstStore(...args, store),
    executeOrderBy: executeOrderByInMemory,
    getBinding: (term) => term,
    getTerm: (binding) => binding,
    getPredicateStatsAndGraphs: () => undefined,
    defaultRdfDataset,
  });
}

/**
 *  Execute a single triple pattern against the store.
 *
 *  A ResultContext will be returned for every matching result.
 */
export async function* executeTriplePatternAgainstStore(
  operation: TriplePattern,
  resultContexts: ResultContexts<Term> | ResultContext<Term>[],
  queryContext: QueryContext,
  store: Store
) {
  const stp: SimpleTriplePattern = operation.pattern;
  const firstTwoAreEqualVariables = typeof stp[0] === "string" && stp[0] === stp[1];
  const secondTwoAreEqualVariables = typeof stp[1] === "string" && stp[1] === stp[2];
  const firstAndLastAreEqualVariables = typeof stp[0] === "string" && stp[0] === stp[2];
  for await (const context of resultContexts) {
    let graphsToQuery: NamedNode[] | [null];

    const graphsFromOperation = operation.graphs;

    if (typeof graphsFromOperation === "string") {
      const graphBinding = context.bindings[graphsFromOperation];

      // We have added the VALUES operation, meaning that if the graph variable is unbound,
      // then we have a problem.
      if (!graphBinding) throw new FatalError("Unbound graph variable. This is a bug, contact a developer.");

      // If we reached here, the binding of the graph should be a NamedNode after the VALUES clause.
      // If it's not, then probably we have a bug in reordering.
      if (graphBinding.termType !== "NamedNode")
        throw new FatalError("Bound graph variable but not a NamedNode. This is a bug, contact a developer.");

      graphsToQuery = [graphBinding];
    } else if (graphsFromOperation) {
      graphsToQuery = graphsFromOperation;
    } else {
      const defaultGraph = queryContext.rdfDataset.defaultGraph;
      if (defaultGraph.length === 1 && defaultGraph[0].value === "") {
        graphsToQuery = [null]; // query everything
      } else {
        graphsToQuery = queryContext.rdfDataset.defaultGraph;
      }
    }

    const sub = typeof stp[0] === "string" ? context.bindings[stp[0]] ?? null : (stp[0] as any);
    const pred = typeof stp[1] === "string" ? context.bindings[stp[1]] ?? null : (stp[1] as any);
    const obj = typeof stp[2] === "string" ? context.bindings[stp[2]] ?? null : (stp[2] as any);

    for (const activeGraphName of graphsToQuery) {
      for (const { subject, predicate, object } of store.match(sub, pred, obj, activeGraphName)) {
        // Assert for an aborted signal.
        if (queryContext?.abortSignal?.aborted) throw new AbortSignalError("Query has been aborted.");
        if (firstTwoAreEqualVariables && !subject.equals(predicate)) continue;
        if (secondTwoAreEqualVariables && !predicate.equals(object)) continue;
        if (firstAndLastAreEqualVariables && !subject.equals(object)) continue;
        yield context.applyMatch([subject, predicate, object] as [Term, Term, Term], stp);
      }
    }
  }
}
