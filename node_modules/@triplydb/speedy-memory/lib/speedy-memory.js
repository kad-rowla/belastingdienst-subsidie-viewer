import { Executor } from "@triplydb/engine/Execution.js";
import { dataFactory } from "@triplydb/engine/constants.js";
import { executeOrderByInMemory } from "@triplydb/engine/executeOrderBy.js";
import { AbortSignalError, FatalError } from "@triplydb/engine/Errors.js";
import { SparqlEngine } from "@triplydb/engine/SparqlEngine.js";
export * from "@triplydb/engine/Errors.js";
export function newEngine(store) {
    return new SparqlEngine(newExecutor(store), {
        store,
        optimize: false,
    });
}
export function newExecutor(store) {
    function defaultRdfDataset() {
        return {
            defaultGraph: [dataFactory.namedNode("", { validationStatus: "disabled" })],
            namedGraphs: store.getGraphs(null, null, null).flatMap((g) => (g.termType === "NamedNode" ? [g] : [])),
        };
    }
    return new Executor({
        executeTriplePattern: (...args) => executeTriplePatternAgainstStore(...args, store),
        executeOrderBy: executeOrderByInMemory,
        getBinding: (term) => term,
        getTerm: (binding) => binding,
        getPredicateStatsAndGraphs: () => undefined,
        defaultRdfDataset,
    });
}
export async function* executeTriplePatternAgainstStore(operation, resultContexts, queryContext, store) {
    const stp = operation.pattern;
    const firstTwoAreEqualVariables = typeof stp[0] === "string" && stp[0] === stp[1];
    const secondTwoAreEqualVariables = typeof stp[1] === "string" && stp[1] === stp[2];
    const firstAndLastAreEqualVariables = typeof stp[0] === "string" && stp[0] === stp[2];
    for await (const context of resultContexts) {
        let graphsToQuery;
        const graphsFromOperation = operation.graphs;
        if (typeof graphsFromOperation === "string") {
            const graphBinding = context.bindings[graphsFromOperation];
            if (!graphBinding)
                throw new FatalError("Unbound graph variable. This is a bug, contact a developer.");
            if (graphBinding.termType !== "NamedNode")
                throw new FatalError("Bound graph variable but not a NamedNode. This is a bug, contact a developer.");
            graphsToQuery = [graphBinding];
        }
        else if (graphsFromOperation) {
            graphsToQuery = graphsFromOperation;
        }
        else {
            const defaultGraph = queryContext.rdfDataset.defaultGraph;
            if (defaultGraph.length === 1 && defaultGraph[0].value === "") {
                graphsToQuery = [null];
            }
            else {
                graphsToQuery = queryContext.rdfDataset.defaultGraph;
            }
        }
        const sub = typeof stp[0] === "string" ? context.bindings[stp[0]] ?? null : stp[0];
        const pred = typeof stp[1] === "string" ? context.bindings[stp[1]] ?? null : stp[1];
        const obj = typeof stp[2] === "string" ? context.bindings[stp[2]] ?? null : stp[2];
        for (const activeGraphName of graphsToQuery) {
            for (const { subject, predicate, object } of store.match(sub, pred, obj, activeGraphName)) {
                if (queryContext?.abortSignal?.aborted)
                    throw new AbortSignalError("Query has been aborted.");
                if (firstTwoAreEqualVariables && !subject.equals(predicate))
                    continue;
                if (secondTwoAreEqualVariables && !predicate.equals(object))
                    continue;
                if (firstAndLastAreEqualVariables && !subject.equals(object))
                    continue;
                yield context.applyMatch([subject, predicate, object], stp);
            }
        }
    }
}
//# sourceMappingURL=speedy-memory.js.map