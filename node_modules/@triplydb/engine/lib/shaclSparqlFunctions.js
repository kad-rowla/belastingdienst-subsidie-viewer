import { DATA_TYPES, dataFactory, DEFAULT_BASE_IRI, MAX_RESULTS_IN_MEMORY, sh } from "./constants.js";
import { v4 as generateRandomName } from "uuid";
import { FatalError, SparqlError, UnsupportedError } from "./Errors.js";
import { scopeVariables, translateVariableNames } from "./Algebra/ASTtoAlgebra/variableScope.js";
import { parse } from "./Helpers.js";
import { operationFromScopedAst } from "./Algebra/ASTtoAlgebra/index.js";
import eachDeep from "deepdash/eachDeep";
import { default as SparqlJs } from "sparqljs";
import { intersection, isSubset, union } from "mnemonist/set.js";
export async function getPrefixes(engine) {
    const results = await engine.select(` prefix sh: <http://www.w3.org/ns/shacl#>
      prefix xsd: <http://www.w3.org/2001/XMLSchema#>
      SELECT * WHERE {
        ?declaration ^sh:declare [];
                    sh:prefix ?prefix;
                    sh:namespace ?namespace.
        FILTER(datatype(?prefix) = xsd:string)
        FILTER(datatype(?namespace) = xsd:anyURI)
      }
  `, { declaration: ["NamedNode", "Literal"], prefix: "Literal", namespace: "Literal" });
    const prefixes = {};
    const declarationIds = new Set();
    for await (const { declaration, prefix, namespace } of results) {
        if (declarationIds.has(declaration.id))
            throw new SparqlError(`The prefix declaration ${declaration.id} should have exactly one sh:prefix and sh:namespace property, but it has more.`);
        if (prefix.value in prefixes)
            throw new SparqlError(`The prefix ${prefix.value} should not be defined more than once.`);
        prefixes[prefix.value] = namespace.value;
    }
    return prefixes;
}
export async function getDataDefinedFunctionInfo(engine, functionNode, prefixes) {
    const preBound = new Set(["this", "shapesGraph", "currentShape"]);
    const selectReserved = new Set(["path", "PATH"]);
    const askReserved = new Set(["value"]);
    const alwaysReservedParameters = new Set([...selectReserved, ...askReserved, ...preBound]);
    const nameTranslation = new Map();
    const shaclDefinedParameters = await getParameters(engine, functionNode, alwaysReservedParameters);
    let ast = await getImplementation(engine, functionNode, prefixes);
    validateShaclSparqlFunctionImplementation(ast, new Set(shaclDefinedParameters.keys()), askReserved, alwaysReservedParameters);
    for (const reservedName of alwaysReservedParameters) {
        const randomName = generateRandomName();
        nameTranslation.set(reservedName, dataFactory.variable(randomName));
    }
    for (const [reservedName, randomName] of [...shaclDefinedParameters]) {
        if (nameTranslation.has(reservedName))
            throw new FatalError(" A parameter in SHACL SPARQL cannot have the same variable name as one of the always reserved paramaters. This is a bug.");
        nameTranslation.set(reservedName, dataFactory.variable(randomName.name));
    }
    const parametersForAstTranslation = new Map([...shaclDefinedParameters.entries()].map((entry) => {
        return [entry[0], dataFactory.variable(entry[1].name)];
    }));
    ast = translateVariableNames(ast, parametersForAstTranslation);
    const parametersInfo = Array.from(shaclDefinedParameters.values());
    const parametersForAlgebraTranslation = new Set(parametersInfo.map((element) => element.name));
    ast = scopeVariables(ast, {
        dontTouchThis: parametersForAlgebraTranslation,
        translateEverything: true,
    });
    const implementation = operationFromScopedAst(ast, {
        dataDefinedFunctions: engine.dataDefinedFunctions,
        variablesToTranslateWithoutErrorChecking: parametersForAlgebraTranslation,
        namedGraphs: engine.executor.defaultRdfDataset().namedGraphs,
    }, "don't set IDs");
    if (ast.queryType === "ASK")
        return {
            implementation,
            parameters: parametersInfo,
        };
    if (ast.variables.length !== 1)
        throw new SparqlError(`The sh:select property of <${functionNode.value}> should return exactly one result variable, ` +
            `but it returns ${ast.variables.length}. See https://www.w3.org/TR/shacl-af/#SPARQLFunction`);
    const resultVariableTerm = "variable" in ast.variables[0] ? ast.variables[0].variable : ast.variables[0];
    if (resultVariableTerm.termType === "Wildcard")
        throw new SparqlError(`The sh:select property of <${functionNode.value}> should not use the ` +
            "`SELECT *` syntax. See https://www.w3.org/TR/shacl-af/#SPARQLFunction");
    return {
        implementation,
        parameters: parametersInfo,
        resultVariable: resultVariableTerm.value,
    };
}
export async function oneVarTriplePattern(engine, stp) {
    const variable = typeof stp[0] === "string"
        ? stp[0]
        : typeof stp[1] === "string"
            ? stp[1]
            : typeof stp[2] === "string"
                ? stp[2]
                : undefined;
    if (variable === undefined)
        throw new FatalError("Type Error");
    const results = [];
    for await (const row of engine.executor.query({
        operationType: "TriplePattern",
        pattern: stp,
    }).results) {
        const result = row[variable];
        if (!result)
            throw new FatalError("The engine returned incorrect results. Please contact a developer.");
        results.push(result);
        if (results.length > MAX_RESULTS_IN_MEMORY)
            throw new UnsupportedError("OOM Code 11");
    }
    return results;
}
function validateShaclSparqlFunctionImplementation(ast, shaclDefinedParameters, askReserved, alwaysReserved) {
    let error = undefined;
    const allPreBound = union(shaclDefinedParameters, alwaysReserved);
    const setOfPreBoundVariablesForLastRule = new Set([
        ...shaclDefinedParameters,
        ...(ast.queryType === "ASK" ? askReserved : []),
        "this",
    ]);
    eachDeep(ast, (node) => {
        if (typeof node !== "object" || error) {
            return false;
        }
        if (node.type === "minus" || node.type === "values" || node.type === "service") {
            error = new SparqlError(`SHACL Queries containing "${node.type.toUpperCase()}" operations are illegal. See https://www.w3.org/TR/shacl/#pre-binding`);
            return false;
        }
        if (node.expression && node.variable) {
            if (allPreBound.has(node.variable.value)) {
                error = new SparqlError(`Cannot re-assign the pre-bound SHACL parameter "${node.variable.value}". See https://www.w3.org/TR/shacl/#pre-binding`);
                return false;
            }
        }
        if (node.queryType) {
            if (node.queryType !== "SELECT") {
                error = new FatalError(`A subquery can only be a SELECT query. This is a bug.`);
                return false;
            }
            const allVariablesBoundInsideWhere = new Set(scopeVariables({
                ...node,
                variables: [new SparqlJs.Wildcard()],
            }).variables.map((variable) => variable.value));
            const preBoundVariablesWeShouldCheck = intersection(allVariablesBoundInsideWhere, setOfPreBoundVariablesForLastRule);
            const variablesInSubProjection = new Set(node.variables.map((v) => ("variable" in v ? v.variable : v).value));
            if (!isSubset(preBoundVariablesWeShouldCheck, variablesInSubProjection)) {
                error = new SparqlError(`Subqueries should return all prebound variables. See https://www.w3.org/TR/shacl/#pre-binding`);
                return false;
            }
        }
    }, { includeRoot: false });
    if (error)
        throw error;
}
async function getParameters(engine, functionNode, alwaysReservedParameters) {
    const parameterQueryResult = await engine.select(` prefix sh: <http://www.w3.org/ns/shacl#>
      SELECT ?parameter ?local ?optional WHERE {
        # https://www.w3.org/TR/shacl/#constraint-components-parameters
        <${functionNode.value}> sh:parameter ?parameter .
        ?parameter sh:path ?path .

        # > the longest NCNAME at the end of the IRI, not immediately
        # > preceded by the first colon
        # from: https://www.w3.org/TR/shacl/#dfn-local-name
        BIND("^[^:]*?(:.+?)?([^/#]*)$" as ?regex)
        BIND(str(?path) as ?strPath)
        BIND(IF(
            REGEX(?strPath, ?regex),
            REPLACE(?strPath, ?regex, "$2"),
            ""
          ) as ?local)

        FILTER(?local)

        # > using 0 as default value if unspecified.
        # from: https://www.w3.org/TR/shacl-af/#function-parameters
        OPTIONAL {
          ?parameter sh:order ?orderFromData
        }
        BIND(COALESCE(?orderFromData, 0) as ?order)

        # the sh:optional property is optional :)
        # See: https://www.w3.org/TR/shacl-af/#function-parameters
        OPTIONAL {
          ?parameter sh:optional ?optional
        }

      # @DECISION strictly speaking we should order by ?local only
      #           when none of the properties define an ?order, but
      #           that would leave room for undefined orders, and
      #           it's easier to write the query like this.
      } ORDER BY ?order ?local`, { parameter: ["NamedNode", "BlankNode"], local: "Literal" });
    const parameterIds = new Set();
    const shaclDefinedParameters = new Map();
    for await (const { parameter, local, optional: optionalTerm } of parameterQueryResult) {
        if (parameterIds.has(parameter.id))
            throw new SparqlError(`The parameter ${parameter.id} has duplicate properties. ` +
                "Possible culprits are: sh:path, sh:order and sh:optional. " +
                "Note that repeating the same triple in different graphs could also cause this error.");
        parameterIds.add(parameter.id);
        let optional = false;
        if (optionalTerm) {
            if (optionalTerm.termType !== "Literal") {
                throw new SparqlError(`The sh:optional property of the parameter ${parameter.id} is not a literal of type xsd:boolean, but a ${optionalTerm.termType.toLocaleLowerCase()}. See https://www.w3.org/TR/shacl/#constraint-components-parameters`);
            }
            if (!optionalTerm.datatype.equals(DATA_TYPES.XSD_BOOLEAN))
                throw new SparqlError(`The sh:optional property of the parameter ${parameter.id} is not a literal of type xsd:boolean, but a literal with datatype <${optionalTerm.datatype.value}>. See https://www.w3.org/TR/shacl/#constraint-components-parameters`);
            if (optionalTerm.value === "true")
                optional = true;
        }
        const nameThatCouldCollide = local.value;
        if (alwaysReservedParameters.has(local.value))
            throw new SparqlError(`The parameter ${parameter.id} has a sh:path that is either reserved or used by an earlier parameter: "${nameThatCouldCollide}". See https://www.w3.org/TR/shacl/#constraint-components-parameters`);
        const name = generateRandomName();
        shaclDefinedParameters.set(nameThatCouldCollide, { name, optional });
    }
    return shaclDefinedParameters;
}
async function getImplementation(engine, functionNode, prefixes) {
    let queryType = "SELECT";
    let implementations = await oneVarTriplePattern(engine, [functionNode, sh("select"), "someVar"]);
    if (implementations.length > 1)
        throw new SparqlError(`The function <${functionNode.value}> should have exactly one value for either sh:ask or sh:select, ` +
            `but it has ${implementations.length} values for sh:select. ` +
            "See https://www.w3.org/TR/shacl-af/#h-function-returntype");
    if (implementations.length === 0) {
        queryType = "ASK";
        implementations = await oneVarTriplePattern(engine, [functionNode, sh("ask"), "someVar"]);
        if (implementations.length !== 1)
            throw new SparqlError(`The function <${functionNode.value}> should have exactly one value for either sh:ask or sh:select, ` +
                `but it has 0 values for sh:select and ${implementations.length} values for sh:ask. ` +
                "See https://www.w3.org/TR/shacl-af/#h-function-returntype");
    }
    const queryTerm = implementations[0];
    if (queryTerm.termType !== "Literal" || !queryTerm.datatype.equals(DATA_TYPES.XSD_STRING))
        throw new SparqlError(`The value of sh:${queryType.toLocaleLowerCase()} of the function <${functionNode.value}> should be a string literal, but it is a ${queryTerm.termType !== "Literal" ? queryTerm.termType.toLocaleLowerCase() : queryTerm.datatype}. See https://www.w3.org/TR/shacl-af/#SPARQLFunction`);
    let ast = parse(queryTerm.value, { baseIri: DEFAULT_BASE_IRI, prefixes });
    if (ast.type !== "query" || ast.queryType !== queryType)
        throw new SparqlError(`The value of sh:${queryType.toLocaleLowerCase()} of the function <${functionNode.value}> should be a SPARQL ${queryType} query, but it is a SPARQL ${ast.type === "update" ? "update operation" : ast.queryType + " query"}. See https://www.w3.org/TR/shacl-af/#SPARQLFunction`);
    return ast;
}
//# sourceMappingURL=shaclSparqlFunctions.js.map