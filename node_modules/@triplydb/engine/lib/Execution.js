import { isEmpty, mapValues, zip, isEqual as deepEqual, cloneDeep } from "lodash-es";
import { injectInPlace } from "@triply/utils/sparqlVarUtils.js";
import { IDENTITY, } from "./Algebra/Operation.js";
import log from "./Debugging.js";
import { FALSE, TRUE, invalidArgumentTypesError, } from "./EvaluationResult.js";
import { default as ResultContext } from "./ResultContext.js";
import { DATA_TYPES, dataFactory, MAX_RESULTS_IN_MEMORY, GEO_FUNCTIONS as GEO_FUNCTIONS, } from "./constants.js";
import { XPATH_FUNCTIONS } from "@triplydb/recognized-datatypes/utils/constants.js";
import { concat, contains, encode_for_uri, validateAndGetNumericDataType, iri, langmatches, lcase, lessThan, newLiteral, regex, replace, str, strafter, strbefore, strdt, strends, strlen, strstarts, substr, ucase, xsdboolean, xsddatetime, xsddecimal, xsddouble, xsdfloat, xsdinteger, xsdstring, strlang, lang, abs, ceil, floor, round, datatype, hashStrings, year, month, day, seconds, hours, minutes, timezone, tz, effectiveBooleanValue, effectiveBooleanValueOfTerm, compare, bnode, xsdint, xsddate, xsdgYear, xsdlong, } from "./EvaluationFunctions.js";
import { QueryContext } from "./QueryContext.js";
import { canonicalToNumber, decimalToRoundedString, next, validators } from "./Helpers.js";
import { v4 as randomUUID } from "uuid";
import { createHash } from "crypto";
import { FatalError, SparqlError, UnsupportedError } from "./Errors.js";
import { sendSparqlSelectRequest } from "./SelectQueryRequests.js";
import { UNBOUND_VARIABLE_NAME } from "./Algebra/ASTtoAlgebra/variableScope.js";
import { DEFAULT_CRS, WktLiteralDatatype, lexicalToValue as wktLexicalToValue, } from "@triplydb/recognized-datatypes/wkt.js";
import { geoProject } from "@triplydb/utils/GeoProject.js";
import { DEFAULT_UNIT, geoArea, isSupportedAreaUnit } from "@triplydb/utils/GeoArea.js";
import { isRecognized, valueToCanonical } from "@triplydb/recognized-datatypes";
import { isSupportedCrs } from "@triplydb/utils/Crs.js";
export function initialResultContext() {
    return [
        new ResultContext({
            bindings: {},
        }),
    ];
}
export class Executor {
    getPredicateStatsAndGraphs;
    executeTriplePattern;
    executeOrderBy;
    getBinding;
    getTerm;
    disableTermValidation;
    defaultRdfDataset;
    constructor(opts) {
        this.executeTriplePattern = opts.executeTriplePattern;
        this.executeOrderBy = opts.executeOrderBy;
        this.getTerm = opts.getTerm;
        this.getBinding = opts.getBinding;
        this.getPredicateStatsAndGraphs = opts.getPredicateStatsAndGraphs;
        this.disableTermValidation = opts.disableTermValidation;
        this.defaultRdfDataset = opts.defaultRdfDataset;
    }
    query(operation, options) {
        const queryContext = new QueryContext({
            ...options,
            disableTermValidation: this.disableTermValidation ?? options?.disableTermValidation,
            algebra: operation,
            rdfDataset: options?.rdfDataset ?? this.getRdfDataset(),
        });
        return {
            queryContext,
            results: this.resultContextsToRdfjsBindings(this.executeOperation(operation, initialResultContext(), queryContext), queryContext),
        };
    }
    async *resultContextsToRdfjsBindings(contexts, queryContext) {
        for await (const context of contexts) {
            const terms = {};
            for (let [variable, binding] of Object.entries(context.bindings)) {
                if (binding === undefined)
                    continue;
                terms[variable] = await this.getTerm(binding);
            }
            yield terms;
        }
    }
    getRdfDataset(from) {
        if (from === undefined || from.default.length + from.named.length === 0)
            return this.defaultRdfDataset();
        const namedGraphs = new Set(this.defaultRdfDataset().namedGraphs.map(({ value }) => value));
        for (const graph of from.default) {
            if (!namedGraphs.has(graph.value)) {
                throw new SparqlError(`A FROM clause references a graph that is not available for querying: ${graph.value}.` +
                    ` Try using 'SELECT * WHERE { GRAPH ?g {} }' to find out what graphs are available.`);
            }
        }
        for (const graph of from.named) {
            if (!namedGraphs.has(graph.value)) {
                throw new SparqlError(`A FROM NAMED clause references a graph that is not available for querying: ${graph.value}.` +
                    ` Try using 'SELECT * WHERE { GRAPH ?g {} }' to find out what graphs are available.`);
            }
        }
        return {
            defaultGraph: from.default,
            namedGraphs: from.named,
        };
    }
    executeOperation(operation, resultContexts, queryContext) {
        return queryContext.countResults(operation, resultContexts, (resultContexts) => {
            switch (operation.operationType) {
                case "TriplePattern":
                    return this.executeTriplePattern(operation, resultContexts, queryContext);
                case "ZeroOrMorePath":
                    return this.executeZeroOrMorePath(operation, resultContexts, queryContext);
                case "Join":
                    return this.executeJoin(operation, resultContexts, queryContext);
                case "LeftJoin":
                    return this.executeLeftJoin(operation, resultContexts, queryContext);
                case "Filter":
                    return this.executeFilter(operation, resultContexts, queryContext);
                case "Union":
                    return this.executeUnion(operation, resultContexts, queryContext);
                case "Extend":
                    return this.executeExtend(operation, resultContexts, queryContext);
                case "Minus":
                    return this.executeMinus(operation, resultContexts, queryContext);
                case "Aggregate":
                    return this.executeAggregate(operation, resultContexts, queryContext);
                case "OrderBy":
                    return this.executeOrderBy(operation, resultContexts, queryContext, this);
                case "Distinct":
                    return this.executeDistinct(operation, resultContexts, queryContext);
                case "Slice":
                    return this.executeSlice(operation, resultContexts, queryContext);
                case "Service":
                    return this.executeService(operation, resultContexts, queryContext);
                case "InlineData":
                    return this.executeInlineData(operation, resultContexts, queryContext);
                case "EnsureBound":
                    return this.executeEnsureBound(operation, resultContexts, queryContext);
            }
        });
    }
    async *executeEnsureBound(operation, resultContexts, queryContext) {
        for await (const context of resultContexts) {
            if (context.bindings[operation.variable]) {
                yield context;
            }
            else {
                const pattern = [randomUUID(), randomUUID(), randomUUID()];
                yield* this.executeOperation({
                    operationType: "Distinct",
                    variables: [operation.variable],
                    inputOperation: {
                        operationType: "Join",
                        inputOperations: [
                            { operationType: "TriplePattern", pattern, graphs: operation.graphs },
                            {
                                operationType: "Union",
                                inputOperations: [pattern[0], pattern[2]].map((variable) => ({
                                    operationType: "Extend",
                                    variable: operation.variable,
                                    variablesInScope: [variable],
                                    expression: { expressionType: "Variable", variable },
                                    inputOperation: IDENTITY,
                                })),
                            },
                        ],
                    },
                }, [context], queryContext);
            }
        }
    }
    async *recursePaths(startVariable, startTerm, inputOperation, end, resultContext, queryContext, visitedTerms) {
        if (visitedTerms.has(startTerm.id)) {
            return;
        }
        visitedTerms.add(startTerm.id);
        yield this.getBinding(startTerm);
        const result = this.executeOperation(inputOperation, [resultContext], queryContext);
        for await (const r of result) {
            const newStartBinding = r.bindings[end];
            if (!newStartBinding)
                throw new FatalError(`Missing binding for ${end}. Please contact a developer.`);
            yield* this.recursePaths(startVariable, await this.getTerm(newStartBinding), inputOperation, end, resultContext.addBinding(startVariable, newStartBinding), queryContext, visitedTerms);
        }
    }
    async *executeZeroOrMorePath(operation, resultContexts, queryContext) {
        for await (const resultContext of resultContexts) {
            const visited = new Set();
            const startBinding = resultContext.bindings[operation.boundStart];
            if (!startBinding)
                throw new FatalError(`The starting variable, ?${operation.boundStart}, must always be bound. Please contact a developer.`);
            const start = await this.getTerm(startBinding);
            const end = resultContext.bindings[operation.end]
                ? await this.getTerm(resultContext.bindings[operation.end])
                : undefined;
            const inputContext = end ? resultContext.removeBinding(operation.end) : resultContext;
            for await (const binding of this.recursePaths(operation.boundStart, start, operation.inputOperation, operation.end, inputContext, queryContext, visited)) {
                if (!end) {
                    yield resultContext.addBinding(operation.end, binding);
                }
                else if (end.equals(await this.getTerm(binding))) {
                    yield resultContext;
                    break;
                }
                else {
                }
            }
        }
    }
    executeJoin(operation, resultContexts, queryContext) {
        for (const nextOperation of operation.inputOperations) {
            resultContexts = this.executeOperation(nextOperation, resultContexts, queryContext);
        }
        return resultContexts;
    }
    async *executeLeftJoin(operation, resultContexts, queryContext) {
        for await (const leftContext of this.executeOperation(operation.inputOperations[0], resultContexts, queryContext)) {
            let foundContext = false;
            for await (const joinedContext of this.executeOperation(operation.inputOperations[1], [leftContext], queryContext)) {
                foundContext = true;
                yield joinedContext;
            }
            if (!foundContext)
                yield leftContext;
        }
    }
    async *executeFilter(operation, resultContexts, queryContext) {
        for await (const context of this.executeOperation(operation.inputOperation, resultContexts, queryContext)) {
            log("sparql:filter:context", "Considering context: %D", context);
            const evaluatedExpression = await this.evaluateExpression(operation.expression, context, queryContext);
            const EBV = effectiveBooleanValue(evaluatedExpression);
            if (EBV === true) {
                log("sparql:filter:true", "Yielding context!");
                yield context;
            }
            else if (EBV === false) {
                log("sparql:filter:false", "Withholding context!");
                continue;
            }
            else {
                log("sparql:filter:error", "Returned error: %D", EBV);
                continue;
            }
        }
    }
    async *executeUnion(operation, resultContexts, queryContext) {
        for await (const context of resultContexts) {
            for (const op of operation.inputOperations) {
                yield* this.executeOperation(op, [context], queryContext);
            }
        }
    }
    async *executeExtend(operation, resultContexts, queryContext) {
        for await (let context of this.executeOperation(operation.inputOperation, resultContexts, queryContext)) {
            const result = await this.evaluateExpression(operation.expression, context, queryContext);
            log("sparql:extend", "The expression for %s evaluated to %O", operation.variable, result);
            if (result.evaluationResultType !== "error") {
                if (operation.variable in context.bindings &&
                    result.term.id !== (await this.getTerm(context.bindings[operation.variable])).id) {
                    continue;
                }
                context = context.addBinding(operation.variable, this.getBinding(result.term));
            }
            yield context;
        }
    }
    async *executeMinus(operation, resultContexts, queryContext) {
        for await (const outerContext of this.executeOperation(operation.inputOperations[0], resultContexts, queryContext)) {
            let shouldSkipOuterContext = false;
            for await (const innerContext of this.executeOperation(operation.inputOperations[1], initialResultContext(), queryContext)) {
                for (const [variable, outerBinding] of Object.entries(outerContext.bindings)) {
                    if (Object.keys(innerContext.bindings).includes(variable)) {
                        const innerBinding = innerContext.bindings[variable];
                        if (!outerBinding || !innerBinding)
                            throw new FatalError("The variables of outer context and inner context should be always be bound in MINUS. Please contact a developer.");
                        const innerTerm = await this.getTerm(innerBinding);
                        const outerTerm = await this.getTerm(outerBinding);
                        if (innerTerm.equals(outerTerm)) {
                            shouldSkipOuterContext = true;
                        }
                        else {
                            shouldSkipOuterContext = false;
                            break;
                        }
                    }
                }
                if (shouldSkipOuterContext)
                    break;
            }
            if (!shouldSkipOuterContext)
                yield outerContext;
        }
    }
    aggregateFunctionMap = {
        AVG: {
            initData: () => ({ total: newLiteral("0", DATA_TYPES.XSD_INTEGER), count: 0 }),
            partialUpdate: (data, result) => {
                data.total = this.evaluateFunctionalCall([data.total, result], "+");
                data.count++;
            },
            finalizeResult: (data) => {
                if ("errorType" in data.total)
                    return data.total;
                if (data.total.term.termType !== "Literal")
                    return { errorType: "InvalidArgumentTypes", evaluationResultType: "error" };
                return data.count > 0
                    ? this.evaluateFunctionalCall([data.total, newLiteral(data.count.toString(), DATA_TYPES.XSD_INTEGER)], "/")
                    : newLiteral("0", DATA_TYPES.XSD_INTEGER);
            },
        },
        COUNT: {
            initData: () => ({ count: 0 }),
            partialUpdate: (data, result) => {
                if ("errorType" in result)
                    return;
                data.count++;
            },
            finalizeResult: (data) => {
                return newLiteral(data.count.toString(), DATA_TYPES.XSD_INTEGER);
            },
        },
        SUM: {
            initData: () => ({ value: newLiteral("0", DATA_TYPES.XSD_INTEGER) }),
            partialUpdate: (data, result) => {
                data.value = this.evaluateFunctionalCall([data.value, result], "+");
            },
            finalizeResult: (data) => data.value,
        },
        GROUP_CONCAT: {
            initData: () => ({ data: newLiteral("", DATA_TYPES.XSD_STRING), count: 0 }),
            partialUpdate: (data, result) => {
                data.count++;
                if (data.count == 1) {
                    data.data =
                        result.evaluationResultType === "value"
                            ? this.evaluateFunctionalCall([data.data, result], "CONCAT")
                            : result;
                    return;
                }
                data.data = this.evaluateFunctionalCall([data.data, newLiteral(data.separator, DATA_TYPES.XSD_STRING), result], "CONCAT");
            },
            finalizeResult: (data) => data.data,
        },
        SAMPLE: {
            initData: () => ({ value: undefined }),
            partialUpdate: (data, result) => {
                if (result.evaluationResultType === "value")
                    data.value = result.term;
            },
            finalizeResult: (data) => {
                if (data.value)
                    return {
                        evaluationResultType: "value",
                        term: data.value,
                    };
                return { errorType: "EmptyAggregateError", evaluationResultType: "error" };
            },
        },
        MIN: {
            initData: () => ({ value: undefined }),
            partialUpdate: (data, result) => {
                if (!data.value) {
                    data.value = result;
                    return;
                }
                let compareValue = lessThan(result, data.value);
                if ("errorType" in compareValue) {
                    data.value = compareValue;
                    return;
                }
                if (compareValue.term.value === "true")
                    data.value = result;
            },
            finalizeResult: (data) => {
                if (data.value)
                    return data.value;
                return { errorType: "EmptyAggregateError", evaluationResultType: "error" };
            },
        },
        MAX: {
            initData: () => ({ value: undefined }),
            partialUpdate: (data, result) => {
                if (!data.value) {
                    data.value = result;
                    return;
                }
                let compareValue = lessThan(data.value, result);
                if ("errorType" in compareValue) {
                    data.value = compareValue;
                    return;
                }
                if (compareValue.term.value === "true")
                    data.value = result;
            },
            finalizeResult: (data) => {
                if (data.value)
                    return data.value;
                return { errorType: "EmptyAggregateError", evaluationResultType: "error" };
            },
        },
    };
    initializeGroup(aggExpr, variable, groupToUpdate) {
        const aggregationFunction = this.aggregateFunctionMap[aggExpr.function];
        const initData = aggregationFunction.initData();
        if (aggExpr.function === "GROUP_CONCAT")
            initData.separator = aggExpr.separator;
        groupToUpdate.set(variable, {
            partialUpdate: (result) => aggregationFunction.partialUpdate(initData, result),
            finalize: () => aggregationFunction.finalizeResult(initData),
            distinctIds: new Set(),
        });
    }
    async performAggregation(aggExpr, variable, resultContext, queryContext, groupToUpdate) {
        const result = aggExpr.expression.expressionType === "WildCard"
            ? ({
                evaluationResultType: "value",
                term: dataFactory.literal("*", dataFactory.namedNode("https://www.triply.cc/wildcard")),
            })
            : await this.evaluateExpression(aggExpr.expression, resultContext, queryContext);
        if (!groupToUpdate.has(variable)) {
            this.initializeGroup(aggExpr, variable, groupToUpdate);
        }
        const variableToCheck = groupToUpdate.get(variable);
        if (aggExpr.distinct && result.evaluationResultType === "value") {
            if (variableToCheck.distinctIds.has(result.term.id))
                return;
            variableToCheck.distinctIds.add(result.term.id);
        }
        variableToCheck.partialUpdate(result);
    }
    async *executeAggregate(operation, resultsContexts, queryContext) {
        for await (const inputContext of resultsContexts) {
            const groups = new Map();
            const getCurrentGroup = async (context) => {
                const group = [];
                for (const expression of operation.groupingExpressions) {
                    const evaluationResult = await this.evaluateExpression(expression, context, queryContext);
                    group.push(evaluationResult.evaluationResultType !== "error" ? evaluationResult.term.id : "undefined");
                }
                return group.join("");
            };
            for await (const context of this.executeOperation(operation.inputOperation, [inputContext], queryContext)) {
                const currentGroup = await getCurrentGroup(context);
                for (const [variable, aggExpr] of Object.entries(operation.aggregatingExpressions)) {
                    let groupToUpdate = groups.get(currentGroup);
                    if (!groupToUpdate) {
                        groupToUpdate = new Map();
                        groups.set(currentGroup, groupToUpdate);
                    }
                    await this.performAggregation(aggExpr, variable, context, queryContext, groupToUpdate);
                }
            }
            if (isEmpty(groups) && isEmpty(operation.groupingExpressions)) {
                const groupToUpdate = new Map();
                groups.set("undefined", groupToUpdate);
                for (const [variable, aggExpr] of Object.entries(operation.aggregatingExpressions)) {
                    this.initializeGroup(aggExpr, variable, groupToUpdate);
                }
            }
            for (const [_, aggrResults] of groups) {
                if (aggrResults) {
                    const bindings = {};
                    for (const [variable, aggResult] of aggrResults) {
                        const result = aggResult.finalize();
                        if ("errorType" in result)
                            continue;
                        bindings[variable] = this.getBinding(result.term);
                    }
                    yield inputContext.addBindings(bindings);
                }
            }
        }
    }
    async *executeDistinct(operation, resultContexts, queryContext) {
        for await (const inContext of resultContexts) {
            const processedBindings = new Set();
            for await (const context of this.executeOperation(operation.inputOperation, [inContext], queryContext)) {
                const hasher = createHash("md5");
                const bindingNameAndTermIds = await Promise.all(operation.variables.map(async (distinctVar) => {
                    const binding = context.bindings[distinctVar];
                    let term;
                    if (binding) {
                        term = await this.getTerm(binding);
                    }
                    return `${distinctVar}#${term?.id}`;
                }));
                log("sparql:distinct", "%D", bindingNameAndTermIds);
                bindingNameAndTermIds.forEach((bindingNameAndTermId) => hasher.update(bindingNameAndTermId));
                const hash = hasher.digest("hex");
                if (processedBindings.has(hash)) {
                    log("sparql:distinct", "duplicate");
                    continue;
                }
                log("sparql:distinct", "distinct");
                processedBindings.add(hash);
                yield context;
            }
        }
    }
    async *executeSlice(operation, outsideContexts, queryContext) {
        const emptyContexts = initialResultContext();
        async function* doSlice(executor) {
            let rowCount = 0;
            for await (const context of executor.executeOperation(operation.inputOperation, emptyContexts, queryContext)) {
                rowCount++;
                if (rowCount <= operation.offset) {
                    log("sparql:slice:offset", "skipping a context");
                    continue;
                }
                log("sparql:slice:limit", "yielding context", rowCount);
                yield context;
                if (operation.limit !== undefined && rowCount >= operation.offset + operation.limit) {
                    log("sparql:slice:limit", "breaking because i=%D, offset=%D and limit=%D", rowCount, operation.offset, operation.limit);
                    break;
                }
            }
        }
        if (!operation.loadIntoMemory) {
            log("sparql:slice", "Streaming through subquery results");
            for await (const context of outsideContexts) {
                if (!deepEqual(emptyContexts[0], context))
                    throw new FatalError("Expected an empty input result context. Please contact a developer. Got " + JSON.stringify(context));
                yield* doSlice(this);
            }
            return;
        }
        log("sparql:slice", "Loading all subquery results into memory");
        const insideContexts = [];
        for await (const element of doSlice(this)) {
            if (insideContexts.length >= MAX_RESULTS_IN_MEMORY)
                throw new UnsupportedError(`A LIMIT larger than ${MAX_RESULTS_IN_MEMORY} isn't supported for sub-queries. Use a lower limit, or limit the outer-most query.`);
            insideContexts.push(element);
        }
        for await (const outsideContext of outsideContexts) {
            for (const insideContext of insideContexts) {
                let isCompatible = true;
                for (const [variable, insideBinding] of Object.entries(insideContext.bindings)) {
                    const outsideBinding = outsideContext.bindings[variable];
                    if (outsideBinding !== undefined &&
                        !(await this.getTerm(insideBinding)).equals(await this.getTerm(outsideBinding))) {
                        isCompatible = false;
                        break;
                    }
                }
                if (isCompatible)
                    yield outsideContext.addBindings(insideContext.bindings);
            }
        }
    }
    async *executeService(operation, resultContexts, queryContext) {
        for await (const context of resultContexts) {
            const { endpoint, query } = await this.addBindingsInServiceQuery(operation.runTimeInformation, context, queryContext);
            const bindings = sendSparqlSelectRequest({
                endpoint: typeof endpoint === "string" ? endpoint : endpoint.value,
                query: query,
            });
            try {
                for await (const binding of bindings) {
                    yield context.addBindings(mapValues(binding, (term) => this.getBinding(term)));
                }
            }
            catch (e) {
                if (!operation.silent)
                    throw e;
                yield context;
            }
        }
    }
    async addBindingsInServiceQuery(runTimeInfo, context, queryContext) {
        runTimeInfo.query.base = queryContext.baseIri;
        if (Object.entries(context.bindings).length < 1)
            return runTimeInfo;
        let runTimeInformationMutable = cloneDeep(runTimeInfo);
        const variablesDef = [];
        const variableValues = {};
        for (let [variable, binding] of Object.entries(context.bindings)) {
            if (binding === undefined)
                continue;
            const termOfBinding = await this.getTerm(binding);
            if (termOfBinding.termType !== "BlankNode") {
                variablesDef.push({ name: variable, termType: termOfBinding.termType });
                variableValues[variable] = termOfBinding.value;
            }
            if (typeof runTimeInformationMutable.endpoint === "string" && variable === runTimeInformationMutable.endpoint) {
                if (termOfBinding.termType === "Literal" || termOfBinding.termType === "BlankNode")
                    throw new SparqlError("Service doesn't have the correct type of value: it can only be an IRI.");
                runTimeInformationMutable = { ...runTimeInformationMutable, endpoint: termOfBinding };
            }
        }
        injectInPlace(runTimeInformationMutable.query, {
            variableDefinitions: variablesDef,
            variableValues: variableValues,
            queryString: "",
        });
        return runTimeInformationMutable;
    }
    async *executeInlineData(operation, resultContexts, queryContext) {
        const dataBindingses = operation.values.map((row) => mapValues(row, (term) => this.getBinding(term)));
        for await (const context of resultContexts) {
            log("sparql:InlineData", "context");
            for (const [terms, bindings] of zip(operation.values, dataBindingses)) {
                if (!terms || !bindings)
                    throw new FatalError("terms and bindings should both be defined.");
                log("sparql:InlineData", "row: %D", terms);
                let allVariablesAreCompatible = true;
                for (const [variable, term] of Object.entries(terms)) {
                    if (!term)
                        continue;
                    const binding = context.bindings[variable];
                    if (!binding)
                        continue;
                    if (!(await this.getTerm(binding)).equals(term)) {
                        allVariablesAreCompatible = false;
                        break;
                    }
                }
                if (allVariablesAreCompatible) {
                    const newContext = context.addBindings(bindings);
                    log("sparql:InlineData", "yielding context %D", newContext);
                    yield newContext;
                }
            }
        }
    }
    async evaluateExpression(expr, resultContext, queryContext) {
        switch (expr.expressionType) {
            case "Variable":
                return this.evaluateVariable(expr, resultContext, queryContext);
            case "Term":
                return { evaluationResultType: "value", term: expr.term };
            case "Exists":
                for await (const _ignored of this.executeOperation(expr.operation, [resultContext], queryContext)) {
                    return TRUE;
                }
                return FALSE;
            case "Operation":
                const outputBindingValue = (await next(this.executeOperation(expr.operation, [resultContext], queryContext)))
                    ?.bindings[expr.resultVariable];
                return outputBindingValue
                    ? {
                        evaluationResultType: "value",
                        term: await this.getTerm(outputBindingValue),
                    }
                    : { evaluationResultType: "error", errorType: "UnboundVariableError", variable: expr.resultVariable };
            case "Bound":
                const binding = resultContext.bindings[expr.variable];
                return binding === undefined ? FALSE : TRUE;
            case "FunctionCall":
                switch (expr.function) {
                    case "IF":
                        const ebv = effectiveBooleanValue(await this.evaluateExpression(expr.expressions[0], resultContext, queryContext));
                        if (typeof ebv !== "boolean")
                            return ebv;
                        return ebv
                            ? this.evaluateExpression(expr.expressions[1], resultContext, queryContext)
                            : this.evaluateExpression(expr.expressions[2], resultContext, queryContext);
                    case "COALESCE":
                        for (const expression of expr.expressions) {
                            const result = await this.evaluateExpression(expression, resultContext, queryContext);
                            if (result.evaluationResultType !== "error")
                                return result;
                        }
                        return { evaluationResultType: "error", errorType: "CoalesceError" };
                    case "!":
                        const value = effectiveBooleanValue(await this.evaluateExpression(expr.expressions[0], resultContext, queryContext));
                        if (typeof value !== "boolean")
                            return value;
                        return value ? FALSE : TRUE;
                    case "||":
                        const ebvleft = effectiveBooleanValue(await this.evaluateExpression(expr.expressions[0], resultContext, queryContext));
                        if (ebvleft === true)
                            return TRUE;
                        const ebvright = effectiveBooleanValue(await this.evaluateExpression(expr.expressions[1], resultContext, queryContext));
                        if (ebvright === true)
                            return TRUE;
                        if (typeof ebvleft === "object")
                            return ebvleft;
                        if (typeof ebvright === "object")
                            return ebvright;
                        return FALSE;
                    case "&&":
                        const ebvl = effectiveBooleanValue(await this.evaluateExpression(expr.expressions[0], resultContext, queryContext));
                        if (ebvl === false)
                            return FALSE;
                        const ebvr = effectiveBooleanValue(await this.evaluateExpression(expr.expressions[1], resultContext, queryContext));
                        if (ebvr === false)
                            return FALSE;
                        if (typeof ebvl === "object")
                            return ebvl;
                        if (typeof ebvr === "object")
                            return ebvr;
                        return TRUE;
                    case "=":
                    case "sameTerm":
                        const evalleft = await this.evaluateExpression(expr.expressions[0], resultContext, queryContext);
                        if (evalleft.evaluationResultType === "error")
                            return evalleft;
                        const evalright = await this.evaluateExpression(expr.expressions[1], resultContext, queryContext);
                        if (evalright.evaluationResultType === "error")
                            return evalright;
                        if (evalleft.term.termType !== evalright.term.termType)
                            return FALSE;
                        if (evalleft.term.termType === "Literal" && evalright.term.termType === "Literal") {
                            if (evalleft.term.datatype.value !== evalright.term.datatype.value)
                                return FALSE;
                            if (evalleft.term.language !== evalright.term.language)
                                return FALSE;
                            if (evalleft.term.value === evalright.term.value)
                                return TRUE;
                            if (isRecognized(evalleft.term.datatype))
                                return FALSE;
                            return expr.function === "=" ? { evaluationResultType: "error", errorType: "RDFEqualTypeError" } : FALSE;
                        }
                        return evalleft.term.value === evalright.term.value ? TRUE : FALSE;
                    case "<":
                        const first = await this.evaluateExpression(expr.expressions[0], resultContext, queryContext);
                        const second = await this.evaluateExpression(expr.expressions[1], resultContext, queryContext);
                        return lessThan(first, second);
                    default:
                        const possiblyErrorValues = await Promise.all(expr.expressions.map(async (expression) => this.evaluateExpression(expression, resultContext, queryContext)));
                        return this.evaluateFunctionalCall(possiblyErrorValues, expr.function, queryContext);
                }
        }
    }
    evaluateFunctionalCall(allValues, functionName, queryContext) {
        const terms = [];
        for (const value of allValues) {
            if (value.evaluationResultType === "error")
                return value;
            terms.push(value.term);
        }
        switch (functionName) {
            case "isIRI":
                return terms[0].termType === "NamedNode" ? TRUE : FALSE;
            case "isBlank":
                return terms[0].termType === "BlankNode" ? TRUE : FALSE;
            case "isLiteral":
                return terms[0].termType === "Literal" ? TRUE : FALSE;
            case "isNumeric":
                return terms[0].termType === "Literal" && validators.numericDatatype(terms[0].datatype) ? TRUE : FALSE;
            case "STR":
                return str(terms);
            case "STRLEN":
                return strlen(terms);
            case "SUBSTR":
                return substr(terms);
            case "UCASE":
                return ucase(terms);
            case "LCASE":
                return lcase(terms);
            case "STRSTARTS":
                return strstarts(terms);
            case "STRENDS":
                return strends(terms);
            case "CONTAINS":
                return contains(terms);
            case "CONCAT":
                return concat(terms);
            case "LANG":
                return lang(terms);
            case XPATH_FUNCTIONS.LANG:
                const langResultAsboolean = effectiveBooleanValue(lang(terms));
                if (typeof langResultAsboolean !== "boolean")
                    return langResultAsboolean;
                return langResultAsboolean ? TRUE : FALSE;
            case "LANGMATCHES":
                return langmatches(terms);
            case "STRBEFORE":
                return strbefore(terms);
            case "STRAFTER":
                return strafter(terms);
            case "ENCODE_FOR_URI":
                return encode_for_uri(terms);
            case XPATH_FUNCTIONS.COMPARE:
                return compare(terms);
            case XPATH_FUNCTIONS.ENCODE_FOR_URI:
                return encode_for_uri(terms, "useURIComponent");
            case "REGEX":
                return regex(terms);
            case "REPLACE":
                return replace(terms);
            case "STRDT":
                return strdt(terms);
            case "STRLANG":
                return strlang(terms);
            case "IRI":
                return iri(terms, queryContext.baseIri);
            case "DATATYPE":
                return datatype(terms);
            case "NOW":
                return {
                    evaluationResultType: "value",
                    term: dataFactory.literal(queryContext.now.toISOString(), DATA_TYPES.XSD_DATE_TIME),
                };
            case "YEAR":
                return year(terms);
            case "MONTH":
                return month(terms);
            case "DAY":
                return day(terms);
            case "HOURS":
                return hours(terms);
            case "MINUTES":
                return minutes(terms);
            case "SECONDS":
                return seconds(terms);
            case "TIMEZONE":
                return timezone(terms);
            case "TZ":
                return tz(terms);
            case "ABS":
                return abs(terms);
            case "CEIL":
                return ceil(terms);
            case "FLOOR":
                return floor(terms);
            case "ROUND":
                return round(terms);
            case XPATH_FUNCTIONS.ROUND:
                return round(terms);
            case DATA_TYPES.XSD_BOOLEAN.value:
                return xsdboolean(terms);
            case DATA_TYPES.XSD_STRING.value:
                return xsdstring(terms);
            case DATA_TYPES.XSD_DOUBLE.value:
                return xsddouble(terms);
            case DATA_TYPES.XSD_FLOAT.value:
                return xsdfloat(terms);
            case DATA_TYPES.XSD_DECIMAL.value:
                return xsddecimal(terms);
            case DATA_TYPES.XSD_INTEGER.value:
                return xsdinteger(terms);
            case DATA_TYPES.XSD_INT.value:
                return xsdint(terms);
            case DATA_TYPES.XSD_LONG.value:
                return xsdlong(terms);
            case DATA_TYPES.XSD_DATE_TIME.value:
                return xsddatetime(terms);
            case DATA_TYPES.XSD_DATE.value:
                return xsddate(terms);
            case DATA_TYPES.XSD_G_YEAR.value:
                return xsdgYear(terms);
            case "+":
                const outputDataType = validateAndGetNumericDataType(terms[0], terms[1]);
                if ("errorType" in outputDataType)
                    return outputDataType;
                return newLiteral(decimalToRoundedString(canonicalToNumber(terms[0].value) + canonicalToNumber(terms[1].value)), outputDataType);
            case "*":
                const newDataType = validateAndGetNumericDataType(terms[0], terms[1]);
                if ("errorType" in newDataType)
                    return newDataType;
                return newLiteral(decimalToRoundedString(canonicalToNumber(terms[0].value) * canonicalToNumber(terms[1].value)), newDataType);
            case "-":
                const outDataType = validateAndGetNumericDataType(terms[0], terms[1]);
                if ("errorType" in outDataType)
                    return outDataType;
                return newLiteral(decimalToRoundedString(canonicalToNumber(terms[0].value) - canonicalToNumber(terms[1].value)), outDataType);
            case "/":
                const numericDataType = validateAndGetNumericDataType(terms[0], terms[1]);
                if ("errorType" in numericDataType)
                    return numericDataType;
                let divisionDataType;
                divisionDataType =
                    numericDataType.value === DATA_TYPES.XSD_INTEGER.value ? DATA_TYPES.XSD_DECIMAL : numericDataType;
                if ("errorType" in divisionDataType)
                    return divisionDataType;
                return newLiteral(decimalToRoundedString(canonicalToNumber(terms[0].value) / canonicalToNumber(terms[1].value)), divisionDataType);
            case "BNODE":
                return bnode(terms);
            case XPATH_FUNCTIONS.BOOLEAN:
                const returnFromEVB = effectiveBooleanValueOfTerm(terms[0]);
                if (typeof returnFromEVB !== "boolean")
                    return returnFromEVB;
                return returnFromEVB ? TRUE : FALSE;
            case "MD5":
                return hashStrings(terms, "md5");
            case "SHA1":
                return hashStrings(terms, "sha1");
            case "SHA256":
                return hashStrings(terms, "sha256");
            case "SHA384":
                return hashStrings(terms, "sha384");
            case "SHA512":
                return hashStrings(terms, "sha512");
            case "UUID":
                return {
                    evaluationResultType: "value",
                    term: dataFactory.namedNode("urn:uuid:" + randomUUID()),
                };
            case "STRUUID":
                return newLiteral(randomUUID(), DATA_TYPES.XSD_STRING);
            case "RAND":
                return newLiteral(decimalToRoundedString(Math.random()), DATA_TYPES.XSD_DOUBLE);
            case GEO_FUNCTIONS.PROJECT.value:
            case GEO_FUNCTIONS.TRANSFORM.value:
                const wktLiteral = terms[0];
                const crs = terms.length === 1 ? dataFactory.namedNode(DEFAULT_CRS) : terms[1];
                if (!validators.literal(wktLiteral) || !validators.namedNode(crs))
                    return invalidArgumentTypesError;
                if (wktLiteral.datatype.value !== WktLiteralDatatype)
                    return invalidArgumentTypesError;
                if (!isSupportedCrs(crs.value))
                    return invalidArgumentTypesError;
                const geometry = wktLexicalToValue(wktLiteral.value);
                if (!isSupportedCrs(geometry.crs))
                    return invalidArgumentTypesError;
                let transformedCoordinates = geoProject(geometry, crs.value);
                return newLiteral(valueToCanonical(transformedCoordinates, WktLiteralDatatype), dataFactory.namedNode(WktLiteralDatatype));
            case GEO_FUNCTIONS.AREA.value:
            case GEO_FUNCTIONS.METRIC_AREA.value:
                const geoLiteral = terms[0];
                const unit = terms.length === 1 ? dataFactory.namedNode(DEFAULT_UNIT) : terms[1];
                if (!validators.literal(geoLiteral) || !validators.namedNode(unit))
                    return invalidArgumentTypesError;
                if (geoLiteral.datatype.value !== WktLiteralDatatype)
                    return invalidArgumentTypesError;
                if (!isSupportedAreaUnit(unit.value))
                    return invalidArgumentTypesError;
                const polygon = wktLexicalToValue(geoLiteral.value);
                return newLiteral(geoArea(polygon, unit.value).toString(), DATA_TYPES.XSD_DOUBLE);
        }
    }
    async evaluateVariable(expr, resultContext, queryContext) {
        const binding = resultContext.bindings[expr.variable];
        if (binding === undefined || expr.variable === UNBOUND_VARIABLE_NAME)
            return {
                evaluationResultType: "error",
                errorType: "UnboundVariableError",
                variable: expr.variable,
            };
        return {
            evaluationResultType: "value",
            term: await this.getTerm(binding),
        };
    }
}
//# sourceMappingURL=Execution.js.map