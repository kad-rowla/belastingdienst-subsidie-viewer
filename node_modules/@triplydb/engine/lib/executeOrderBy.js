import log from "./Debugging.js";
import { FatalError, UnsupportedError } from "./Errors.js";
import { lessThan } from "./EvaluationFunctions.js";
import { deplete } from "./Helpers.js";
function lt(a, b, i) {
    if (a.sortKey[i].evaluationResultType === "error")
        return true;
    const comparison = lessThan(a.sortKey[i], b.sortKey[i]);
    if (comparison.evaluationResultType === "error")
        return false;
    return comparison.term.value === "true";
}
function getComparator(ordering) {
    return (a, b) => {
        if (a.sortKey.length !== b.sortKey.length || a.sortKey.length !== ordering.length) {
            throw new FatalError("Expected same lengths, implementation error.");
        }
        for (const [i, { direction }] of ordering.entries()) {
            if (lt(a, b, i))
                return direction === "descending" ? 1 : -1;
            if (lt(b, a, i))
                return direction === "descending" ? -1 : 1;
        }
        return 0;
    };
}
export async function* executeOrderByInMemory(operation, inputContexts, queryContext, executor) {
    const allInputContexts = await deplete(executor.executeOperation(operation.inputOperation, inputContexts, queryContext));
    yield* await orderByInMemory(operation, allInputContexts, queryContext, executor);
}
async function getSortKey(context, operation, queryContext, executor) {
    return Promise.all(operation.ordering.map((orderByPart) => executor.evaluateExpression(orderByPart.expression, context, queryContext)));
}
async function orderByInMemory(operation, contexts, queryContext, executor) {
    const sortableContexts = await Promise.all(contexts.map(async (context) => ({
        context,
        sortKey: await getSortKey(context, operation, queryContext, executor),
    })));
    log("sparql:sort", "Number of things that will be sorted: " + sortableContexts.length);
    return sortableContexts.sort(getComparator(operation.ordering)).map((bla) => bla.context);
}
export async function* executeOrderByOnDisk(operation, inputContexts, queryContext, executor) {
    const pendingContexts = executor.executeOperation(operation.inputOperation, inputContexts, queryContext);
    let useMemory = true;
    const loadedContexts = [];
    for await (const context of pendingContexts) {
        loadedContexts.push(context);
        if (loadedContexts.length >= 10000) {
            useMemory = false;
            break;
        }
    }
    if (useMemory) {
        yield* await orderByInMemory(operation, loadedContexts, queryContext, executor);
        return;
    }
    throw new UnsupportedError("Disk-based sorting is not supported yet");
}
//# sourceMappingURL=executeOrderBy.js.map