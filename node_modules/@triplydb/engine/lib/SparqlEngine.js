import { QueryEngine, fillOutTripleTemplates } from "./QueryEngine.js";
import { default as sparqljs } from "sparqljs";
import { DEFAULT_BASE_IRI, dataFactory } from "./constants.js";
import { FatalError, UnsupportedError, UpdateFailureError } from "./Errors.js";
import { templatesFromAst } from "./Algebra/ASTtoAlgebra/index.js";
import { parse } from "./Helpers.js";
import log from "./Debugging.js";
async function deleteGraph(store, graph) {
    return new Promise((resolve, reject) => store.deleteGraph(graph).on("end", resolve).on("error", reject));
}
const updateSuccess = "success";
export class SparqlEngine extends QueryEngine {
    store;
    constructor(executor, opts) {
        super(executor, { optimize: opts.optimize });
        this.store = opts.store;
    }
    async update(updateString, opts) {
        log("sparql:updateString", updateString);
        const update = parse(updateString, { baseIri: opts?.baseIri ?? DEFAULT_BASE_IRI });
        if (update.type !== "update")
            throw new UnsupportedError(`Only SPARQL UPDATE is supported using this method. For queries, you can use 'engine.query()'`);
        for (const op of update.updates) {
            if ("type" in op) {
                switch (op.type) {
                    case "create":
                        if (op.silent)
                            continue;
                        if (op.graph.name && this.store.some(() => true, null, null, null, op.graph.name)) {
                            throw new UpdateFailureError(`Cannot create the graph named "${op.graph.name.value}", because this graph already exists.`);
                        }
                        else
                            continue;
                    case "drop":
                    case "clear":
                        if (op.graph.all)
                            this.store.removeMatches();
                        if (op.graph.default)
                            this.store.removeMatches(undefined, undefined, undefined, dataFactory.defaultGraph());
                        if (op.graph.name)
                            await deleteGraph(this.store, op.graph.name);
                        if (op.graph.named) {
                            const promises = [];
                            this.store.forGraphs((graph) => {
                                if (graph.termType === "BlankNode" || graph.termType === "Variable")
                                    throw new FatalError("The graph to remove cannot be a blanknode or a variable.");
                                if (graph.termType !== "DefaultGraph")
                                    promises.push(deleteGraph(this.store, graph));
                            }, null, null, null);
                            await Promise.all(promises);
                        }
                        continue;
                    case "copy": {
                        if ((op.source.default && op.destination.default) || op.source.name?.equals(op.destination.name))
                            continue;
                        const source = op.source.default ? dataFactory.defaultGraph() : op.source.name;
                        const destination = op.destination.default ? dataFactory.defaultGraph() : op.destination.name;
                        await deleteGraph(this.store, destination);
                        this.store.addQuads(this.store
                            .getQuads(null, null, null, source)
                            .map((q) => this.store.factory.quad(q.subject, q.predicate, q.object, destination)));
                        continue;
                    }
                    case "move": {
                        if ((op.source.default && op.destination.default) || op.source.name?.equals(op.destination.name))
                            continue;
                        const source = op.source.default ? dataFactory.defaultGraph() : op.source.name;
                        const destination = op.destination.default ? dataFactory.defaultGraph() : op.destination.name;
                        await deleteGraph(this.store, destination);
                        this.store.addQuads(this.store
                            .getQuads(null, null, null, source)
                            .map((q) => this.store.factory.quad(q.subject, q.predicate, q.object, destination)));
                        await deleteGraph(this.store, source);
                        continue;
                    }
                    case "add": {
                        const source = op.source.default ? dataFactory.defaultGraph() : op.source.name;
                        const destination = op.destination.default ? dataFactory.defaultGraph() : op.destination.name;
                        this.store.addQuads(this.store
                            .getQuads(null, null, null, source)
                            .map((q) => this.store.factory.quad(q.subject, q.predicate, q.object, destination)));
                        continue;
                    }
                    case "load":
                        throw new UnsupportedError("The SPARQL LOAD operation is not supported.");
                }
            }
            else {
                if (op.graph)
                    throw new UnsupportedError("Toplevel GRAPH not yet supported. Please report your use-case to a Triply developer.");
                if ("using" in op && op.using)
                    throw new UnsupportedError("USING is not yet supported. Please report your use-case to a Triply developer.");
                if (op.updateType === "deletewhere") {
                    op.where = op.delete.map((p) => p.type === "bgp" ? p : { type: "graph", name: p.name, patterns: [{ type: "bgp", triples: p.triples }] });
                }
                const results = await this.queryAst({
                    queryType: "SELECT",
                    prefixes: {},
                    type: "query",
                    variables: [new sparqljs.Wildcard()],
                    where: "where" in op ? op.where : undefined,
                }, opts);
                const mutableState = {
                    blankNodeCounter: 0,
                    hashedQuads: new Set(),
                };
                for await (const bindings of results) {
                    const deleteOp = "delete" in op && op.delete ? op.delete : [];
                    for (const deleteInfo of deleteOp) {
                        let graph;
                        if (deleteInfo.type === "graph") {
                            if (deleteInfo.name.termType === "Variable") {
                                const unverifiedGraph = bindings[deleteInfo.name.value];
                                if (unverifiedGraph?.termType !== "NamedNode")
                                    continue;
                                graph = unverifiedGraph;
                            }
                            else {
                                graph = deleteInfo.name;
                            }
                        }
                        const quads = [
                            ...fillOutTripleTemplates(bindings, templatesFromAst(deleteInfo.triples), mutableState, graph),
                        ];
                        this.store.removeQuads(quads);
                    }
                    const insert = "insert" in op && op.insert ? op.insert : [];
                    for (const insertInfo of insert) {
                        let graph;
                        if (insertInfo.type === "graph") {
                            if (insertInfo.name.termType === "Variable") {
                                const unverifiedGraph = bindings[insertInfo.name.value];
                                if (unverifiedGraph?.termType !== "NamedNode")
                                    continue;
                                graph = unverifiedGraph;
                            }
                            else {
                                graph = insertInfo.name;
                            }
                        }
                        const quads = [
                            ...fillOutTripleTemplates(bindings, templatesFromAst(insertInfo.triples), mutableState, graph),
                        ];
                        try {
                            this.store.addQuads(quads);
                        }
                        catch (e) {
                            throw new UpdateFailureError("The graph could not be created. The reason is: " + e.message);
                        }
                    }
                }
            }
        }
        return updateSuccess;
    }
}
//# sourceMappingURL=SparqlEngine.js.map