import { dataFactory, dataFactoryWithRewriteOfInvalidLiterals, DATA_TYPES } from "./constants.js";
import { SUB_TYPES, isNumericDatatype } from "@triplydb/recognized-datatypes/utils/constants.js";
import { SparqlError, SpeedyError } from "./Errors.js";
import * as SparqlJs from "sparqljs";
export function parse(queryString, opts) {
    const parser = new SparqlJs.Parser({
        factory: dataFactoryWithRewriteOfInvalidLiterals,
        skipUngroupedVariableCheck: true,
        baseIRI: opts.baseIri,
        prefixes: opts.prefixes,
    });
    parser._resetBlanks();
    dataFactory.resetBnodeCounter();
    return parser.parse(queryString);
}
export function basicLanguageTagFilter(tags, ranges) {
    function check(tag, range) {
        return range === "*" || tag === range || tag.includes(range + "-");
    }
    let left = typeof tags === "string" ? [tags] : tags;
    const right = typeof ranges === "string" ? [ranges] : ranges;
    const matches = [];
    let rightIndex = -1;
    while (++rightIndex < right.length) {
        const range = right[rightIndex].toLowerCase();
        let leftIndex = -1;
        const next = [];
        while (++leftIndex < left.length) {
            if (check(left[leftIndex].toLowerCase(), range)) {
                matches.push(left[leftIndex]);
            }
            else {
                next.push(left[leftIndex]);
            }
        }
        left = next;
    }
    return matches;
}
export function isSupportedFlag(flag) {
    if (/^[smi]+$/.test(flag))
        return new Set(flag).size === flag.length;
}
export async function deplete(iterable, maxResults) {
    const result = [];
    for await (const element of iterable) {
        if (maxResults !== undefined && result.length >= maxResults)
            throw new SpeedyError(`Cannot load more than ${maxResults} results into memory.`);
        result.push(element);
    }
    return result;
}
export async function next(iterable) {
    for await (const element of iterable) {
        return element;
    }
}
export function forEachAlgebraNode(node, onOperation, onExpression, state) {
    if ("operationType" in node) {
        state = onOperation(node, state);
        if ("inputOperation" in node) {
            forEachAlgebraNode(node.inputOperation, onOperation, onExpression, state);
        }
        if ("inputOperations" in node) {
            node.inputOperations.forEach((operation) => forEachAlgebraNode(operation, onOperation, onExpression, state));
        }
        if ("expression" in node) {
            forEachAlgebraNode(node.expression, onOperation, onExpression, state);
        }
        if ("ordering" in node) {
            node.ordering.forEach(({ expression }) => forEachAlgebraNode(expression, onOperation, onExpression, state));
        }
        if ("groupingExpressions" in node) {
            node.groupingExpressions.forEach((expression) => forEachAlgebraNode(expression, onOperation, onExpression, state));
            Object.values(node.aggregatingExpressions).forEach((expression) => forEachAlgebraNode(expression, onOperation, onExpression, state));
        }
    }
    else {
        state = onExpression(node, state);
        if ("operation" in node) {
            forEachAlgebraNode(node.operation, onOperation, onExpression, state);
        }
        if ("expressions" in node) {
            node.expressions.forEach((expression) => forEachAlgebraNode(expression, onOperation, onExpression, state));
        }
    }
}
export function getSharedLanguageTag(terms) {
    const firstElementLanguage = terms[0].language;
    const sharedLanguage = terms.every((term) => term.language && term.language === firstElementLanguage);
    return sharedLanguage ? firstElementLanguage : DATA_TYPES.XSD_STRING;
}
export function getMatchingDatatypeOrLanguage(firstvalue, secondvalue) {
    if (firstvalue.language && secondvalue.language) {
        return firstvalue.language === secondvalue.language
            ? firstvalue.language
            : {
                evaluationResultType: "error",
                errorType: "IncompatibleLanguageOperation",
            };
    }
    if (firstvalue.language)
        return firstvalue.value.includes(secondvalue.value)
            ? firstvalue.language
            : secondvalue.datatype;
    if (secondvalue.language)
        return {
            evaluationResultType: "error",
            errorType: "IncompatibleLanguageOperation",
        };
    return DATA_TYPES.XSD_STRING;
}
export function changeLiteralValue(literal, value) {
    return dataFactory.literal(value, literal.language || literal.datatype);
}
export function ValidateLiteralOrNamedNode(terms, valueType) {
    if (valueType.length !== terms.length)
        throw Error("Arrays for validation of types have different lengths");
    for (let i = 0; i < terms.length; ++i) {
        let validationPasses = true;
        for (let validator of valueType[i]) {
            validationPasses = validator(terms[i]);
            if (validationPasses)
                break;
        }
        if (!validationPasses)
            return { evaluationResultType: "error", errorType: "InvalidArgumentTypes" };
    }
}
export function canonicalToNumber(n) {
    if (n === "INF")
        return Infinity;
    if (n === "-INF")
        return -Infinity;
    return Number(n);
}
export function decimalToRoundedString(value, sd = 16) {
    if (value === Number.POSITIVE_INFINITY)
        return "INF";
    if (value === Number.NEGATIVE_INFINITY)
        return "-INF";
    const decimalValue = +value;
    if (!decimalValue)
        return decimalValue.toString();
    const digits = Math.floor(Math.log10(decimalValue));
    const significantDigit = sd - (digits > 0 ? digits : 0);
    const props = significantDigit > 0
        ? { useGrouping: false, maximumFractionDigits: significantDigit - 1 }
        : { useGrouping: false, maximumSignificantDigits: sd };
    return (Math.round(decimalValue * 10 ** significantDigit) / 10 ** significantDigit).toLocaleString("fullwide", props);
}
function isStringLiteral(term) {
    return term.termType === "Literal" && term.datatype.value === DATA_TYPES.XSD_STRING.value;
}
function isIntegerLiteral(term) {
    return term.termType === "Literal" && term.datatype.value === DATA_TYPES.XSD_INTEGER.value;
}
function isBooleanLiteral(term) {
    return term.termType === "Literal" && term.datatype.value === DATA_TYPES.XSD_BOOLEAN.value;
}
function isDateTimeLiteral(term) {
    return term.termType === "Literal" && term.datatype.value === DATA_TYPES.XSD_DATE_TIME.value;
}
export function isLanguageLiteral(term) {
    return term.termType === "Literal" && term.datatype.value === DATA_TYPES.RDF_LANG_STRING.value;
}
function isLiteral(term) {
    return term.termType === "Literal";
}
function isNamedNode(term) {
    return term.termType === "NamedNode";
}
function isBlankNode(term) {
    return term.termType === "BlankNode";
}
export function isDerivedFromIntegerLiteral(term) {
    return term.termType === "Literal" && SUB_TYPES.XSD_INTEGER.includes(term.datatype.value);
}
export function isDerivedFromStringLiteral(term) {
    return term.termType === "Literal" && SUB_TYPES.XSD_STRING.includes(term.datatype.value);
}
export function isDerivedFromDecimalLiteral(term) {
    return term.termType === "Literal" && SUB_TYPES.XSD_DECIMAL.includes(term.datatype.value);
}
export function isDerivedFromDateTimeLiteral(term) {
    return term.termType === "Literal" && SUB_TYPES.XSD_DATE_TIME.includes(term.datatype.value);
}
export const validators = {
    literal: isLiteral,
    namedNode: isNamedNode,
    blankNode: isBlankNode,
    stringLiteral: isStringLiteral,
    integerLiteral: isIntegerLiteral,
    languageLiteral: isLanguageLiteral,
    booleanLiteral: isBooleanLiteral,
    dateTimeLiteral: isDateTimeLiteral,
    numericDatatype: isNumericDatatype,
    derivedFromIntegerLiteral: isDerivedFromIntegerLiteral,
    derivedFromStringLiteral: isDerivedFromStringLiteral,
    derivedFromDateTime: isDerivedFromDateTimeLiteral,
};
export function throwAggregateError(value) {
    throw new SparqlError(`Syntactically invalid query: the variable ?${value} is projected from an aggregate SPARQL query, but is not used for grouping. Include ?${value} in the 'GROUP BY' to make the query valid. See https://www.w3.org/TR/sparql11-query/#aggregateRestrictions`);
}
//# sourceMappingURL=Helpers.js.map