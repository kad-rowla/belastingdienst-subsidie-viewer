import { IDENTITY, NOTHING } from "./Algebra/Operation.js";
import { DEFAULT_BASE_IRI } from "./constants.js";
import log from "./Debugging.js";
import { forEachAlgebraNode } from "./Helpers.js";
export class QueryContext {
    baseIri;
    abortSignal;
    now = new Date();
    counts = {};
    algebra;
    disableTermValidation;
    rdfDataset;
    constructor(options) {
        this.algebra = options.algebra;
        this.baseIri = options.baseIri ?? DEFAULT_BASE_IRI;
        this.abortSignal = options?.abortSignal;
        this.disableTermValidation = !!options.disableTermValidation;
        this.rdfDataset = options.rdfDataset;
    }
    countResults(operation, resultContexts, execute) {
        if (operation.id === undefined) {
            return execute(resultContexts);
        }
        if (operation.id === IDENTITY.id || operation.id === NOTHING.id)
            return execute(resultContexts);
        if (!this.counts[operation.id])
            this.counts[operation.id] = { received: 0, yielded: 0 };
        const counts = this.counts[operation.id];
        async function* count(resultContexts, what) {
            for await (const r of resultContexts) {
                counts[what]++;
                yield r;
            }
        }
        return count(execute(count(resultContexts, "received")), "yielded");
    }
    logCounts() {
        this.mergeCountsWithAlgebra();
        log("sparql:counts", "%D", this.algebra);
    }
    mergeCountsWithAlgebra() {
        forEachAlgebraNode(this.algebra, (operation) => {
            if (operation !== IDENTITY && operation !== NOTHING)
                operation.counts = this.counts[operation.id];
        }, () => { }, undefined);
        return this.algebra;
    }
}
//# sourceMappingURL=QueryContext.js.map