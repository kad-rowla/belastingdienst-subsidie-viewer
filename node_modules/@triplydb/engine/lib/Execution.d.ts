import { SimpleTriplePattern, Operation, Join, LeftJoin, Filter, Union, Extend, Minus, Aggregate, OrderBy, Distinct, Slice, Service, InlineData, EnsureBound, serviceRunTimeInfo, TriplePattern } from "./Algebra/Operation.js";
import * as sparqljs from "sparqljs";
import { EvaluationResult, AggregationType, AggregationFunctionNames } from "./EvaluationResult.js";
import { FunctionName, Expression, VariableExpression } from "./Algebra/Expression.js";
import { default as ResultContext, ResultContexts } from "./ResultContext.js";
import { GraphName, Term, Bindings, RdfDataset } from "./constants.js";
import { QueryContext, QueryContextOptions } from "./QueryContext.js";
import { Literal, NamedNode } from "@triplydb/data-factory/Terms.js";
type AggregateFunctionMap = AggregationType<AggregationFunctionNames>;
type NonStandardFunctionCall = "<" | "!" | "||" | "&&" | "=" | "sameTerm" | "IF" | "COALESCE";
type StandardFunctionCall = Exclude<FunctionName, NonStandardFunctionCall>;
export declare function initialResultContext(): readonly [ResultContext<any>];
export type QueryOptions = Partial<Omit<QueryContextOptions, "algebra">>;
export type AsyncBindingsIterable = AsyncIterable<Bindings<Term>>;
export type PredicateStatsAndGraphs = {
    readonly distinctSubjects: (predicate?: NamedNode<string>) => Promise<number>;
    readonly distinctObjects: (predicate?: NamedNode<string>) => Promise<number>;
    readonly subjectBranchingFactor: (predicate: NamedNode<string>) => Promise<number>;
    readonly objectBranchingFactor: (predicate: NamedNode<string>) => Promise<number>;
    readonly distinctLiteralsWithLanguageTag: (predicate: NamedNode<string>, languageTag: Literal<string>["language"]) => Promise<number>;
    readonly distinctLiteralsWithDatatype: (predicate: NamedNode<string>, datatype: NamedNode<string>) => Promise<number>;
    readonly countTriples: (triple?: SimpleTriplePattern) => Promise<number>;
    readonly numTriplesMatchingPredicate: (predicate: NamedNode<string>) => Promise<number>;
    readonly getGraphsMatchingPredicateIfNotInAllGraphs: (predicate: NamedNode<string>) => Promise<GraphName[] | undefined>;
};
export declare class Executor<BindingValue> {
    readonly getPredicateStatsAndGraphs: () => PredicateStatsAndGraphs | undefined;
    readonly executeTriplePattern: (operation: TriplePattern, resultContexts: ResultContexts<BindingValue>, queryContext: QueryContext) => ResultContexts<BindingValue>;
    readonly executeOrderBy: (operation: OrderBy, inputContexts: ResultContexts<BindingValue>, queryContext: QueryContext, executor: Executor<BindingValue>) => ResultContexts<BindingValue>;
    readonly getBinding: (term: Term) => BindingValue;
    readonly getTerm: (binding: BindingValue) => Term | Promise<Term>;
    readonly disableTermValidation?: boolean;
    readonly defaultRdfDataset: () => RdfDataset;
    constructor(opts: Pick<Executor<BindingValue>, "executeTriplePattern" | "executeOrderBy" | "getTerm" | "getBinding" | "getPredicateStatsAndGraphs" | "disableTermValidation" | "defaultRdfDataset">);
    query(operation: Operation, options?: QueryOptions): {
        queryContext: QueryContext;
        results: AsyncGenerator<Bindings<Term>, any, unknown>;
    };
    resultContextsToRdfjsBindings(contexts: ResultContexts<BindingValue>, queryContext: QueryContext): AsyncGenerator<Bindings<Term>>;
    getRdfDataset(from?: sparqljs.BaseQuery["from"]): RdfDataset;
    executeOperation(operation: Operation, resultContexts: ResultContexts<BindingValue>, queryContext: QueryContext): ResultContexts<BindingValue>;
    executeEnsureBound(operation: EnsureBound, resultContexts: ResultContexts<BindingValue>, queryContext: QueryContext): AsyncGenerator<ResultContext<BindingValue>, void, undefined>;
    private recursePaths;
    private executeZeroOrMorePath;
    executeJoin(operation: Join, resultContexts: ResultContexts<BindingValue>, queryContext: QueryContext): ResultContexts<BindingValue>;
    executeLeftJoin(operation: LeftJoin, resultContexts: ResultContexts<BindingValue>, queryContext: QueryContext): AsyncGenerator<ResultContext<BindingValue>>;
    executeFilter(operation: Filter, resultContexts: ResultContexts<BindingValue>, queryContext: QueryContext): AsyncGenerator<ResultContext<BindingValue>>;
    executeUnion(operation: Union, resultContexts: ResultContexts<BindingValue>, queryContext: QueryContext): AsyncGenerator<ResultContext<BindingValue>, any, undefined>;
    executeExtend(operation: Extend, resultContexts: ResultContexts<BindingValue>, queryContext: QueryContext): AsyncGenerator<ResultContext<BindingValue>>;
    executeMinus(operation: Minus, resultContexts: ResultContexts<BindingValue>, queryContext: QueryContext): AsyncGenerator<ResultContext<BindingValue>>;
    aggregateFunctionMap: AggregateFunctionMap;
    private initializeGroup;
    private performAggregation;
    executeAggregate(operation: Aggregate, resultsContexts: ResultContexts<BindingValue>, queryContext: QueryContext): AsyncGenerator<ResultContext<BindingValue>>;
    executeDistinct(operation: Distinct, resultContexts: ResultContexts<BindingValue>, queryContext: QueryContext): AsyncGenerator<ResultContext<BindingValue>>;
    executeSlice(operation: Slice, outsideContexts: ResultContexts<BindingValue>, queryContext: QueryContext): AsyncGenerator<ResultContext<BindingValue>, void, unknown>;
    executeService(operation: Service, resultContexts: ResultContexts<BindingValue>, queryContext: QueryContext): AsyncGenerator<ResultContext<BindingValue>>;
    addBindingsInServiceQuery(runTimeInfo: serviceRunTimeInfo, context: ResultContext<BindingValue>, queryContext: QueryContext): Promise<serviceRunTimeInfo>;
    executeInlineData(operation: InlineData, resultContexts: ResultContexts<BindingValue>, queryContext: QueryContext): AsyncGenerator<ResultContext<BindingValue>>;
    evaluateExpression(expr: Expression, resultContext: ResultContext<BindingValue>, queryContext: QueryContext): Promise<EvaluationResult>;
    evaluateFunctionalCall(allValues: EvaluationResult[], functionName: StandardFunctionCall, queryContext?: QueryContext): EvaluationResult;
    evaluateVariable(expr: VariableExpression, resultContext: ResultContext<BindingValue>, queryContext: QueryContext): Promise<EvaluationResult>;
}
export {};
//# sourceMappingURL=Execution.d.ts.map