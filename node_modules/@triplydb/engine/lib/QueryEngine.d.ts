import { AsyncBindingsIterable, Executor, QueryOptions } from "./Execution.js";
import * as sparqljs from "sparqljs";
import * as Terms from "@triplydb/data-factory/Terms.js";
import { Bindings, Term } from "./constants.js";
import { BindingsResult, BooleanResult, QuadsResult } from "./QueryResults.js";
import { Operation } from "./Algebra/Operation.js";
import { ExtraTranslationInfo, TripleTemplates } from "./Algebra/ASTtoAlgebra/index.js";
import { BindingsType, SpecificationToBindings } from "./validateBindings.js";
export interface DebugInfo {
    operation?: Operation;
    optimizedAlgebra?: Operation;
    estimatedComplexity?: number;
    optimize?: boolean;
}
type QueryResultType = {
    SELECT: BindingsResult;
    CONSTRUCT: QuadsResult;
    DESCRIBE: QuadsResult;
    ASK: BooleanResult;
};
export type QueryResult = QueryResultType[keyof QueryResultType];
export declare class QueryEngine {
    readonly executor: Executor<unknown>;
    readonly optimize: boolean;
    dataDefinedFunctions: ExtraTranslationInfo["dataDefinedFunctions"];
    constructor(executor: Executor<any>, opts: Pick<QueryEngine, "optimize">);
    select(query: string): Promise<BindingsResult>;
    select<B extends BindingsType>(query: string, bindingsType: B): Promise<BindingsResult<SpecificationToBindings<B>>>;
    construct(query: string): Promise<QuadsResult>;
    describe(query: string): Promise<QuadsResult>;
    ask(query: string): Promise<boolean>;
    query<Q extends sparqljs.Query["queryType"]>(query: string, options?: Omit<QueryOptions, "rdfDataset"> & {
        queryType?: Q;
    }): Promise<QueryResultType[Q]>;
    query<B extends BindingsType>(query: string, options?: Omit<QueryOptions, "rdfDataset"> & {
        queryType: "SELECT";
        bindingsType: B;
    }): Promise<BindingsResult<SpecificationToBindings<B>>>;
    queryAst<Q extends sparqljs.Query>(ast: Q, options?: Omit<QueryOptions, "rdfDataset">): Promise<QueryResultType[Q["queryType"]]>;
    queryAst<B extends BindingsType>(ast: sparqljs.SelectQuery, options?: Omit<QueryOptions, "rdfDataset"> & {
        bindingsType: B;
    }): Promise<BindingsResult<SpecificationToBindings<B>>>;
    initializeShaclSparqlFunctions(): Promise<void>;
}
export declare function fillOutTripleTemplates(bindings: Bindings<Term>, templates: TripleTemplates, mutable: {
    blankNodeCounter: number;
    hashedQuads: Set<string>;
}, graph?: Terms.NamedNode): Generator<Terms.Quad<{
    subject: Terms.BlankNode | Terms.NamedNode<string>;
    predicate: Terms.NamedNode<string>;
    object: Terms.BlankNode | Terms.NamedNode<string> | Terms.Literal<string>;
    graph: Terms.NamedNode<string> | Terms.DefaultGraph;
}>, void, unknown>;
export declare function fillOutConstructTemplates(results: AsyncBindingsIterable, templates: TripleTemplates, graph?: Terms.NamedNode): AsyncGenerator<Terms.Quad<{
    subject: Terms.BlankNode | Terms.NamedNode<string>;
    predicate: Terms.NamedNode<string>;
    object: Terms.BlankNode | Terms.NamedNode<string> | Terms.Literal<string>;
    graph: Terms.NamedNode<string> | Terms.DefaultGraph;
}>, void, unknown>;
export {};
//# sourceMappingURL=QueryEngine.d.ts.map