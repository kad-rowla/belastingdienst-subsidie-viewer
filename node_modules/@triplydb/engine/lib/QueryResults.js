import log from "./Debugging.js";
import { deplete } from "./Helpers.js";
import { rdfjsTerm2sparqlJsonTerm, selectQuerytoSparqlJson, toSparqlHead, toSparqlResults, } from "./Serialization/sparql2json.js";
import { Readable } from "stream";
import { dataFactory, DATA_TYPES } from "./constants.js";
import { fillOutConstructTemplates } from "./QueryEngine.js";
class BaseResult {
    iteratorCalled = false;
    results;
    markIteratorCalled() {
        if (this.iteratorCalled)
            throw new Error("Cannot fetch query results multiple times");
        this.iteratorCalled = true;
    }
    queryContext;
    constructor(results, queryContext) {
        this.queryContext = queryContext;
        this.results = results;
    }
}
class BaseIterableResult extends BaseResult {
    [Symbol.asyncIterator]() {
        this.markIteratorCalled();
        return this.results[Symbol.asyncIterator]();
    }
}
export class BooleanResult extends BaseResult {
    type = "boolean";
    async sparqlJson() {
        const result = await this.result();
        return { head: {}, boolean: result };
    }
    async result() {
        this.markIteratorCalled();
        for await (const _ of this.results) {
            this.queryContext.logCounts();
            return true;
        }
        this.queryContext.logCounts();
        return false;
    }
}
export class BindingsResult extends BaseIterableResult {
    type = "bindings";
    variables;
    constructor(results, variables, queryContext) {
        async function* projectedResults() {
            for await (const unprojectedRow of results) {
                const row = {};
                for (const variable of variables) {
                    const binding = unprojectedRow[variable];
                    if (binding)
                        row[variable] = binding;
                }
                yield row;
            }
        }
        super(projectedResults(), queryContext);
        this.variables = variables;
    }
    async sparqlJson() {
        const bindingsAsRdfjs = await this.toArray();
        const queryResults = selectQuerytoSparqlJson([...this.variables], bindingsAsRdfjs);
        log("sparql:engine:query:select:results", "Select query results: %D ", queryResults);
        return queryResults;
    }
    serializedSparqlJsonStream() {
        return Readable.from((async function* (variables, iterator, queryContext) {
            yield `{ "head": { "vars": ${JSON.stringify(variables)} }, "results": {"bindings": [`;
            let isFirst = true;
            for await (const row of iterator) {
                const bindingAsJson = {};
                for (const [variable, term] of Object.entries(row)) {
                    if (!term)
                        continue;
                    const sparqlJsonTerm = rdfjsTerm2sparqlJsonTerm(term);
                    bindingAsJson[variable] = sparqlJsonTerm;
                }
                const jsonSerializedBinding = JSON.stringify(bindingAsJson);
                log("sparql:resultstream", "Result: %D", jsonSerializedBinding);
                yield `${isFirst ? "" : ","}${jsonSerializedBinding}`;
                isFirst = false;
            }
            yield "]}}";
            log("sparql:resultstream", "Done!");
            queryContext.logCounts();
        })(this.variables, this, this.queryContext));
    }
    async toArray() {
        const array = deplete(this);
        this.queryContext.logCounts();
        return array;
    }
}
export class QuadsResult extends BaseIterableResult {
    type = "quads";
    async quads() {
        const quads = deplete(this);
        this.queryContext.logCounts();
        return quads;
    }
    stream() {
        return Readable.from((async function* (iterator, queryContext) {
            for await (const quad of iterator) {
                yield quad;
            }
            log("sparql:resultstream", "Done!");
            queryContext.logCounts();
        })(this, this.queryContext));
    }
}
export class DebugResult {
    iteratorCalled = false;
    type;
    queryContext;
    debugInfo;
    error;
    constructor(type, debugInfo, queryContext, error) {
        this.type = type;
        this.debugInfo = debugInfo;
        this.queryContext = queryContext;
        this.error = error;
    }
    markIteratorCalled() {
        if (this.iteratorCalled)
            throw new Error("Cannot fetch debug results multiple times");
        this.iteratorCalled = true;
    }
    constructBindings() {
        let debugBindings;
        if (this.debugInfo.operation === undefined) {
            debugBindings = {
                error: this.error ? dataFactory.literal(this.error.message, DATA_TYPES.XSD_STRING) : undefined,
                errorStack: this.error?.stack ? dataFactory.literal(this.error.stack, DATA_TYPES.XSD_STRING) : undefined,
            };
        }
        else {
            const algebra = this.queryContext
                ? this.queryContext.mergeCountsWithAlgebra()
                : this.debugInfo.optimizedAlgebra || this.debugInfo.operation;
            debugBindings = {
                algebra: dataFactory.literal(JSON.stringify(algebra)),
                estimatedComplexity: this.debugInfo.estimatedComplexity
                    ? dataFactory.literal(this.debugInfo.estimatedComplexity, DATA_TYPES.XSD_DOUBLE)
                    : undefined,
                isOptimized: this.debugInfo.optimize === undefined
                    ? dataFactory.literal("unknown")
                    : dataFactory.literal(this.debugInfo.optimize, DATA_TYPES.XSD_BOOLEAN),
                disableTermValidation: this.queryContext
                    ? dataFactory.literal(this.queryContext.disableTermValidation, DATA_TYPES.XSD_BOOLEAN)
                    : dataFactory.literal("unknown"),
                error: this.error ? dataFactory.literal(this.error.message) : undefined,
                errorStack: this.error?.stack ? dataFactory.literal(this.error.stack) : undefined,
            };
        }
        const bindings = Object.keys(debugBindings)
            .filter((a) => debugBindings[a] !== null && debugBindings[a] !== undefined)
            .reduce((c, a) => {
            c[a] = debugBindings[a];
            return c;
        }, {});
        return bindings;
    }
    async *asyncBindingIterable() {
        yield this.constructBindings();
    }
    async sparqlJson() {
        this.markIteratorCalled();
        const bindings = this.constructBindings();
        const sparqlResults = { ...toSparqlHead(Object.keys(bindings)), ...toSparqlResults([bindings]) };
        return sparqlResults;
    }
    async quads() {
        return deplete(this.asyncQuadsIterable());
    }
    asyncQuadsIterable() {
        this.markIteratorCalled();
        const templates = [
            { subject: dataFactory.namedNode("d:algebra"), predicate: DATA_TYPES.XSD_STRING, object: "algebra" },
            {
                subject: dataFactory.namedNode("d:estimatedComplexity"),
                predicate: DATA_TYPES.XSD_DOUBLE,
                object: "estimatedComplexity",
            },
            { subject: dataFactory.namedNode("d:isOptimized"), predicate: DATA_TYPES.XSD_BOOLEAN, object: "isOptimized" },
            {
                subject: dataFactory.namedNode("d:disableTermValidation"),
                predicate: DATA_TYPES.XSD_BOOLEAN,
                object: "disabletermvalidation",
            },
            { subject: dataFactory.namedNode("d:error"), predicate: DATA_TYPES.XSD_STRING, object: "error" },
            { subject: dataFactory.namedNode("d:errorStack"), predicate: DATA_TYPES.XSD_STRING, object: "errorStack" },
        ];
        return fillOutConstructTemplates(this.asyncBindingIterable(), templates);
    }
    stream() {
        if (this.type === "bindings")
            return Readable.from(this.asyncBindingIterable());
        else
            return Readable.from(this.asyncQuadsIterable());
    }
}
//# sourceMappingURL=QueryResults.js.map