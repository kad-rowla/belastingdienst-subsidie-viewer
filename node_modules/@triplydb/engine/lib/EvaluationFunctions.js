import { invalidArgumentTypesError, } from "./EvaluationResult.js";
import { createHash } from "crypto";
import { resolve } from "relative-to-absolute-iri";
import { FALSE, TRUE } from "./EvaluationResult.js";
import { changeLiteralValue, getMatchingDatatypeOrLanguage, getSharedLanguageTag, isSupportedFlag, ValidateLiteralOrNamedNode, validators, canonicalToNumber, basicLanguageTagFilter, decimalToRoundedString, isDerivedFromStringLiteral, isDerivedFromDecimalLiteral, isDerivedFromIntegerLiteral, } from "./Helpers.js";
import { dataFactory, DATA_TYPES, isNaN } from "./constants.js";
import { SUB_TYPES, SUB_TYPE_IRIS, numericDatatypeIris } from "@triplydb/recognized-datatypes/utils/constants.js";
import { lexicalToValue, valueToCanonical } from "@triplydb/recognized-datatypes";
import { timezoneFragmentToCanonical } from "@triplydb/recognized-datatypes/xsd/dateTime.js";
import { durationToCanonical } from "@triplydb/recognized-datatypes/xsd/duration.js";
import { ParseError } from "@triplydb/data-factory/DataFactory.js";
import { round as lodRound, escapeRegExp } from "lodash-es";
import log from "./Debugging.js";
export function lessThan(first, second) {
    if (first.evaluationResultType === "error")
        return first;
    if (second.evaluationResultType === "error")
        return second;
    if (isNaN(first.term) || isNaN(second.term))
        return FALSE;
    return first.term.cmpString < second.term.cmpString ? TRUE : FALSE;
}
export function effectiveBooleanValue(arg) {
    log("sparql:filter:effectiveBooleanValue", "Execute with value: %D", arg);
    if (arg.evaluationResultType === "error") {
        log("sparql:filter:effectiveBooleanValue", "error");
        return arg;
    }
    return effectiveBooleanValueOfTerm(arg.term);
}
export function effectiveBooleanValueOfTerm(term) {
    if (term.termType === "Literal") {
        if (term.datatype.equals(DATA_TYPES.XSD_BOOLEAN)) {
            log("sparql:filter:effectiveBooleanValue", "boolean literal");
            return term.value === "true";
        }
        if (term.datatype.equals(DATA_TYPES.XSD_STRING) || term.datatype.equals(DATA_TYPES.RDF_LANG_STRING)) {
            log("sparql:filter:effectiveBooleanValue", "string literal");
            return term.value.length > 0;
        }
        if (validators.numericDatatype(term.datatype)) {
            log("sparql:filter:effectiveBooleanValue", "numeric literal");
            return !["-0.0E0", "0.0E0", "0", "NaN"].includes(term.value);
        }
    }
    log("sparql:filter:effectiveBooleanValue", "type error");
    return {
        evaluationResultType: "error",
        errorType: "EffectiveBooleanValueError",
    };
}
export function compare(terms) {
    const validationError = ValidateLiteralOrNamedNode(terms, [
        [validators.stringLiteral, validators.languageLiteral],
        [validators.stringLiteral, validators.languageLiteral],
    ]);
    if (validationError)
        return validationError;
    if (!validators.literal(terms[0]) || !validators.literal(terms[1]))
        return invalidArgumentTypesError;
    if (terms[0].value === terms[1].value && terms[0].datatype.value === terms[1].datatype.value)
        return newLiteral("0", DATA_TYPES["XSD_INTEGER"]);
    if (terms[0].cmpString < terms[1].cmpString)
        return newLiteral("-1", DATA_TYPES["XSD_INTEGER"]);
    return newLiteral("1", DATA_TYPES["XSD_INTEGER"]);
}
export function str(terms) {
    const validationError = ValidateLiteralOrNamedNode(terms, [[validators.literal, validators.namedNode]]);
    if (validationError)
        return validationError;
    return {
        evaluationResultType: "value",
        term: dataFactory.literal(terms[0].value, DATA_TYPES.XSD_STRING),
    };
}
export function strlen(terms) {
    const validationError = ValidateLiteralOrNamedNode(terms, [
        [validators.derivedFromStringLiteral, validators.languageLiteral],
    ]);
    if (validationError)
        return validationError;
    let length = 0;
    const stringIterator = terms[0].value[Symbol.iterator]();
    while (!stringIterator.next().done)
        length++;
    return {
        evaluationResultType: "value",
        term: dataFactory.literal(length, DATA_TYPES.XSD_INTEGER),
    };
}
export function substr(terms) {
    const valueArray = [
        [validators.derivedFromStringLiteral, validators.languageLiteral],
        [validators.derivedFromIntegerLiteral],
    ];
    if (terms[2])
        valueArray.push([validators.derivedFromIntegerLiteral]);
    const validationError = ValidateLiteralOrNamedNode(terms, valueArray);
    if (validationError)
        return validationError;
    const inputStringArray = [...terms[0].value];
    let zeroIndexedStartingLoc = parseInt(terms[1].value) - 1;
    let substringedValue;
    if (terms[2]) {
        let substrLength = parseInt(terms[2].value);
        if (zeroIndexedStartingLoc < 0) {
            substrLength += zeroIndexedStartingLoc;
            zeroIndexedStartingLoc = 0;
        }
        substringedValue = inputStringArray.slice(zeroIndexedStartingLoc, zeroIndexedStartingLoc + substrLength).join("");
    }
    else {
        substringedValue = inputStringArray.slice(zeroIndexedStartingLoc).join("");
    }
    return {
        evaluationResultType: "value",
        term: changeLiteralValue(terms[0], substringedValue),
    };
}
export function ucase(terms) {
    const validationError = ValidateLiteralOrNamedNode(terms, [
        [validators.derivedFromStringLiteral, validators.languageLiteral],
    ]);
    if (validationError)
        return validationError;
    const upperCasedValue = terms[0].value.toUpperCase();
    const changedLiteral = changeLiteralValue(terms[0], upperCasedValue);
    return {
        evaluationResultType: "value",
        term: changedLiteral,
    };
}
export function lcase(terms) {
    const validationError = ValidateLiteralOrNamedNode(terms, [
        [validators.derivedFromStringLiteral, validators.languageLiteral],
    ]);
    if (validationError)
        return validationError;
    const lowerCasedValue = terms[0].value.toLowerCase();
    const changedLiteral = changeLiteralValue(terms[0], lowerCasedValue);
    return {
        evaluationResultType: "value",
        term: changedLiteral,
    };
}
export function strstarts(terms) {
    const validationError = ValidateLiteralOrNamedNode(terms, [
        [validators.derivedFromStringLiteral, validators.languageLiteral],
        [validators.derivedFromStringLiteral, validators.languageLiteral],
    ]);
    if (validationError)
        return validationError;
    const haveMatchingLanguages = getMatchingDatatypeOrLanguage(terms[0], terms[1]);
    if (typeof haveMatchingLanguages === "object" && "errorType" in haveMatchingLanguages)
        return haveMatchingLanguages;
    const indexBoolean = terms[0].value.startsWith(terms[1].value);
    return indexBoolean ? TRUE : FALSE;
}
export function strends(terms) {
    const validationError = ValidateLiteralOrNamedNode(terms, [
        [validators.derivedFromStringLiteral, validators.languageLiteral],
        [validators.derivedFromStringLiteral, validators.languageLiteral],
    ]);
    if (validationError)
        return validationError;
    const haveMatchingLanguages = getMatchingDatatypeOrLanguage(terms[0], terms[1]);
    if (typeof haveMatchingLanguages === "object" && "errorType" in haveMatchingLanguages)
        return haveMatchingLanguages;
    const indexBoolean = terms[0].value.endsWith(terms[1].value);
    return indexBoolean ? TRUE : FALSE;
}
export function contains(terms) {
    const validationError = ValidateLiteralOrNamedNode(terms, [
        [validators.derivedFromStringLiteral, validators.languageLiteral],
        [validators.derivedFromStringLiteral, validators.languageLiteral],
    ]);
    if (validationError)
        return validationError;
    const haveMatchingLanguages = getMatchingDatatypeOrLanguage(terms[0], terms[1]);
    if (typeof haveMatchingLanguages === "object" && "errorType" in haveMatchingLanguages)
        return haveMatchingLanguages;
    const indexBoolean = terms[0].value.includes(terms[1].value);
    return indexBoolean ? TRUE : FALSE;
}
export function concat(terms) {
    const stringValueArray = Array(terms.length).fill([validators.derivedFromStringLiteral, validators.languageLiteral]);
    const validationError = ValidateLiteralOrNamedNode(terms, stringValueArray);
    if (validationError)
        return validationError;
    const indexValue = terms.map((term) => term.value).join("");
    return {
        evaluationResultType: "value",
        term: dataFactory.literal(indexValue, terms.length === 0 ? undefined : getSharedLanguageTag(terms)),
    };
}
export function lang(terms) {
    const validationError = ValidateLiteralOrNamedNode(terms, [[validators.literal]]);
    if (validationError)
        return validationError;
    return newLiteral(terms[0].language, DATA_TYPES["XSD_STRING"]);
}
export function langmatches(terms) {
    const validationError = ValidateLiteralOrNamedNode(terms, [
        [validators.derivedFromStringLiteral],
        [validators.derivedFromStringLiteral],
    ]);
    if (validationError)
        return validationError;
    if (terms[0].value === "")
        return FALSE;
    const match = basicLanguageTagFilter(terms[0].value, terms[1].value);
    return match.length > 0 ? TRUE : FALSE;
}
export function abs(terms) {
    if (!validators.literal(terms[0]) || !numericDatatypeIris.has(terms[0].datatype.value)) {
        return invalidArgumentTypesError;
    }
    return newLiteral(String(Math.abs(canonicalToNumber(terms[0].value))), terms[0].datatype);
}
export function ceil(terms) {
    if (!validators.literal(terms[0]) || !numericDatatypeIris.has(terms[0].datatype.value)) {
        return invalidArgumentTypesError;
    }
    return newLiteral(String(Math.ceil(canonicalToNumber(terms[0].value))), terms[0].datatype);
}
export function floor(terms) {
    if (!validators.literal(terms[0]) || !numericDatatypeIris.has(terms[0].datatype.value)) {
        return invalidArgumentTypesError;
    }
    return newLiteral(String(Math.floor(canonicalToNumber(terms[0].value))), terms[0].datatype);
}
export function round(terms) {
    if (!validators.literal(terms[0]) || !numericDatatypeIris.has(terms[0].datatype.value)) {
        return invalidArgumentTypesError;
    }
    if (terms.length === 1)
        return newLiteral(String(Math.round(canonicalToNumber(terms[0].value))), terms[0].datatype);
    if (!validators.integerLiteral(terms[1]))
        return invalidArgumentTypesError;
    return newLiteral(String(lodRound(canonicalToNumber(terms[0].value), canonicalToNumber(terms[1].value))), terms[0].datatype);
}
export function strbefore(terms) {
    const validationError = ValidateLiteralOrNamedNode(terms, [
        [validators.derivedFromStringLiteral, validators.languageLiteral],
        [validators.derivedFromStringLiteral, validators.languageLiteral],
    ]);
    if (validationError)
        return validationError;
    const haveMatchingLanguages = getMatchingDatatypeOrLanguage(terms[0], terms[1]);
    if (typeof haveMatchingLanguages === "object" && "errorType" in haveMatchingLanguages)
        return haveMatchingLanguages;
    const indexValue = terms[0].value.slice(0, Math.max(0, terms[0].value.indexOf(terms[1].value)));
    return {
        evaluationResultType: "value",
        term: dataFactory.literal(indexValue, haveMatchingLanguages),
    };
}
export function strafter(terms) {
    const validationError = ValidateLiteralOrNamedNode(terms, [
        [validators.derivedFromStringLiteral, validators.languageLiteral],
        [validators.derivedFromStringLiteral, validators.languageLiteral],
    ]);
    if (validationError)
        return validationError;
    const haveMatchingLanguages = getMatchingDatatypeOrLanguage(terms[0], terms[1]);
    if (typeof haveMatchingLanguages === "object" && "errorType" in haveMatchingLanguages)
        return haveMatchingLanguages;
    const stringAfter = terms[0].value.slice(terms[0].value.indexOf(terms[1].value)).slice(terms[1].value.length);
    return {
        evaluationResultType: "value",
        term: dataFactory.literal(stringAfter, haveMatchingLanguages),
    };
}
export function encode_for_uri(terms, useURIComponent) {
    const validationError = ValidateLiteralOrNamedNode(terms, [
        [validators.derivedFromStringLiteral, validators.languageLiteral],
    ]);
    if (validationError)
        return validationError;
    const indexValue = useURIComponent ? encodeURIComponent(terms[0].value) : encodeURI(terms[0].value);
    return {
        evaluationResultType: "value",
        term: dataFactory.literal(indexValue),
    };
}
const DEFAULT_REGEX_FLAGS = `gu`;
export function regex(terms) {
    const valueArray = [
        [validators.derivedFromStringLiteral, validators.languageLiteral],
        [validators.derivedFromStringLiteral],
    ];
    if (terms[2])
        valueArray.push([validators.derivedFromStringLiteral]);
    const validationError = ValidateLiteralOrNamedNode(terms, valueArray);
    if (validationError)
        return validationError;
    const initialString = terms[0].value;
    const pattern = terms[1].value;
    let customFlags = "";
    if (terms[2]) {
        let flag = terms[2].value;
        if (!isSupportedFlag(flag))
            return { evaluationResultType: "error" };
        customFlags = flag;
    }
    let reg;
    try {
        reg = new RegExp(pattern, customFlags + DEFAULT_REGEX_FLAGS);
    }
    catch (e) {
        return { evaluationResultType: "error" };
    }
    const indexBoolean = reg.test(initialString);
    return indexBoolean ? TRUE : FALSE;
}
export function replace(terms) {
    const valueArray = [
        [validators.derivedFromStringLiteral, validators.languageLiteral],
        [validators.derivedFromStringLiteral],
        [validators.derivedFromStringLiteral],
    ];
    if (terms[3])
        valueArray.push([validators.derivedFromStringLiteral]);
    const validationError = ValidateLiteralOrNamedNode(terms, valueArray);
    if (validationError)
        return validationError;
    const initialString = terms[0].value;
    const pattern = terms[1].value;
    const replacement = terms[2].value;
    let reg;
    let escapedPattern = "";
    let regexCharacters = ["{"];
    escapedPattern = regexCharacters.some((char) => pattern.includes(char)) ? escapeRegExp(pattern) : pattern;
    if (terms[3]) {
        const flag = terms[3].value;
        if (!isSupportedFlag(flag))
            return { evaluationResultType: "error" };
        reg = new RegExp(escapedPattern, flag + DEFAULT_REGEX_FLAGS);
    }
    else {
        reg = new RegExp(escapedPattern, DEFAULT_REGEX_FLAGS);
    }
    return {
        evaluationResultType: "value",
        term: changeLiteralValue(terms[0], initialString.replace(reg, replacement)),
    };
}
export function hashStrings(terms, algorithm) {
    const validationError = ValidateLiteralOrNamedNode(terms, [[validators.derivedFromStringLiteral]]);
    if (validationError)
        return validationError;
    const valueHashed = createHash(algorithm).update(terms[0].value, "utf8").digest("hex");
    return newLiteral(valueHashed, DATA_TYPES.XSD_STRING);
}
export function newLiteral(value, dataType) {
    try {
        return {
            evaluationResultType: "value",
            term: dataFactory.literal(value, dataType),
        };
    }
    catch (e) {
        if (e instanceof ParseError) {
            return {
                evaluationResultType: "error",
                errorType: "InvalidLexicalForm",
            };
        }
        else {
            throw e;
        }
    }
}
export function strdt(terms) {
    const validationError = ValidateLiteralOrNamedNode(terms, [
        [validators.derivedFromStringLiteral],
        [validators.namedNode],
    ]);
    if (validationError)
        return validationError;
    return newLiteral(terms[0].value, terms[1]);
}
export function strlang(terms) {
    const validationError = ValidateLiteralOrNamedNode(terms, [[validators.stringLiteral], [validators.stringLiteral]]);
    if (validationError)
        return validationError;
    return newLiteral(terms[0].value, terms[1].value);
}
export function iri(terms, baseIri) {
    const validationError = ValidateLiteralOrNamedNode(terms, [
        [validators.derivedFromStringLiteral, validators.namedNode],
    ]);
    if (validationError)
        return validationError;
    let namedNode;
    const resolvedIri = resolve(terms[0].value, baseIri);
    try {
        namedNode = dataFactory.namedNode(resolvedIri);
    }
    catch (e) {
        if (e instanceof ParseError)
            return { evaluationResultType: "error", errorType: "InvalidIri", value: resolvedIri };
        throw e;
    }
    return {
        evaluationResultType: "value",
        term: namedNode,
    };
}
export function bnode(terms) {
    if (terms.length > 0) {
        const validationError = ValidateLiteralOrNamedNode(terms, [[validators.derivedFromStringLiteral]]);
        if (validationError)
            return validationError;
    }
    return {
        evaluationResultType: "value",
        term: dataFactory.blankNode(),
    };
}
export function datatype(terms) {
    if (!validators.literal(terms[0]))
        return invalidArgumentTypesError;
    return {
        evaluationResultType: "value",
        term: terms[0].datatype,
    };
}
export function xsdboolean(terms) {
    if (!validators.literal(terms[0]))
        return {
            evaluationResultType: "error",
            errorType: "InvalidArgumentTypes",
        };
    if (isDerivedFromStringLiteral(terms[0]))
        return newLiteral(terms[0].value, DATA_TYPES.XSD_BOOLEAN);
    switch (terms[0].datatype.value) {
        case DATA_TYPES.RDF_LANG_STRING.value:
        case DATA_TYPES.XSD_UNTYPED_ATOMIC.value:
            return newLiteral(terms[0].value, DATA_TYPES.XSD_BOOLEAN);
        case DATA_TYPES.XSD_BOOLEAN.value:
            return terms[0].value === "true" ? TRUE : FALSE;
        case DATA_TYPES.XSD_FLOAT.value:
        case DATA_TYPES.XSD_DOUBLE.value:
            if (["0.0E0", "-0.0E0", "NaN"].includes(terms[0].value))
                return FALSE;
            else
                return TRUE;
        case DATA_TYPES.XSD_DECIMAL.value:
        case DATA_TYPES.XSD_INTEGER.value:
            if (terms[0].value === "0")
                return FALSE;
            else
                return TRUE;
    }
    return {
        evaluationResultType: "error",
        errorType: "InvalidArgumentTypes",
    };
}
export function xsddatetime(terms) {
    if (!validators.literal(terms[0]))
        return {
            evaluationResultType: "error",
            errorType: "InvalidArgumentTypes",
        };
    if (isDerivedFromStringLiteral(terms[0]))
        return newLiteral(terms[0].value, DATA_TYPES.XSD_DATE_TIME);
    switch (terms[0].datatype.value) {
        case DATA_TYPES.RDF_LANG_STRING.value:
        case DATA_TYPES.XSD_UNTYPED_ATOMIC.value:
            return newLiteral(terms[0].value, DATA_TYPES.XSD_DATE_TIME);
        case DATA_TYPES.XSD_DATE_TIME.value:
            return { evaluationResultType: "value", term: terms[0] };
        case DATA_TYPES.XSD_DATE.value:
            return newLiteral(xsdDateToxsdDatetime(terms[0].value), DATA_TYPES.XSD_DATE_TIME);
    }
    return {
        evaluationResultType: "error",
        errorType: "InvalidArgumentTypes",
    };
}
export function xsddate(terms) {
    if (!validators.literal(terms[0]))
        return {
            evaluationResultType: "error",
            errorType: "InvalidArgumentTypes",
        };
    if (isDerivedFromStringLiteral(terms[0]))
        return newLiteral(terms[0].value, DATA_TYPES.XSD_DATE);
    switch (terms[0].datatype.value) {
        case DATA_TYPES.XSD_UNTYPED_ATOMIC.value:
        case DATA_TYPES.RDF_LANG_STRING.value:
            return newLiteral(terms[0].value, DATA_TYPES.XSD_DATE);
        case DATA_TYPES.XSD_DATE.value:
            return { evaluationResultType: "value", term: terms[0] };
        case DATA_TYPES.XSD_DATE_TIME.value:
            const dateTime = lexicalToValue(terms[0].value, DATA_TYPES.XSD_DATE_TIME);
            const year = dateTime.year.toString();
            const month = dateTime.month.toString().padStart(2, "0");
            const day = dateTime.day.toString().padStart(2, "0");
            return newLiteral(year + "-" + month + "-" + day, DATA_TYPES.XSD_DATE);
    }
    return {
        evaluationResultType: "error",
        errorType: "InvalidArgumentTypes",
    };
}
export function xsdgYear(terms) {
    if (!validators.literal(terms[0]))
        return {
            evaluationResultType: "error",
            errorType: "InvalidArgumentTypes",
        };
    if (isDerivedFromStringLiteral(terms[0]))
        return newLiteral(terms[0].value, DATA_TYPES.XSD_G_YEAR);
    switch (terms[0].datatype.value) {
        case DATA_TYPES.RDF_LANG_STRING.value:
        case DATA_TYPES.XSD_UNTYPED_ATOMIC.value:
            return newLiteral(terms[0].value, DATA_TYPES.XSD_G_YEAR);
        case DATA_TYPES.XSD_G_YEAR.value:
            return { evaluationResultType: "value", term: terms[0] };
        case DATA_TYPES.XSD_DATE_TIME.value:
            const dateTime = lexicalToValue(terms[0].value, DATA_TYPES.XSD_DATE_TIME);
            return newLiteral(dateTime.year.toString(), DATA_TYPES.XSD_G_YEAR);
        case DATA_TYPES.XSD_DATE.value:
            const date = lexicalToValue(terms[0].value, DATA_TYPES.XSD_DATE);
            if (date.timezone === undefined)
                return newLiteral(date.year.toString(), DATA_TYPES.XSD_G_YEAR);
            if (date.timezone === 0) {
                return newLiteral(date.year + "Z", DATA_TYPES.XSD_G_YEAR);
            }
            const tzSign = Math.sign(date.timezone) + "" === "1" ? "+" : "-";
            const absTimezone = Math.abs(date.timezone);
            const tzHours = Math.floor(Number(absTimezone) / 60)
                .toString()
                .padStart(2, "0");
            const tzMinutes = (Number(absTimezone) % 60).toString().padStart(2, "0");
            const reconstitutedTimezone = tzSign + tzHours + ":" + tzMinutes;
            return newLiteral(date.year + reconstitutedTimezone, DATA_TYPES.XSD_G_YEAR);
    }
    return {
        evaluationResultType: "error",
        errorType: "InvalidArgumentTypes",
    };
}
export function xsdfloat(terms) {
    if (!validators.literal(terms[0]))
        return {
            evaluationResultType: "error",
            errorType: "InvalidArgumentTypes",
        };
    if (isDerivedFromStringLiteral(terms[0]))
        return newLiteral(terms[0].value, DATA_TYPES.XSD_FLOAT);
    switch (terms[0].datatype.value) {
        case DATA_TYPES.RDF_LANG_STRING.value:
        case DATA_TYPES.XSD_UNTYPED_ATOMIC.value:
        case DATA_TYPES.XSD_DECIMAL.value:
        case DATA_TYPES.XSD_INTEGER.value:
            return newLiteral(terms[0].value, DATA_TYPES.XSD_FLOAT);
        case DATA_TYPES.XSD_BOOLEAN.value:
            if (terms[0].value === "true")
                return newLiteral("1.0E0", DATA_TYPES.XSD_FLOAT);
            return newLiteral("0.0E0", DATA_TYPES.XSD_FLOAT);
        case DATA_TYPES.XSD_FLOAT.value:
        case DATA_TYPES.XSD_DOUBLE.value:
            if (Math.abs(Number(terms[0].value)) < 2.350988701644575e-38)
                return newLiteral(terms[0].value.charAt(0) === "-" ? "-0.0E0" : "0.0E0", DATA_TYPES.XSD_FLOAT);
            if (Math.abs(Number(terms[0].value)) > 3.402823669209385e38)
                return newLiteral(terms[0].value.charAt(0) === "-" ? "-INF" : "INF", DATA_TYPES.XSD_FLOAT);
            return newLiteral(terms[0].value, DATA_TYPES.XSD_FLOAT);
    }
    return {
        evaluationResultType: "error",
        errorType: "InvalidArgumentTypes",
    };
}
export function xsddouble(terms) {
    if (!validators.literal(terms[0]))
        return {
            evaluationResultType: "error",
            errorType: "InvalidArgumentTypes",
        };
    if (isDerivedFromStringLiteral(terms[0])) {
        return newLiteral(terms[0].value, DATA_TYPES.XSD_DOUBLE);
    }
    switch (terms[0].datatype.value) {
        case DATA_TYPES.XSD_DOUBLE.value:
            return { evaluationResultType: "value", term: terms[0] };
        case DATA_TYPES.XSD_FLOAT.value:
        case DATA_TYPES.RDF_LANG_STRING.value:
        case DATA_TYPES.XSD_UNTYPED_ATOMIC.value:
        case DATA_TYPES.XSD_DECIMAL.value:
        case DATA_TYPES.XSD_INTEGER.value:
            return newLiteral(terms[0].value, DATA_TYPES.XSD_DOUBLE);
        case DATA_TYPES.XSD_BOOLEAN.value:
            if (terms[0].value === "true")
                return newLiteral("1.0E0", DATA_TYPES.XSD_DOUBLE);
            return newLiteral("0.0E0", DATA_TYPES.XSD_DOUBLE);
    }
    return {
        evaluationResultType: "error",
        errorType: "InvalidArgumentTypes",
    };
}
export function xsddecimal(terms) {
    if (!validators.literal(terms[0]))
        return {
            evaluationResultType: "error",
            errorType: "InvalidArgumentTypes",
        };
    if (isDerivedFromStringLiteral(terms[0]) ||
        isDerivedFromDecimalLiteral(terms[0])) {
        return newLiteral(terms[0].value, DATA_TYPES.XSD_DECIMAL);
    }
    switch (terms[0].datatype.value) {
        case DATA_TYPES.RDF_LANG_STRING.value:
        case DATA_TYPES.XSD_UNTYPED_ATOMIC.value:
            return newLiteral(terms[0].value, DATA_TYPES.XSD_DECIMAL);
        case DATA_TYPES.XSD_DOUBLE.value:
        case DATA_TYPES.XSD_FLOAT.value:
            if (["NaN", "INF", "-INF"].includes(terms[0].value))
                return { evaluationResultType: "error", errorType: "InvalidLexicalForm" };
            return newLiteral(decimalToRoundedString(Number(terms[0].value)), DATA_TYPES.XSD_DECIMAL);
        case DATA_TYPES.XSD_BOOLEAN.value:
            if (terms[0].value === "true")
                return newLiteral("1", DATA_TYPES.XSD_DECIMAL);
            return newLiteral("0", DATA_TYPES.XSD_DECIMAL);
    }
    return {
        evaluationResultType: "error",
        errorType: "InvalidArgumentTypes",
    };
}
export function xsdinteger(terms) {
    if (!validators.literal(terms[0]))
        return {
            evaluationResultType: "error",
            errorType: "InvalidArgumentTypes",
        };
    if (isDerivedFromStringLiteral(terms[0]) ||
        isDerivedFromIntegerLiteral(terms[0]))
        return newLiteral(terms[0].value, DATA_TYPES.XSD_INTEGER);
    switch (terms[0].datatype.value) {
        case DATA_TYPES.RDF_LANG_STRING.value:
        case DATA_TYPES.XSD_UNTYPED_ATOMIC.value:
            return newLiteral(terms[0].value, DATA_TYPES.XSD_INTEGER);
        case DATA_TYPES.XSD_DECIMAL.value:
        case DATA_TYPES.XSD_DOUBLE.value:
        case DATA_TYPES.XSD_FLOAT.value:
            if (["NaN", "INF", "-INF"].includes(terms[0].value))
                return { evaluationResultType: "error", errorType: "InvalidLexicalForm" };
            return newLiteral(parseInt(Number(terms[0].value).toString()).toString(), DATA_TYPES.XSD_INTEGER);
        case DATA_TYPES.XSD_BOOLEAN.value:
            if (terms[0].value === "true")
                return newLiteral("1", DATA_TYPES.XSD_INTEGER);
            return newLiteral("0", DATA_TYPES.XSD_INTEGER);
    }
    return {
        evaluationResultType: "error",
        errorType: "InvalidArgumentTypes",
    };
}
export function xsdlong(terms) {
    if (!validators.literal(terms[0])) {
        return {
            evaluationResultType: "error",
            errorType: "InvalidArgumentTypes",
        };
    }
    if (isDerivedFromStringLiteral(terms[0]) || isDerivedFromIntegerLiteral(terms[0])) {
        return newLiteral(terms[0].value, DATA_TYPES.XSD_LONG);
    }
    switch (terms[0].datatype.value) {
        case DATA_TYPES.RDF_LANG_STRING.value:
        case DATA_TYPES.XSD_UNTYPED_ATOMIC.value:
            return newLiteral(terms[0].value, DATA_TYPES.XSD_LONG);
        case DATA_TYPES.XSD_DECIMAL.value:
        case DATA_TYPES.XSD_DOUBLE.value:
        case DATA_TYPES.XSD_FLOAT.value:
            if (["NaN", "INF", "-INF"].includes(terms[0].value))
                return { evaluationResultType: "error", errorType: "InvalidLexicalForm" };
            return newLiteral(parseInt(terms[0].value).toString(), DATA_TYPES.XSD_LONG);
        case DATA_TYPES.XSD_BOOLEAN.value:
            return terms[0].value === "true" ? newLiteral("1", DATA_TYPES.XSD_LONG) : newLiteral("0", DATA_TYPES.XSD_LONG);
        default:
            return {
                evaluationResultType: "error",
                errorType: "InvalidArgumentTypes",
            };
    }
}
export function xsdint(terms) {
    if (!validators.literal(terms[0]))
        return {
            evaluationResultType: "error",
            errorType: "InvalidArgumentTypes",
        };
    if (isDerivedFromStringLiteral(terms[0]) || isDerivedFromIntegerLiteral(terms[0])) {
        return newLiteral(terms[0].toString(), DATA_TYPES.XSD_INT);
    }
    switch (terms[0].datatype.value) {
        case DATA_TYPES.XSD_UNTYPED_ATOMIC.value:
        case DATA_TYPES.RDF_LANG_STRING.value:
            return newLiteral(terms[0].value, DATA_TYPES.XSD_INT);
        case DATA_TYPES.XSD_DECIMAL.value:
        case DATA_TYPES.XSD_DOUBLE.value:
        case DATA_TYPES.XSD_FLOAT.value:
            return newLiteral(parseInt(terms[0].value).toString().toString(), DATA_TYPES.XSD_INT);
        case DATA_TYPES.XSD_BOOLEAN.value:
            return terms[0].value === "true" ? newLiteral("1", DATA_TYPES.XSD_INT) : newLiteral("0", DATA_TYPES.XSD_INT);
        default:
            return {
                evaluationResultType: "error",
                errorType: "InvalidArgumentTypes",
            };
    }
}
export function xsdstring(terms) {
    const term = terms[0];
    if (term.termType === "Literal" &&
        (term.datatype.value === DATA_TYPES.XSD_FLOAT.value || term.datatype.value === DATA_TYPES.XSD_DOUBLE.value)) {
        if (term.value === "0.0E0")
            return newLiteral("0", DATA_TYPES.XSD_STRING);
        if (term.value === "-0.0E0")
            return newLiteral("-0", DATA_TYPES.XSD_STRING);
        const value = +term.value;
        const abs = Math.abs(value);
        if (0.000001 <= abs && abs < 1000000) {
            return newLiteral(valueToCanonical("" + value, DATA_TYPES.XSD_DECIMAL), DATA_TYPES.XSD_STRING);
        }
    }
    return newLiteral(term.value, DATA_TYPES.XSD_STRING);
}
const PROMOTABLE_NUMERIC_TYPES = SUB_TYPES.XSD_FLOAT.concat(SUB_TYPES.XSD_DECIMAL);
export function getNumericOutputDataType(a, b, alsoTestWithFlippedArguments = true) {
    if (SUB_TYPE_IRIS[a.value].includes(b.value))
        return a;
    if ((a.equals(DATA_TYPES.XSD_DOUBLE) || a.equals(DATA_TYPES.XSD_FLOAT)) && PROMOTABLE_NUMERIC_TYPES.includes(b.value))
        return a;
    if (alsoTestWithFlippedArguments)
        return getNumericOutputDataType(b, a, false);
    else
        return {
            evaluationResultType: "error",
            errorType: "InvalidArgumentTypes",
        };
}
export function validateAndGetNumericDataType(a, b) {
    let numericDataType = [];
    for (const term of [a, b]) {
        if (term.termType !== "Literal")
            return { errorType: "InvalidArgumentTypes", evaluationResultType: "error" };
        if (!numericDatatypeIris.has(term.datatype.value))
            return { errorType: "InvalidArgumentTypes", evaluationResultType: "error" };
        numericDataType.push(term.datatype);
    }
    return getNumericOutputDataType(numericDataType[0], numericDataType[1]);
}
function splice(str, index, value) {
    return str.slice(0, index) + value + str.slice(index, str.length);
}
export function xsdDateToxsdDatetime(date) {
    let yearSign = "";
    if (date.indexOf("-") === 0) {
        yearSign = "-";
        date = date.substring(1);
    }
    if (date.includes("Z"))
        return yearSign + splice(date, date.length - 1, "T00:00:00");
    if (date.includes("+"))
        return yearSign + splice(date, date.indexOf("+"), "T00:00:00");
    const [timezone] = date.split("-").slice(3);
    if (timezone)
        return yearSign + splice(date, date.lastIndexOf("-"), "T00:00:00");
    return yearSign + date + "T00:00:00";
}
export function year(terms) {
    const validationError = ValidateLiteralOrNamedNode(terms, [[validators.dateTimeLiteral]]);
    if (validationError)
        return validationError;
    return {
        evaluationResultType: "value",
        term: dataFactory.literal(lexicalToValue(terms[0].value, DATA_TYPES.XSD_DATE_TIME).year, DATA_TYPES.XSD_INTEGER),
    };
}
export function month(terms) {
    const validationError = ValidateLiteralOrNamedNode(terms, [[validators.dateTimeLiteral]]);
    if (validationError)
        return validationError;
    return {
        evaluationResultType: "value",
        term: dataFactory.literal(lexicalToValue(terms[0].value, DATA_TYPES.XSD_DATE_TIME).month, DATA_TYPES.XSD_INTEGER),
    };
}
export function day(terms) {
    const validationError = ValidateLiteralOrNamedNode(terms, [[validators.dateTimeLiteral]]);
    if (validationError)
        return validationError;
    return {
        evaluationResultType: "value",
        term: dataFactory.literal(lexicalToValue(terms[0].value, DATA_TYPES.XSD_DATE_TIME).day, DATA_TYPES.XSD_INTEGER),
    };
}
export function hours(terms) {
    const validationError = ValidateLiteralOrNamedNode(terms, [[validators.dateTimeLiteral]]);
    if (validationError)
        return validationError;
    return {
        evaluationResultType: "value",
        term: dataFactory.literal(lexicalToValue(terms[0].value, DATA_TYPES.XSD_DATE_TIME).hour, DATA_TYPES.XSD_INTEGER),
    };
}
export function minutes(terms) {
    const validationError = ValidateLiteralOrNamedNode(terms, [[validators.dateTimeLiteral]]);
    if (validationError)
        return validationError;
    return {
        evaluationResultType: "value",
        term: dataFactory.literal(lexicalToValue(terms[0].value, DATA_TYPES.XSD_DATE_TIME).minute, DATA_TYPES.XSD_INTEGER),
    };
}
export function seconds(terms) {
    const validationError = ValidateLiteralOrNamedNode(terms, [[validators.dateTimeLiteral]]);
    if (validationError)
        return validationError;
    return {
        evaluationResultType: "value",
        term: dataFactory.literal(lexicalToValue(terms[0].value, DATA_TYPES.XSD_DATE_TIME).second, DATA_TYPES.XSD_DECIMAL),
    };
}
export function timezone(terms) {
    const validationError = ValidateLiteralOrNamedNode(terms, [[validators.dateTimeLiteral]]);
    if (validationError)
        return validationError;
    const timezone = lexicalToValue(terms[0].value, DATA_TYPES.XSD_DATE_TIME).timezone;
    if (timezone === undefined) {
        return {
            evaluationResultType: "error",
            errorType: "InvalidTimezoneCall",
        };
    }
    return {
        evaluationResultType: "value",
        term: dataFactory.literal(durationToCanonical({ months: 0, seconds: timezone * 60, isNegative: false, fraction: "" }), DATA_TYPES.XSD_DAYTIME_DURATION),
    };
}
export function tz(terms) {
    const validationError = ValidateLiteralOrNamedNode(terms, [[validators.dateTimeLiteral]]);
    if (validationError)
        return validationError;
    const timezone = lexicalToValue(terms[0].value, DATA_TYPES.XSD_DATE_TIME).timezone;
    return {
        evaluationResultType: "value",
        term: dataFactory.literal(timezone === undefined ? "" : timezoneFragmentToCanonical(timezone), DATA_TYPES.XSD_STRING),
    };
}
//# sourceMappingURL=EvaluationFunctions.js.map