import * as Terms from "@triplydb/data-factory/Terms.js";
import { TermTypeToTerm } from "@triplydb/data-factory/Terms.js";
import { DATA_TYPE_NAME_MAPPING, NumericDataTypeIri } from "@triplydb/recognized-datatypes/utils/constants.js";
export declare const MAX_RESULTS_IN_MEMORY = 10000;
export type Id = number;
export type Variable = string;
export type Term = Terms.NamedNode | Terms.BlankNode | Terms.Literal;
export type GraphName = Terms.NamedNode;
declare const quadTerms: {
    subject: ("NamedNode" | "BlankNode")[];
    predicate: "NamedNode"[];
    object: ("NamedNode" | "BlankNode" | "Literal")[];
    graph: ("NamedNode" | "DefaultGraph")[];
};
type QuadTerms = {
    subject: TermTypeToTerm[(typeof quadTerms)["subject"][number]];
    predicate: TermTypeToTerm[(typeof quadTerms)["predicate"][number]];
    object: TermTypeToTerm[(typeof quadTerms)["object"][number]];
    graph: TermTypeToTerm[(typeof quadTerms)["graph"][number]];
};
export type Quad = Terms.Quad<QuadTerms>;
export declare const dataFactory: {
    fromTerm: <T extends import("rdf-js").Term>(term: T, opts?: {
        validationStatus?: Terms.ValidationStatus | undefined;
    } | undefined) => Terms.TermTypeToTerm[T["termType"]];
    fromQuad: (term: import("rdf-js").Quad) => Terms.Quad<{
        subject: Terms.BlankNode | Terms.NamedNode<string>;
        predicate: Terms.NamedNode<string>;
        object: Terms.BlankNode | Terms.NamedNode<string> | Terms.Literal<string>;
        graph: Terms.NamedNode<string> | Terms.DefaultGraph;
    }>;
    resetBnodeCounter: () => void;
    prefixer: <Prefix extends string>(base: Prefix | Terms.NamedNode<Prefix>) => <Suffix extends string>(local: Suffix) => Terms.NamedNode<`${Prefix}${Suffix}`>;
    isValidSubject: (term: Terms.Term) => term is Terms.BlankNode | Terms.NamedNode<string>;
    isValidPredicate: (term: Terms.Term) => term is Terms.NamedNode<string>;
    isValidObject: (term: Terms.Term) => term is Terms.BlankNode | Terms.NamedNode<string> | Terms.Literal<string>;
    isValidGraph: (term: Terms.Term) => term is Terms.NamedNode<string> | Terms.DefaultGraph;
    literal: {
        (value: string, languageOrDataType?: string | import("rdf-js").NamedNode<string> | undefined, opts?: {
            validationStatus?: Terms.ValidationStatus | undefined;
        } | undefined): Terms.Literal<string>;
        (value: number | boolean, languageTagOrDatatype: string | import("rdf-js").NamedNode<string>, opts?: {
            validationStatus?: Terms.ValidationStatus | undefined;
        } | undefined): Terms.Literal<string>;
    };
    namedNode: (<Iri extends string = string>(iri: Iri, opts?: {
        validationStatus?: Terms.ValidationStatus | undefined;
    } | undefined) => Terms.NamedNode<Iri>) & import("lodash").MemoizedFunction;
    blankNode: (name?: string | undefined) => Terms.BlankNode;
    defaultGraph: () => Terms.DefaultGraph;
    quad: (subject: Terms.BlankNode | Terms.NamedNode<string>, predicate: Terms.NamedNode<string>, object: Terms.BlankNode | Terms.NamedNode<string> | Terms.Literal<string>, graph?: Terms.NamedNode<string> | Terms.DefaultGraph | undefined) => Terms.Quad<{
        subject: Terms.BlankNode | Terms.NamedNode<string>;
        predicate: Terms.NamedNode<string>;
        object: Terms.BlankNode | Terms.NamedNode<string> | Terms.Literal<string>;
        graph: Terms.NamedNode<string> | Terms.DefaultGraph;
    }>;
    variable: (name: string) => Terms.Variable;
};
export type DataFactory = typeof dataFactory;
export declare const dataFactoryWithoutValidation: {
    fromTerm: <T extends import("rdf-js").Term>(term: T, opts?: {
        validationStatus?: Terms.ValidationStatus | undefined;
    } | undefined) => Terms.TermTypeToTerm[T["termType"]];
    fromQuad: (term: import("rdf-js").Quad) => Terms.Quad<{
        subject: Terms.BlankNode | Terms.NamedNode<string>;
        predicate: Terms.NamedNode<string>;
        object: Terms.BlankNode | Terms.NamedNode<string> | Terms.Literal<string>;
        graph: Terms.NamedNode<string> | Terms.DefaultGraph;
    }>;
    resetBnodeCounter: () => void;
    prefixer: <Prefix extends string>(base: Prefix | Terms.NamedNode<Prefix>) => <Suffix extends string>(local: Suffix) => Terms.NamedNode<`${Prefix}${Suffix}`>;
    isValidSubject: (term: Terms.Term) => term is Terms.BlankNode | Terms.NamedNode<string>;
    isValidPredicate: (term: Terms.Term) => term is Terms.NamedNode<string>;
    isValidObject: (term: Terms.Term) => term is Terms.BlankNode | Terms.NamedNode<string> | Terms.Literal<string>;
    isValidGraph: (term: Terms.Term) => term is Terms.NamedNode<string> | Terms.DefaultGraph;
    literal: {
        (value: string, languageOrDataType?: string | import("rdf-js").NamedNode<string> | undefined, opts?: {
            validationStatus?: Terms.ValidationStatus | undefined;
        } | undefined): Terms.Literal<string>;
        (value: number | boolean, languageTagOrDatatype: string | import("rdf-js").NamedNode<string>, opts?: {
            validationStatus?: Terms.ValidationStatus | undefined;
        } | undefined): Terms.Literal<string>;
    };
    namedNode: (<Iri extends string = string>(iri: Iri, opts?: {
        validationStatus?: Terms.ValidationStatus | undefined;
    } | undefined) => Terms.NamedNode<Iri>) & import("lodash").MemoizedFunction;
    blankNode: (name?: string | undefined) => Terms.BlankNode;
    defaultGraph: () => Terms.DefaultGraph;
    quad: (subject: Terms.BlankNode | Terms.NamedNode<string>, predicate: Terms.NamedNode<string>, object: Terms.BlankNode | Terms.NamedNode<string> | Terms.Literal<string>, graph?: Terms.NamedNode<string> | Terms.DefaultGraph | undefined) => Terms.Quad<{
        subject: Terms.BlankNode | Terms.NamedNode<string>;
        predicate: Terms.NamedNode<string>;
        object: Terms.BlankNode | Terms.NamedNode<string> | Terms.Literal<string>;
        graph: Terms.NamedNode<string> | Terms.DefaultGraph;
    }>;
    variable: (name: string) => Terms.Variable;
};
export declare const dataFactoryWithRewriteOfInvalidLiterals: {
    fromTerm: <T extends import("rdf-js").Term>(term: T, opts?: {
        validationStatus?: Terms.ValidationStatus | undefined;
    } | undefined) => Terms.TermTypeToTerm[T["termType"]];
    fromQuad: (term: import("rdf-js").Quad) => Terms.Quad<{
        subject: Terms.BlankNode | Terms.NamedNode<string>;
        predicate: Terms.NamedNode<string>;
        object: Terms.BlankNode | Terms.NamedNode<string> | Terms.Literal<string>;
        graph: Terms.NamedNode<string> | Terms.DefaultGraph;
    }>;
    resetBnodeCounter: () => void;
    prefixer: <Prefix extends string>(base: Prefix | Terms.NamedNode<Prefix>) => <Suffix extends string>(local: Suffix) => Terms.NamedNode<`${Prefix}${Suffix}`>;
    isValidSubject: (term: Terms.Term) => term is Terms.BlankNode | Terms.NamedNode<string>;
    isValidPredicate: (term: Terms.Term) => term is Terms.NamedNode<string>;
    isValidObject: (term: Terms.Term) => term is Terms.BlankNode | Terms.NamedNode<string> | Terms.Literal<string>;
    isValidGraph: (term: Terms.Term) => term is Terms.NamedNode<string> | Terms.DefaultGraph;
    literal: {
        (value: string, languageOrDataType?: string | import("rdf-js").NamedNode<string> | undefined, opts?: {
            validationStatus?: Terms.ValidationStatus | undefined;
        } | undefined): Terms.Literal<string>;
        (value: number | boolean, languageTagOrDatatype: string | import("rdf-js").NamedNode<string>, opts?: {
            validationStatus?: Terms.ValidationStatus | undefined;
        } | undefined): Terms.Literal<string>;
    };
    namedNode: (<Iri extends string = string>(iri: Iri, opts?: {
        validationStatus?: Terms.ValidationStatus | undefined;
    } | undefined) => Terms.NamedNode<Iri>) & import("lodash").MemoizedFunction;
    blankNode: (name?: string | undefined) => Terms.BlankNode;
    defaultGraph: () => Terms.DefaultGraph;
    quad: (subject: Terms.BlankNode | Terms.NamedNode<string>, predicate: Terms.NamedNode<string>, object: Terms.BlankNode | Terms.NamedNode<string> | Terms.Literal<string>, graph?: Terms.NamedNode<string> | Terms.DefaultGraph | undefined) => Terms.Quad<{
        subject: Terms.BlankNode | Terms.NamedNode<string>;
        predicate: Terms.NamedNode<string>;
        object: Terms.BlankNode | Terms.NamedNode<string> | Terms.Literal<string>;
        graph: Terms.NamedNode<string> | Terms.DefaultGraph;
    }>;
    variable: (name: string) => Terms.Variable;
};
export type Bindings<BindingValue> = {
    [variable: string]: BindingValue | undefined;
};
export type MatchPattern = [Id | undefined, Id | undefined, Id | undefined];
export interface RdfDataset {
    defaultGraph: GraphName[];
    namedGraphs: GraphName[];
}
export declare const DEFAULT_BASE_IRI = "https://www.triplydb.com/";
type NameToType = typeof DATA_TYPE_NAME_MAPPING;
export declare const DATA_TYPES: {
    [Name in keyof NameToType]: Terms.NamedNode<NameToType[Name]>;
};
export type NumericDataType = Terms.NamedNode<NumericDataTypeIri>;
export declare function isNaN(term: Terms.Term): boolean;
export declare const sh: <Suffix extends string>(local: Suffix) => Terms.NamedNode<`http://www.w3.org/ns/shacl#${Suffix}`>;
export declare const geof: <Suffix extends string>(local: Suffix) => Terms.NamedNode<`http://www.opengis.net/def/function/geosparql/${Suffix}`>;
export declare const triplyFunctions: <Suffix extends string>(local: Suffix) => Terms.NamedNode<`https://triplydb.com/Triply/function/${Suffix}`>;
export declare const GEO_FUNCTIONS: {
    readonly PROJECT: Terms.NamedNode<"https://triplydb.com/Triply/function/project">;
    readonly TRANSFORM: Terms.NamedNode<"http://www.opengis.net/def/function/geosparql/transform">;
    readonly AREA: Terms.NamedNode<"http://www.opengis.net/def/function/geosparql/area">;
    readonly METRIC_AREA: Terms.NamedNode<"http://www.opengis.net/def/function/geosparql/metricArea">;
};
export {};
//# sourceMappingURL=constants.d.ts.map