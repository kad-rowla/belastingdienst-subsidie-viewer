import { stringify } from "@triply/utils/sparqlVarUtils.js";
import fetch, { FetchError } from "node-fetch";
import { mapValues } from "lodash-es";
import { factory } from "@triplydb/data-factory";
import { FederationError } from "./Errors.js";
function isNotValidUrl(url) {
    if (!url || url.trim() === "")
        true;
    url = url.trim();
    const urlRegex = /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:[/?#]\S*)?$/i;
    return !urlRegex.test(url);
}
export async function* sendSparqlSelectRequest(opts) {
    const parsedJson = parseJson(await fetchResponseText(opts), opts.endpoint);
    for (const binding of parsedJson.results.bindings) {
        try {
            yield mapValues(binding, (term) => (term ? sparqlJsonToBindings(term) : undefined));
        }
        catch (e) {
            const error = e;
            throw new FederationError(`Failed to transform to bindings from endpoint ${opts.endpoint} (${error.name}, ${error.message})`);
        }
    }
}
function parseJson(receivedResponseText, endpoint) {
    let parsedJson;
    try {
        parsedJson = JSON.parse(receivedResponseText);
    }
    catch (e) {
        const error = e;
        throw new FederationError(`Failed to parse response from ${endpoint} as JSON (${error.name}, ${error.message})`);
    }
    if (!("results" in parsedJson) || !("bindings" in parsedJson.results)) {
        throw new FederationError(`Failed to parse response from ${endpoint} as SPARQL JSON.`);
    }
    return parsedJson;
}
function sparqlJsonToBindings(term) {
    switch (term.type) {
        case "uri":
            return factory.namedNode(term.value);
        case "bnode":
            return factory.blankNode(term.value);
        case "literal":
        case "typed-literal":
            let datatypeOrLangString;
            if ("xml:lang" in term) {
                datatypeOrLangString = term["xml:lang"];
            }
            else if ("datatype" in term) {
                datatypeOrLangString = factory.namedNode(term.datatype);
            }
            return factory.literal(term.value, datatypeOrLangString);
    }
    throw new Error(`Invalid term type.${term}`);
}
async function fetchResponseText(opts) {
    if (isNotValidUrl(opts.endpoint)) {
        throw new FederationError(`Invalid endpoint provided (${opts.endpoint})`);
    }
    const requestHeaders = {
        "content-type": "application/x-www-form-urlencoded",
        accept: "application/sparql-results+json; charset=UTF-8",
    };
    let response;
    try {
        response = await fetch(opts.endpoint, {
            method: "POST",
            headers: requestHeaders,
            body: new URLSearchParams({ query: stringify(opts.query) }),
        });
    }
    catch (e) {
        if (e instanceof FetchError) {
            throw new FederationError(`Failed to query ${opts.endpoint} (${e.code}, ${e.errno}, ${e.name}, ${e.message})`);
        }
        else {
            const error = e;
            throw new FederationError(`Failed to query ${opts.endpoint} (${error.name}, ${error.message})`);
        }
    }
    if (response.status >= 300) {
        let message = `Unsuccessful query operation with status code ` + response.status + ` (endpoint:${opts.endpoint}).`;
        try {
            const responseText = await response.text();
            if (responseText) {
                message += `\n\nResponse body: ${responseText.length > 10000 ? responseText.slice(0, 10000) + "..." : responseText}`;
            }
        }
        catch (e) {
        }
        throw new FederationError(message);
    }
    return response.text();
}
//# sourceMappingURL=SelectQueryRequests.js.map