import { forEach } from "lodash-es";
import { default as SparqlJs } from "sparqljs";
import { IDENTITY, NOTHING } from "../Operation.js";
import { forEachAlgebraNode } from "../../Helpers.js";
import { dataFactory } from "../../constants.js";
import { v4 as randomUUID } from "uuid";
import { scopeVariables } from "./variableScope.js";
import { FatalError, UnsupportedError } from "../../Errors.js";
export function fixSparqlJsValues(values, removeUndefined) {
    return values.map((bindings) => {
        const values = {};
        forEach(bindings, (value, name) => {
            if (removeUndefined === "keep undefined" || value) {
                if (["?", "$"].includes(name.charAt(0))) {
                    name = name.slice(1);
                }
                values[name] = value;
            }
        });
        return values;
    });
}
export function isWildCard(element) {
    return element.length === 1 && "termType" in element[0] && element[0].termType === "Wildcard";
}
export function isAggregateQuery(query) {
    return (!!query.group ||
        query.variables.some((variable) => "expression" in variable && isAggregateExpression(variable.expression)) ||
        !!query.having?.some(isAggregateExpression) ||
        !!query.order?.some((variable) => "expression" in variable && isAggregateExpression(variable.expression)));
}
function isAggregateExpression(expression) {
    if (Array.isArray(expression))
        return expression.some(isAggregateExpression);
    if ("termType" in expression)
        return false;
    switch (expression.type) {
        case "aggregate":
            return true;
        case "operation":
        case "functionCall":
            return expression.args.some(isAggregateExpression);
        case "graph":
        case "group":
        case "minus":
        case "service":
        case "union":
        case "optional":
        case "query":
        case "bgp":
        case "bind":
        case "values":
        case "filter":
            return false;
    }
}
export function setIdsInPlace(operation) {
    forEachAlgebraNode(operation, (operation, data) => {
        if (operation === IDENTITY || operation === NOTHING)
            return {};
        if (data.parentId === undefined) {
            operation.id = "";
        }
        else if (data.parentId === "") {
            operation.id = `${data.siblingCount++}`;
        }
        else {
            operation.id = data.parentId + "." + data.siblingCount++;
        }
        return { parentId: operation.id, siblingCount: 0 };
    }, (_expression, data) => {
        let id;
        if (data.parentId === undefined) {
            id = "";
        }
        else if (data.parentId === "") {
            id = `${data.siblingCount++}`;
        }
        else {
            id = data.parentId + "." + data.siblingCount++;
        }
        return { parentId: id, siblingCount: 0 };
    }, { parentId: undefined, siblingCount: 0 });
}
const EMPTY_CONSTRUCT = {
    type: "query",
    queryType: "CONSTRUCT",
    where: [],
    prefixes: {},
};
function hasOnlyIrisNotVariableTerm(element) {
    if (element.some((element) => element.termType === "Variable"))
        return false;
    return true;
}
export function rewriteDescribeQuery(describeQuery) {
    if (isWildCard(describeQuery.variables)) {
        describeQuery = scopeVariables(describeQuery);
    }
    if (isWildCard(describeQuery.variables))
        throw new FatalError("Scope didn't work. This is a bug.");
    const triples = describeQuery.variables.map((variable) => {
        return {
            subject: variable.termType === "Variable" ? dataFactory.variable(variable.value) : variable,
            predicate: dataFactory.variable(randomUUID()),
            object: dataFactory.variable(randomUUID()),
        };
    });
    if ("where" in describeQuery) {
        if (describeQuery.where.length > 1 || !(describeQuery.where[0].type === "bgp"))
            return EMPTY_CONSTRUCT;
        return {
            queryType: "CONSTRUCT",
            template: triples,
            where: [
                {
                    type: "group",
                    patterns: [
                        {
                            type: "query",
                            queryType: "SELECT",
                            variables: [new SparqlJs.Wildcard()],
                            prefixes: describeQuery.prefixes,
                            where: [
                                {
                                    type: "bgp",
                                    triples: describeQuery.where[0].triples,
                                },
                            ],
                        },
                    ],
                },
                {
                    type: "union",
                    patterns: triples.map((triple) => {
                        return {
                            type: "bgp",
                            triples: [triple],
                        };
                    }),
                },
            ],
            type: describeQuery.type,
            base: describeQuery.base,
            prefixes: describeQuery.prefixes,
        };
    }
    else {
        if (!hasOnlyIrisNotVariableTerm(describeQuery.variables))
            throw new UnsupportedError(`We don't support DESCRIBE queries including projected variables and without a WHERE clause, for example 'DESCRIBE ?s'. `);
        return {
            queryType: "CONSTRUCT",
            template: triples,
            where: [
                {
                    type: "values",
                    values: describeQuery.variables.map((variable) => {
                        return { [triples[0].subject.value]: variable };
                    }),
                },
                { type: "bgp", triples: triples },
            ],
            type: describeQuery.type,
            base: describeQuery.base,
            prefixes: describeQuery.prefixes,
        };
    }
}
//# sourceMappingURL=translationUtils.js.map