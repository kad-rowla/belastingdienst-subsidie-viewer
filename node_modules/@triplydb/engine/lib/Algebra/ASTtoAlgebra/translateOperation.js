import { default as SparqlJs } from "sparqljs";
import { IDENTITY, NOTHING } from "../Operation.js";
import { createJoin, createUnion } from "./creation.js";
import { compact } from "lodash-es";
import { translateExpression } from "./translateExpression.js";
import { translateSelectQuery } from "./translateQuery.js";
import { v4 as randomUUID } from "uuid";
import { FatalError, SparqlError, UnsupportedError } from "../../Errors.js";
import { getVariablesMatchedByOperation } from "../Optimization/optimization-utils.js";
import { fixSparqlJsValues } from "./translationUtils.js";
import { forEachAlgebraNode } from "../../Helpers.js";
export const UUID_REGEX = /^[a-f0-9]+-[a-f0-9]+-[a-f0-9]+-[a-f0-9]+-[a-f0-9]+$/;
export function translateSparqljsPatterns(patterns, info) {
    if (!patterns.length)
        return IDENTITY;
    const filterPatterns = [];
    const operation = patterns.reduce((operation, pattern) => {
        if (pattern.type === "filter") {
            filterPatterns.push(pattern);
            return operation;
        }
        else {
            return translateSparqljsPattern(pattern, operation, info);
        }
    }, IDENTITY);
    return filterPatterns.reduce((operation, pattern) => {
        return translateSparqljsPattern(pattern, operation, info);
    }, operation);
}
export function translateSparqljsPattern(pattern, inputOperation, info) {
    if (inputOperation === NOTHING)
        return NOTHING;
    switch (pattern.type) {
        case "bind":
            return {
                operationType: "Extend",
                variable: pattern.variable.value,
                expression: translateExpression(pattern.expression, info),
                inputOperation,
            };
        case "filter":
            return {
                operationType: "Filter",
                expression: translateExpression(pattern.expression, info),
                inputOperation,
            };
        case "minus": {
            const innerOperation = translateSparqljsPatterns(pattern.patterns, info);
            const outerOperation = inputOperation;
            const outerVariables = new Set(getVariablesMatchedByOperation(outerOperation));
            for (const innerVariable of getVariablesMatchedByOperation(innerOperation)) {
                if (outerVariables.has(innerVariable)) {
                    return {
                        operationType: "Minus",
                        inputOperations: [outerOperation, innerOperation],
                    };
                }
            }
            return outerOperation;
        }
        case "bgp": {
            return createJoin([inputOperation, ...pattern.triples.map(translateTriplePattern)]);
        }
        case "graph": {
            const operations = [inputOperation];
            let graphFromAST;
            if (pattern.name.termType === "Variable") {
                operations.push({
                    operationType: "InlineData",
                    values: info.namedGraphs.map((graphName) => ({ [pattern.name.value]: graphName })),
                });
                graphFromAST = pattern.name.value;
            }
            else if (!info.namedGraphs.some((g) => g.equals(pattern.name))) {
                return NOTHING;
            }
            else {
                graphFromAST = [pattern.name];
            }
            const insidePatterns = translateSparqljsPatterns(pattern.patterns, info);
            operations.push(insidePatterns);
            forEachAlgebraNode(insidePatterns, (operation) => {
                if (operation.operationType === "TriplePattern" || operation.operationType === "EnsureBound") {
                    if (operation.graphs)
                        return;
                    operation.graphs = graphFromAST;
                }
            }, () => { }, undefined);
            return createJoin(operations);
        }
        case "optional":
            const optionalPart = translateSparqljsPatterns(pattern.patterns, info);
            if (optionalPart === NOTHING || optionalPart === IDENTITY)
                return inputOperation;
            return {
                operationType: "LeftJoin",
                inputOperations: [inputOperation, optionalPart],
            };
        case "service":
            const ASTquery = {
                type: "query",
                queryType: "SELECT",
                variables: [new SparqlJs.Wildcard()],
                where: pattern.patterns,
                prefixes: {},
            };
            return createJoin([
                inputOperation,
                {
                    operationType: "Service",
                    runTimeInformation: {
                        query: ASTquery,
                        endpoint: pattern.name.termType === "Variable" ? pattern.name.value : pattern.name,
                    },
                    silent: pattern.silent,
                },
            ]);
        case "union":
            return createJoin([
                inputOperation,
                createUnion(pattern.patterns.map((p) => translateSparqljsPattern(p, IDENTITY, info))),
            ]);
        case "values":
            return translateInlineData(pattern.values, inputOperation);
        case "group":
            return createJoin([inputOperation, translateSparqljsPatterns(pattern.patterns, info)]);
        case "query":
            if (inputOperation !== IDENTITY)
                throw new FatalError("Expected 'query' to always be alone inside its 'group'. Please contact a developer.");
            return translateSelectQuery(pattern, info, "loadResultsInMemoryForLimit");
    }
}
function getOnlyPathItem(pathName, pathItems) {
    if (pathItems.length != 1) {
        const errorMessage = `${pathName} property paths is unary, but more than one argument was given.`;
        throw new SparqlError(errorMessage);
    }
    return pathItems[0];
}
export function translatePropertyPath(start, term, end) {
    if ("termType" in term) {
        if (typeof start === "object" && start.termType === "Literal")
            return NOTHING;
        return {
            operationType: "TriplePattern",
            pattern: [start, term, end],
        };
    }
    const freshVariable = randomUUID();
    switch (term.pathType) {
        case "^":
            return translatePropertyPath(end, getOnlyPathItem("Inverse", term.items), start);
        case "/":
            const paths = term.items;
            const joins = [];
            const lastIndex = paths.length - 1;
            let lastFreshVariable = freshVariable;
            for (const [i, propertyPath] of paths.entries()) {
                const newFreshVariable = randomUUID();
                joins.push([i === 0 ? start : lastFreshVariable, propertyPath, i === lastIndex ? end : newFreshVariable]);
                lastFreshVariable = newFreshVariable;
            }
            return createJoin(joins.map((pattern) => translatePropertyPath(...pattern)));
        case "|":
            return createUnion(term.items.map((item) => translatePropertyPath(start, item, end)));
        case "*":
            if (typeof start === "string" && typeof end === "string") {
                return {
                    operationType: "Join",
                    inputOperations: [
                        { operationType: "EnsureBound", variable: start },
                        {
                            operationType: "ZeroOrMorePath",
                            inputOperation: translatePropertyPath(start, getOnlyPathItem("Zero or more", term.items), end),
                            boundStart: start,
                            end,
                        },
                    ],
                };
            }
            else if (typeof start === "string" && typeof end !== "string") {
                return translatePropertyPath(end, { ...term, items: [{ type: "path", pathType: "^", items: term.items }] }, start);
            }
            else if (typeof start !== "string" && typeof end === "string") {
                return createJoin([
                    {
                        operationType: "Extend",
                        inputOperation: IDENTITY,
                        variable: freshVariable,
                        expression: { expressionType: "Term", term: start },
                    },
                    {
                        operationType: "ZeroOrMorePath",
                        inputOperation: translatePropertyPath(freshVariable, getOnlyPathItem("Zero or more", term.items), end),
                        boundStart: freshVariable,
                        end: end,
                    },
                ]);
            }
            else if (typeof start !== "string" && typeof end !== "string") {
                return createJoin([
                    {
                        operationType: "Extend",
                        inputOperation: IDENTITY,
                        variable: freshVariable,
                        expression: { expressionType: "Term", term: end },
                    },
                    translatePropertyPath(start, term, freshVariable),
                ]);
            }
        case "+":
            return {
                operationType: "Distinct",
                variables: compact([typeof start === "string" ? start : undefined, typeof end === "string" ? end : undefined]),
                inputOperation: createJoin([
                    translatePropertyPath(start, getOnlyPathItem("One or more", term.items), freshVariable),
                    translatePropertyPath(freshVariable, { ...term, pathType: "*" }, end),
                ]),
            };
        case "?":
            if (typeof start === "object" && typeof end === "object") {
                if (start.equals(end)) {
                    return IDENTITY;
                }
                else {
                    return {
                        operationType: "Distinct",
                        variables: [],
                        inputOperation: translatePropertyPath(start, getOnlyPathItem("Zero or one", term.items), end),
                    };
                }
            }
            else if (typeof start === "object" && typeof end === "string") {
                return {
                    operationType: "Distinct",
                    variables: compact([
                        typeof start === "string" ? start : undefined,
                        typeof end === "string" ? end : undefined,
                    ]),
                    inputOperation: createUnion([
                        {
                            operationType: "Extend",
                            inputOperation: IDENTITY,
                            variable: end,
                            expression: { expressionType: "Term", term: start },
                        },
                        translatePropertyPath(start, getOnlyPathItem("Zero or one", term.items), end),
                    ]),
                };
            }
            else if (typeof start === "string" && typeof end === "object") {
                return translatePropertyPath(end, { ...term, items: [{ type: "path", pathType: "^", items: term.items }] }, start);
            }
            else if (typeof start === "string" && typeof end === "string") {
                return createJoin([
                    { operationType: "EnsureBound", variable: start },
                    {
                        operationType: "Distinct",
                        variables: compact([
                            typeof start === "string" ? start : undefined,
                            typeof end === "string" ? end : undefined,
                        ]),
                        inputOperation: createUnion([
                            {
                                operationType: "Extend",
                                inputOperation: IDENTITY,
                                variable: end,
                                expression: { expressionType: "Variable", variable: start },
                            },
                            translatePropertyPath(start, getOnlyPathItem("Zero or one", term.items), end),
                        ]),
                    },
                ]);
            }
        case "!":
            const initStart = start, initEnd = end;
            const operationPropertyPath = translatePropertyPath(start, getOnlyPathItem("Negated", term.items), end);
            let appendOperations;
            if (operationPropertyPath.operationType === "TriplePattern") {
                appendOperations = [operationPropertyPath];
            }
            else if (operationPropertyPath.operationType === "Union") {
                appendOperations = operationPropertyPath.inputOperations;
            }
            else {
                throw Error(`This operation should not be any other than Union or TriplePattern. Contact a developer.`);
            }
            const operationRegular = [], operationReversed = [];
            for (let appendOperation of appendOperations) {
                if (appendOperation.operationType !== "TriplePattern") {
                    throw Error(`This operation should not be any other than TriplePattern. Contact a developer`);
                }
                if (appendOperation.pattern[0] === initStart && appendOperation.pattern[2] === initEnd) {
                    operationRegular.push(appendOperation);
                }
                else {
                    operationReversed.push(appendOperation);
                }
            }
            if (operationReversed.length > 0 && operationRegular.length > 0) {
                return createUnion([
                    translateNegatedPathUsingFilter(start, freshVariable, end, operationRegular),
                    translateNegatedPathUsingFilter(end, freshVariable, start, operationReversed),
                ]);
            }
            else if (operationReversed.length > 0 && operationRegular.length === 0) {
                return translateNegatedPathUsingFilter(end, freshVariable, start, operationReversed);
            }
            return translateNegatedPathUsingFilter(start, freshVariable, end, operationRegular);
    }
}
function translateNegatedPathUsingFilter(start, term, end, insideOperations) {
    if (typeof start === "object" && start.termType === "Literal")
        return NOTHING;
    return {
        operationType: "Filter",
        expression: {
            expressionType: "FunctionCall",
            function: "!",
            expressions: [
                {
                    expressionType: "Exists",
                    operation: createUnion(insideOperations),
                },
            ],
        },
        inputOperation: {
            operationType: "TriplePattern",
            pattern: [start, term, end],
        },
    };
}
function translateTerm(term) {
    if (term.termType === "Variable")
        return term.value;
    if (term.termType === "BlankNode")
        return term.id;
    if (term.termType === "Quad") {
        throw new UnsupportedError(`SPARQL* is not supported.`);
    }
    return term;
}
export function translateTriplePattern(triple) {
    const subject = translateTerm(triple.subject);
    const object = translateTerm(triple.object);
    if ("termType" in triple.predicate) {
        const predicate = triple.predicate.termType === "Variable" ? triple.predicate.value : triple.predicate;
        return {
            operationType: "TriplePattern",
            pattern: [subject, predicate, object],
        };
    }
    else {
        return translatePropertyPath(subject, triple.predicate, object);
    }
}
export function translateInlineData(values, inputOperation) {
    values = fixSparqlJsValues(values, "remove undefined");
    return createJoin([inputOperation, { operationType: "InlineData", values }]);
}
//# sourceMappingURL=translateOperation.js.map