import { FatalError, SparqlError } from "../../Errors.js";
import { translateSelectQuery } from "./translateQuery.js";
import { setIdsInPlace } from "./translationUtils.js";
export function operationFromScopedAst(ast, info, dontSetIds) {
    if (!("variables" in ast))
        throw new FatalError("Variable scoping should have introduced a `.variables` property to all queries.");
    const operation = translateSelectQuery(ast, info);
    if (!dontSetIds)
        setIdsInPlace(operation);
    return operation;
}
export function templatesFromAst(template) {
    if (!template)
        return [];
    return template.map((triple) => {
        let subject;
        if (triple.subject.termType === "Variable") {
            subject = triple.subject.value;
        }
        else if (triple.subject.termType === "Quad") {
            throw new SparqlError("Quads cannot be in subject position of CONSTRUCT template.");
        }
        else {
            subject = triple.subject;
        }
        let predicate;
        if ("type" in triple.predicate) {
            throw new SparqlError("Property paths cannot be in predicate position of CONSTRUCT template.");
        }
        else if ("termType" in triple.predicate && triple.predicate.termType === "Variable") {
            predicate = triple.predicate.value;
        }
        else {
            predicate = triple.predicate;
        }
        let object;
        if (triple.object.termType === "Variable") {
            object = triple.object.value;
        }
        else if (triple.object.termType === "Quad") {
            throw new SparqlError("Quads cannot be in object position of CONSTRUCT template.");
        }
        else {
            object = triple.object;
        }
        return { subject, predicate, object };
    });
}
//# sourceMappingURL=index.js.map