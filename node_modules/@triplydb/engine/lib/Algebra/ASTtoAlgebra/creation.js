import { IDENTITY, NOTHING } from "../Operation.js";
import { flatten, fromPairs, zip } from "lodash-es";
import { XPATH_FUNCTIONS } from "@triplydb/recognized-datatypes/utils/constants.js";
import { BINARY_FUNCTION_NAMES, NIL_FUNCTION_NAMES, UNARY_FUNCTION_NAMES, } from "../Expression.js";
import { SparqlError } from "../../Errors.js";
import { UUID_REGEX } from "./translateOperation.js";
import { v4 as randomUuid } from "uuid";
import mapKeysDeep from "deepdash/mapKeysDeep";
import mapValuesDeep from "deepdash/mapValuesDeep";
import { GEO_FUNCTIONS } from "../../constants.js";
export function createJoin(operations) {
    const flattenedOperations = operations.flatMap((operation) => {
        return operation.operationType === "Join" ? operation.inputOperations : [operation];
    });
    if (flattenedOperations.length === 0)
        return IDENTITY;
    if (flattenedOperations.length === 1)
        return flattenedOperations[0];
    if (flattenedOperations.includes(NOTHING))
        return NOTHING;
    return {
        operationType: "Join",
        inputOperations: flattenedOperations,
    };
}
export function createUnion(operations) {
    const flattenedOperations = flatten(operations.map((operation) => (operation.operationType === "Union" ? operation.inputOperations : [operation])));
    if (flattenedOperations.length === 0)
        return NOTHING;
    if (flattenedOperations.length === 1)
        return flattenedOperations[0];
    return {
        operationType: "Union",
        inputOperations: flattenedOperations,
    };
}
export function makeNameTranslation(names) {
    return fromPairs(names.map((name) => [name.startsWith("http://") || name.startsWith("https://") ? name : name.toLowerCase(), name]));
}
const POSSIBLY_NIL_FUNCTION_NAME_TRANSLATION = makeNameTranslation([...NIL_FUNCTION_NAMES, "BNODE"]);
POSSIBLY_NIL_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.CURRENT_DATE_TIME] = "NOW";
const UNARY_FUNCTION_NAME_TRANSLATION = makeNameTranslation(UNARY_FUNCTION_NAMES);
UNARY_FUNCTION_NAME_TRANSLATION["isuri"] = "isIRI";
UNARY_FUNCTION_NAME_TRANSLATION["uri"] = "IRI";
UNARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.STRING] = "STR";
UNARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.STRING_LENGTH] = "STRLEN";
UNARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.UPPER_CASE] = "UCASE";
UNARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.LOWER_CASE] = "LCASE";
UNARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.ABS] = "ABS";
UNARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.CEILING] = "CEIL";
UNARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.FLOOR] = "FLOOR";
UNARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.ROUND] = "ROUND";
UNARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.NOT] = "!";
const POSSIBLY_BINARY_FUNCTION_NAME_TRANSLATION = makeNameTranslation([
    "+",
    "-",
    GEO_FUNCTIONS.TRANSFORM.value,
    ...BINARY_FUNCTION_NAMES,
    "SUBSTR",
    "REGEX",
]);
POSSIBLY_BINARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.SUBSTRING] = "SUBSTR";
POSSIBLY_BINARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.SUBSTRING_BEFORE] = "STRBEFORE";
POSSIBLY_BINARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.SUBSTRING_AFTER] = "STRAFTER";
POSSIBLY_BINARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.STARTS_WITH] = "STRSTARTS";
POSSIBLY_BINARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.ENDS_WITH] = "STRENDS";
POSSIBLY_BINARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.CONTAINS] = "CONTAINS";
POSSIBLY_BINARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.MATCHES] = "REGEX";
const POSSIBLY_TERNARY_FUNCTION_NAME_TRANSLATION = makeNameTranslation(["SUBSTR", "REGEX", "IF", "REPLACE"]);
POSSIBLY_TERNARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.SUBSTRING] = "SUBSTR";
POSSIBLY_TERNARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.REPLACE] = "REPLACE";
export function createFunctionCall(functionName, args) {
    if (functionName === "coalesce" || functionName === "concat")
        return {
            expressionType: "FunctionCall",
            function: functionName.toUpperCase(),
            expressions: args,
        };
    if (functionName === XPATH_FUNCTIONS.CONCAT) {
        if (args.length < 2)
            throw new SparqlError("Syntax error: CONCAT accepts two or more arguments. Got " + args.length);
        return {
            expressionType: "FunctionCall",
            function: "CONCAT",
            expressions: args,
        };
    }
    switch (args.length) {
        case 0: {
            const translation = POSSIBLY_NIL_FUNCTION_NAME_TRANSLATION[functionName];
            if (!translation)
                break;
            return { expressionType: "FunctionCall", function: translation, expressions: args };
        }
        case 1: {
            if (functionName === "bnode")
                return { expressionType: "FunctionCall", function: "BNODE", expressions: args };
            if (functionName === "+")
                return { expressionType: "FunctionCall", function: "+", expressions: args };
            if (functionName === "-")
                return { expressionType: "FunctionCall", function: "-", expressions: args };
            if (functionName === GEO_FUNCTIONS.TRANSFORM.value)
                return {
                    expressionType: "FunctionCall",
                    function: functionName,
                    expressions: args,
                };
            const translation = UNARY_FUNCTION_NAME_TRANSLATION[functionName];
            if (!translation)
                break;
            return { expressionType: "FunctionCall", function: translation, expressions: args };
        }
        case 2: {
            if (functionName === "!=")
                return {
                    expressionType: "FunctionCall",
                    function: "!",
                    expressions: [
                        {
                            expressionType: "FunctionCall",
                            function: "=",
                            expressions: args,
                        },
                    ],
                };
            if (functionName === "<=")
                return {
                    expressionType: "FunctionCall",
                    function: "!",
                    expressions: [
                        {
                            expressionType: "FunctionCall",
                            function: "<",
                            expressions: [args[1], args[0]],
                        },
                    ],
                };
            if (functionName === ">=")
                return {
                    expressionType: "FunctionCall",
                    function: "!",
                    expressions: [
                        {
                            expressionType: "FunctionCall",
                            function: "<",
                            expressions: args,
                        },
                    ],
                };
            if (functionName === ">")
                return {
                    expressionType: "FunctionCall",
                    function: "<",
                    expressions: [args[1], args[0]],
                };
            const translation = POSSIBLY_BINARY_FUNCTION_NAME_TRANSLATION[functionName];
            if (!translation)
                break;
            return {
                expressionType: "FunctionCall",
                function: translation,
                expressions: args,
            };
        }
        case 3: {
            const translation = POSSIBLY_TERNARY_FUNCTION_NAME_TRANSLATION[functionName];
            if (!translation)
                break;
            return {
                expressionType: "FunctionCall",
                function: translation,
                expressions: args,
            };
        }
        case 4: {
            if (functionName === "replace" || functionName === XPATH_FUNCTIONS.REPLACE)
                return {
                    expressionType: "FunctionCall",
                    function: "REPLACE",
                    expressions: args,
                };
        }
    }
}
export function createOperationExpression(dataDefinedFunctionInfo, args) {
    let operation = IDENTITY;
    const variableTranslation = {};
    for (const [variableTerm, expression] of zip(dataDefinedFunctionInfo.parameters, args)) {
        if (variableTerm === undefined)
            return;
        if (expression === undefined)
            if (variableTerm.optional)
                continue;
            else
                return;
        const variable = randomUuid();
        variableTranslation[variableTerm.name] = variable;
        operation = { operationType: "Extend", variable, expression, inputOperation: operation };
    }
    operation = createJoin([
        operation,
        rerandomizeVariables(dataDefinedFunctionInfo.implementation, variableTranslation),
    ]);
    if (!dataDefinedFunctionInfo.resultVariable)
        return {
            expressionType: "Exists",
            operation,
        };
    return {
        expressionType: "Operation",
        operation: operation,
        resultVariable: variableTranslation[dataDefinedFunctionInfo.resultVariable],
    };
}
function rerandomizeVariables(object, randomVariables) {
    function derandomize(variable) {
        if (typeof variable === "string" && UUID_REGEX.test(variable)) {
            if (!(variable in randomVariables))
                randomVariables[variable] = randomUuid();
            variable = randomVariables[variable];
        }
        return variable;
    }
    object = mapKeysDeep(object, (_value, key) => {
        return derandomize(key);
    });
    object = mapValuesDeep(object, (value) => {
        return derandomize(value);
    });
    return object;
}
//# sourceMappingURL=creation.js.map