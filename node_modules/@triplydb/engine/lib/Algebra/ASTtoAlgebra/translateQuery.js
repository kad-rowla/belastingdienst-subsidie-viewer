import { NOTHING } from "../Operation.js";
import log from "../../Debugging.js";
import { v4 as randomUUID } from "uuid";
import { addAggregateExpression } from "./aggregation.js";
import { translateExpression } from "./translateExpression.js";
import { translateInlineData, translateSparqljsPatterns } from "./translateOperation.js";
import { compact } from "lodash-es";
import { FatalError, SparqlError } from "../../Errors.js";
import { isAggregateQuery, isWildCard } from "./translationUtils.js";
export function translateSelectQuery(query, info, loadResultsInMemoryForLimit) {
    if (query.limit === 0) {
        log("sparql:translate", "Found LIMIT 0, thus resulting algebra is NOTHING");
        return NOTHING;
    }
    if (isWildCard(query.variables))
        throw new FatalError("We were promised no wildcards. This is a bug.");
    query.where = query.where ?? [];
    let operation = translateSparqljsPatterns(query.where, info);
    const isAggregate = isAggregateQuery(query);
    if (isAggregate) {
        query.group = query.group ?? [];
        for (const { variable, expression } of query.group) {
            if (!variable)
                continue;
            operation = {
                operationType: "Extend",
                variable: variable.value,
                expression: translateExpression(expression, info),
                inputOperation: operation,
            };
        }
        const aggregate = (operation = {
            operationType: "Aggregate",
            groupingExpressions: query.group.map(({ variable, expression }) => variable ? { expressionType: "Variable", variable: variable.value } : translateExpression(expression, info)),
            aggregatingExpressions: {},
            inputOperation: operation,
        });
        const aggregatedVariables = new Set(compact(aggregate.groupingExpressions.map((e) => (e.expressionType === "Variable" ? e.variable : undefined))));
        for (const variable of aggregatedVariables) {
            aggregate.aggregatingExpressions[variable] = {
                expressionType: "AggregateFunction",
                function: "SAMPLE",
                expression: { expressionType: "Variable", variable },
                distinct: false,
            };
        }
        for (const expression of query.variables) {
            let name;
            let expr;
            if ("variable" in expression) {
                name = expression.variable.value;
                expr = expression.expression;
            }
            else {
                name = expression.value;
                expr = expression;
            }
            operation = addAggregateExpression(name, expr, aggregate, operation, aggregatedVariables, info);
            aggregatedVariables.add(name);
        }
        if (query.having) {
            const emptySet = new Set();
            for (const having of query.having) {
                const variable = randomUUID();
                operation = addAggregateExpression(variable, having, aggregate, operation, emptySet, info);
                operation = {
                    operationType: "Filter",
                    expression: { expressionType: "Variable", variable },
                    inputOperation: operation,
                };
            }
        }
        if (query.order) {
            const ordering = [];
            for (const { expression, descending } of query.order) {
                const variable = randomUUID();
                ordering.push({
                    direction: descending ? "descending" : "ascending",
                    expression: { expressionType: "Variable", variable },
                });
                operation = addAggregateExpression(variable, expression, aggregate, operation, aggregatedVariables, info);
            }
            operation = {
                operationType: "OrderBy",
                inputOperation: operation,
                ordering,
            };
        }
    }
    if (query.values) {
        operation = translateInlineData(query.values, operation);
    }
    if (!isAggregate) {
        if (query.having?.length)
            throw new SparqlError("Using the HAVING clause for non-aggregate queries is not supported.");
        for (const exprAsVar of query.variables) {
            if (!("variable" in exprAsVar))
                continue;
            const variable = exprAsVar.variable.value;
            operation = {
                operationType: "Extend",
                variable,
                expression: translateExpression(exprAsVar.expression, info),
                inputOperation: operation,
            };
        }
    }
    if (query.order) {
        operation = {
            operationType: "OrderBy",
            inputOperation: operation,
            ordering: query.order.map(({ descending, expression }) => ({
                direction: descending ? "descending" : "ascending",
                expression: translateExpression(expression, info),
            })),
        };
    }
    if (query.distinct) {
        const projection = query.variables.map((v) => ("variable" in v ? v.variable : v).value);
        operation = { operationType: "Distinct", inputOperation: operation, variables: projection };
    }
    if (query.offset !== undefined || query.limit !== undefined) {
        operation = {
            operationType: "Slice",
            offset: query.offset ?? 0,
            ...(query.limit ? { limit: query.limit } : {}),
            inputOperation: operation,
            loadIntoMemory: !!loadResultsInMemoryForLimit,
        };
    }
    return operation;
}
//# sourceMappingURL=translateQuery.js.map