import { AGGREGATE_FUNCTION_NAMES, } from "../Expression.js";
import { IDENTITY } from "../Operation.js";
import { createFunctionCall, createOperationExpression, makeNameTranslation } from "./creation.js";
import { dataFactory, DATA_TYPES } from "../../constants.js";
import { v4 as randumUuid } from "uuid";
import { translateSparqljsPattern } from "./translateOperation.js";
import { FatalError, SparqlError, UnknownFunctionError, UnsupportedError } from "../../Errors.js";
export function translateExpression(expression, info) {
    return translatePossiblyAggregateExpression(expression, "non-aggregate", new Set(), info).expression;
}
function translatePossiblyAggregateExpressions(expressions, type, aggregatedVariables, info) {
    let aggregates = {};
    const translated = [];
    for (const expression of expressions) {
        const t = translatePossiblyAggregateExpression(expression, type, aggregatedVariables, info);
        aggregates = { ...aggregates, ...t.aggregates };
        translated.push(t.expression);
    }
    return { expressions: translated, aggregates };
}
export function translatePossiblyAggregateExpression(expression, type, aggregatedVariables, info) {
    if ("type" in expression) {
        switch (expression.type) {
            case "graph":
            case "group":
            case "minus":
            case "service":
            case "union":
            case "optional":
            case "query":
            case "bgp":
            case "bind":
            case "values":
            case "filter":
                throw new FatalError(`Encountered a SparqlJs ${expression.type}, which shouldn't happen here.`);
            case "functionCall":
                return translateFunctionCall(expression, type, aggregatedVariables, info);
            case "operation":
                const specialCases = translateSpecialCases(expression, type, aggregatedVariables, info);
                if (specialCases)
                    return specialCases;
                return translateFunctionCall(expression, type, aggregatedVariables, info);
            case "aggregate": {
                if (type !== "aggregate")
                    throw new SparqlError("Cannot have an aggregate expression when requesting a non-aggregate expression.");
                const { expression: translatedExpression, aggregates } = translateAggregateFunction(expression, info);
                return { expression: translatedExpression, aggregates: aggregates };
            }
        }
    }
    else if ("termType" in expression) {
        return translateTerm(expression, type, aggregatedVariables, info);
    }
    else {
        throw new FatalError("Encountered an unexpected SparqlJs.Tuple");
    }
}
function translateTerm(expression, type, aggregatedVariables, info) {
    switch (expression.termType) {
        case "Variable":
            const variableExpression = {
                expressionType: "Variable",
                variable: expression.value,
            };
            return { expression: variableExpression, aggregates: {} };
        default:
            return { expression: { expressionType: "Term", term: expression }, aggregates: {} };
    }
}
function translateInExpression(lhsArg, rhsArgs) {
    if (rhsArgs.length == 0)
        return {
            expressionType: "Term",
            term: dataFactory.literal(false, DATA_TYPES.XSD_BOOLEAN),
        };
    if (rhsArgs.length == 1)
        return {
            expressionType: "FunctionCall",
            function: "=",
            expressions: [lhsArg, rhsArgs[0]],
        };
    return {
        expressionType: "FunctionCall",
        function: "||",
        expressions: [
            {
                expressionType: "FunctionCall",
                function: "=",
                expressions: [lhsArg, rhsArgs[0]],
            },
            translateInExpression(lhsArg, rhsArgs.slice(1)),
        ],
    };
}
function translateSpecialCases(expression, type, aggregatedVariables, info) {
    switch (expression.operator) {
        case "notexists": {
            if (expression.args.length !== 1) {
                throw new SparqlError("Wrong number of arguments for NOT EXISTS: " + JSON.stringify(expression.args));
            }
            return {
                aggregates: {},
                expression: {
                    expressionType: "FunctionCall",
                    function: "!",
                    expressions: [
                        {
                            expressionType: "Exists",
                            operation: translateSparqljsPattern(expression.args[0], IDENTITY, info),
                        },
                    ],
                },
            };
        }
        case "exists": {
            if (expression.args.length !== 1)
                throw new SparqlError("Wrong number of arguments for EXISTS: " + JSON.stringify(expression.args));
            return {
                aggregates: {},
                expression: {
                    expressionType: "Exists",
                    operation: translateSparqljsPattern(expression.args[0], IDENTITY, info),
                },
            };
        }
        case "in": {
            if (expression.args[2] || !Array.isArray(expression.args[1]))
                throw new SparqlError("Bad arguments for IN " + JSON.stringify(expression.args));
            const { expression: leftHandSide, aggregates: lhsAgg } = translatePossiblyAggregateExpression(expression.args[0], type, aggregatedVariables, info);
            const { expressions: rightHandSide, aggregates: rhsAgg } = translatePossiblyAggregateExpressions(expression.args[1], type, aggregatedVariables, info);
            return {
                aggregates: { ...lhsAgg, ...rhsAgg },
                expression: translateInExpression(leftHandSide, rightHandSide),
            };
        }
        case "notin": {
            if (expression.args[2] || !Array.isArray(expression.args[1]))
                throw new SparqlError("Bad arguments for IN " + JSON.stringify(expression.args));
            const { expression: leftHandSide, aggregates: lhsAgg } = translatePossiblyAggregateExpression(expression.args[0], type, aggregatedVariables, info);
            const { expressions: rightHandSide, aggregates: rhsAgg } = translatePossiblyAggregateExpressions(expression.args[1], type, aggregatedVariables, info);
            return {
                aggregates: { ...lhsAgg, ...rhsAgg },
                expression: {
                    expressionType: "FunctionCall",
                    function: "!",
                    expressions: [translateInExpression(leftHandSide, rightHandSide)],
                },
            };
        }
        case "bound":
            const [variableTerm] = expression.args;
            if (expression.args[1] || !(variableTerm && "termType" in variableTerm && variableTerm.termType === "Variable")) {
                throw new FatalError("Bad arguments for BOUND: " + JSON.stringify(expression.args));
            }
            return {
                expression: {
                    expressionType: "Bound",
                    variable: variableTerm.value,
                },
                aggregates: {},
            };
    }
}
const AGGREGATE_FUNCTION_NAME_TRANSLATION = makeNameTranslation(AGGREGATE_FUNCTION_NAMES);
function translateAggregateFunction(sparqljsExpression, info) {
    const translatedName = AGGREGATE_FUNCTION_NAME_TRANSLATION[sparqljsExpression.aggregation];
    if (!translatedName)
        throw new UnsupportedError(`Encountered unsupported aggregate function: ${sparqljsExpression.aggregation}`);
    const variable = randumUuid();
    const distinct = sparqljsExpression.distinct ?? false;
    if ("termType" in sparqljsExpression.expression && sparqljsExpression.expression.termType === "Wildcard") {
        if (translatedName !== "COUNT") {
            throw new SparqlError("COUNT is the only function that accepts a wildcard (*) as argument.");
        }
        if (distinct === true)
            throw new UnsupportedError("COUNT(DISTINCT *) is not supported yet");
        return {
            expression: {
                expressionType: "Variable",
                variable,
            },
            aggregates: {
                [variable]: {
                    expressionType: "AggregateFunction",
                    function: "COUNT",
                    distinct: false,
                    expression: { expressionType: "WildCard" },
                },
            },
        };
    }
    const expression = translateExpression(sparqljsExpression.expression, info);
    return {
        expression: {
            expressionType: "Variable",
            variable,
        },
        aggregates: {
            [variable]: translatedName === "GROUP_CONCAT"
                ? {
                    expressionType: "AggregateFunction",
                    function: "GROUP_CONCAT",
                    distinct,
                    expression,
                    separator: sparqljsExpression.separator ?? " ",
                }
                : {
                    expressionType: "AggregateFunction",
                    function: translatedName,
                    distinct,
                    expression,
                },
        },
    };
}
function translateFunctionCall(expression, type, aggregatedVariables, info) {
    let functionName = "function" in expression ? expression.function : expression.operator;
    if (typeof functionName === "object") {
        functionName = functionName.value;
    }
    else {
        functionName = functionName.toLowerCase();
    }
    const { expressions: args, aggregates } = translatePossiblyAggregateExpressions(expression.args, type, aggregatedVariables, info);
    let functionCall = createFunctionCall(functionName, args);
    if (!functionCall) {
        const dataDefinedFunctionInfo = info.dataDefinedFunctions[functionName];
        if (dataDefinedFunctionInfo) {
            functionCall = createOperationExpression(dataDefinedFunctionInfo, args);
        }
    }
    if (!functionCall)
        throw new UnknownFunctionError(`Unknown function or wrong number of arguments: ${functionName} with ${args.length} arguments`);
    return { expression: functionCall, aggregates };
}
//# sourceMappingURL=translateExpression.js.map