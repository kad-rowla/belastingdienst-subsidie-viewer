import { default as SparqlJs } from "sparqljs";
import { dataFactory } from "../../constants.js";
import { FatalError, SparqlError } from "../../Errors.js";
import { v4 as randomUuid } from "uuid";
import { factory } from "@triplydb/data-factory";
import { cloneDeep, mapKeys } from "lodash-es";
import mapKeysDeep from "deepdash/mapKeysDeep";
import mapValuesDeep from "deepdash/mapValuesDeep";
import { fixSparqlJsValues, isAggregateQuery, isWildCard } from "./translationUtils.js";
import { throwAggregateError } from "../../Helpers.js";
export const UNBOUND_VARIABLE_NAME = "???";
const UNBOUND_VARIABLE = factory.variable(UNBOUND_VARIABLE_NAME);
export function scopeVariables(query, opts) {
    const variables = new Variables(opts);
    query = cloneDeep(query);
    query.variables = query.variables ?? [new SparqlJs.Wildcard()];
    select(variables, query, "keep unbound variables in projection");
    if (!opts?.translateEverything && query.queryType === "SELECT") {
        const translationToBeDone = new Map();
        for (const variable of variables.untranslatedVariablesInScope) {
            const translation = variables.inScopeBoundVariableTranslation.get(variable);
            if (translation && translation.value !== variable) {
                translationToBeDone.set(translation.value, dataFactory.variable(variable));
                translationToBeDone.set(variable, dataFactory.variable(randomUuid()));
            }
        }
        query = translateVariableNames(query, translationToBeDone);
    }
    else if (query.queryType === "CONSTRUCT") {
        for (const triple of query.template ?? []) {
            triple.subject = variables.onTermRead(triple.subject);
            if (!("termType" in triple.predicate)) {
                throw new FatalError("Triple pattern templates cannot contain property paths");
            }
            triple.predicate = variables.onTermRead(triple.predicate);
            triple.object = variables.onTermRead(triple.object);
        }
    }
    return query;
}
export function translateVariableNames(query, translation) {
    query = mapKeysDeep(query, (value, key, _parentValue, context) => {
        if (typeof key !== "string")
            return key;
        const grandParent = context.parents?.slice(-3)[0]?.value;
        if ((value === undefined || (value && typeof value === "object" && "termType" in value)) &&
            grandParent &&
            typeof grandParent === "object" &&
            "type" in grandParent &&
            (grandParent.type === "query" || grandParent.type === "values")) {
            return translation.get(key)?.value ?? key;
        }
        return key;
    });
    query = mapValuesDeep(query, (unknown, _key, _parentValue, context) => {
        if (unknown && typeof unknown === "object" && "termType" in unknown && unknown.termType === "Variable") {
            const variable = unknown;
            context.skipChildren(true);
            return translation.get(variable.value) ?? variable;
        }
        return unknown;
    });
    return query;
}
class Variables {
    dontTouchThis;
    translateEverything;
    inScopeBoundVariableTranslation = new Map();
    ancestorScopeBoundVariableTranslation = new Map();
    translatedVariablesNotInScope = new Set();
    untranslatedVariablesInScope = new Set();
    insideServiceClause;
    constructor(opts) {
        this.dontTouchThis = opts?.dontTouchThis ?? new Set();
        this.translateEverything = !!opts?.translateEverything;
        this.insideServiceClause = !!opts?.insideServiceClause;
    }
    add(other) {
        this.mergeChildScope(other);
        for (const entry of other.ancestorScopeBoundVariableTranslation.entries()) {
            this.ancestorScopeBoundVariableTranslation.set(...entry);
        }
    }
    copy() {
        const copy = new Variables(this);
        copy.add(this);
        return copy;
    }
    addUnrelatedScope(other) {
        for (const name of other.translatedVariablesNotInScope) {
            this.translatedVariablesNotInScope.add(name);
        }
    }
    mergeChildScope(other) {
        for (const entry of other.inScopeBoundVariableTranslation.entries()) {
            this.inScopeBoundVariableTranslation.set(...entry);
        }
        for (const variable of other.untranslatedVariablesInScope) {
            this.untranslatedVariablesInScope.add(variable);
        }
        this.addUnrelatedScope(other);
    }
    mergeUnrelatedScope(other) {
        this.addUnrelatedScope(other);
        for (const variable of other.inScopeBoundVariableTranslation.values()) {
            this.translatedVariablesNotInScope.add(variable.value);
        }
    }
    newScope(insideServiceClause) {
        const copy = new Variables(insideServiceClause ? { ...this, insideServiceClause: true } : this);
        copy.addUnrelatedScope(this);
        for (const entry of this.inScopeBoundVariableTranslation.entries()) {
            copy.ancestorScopeBoundVariableTranslation.set(...entry);
        }
        for (const entry of this.ancestorScopeBoundVariableTranslation.entries()) {
            copy.ancestorScopeBoundVariableTranslation.set(...entry);
        }
        return copy;
    }
    project(untranslatedVariablesToKeep) {
        for (const [untranslatedVariable, translation] of this.inScopeBoundVariableTranslation) {
            if (!untranslatedVariablesToKeep.has(untranslatedVariable)) {
                this.translatedVariablesNotInScope.add(translation.value);
                this.inScopeBoundVariableTranslation.delete(untranslatedVariable);
                this.untranslatedVariablesInScope.delete(untranslatedVariable);
            }
        }
        this.projectAncestorScope(untranslatedVariablesToKeep);
    }
    projectAncestorScope(untranslatedVariablesToKeep) {
        for (const [untranslatedVariable, translation] of this.ancestorScopeBoundVariableTranslation) {
            if (!untranslatedVariablesToKeep.has(untranslatedVariable)) {
                this.translatedVariablesNotInScope.add(translation.value);
                this.ancestorScopeBoundVariableTranslation.delete(untranslatedVariable);
                this.untranslatedVariablesInScope.delete(untranslatedVariable);
            }
        }
    }
    onTermRead(term) {
        if (term.termType !== "Variable" || this.dontTouchThis.has(term.value))
            return term;
        if (this.insideServiceClause) {
            this.translatedVariablesNotInScope.add(term.value);
            return term;
        }
        const existingTranslation = this.inScopeBoundVariableTranslation.get(term.value);
        if (existingTranslation !== undefined)
            return existingTranslation;
        return UNBOUND_VARIABLE;
    }
    onTermBind(term) {
        if (term.termType !== "Variable" || this.dontTouchThis.has(term.value))
            return term;
        this.untranslatedVariablesInScope.add(term.value);
        const existingTranslation = this.inScopeBoundVariableTranslation.get(term.value);
        if (existingTranslation !== undefined)
            return existingTranslation;
        let newVariable = this.ancestorScopeBoundVariableTranslation.get(term.value);
        if (newVariable === undefined) {
            newVariable =
                this.translateEverything || this.translatedVariablesNotInScope.has(term.value)
                    ? factory.variable(randomUuid())
                    : term;
        }
        this.inScopeBoundVariableTranslation.set(term.value, newVariable);
        return newVariable;
    }
}
function select(variables, query, keepUnboundVariablesInProjection = undefined) {
    if (!isWildCard(query.variables)) {
        const variablesToKeep = new Set();
        for (const variable of query.variables) {
            if ("termType" in variable && variable.termType === "Variable")
                variablesToKeep.add(variable.value);
        }
        variables.project(variablesToKeep);
    }
    if (query.where) {
        groupGraphPattern(variables, query.where);
    }
    const untranslatedGroupedVariables = new Set();
    const isAggregate = isAggregateQuery(query) ? untranslatedGroupedVariables : "non-aggregate";
    if (query.group) {
        const queryGroup = [];
        for (const group of query.group) {
            if (group.variable) {
                if (variables.inScopeBoundVariableTranslation.has(group.variable.value)) {
                    throw new SparqlError(`The variable ?${group.variable.value} cannot be bound more than once`);
                }
                untranslatedGroupedVariables.add(group.variable.value);
                group.variable = variables.onTermBind(group.variable);
            }
            else if ("termType" in group.expression && group.expression.termType === "Variable") {
                untranslatedGroupedVariables.add(group.expression.value);
            }
            group.expression = expression(variables, group.expression, "non-aggregate");
            if (group.expression !== UNBOUND_VARIABLE)
                queryGroup.push(group);
        }
        query.group = queryGroup;
    }
    if (query.having)
        query.having = expression(variables, query.having, untranslatedGroupedVariables);
    if (query.values)
        query.values = values(variables, query.values);
    if (isWildCard(query.variables)) {
        if (isAggregate !== "non-aggregate")
            throw new SparqlError("Wildcards are not allowed in combination with GROUP BY");
        query.variables = [...variables.inScopeBoundVariableTranslation.values()];
    }
    else {
        const translatedProjection = [];
        const untranslatedProjection = new Set();
        for (let variable of query.variables) {
            if ("variable" in variable) {
                if (variables.inScopeBoundVariableTranslation.has(variable.variable.value)) {
                    throw new SparqlError(`The variable ?${variable.variable.value} cannot be bound more than once`);
                }
                untranslatedProjection.add(variable.variable.value);
                untranslatedGroupedVariables.add(variable.variable.value);
                variable.variable = variables.onTermBind(variable.variable);
                variable.expression = expression(variables, variable.expression, isAggregate);
            }
            else if (variable.termType === "Variable") {
                const untranslatedVariable = variable;
                untranslatedProjection.add(untranslatedVariable.value);
                variable = expression(variables, variable, isAggregate);
                if (keepUnboundVariablesInProjection && variable === UNBOUND_VARIABLE)
                    translatedProjection.push(untranslatedVariable);
            }
            if (variable !== UNBOUND_VARIABLE)
                translatedProjection.push(variable);
        }
        variables.untranslatedVariablesInScope = untranslatedProjection;
        query.variables = translatedProjection;
    }
    for (const order of query.order ?? []) {
        order.expression = expression(variables, order.expression, isAggregate);
    }
    variables.project(variables.untranslatedVariablesInScope);
}
function groupGraphPattern(variables, patterns, existsExpressionWorkaroud) {
    const filterPatterns = [];
    for (const pattern of patterns) {
        if (pattern.type === "filter") {
            filterPatterns.push(pattern);
        }
        else {
            graphPattern(variables, pattern, existsExpressionWorkaroud);
        }
    }
    for (const pattern of filterPatterns) {
        pattern.expression = expression(variables, pattern.expression, "non-aggregate");
    }
}
function triple(variables, triples) {
    for (const triple of triples) {
        triple.subject = variables.onTermBind(triple.subject);
        if ("termType" in triple.predicate)
            triple.predicate = variables.onTermBind(triple.predicate);
        triple.object = variables.onTermBind(triple.object);
    }
}
function expression(variables, expr, isAggregate) {
    if (Array.isArray(expr)) {
        return expr.map((exp) => expression(variables, exp, isAggregate));
    }
    if ("termType" in expr) {
        const term = variables.onTermRead(expr);
        if (term.termType === "Variable" &&
            !variables.dontTouchThis.has(term.value) &&
            isAggregate !== "non-aggregate" &&
            !isAggregate.has(expr.value)) {
            throwAggregateError(expr.value);
        }
        return term;
    }
    else {
        switch (expr.type) {
            case "aggregate":
                if (!("termType" in expr.expression && expr.expression.termType === "Wildcard")) {
                    expr.expression = expression(variables, expr.expression, "non-aggregate");
                }
                break;
            case "operation":
            case "functionCall":
                expr.args = expr.args.map((exp) => expression(variables, exp, isAggregate));
                break;
            case "group":
            case "graph":
            case "minus":
            case "service":
            case "union":
            case "optional":
            case "query":
            case "bgp":
            case "bind":
            case "values":
            case "filter":
                const existsVariables = variables.copy();
                existsVariables.projectAncestorScope(new Set());
                groupGraphPattern(existsVariables, expr.type === "group" ? expr.patterns : [expr], "bind in filter exists");
                variables.mergeUnrelatedScope(existsVariables);
                break;
        }
        return expr;
    }
}
function values(variables, values) {
    return fixSparqlJsValues(values, "remove undefined").map((oldRow) => mapKeys(oldRow, (_, oldVariable) => variables.onTermBind(dataFactory.variable(oldVariable)).value));
}
function graphPattern(variables, pattern, existsExpressionWorkaround) {
    switch (pattern.type) {
        case "bgp":
            triple(variables, pattern.triples);
            break;
        case "bind":
            if (!existsExpressionWorkaround && variables.inScopeBoundVariableTranslation.has(pattern.variable.value)) {
                throw new SparqlError(`The variable ?${pattern.variable.value} cannot be bound more than once`);
            }
            pattern.variable = variables.onTermBind(pattern.variable);
            pattern.expression = expression(variables, pattern.expression, "non-aggregate");
            break;
        case "query":
            const queryVariables = variables.newScope();
            select(queryVariables, pattern);
            variables.mergeChildScope(queryVariables);
            break;
        case "values":
            pattern.values = values(variables, pattern.values);
            break;
        case "optional":
            groupGraphPattern(variables, pattern.patterns);
            break;
        case "service":
            pattern.name = variables.onTermRead(pattern.name);
            const serviceVariables = variables.newScope("insideServiceClause");
            groupGraphPattern(serviceVariables, pattern.patterns);
            variables.mergeChildScope(serviceVariables);
            break;
        case "graph":
            pattern.name = variables.onTermBind(pattern.name);
        case "group":
            const patternVariables = variables.newScope();
            groupGraphPattern(patternVariables, pattern.patterns);
            variables.mergeChildScope(patternVariables);
            break;
        case "union":
            pattern.patterns
                .map((pattern) => {
                const unionVariables = variables.newScope();
                if (pattern.type === "filter") {
                    pattern.expression = expression(unionVariables, pattern.expression, "non-aggregate");
                }
                else {
                    graphPattern(unionVariables, pattern);
                }
                return unionVariables;
            })
                .forEach((v) => variables.mergeChildScope(v));
            break;
        case "minus": {
            const patternVariables = variables.newScope();
            groupGraphPattern(patternVariables, pattern.patterns);
            variables.mergeUnrelatedScope(patternVariables);
            break;
        }
    }
}
//# sourceMappingURL=variableScope.js.map