import { default as SparqlJs } from "sparqljs";
import { Term } from "../../constants.js";
export declare const UNBOUND_VARIABLE_NAME: "???";
export declare function scopeVariables<Q extends SparqlJs.Query>(query: Q, opts?: ConstructorParameters<typeof Variables>[0]): Q;
export declare function translateVariableNames<Q>(query: Q, translation: Variables["inScopeBoundVariableTranslation"]): Q;
declare class Variables {
    dontTouchThis: Set<Term["value"]>;
    translateEverything: boolean;
    inScopeBoundVariableTranslation: Map<Term["value"], SparqlJs.VariableTerm>;
    ancestorScopeBoundVariableTranslation: Map<Term["value"], SparqlJs.VariableTerm>;
    translatedVariablesNotInScope: Set<Term["value"]>;
    untranslatedVariablesInScope: Set<Term["value"]>;
    insideServiceClause: boolean;
    constructor(opts?: {
        dontTouchThis?: Variables["dontTouchThis"];
        translateEverything?: boolean;
        insideServiceClause?: boolean;
    });
    add(other: Variables): void;
    copy(): Variables;
    private addUnrelatedScope;
    mergeChildScope(other: Variables): void;
    mergeUnrelatedScope(other: Variables): void;
    newScope(insideServiceClause?: "insideServiceClause"): Variables;
    project(untranslatedVariablesToKeep: Set<SparqlJs.VariableTerm["value"]>): void;
    projectAncestorScope(untranslatedVariablesToKeep: Set<SparqlJs.VariableTerm["value"]>): void;
    onTermRead<T extends SparqlJs.Term>(term: T): T;
    onTermBind<T extends SparqlJs.Term>(term: T): T;
}
export {};
//# sourceMappingURL=variableScope.d.ts.map