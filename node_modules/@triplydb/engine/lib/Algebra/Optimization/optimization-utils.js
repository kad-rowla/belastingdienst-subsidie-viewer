import { compact, flatten, uniq } from "lodash-es";
import { FatalError } from "../../Errors.js";
import { UNBOUND_VARIABLE_NAME, scopeVariables } from "../ASTtoAlgebra/variableScope.js";
export function getVariablesMentionedByOperation(operation) {
    switch (operation.operationType) {
        case "Aggregate":
            return [
                ...Object.keys(operation.aggregatingExpressions),
                ...flatten(operation.groupingExpressions.map(getVariablesMentionedByExpression)),
                ...getVariablesMentionedByOperation(operation.inputOperation),
            ];
        case "Distinct":
            return [...operation.variables, ...getVariablesMentionedByOperation(operation.inputOperation)];
        case "EnsureBound":
            return [operation.variable];
        case "Extend":
            return [
                operation.variable,
                ...getVariablesMentionedByOperation(operation.inputOperation),
                ...getVariablesMentionedByExpression(operation.expression),
            ];
        case "Filter":
            return [
                ...getVariablesMentionedByOperation(operation.inputOperation),
                ...getVariablesMentionedByExpression(operation.expression),
            ];
        case "InlineData":
            return operation.values.flatMap((bindings) => Object.keys(bindings));
        case "Join":
            return flatten(operation.inputOperations.map(getVariablesMentionedByOperation));
        case "LeftJoin":
            return flatten(operation.inputOperations.map(getVariablesMentionedByOperation));
        case "Minus":
            return flatten(operation.inputOperations.map(getVariablesMentionedByOperation));
        case "OrderBy":
            return [
                ...flatten(operation.ordering.map((o) => getVariablesMentionedByExpression(o.expression))),
                ...getVariablesMentionedByOperation(operation.inputOperation),
            ];
        case "Service":
            const scopedVariables = scopeVariables(operation.runTimeInformation.query).variables.map((variableOrVariableExpression) => {
                if ("termType" in variableOrVariableExpression && variableOrVariableExpression.termType === "Wildcard")
                    throw new FatalError("Wildcard found in scoping variables. This is a bug.");
                if ("expression" in variableOrVariableExpression)
                    return variableOrVariableExpression.variable.value;
                return variableOrVariableExpression.value;
            });
            return scopedVariables;
        case "Slice":
            return getVariablesMentionedByOperation(operation.inputOperation);
        case "TriplePattern":
            return operation.pattern.filter((a) => typeof a === "string");
        case "Union":
            return flatten(operation.inputOperations.map(getVariablesMentionedByOperation));
        case "ZeroOrMorePath":
            return [...getVariablesMentionedByOperation(operation.inputOperation), operation.boundStart, operation.end];
        default:
            throw new FatalError("Unrecognized operation type");
    }
}
export function getVariablesMatchedByOperation(operation) {
    switch (operation.operationType) {
        case "Aggregate":
            const varsInScope = getVariablesMatchedByOperation(operation.inputOperation);
            const aggregatingExpressionVars = new Set(compact(operation.groupingExpressions.map((e) => (e.expressionType === "Variable" ? e.variable : undefined))));
            return [...new Set([...varsInScope, ...aggregatingExpressionVars])];
        case "Distinct":
            const varsOfDistinct = getVariablesMatchedByOperation(operation.inputOperation);
            return [...new Set([...varsOfDistinct, ...operation.variables])];
        case "EnsureBound":
            return [operation.variable];
        case "Extend":
            const varsOfExtend = getVariablesMatchedByOperation(operation.inputOperation);
            return [...new Set([...varsOfExtend, operation.variable])];
        case "InlineData":
            return [...new Set([...flatten(operation.values.map((binding) => Object.keys(binding)))])];
        case "Slice":
        case "Filter":
        case "OrderBy":
            return getVariablesMatchedByOperation(operation.inputOperation);
        case "Service":
            const scopedVariables = scopeVariables(operation.runTimeInformation.query).variables.map((variableOrVariableExpression) => {
                if ("termType" in variableOrVariableExpression && variableOrVariableExpression.termType === "Wildcard")
                    throw new FatalError("Wildcard found in scoping variables. This is a bug.");
                if ("expression" in variableOrVariableExpression)
                    return variableOrVariableExpression.variable.value;
                return variableOrVariableExpression.value;
            });
            return scopedVariables;
        case "TriplePattern":
            const varsInTps = operation.pattern.filter((term) => typeof term === "string");
            return varsInTps;
        case "ZeroOrMorePath":
            return [operation.end, operation.boundStart];
        case "Join":
        case "Union":
            let variablesAssignedByJoin = [];
            for (const op of operation.inputOperations) {
                variablesAssignedByJoin.push(...getVariablesMatchedByOperation(op));
            }
            return [...new Set(variablesAssignedByJoin)];
        case "LeftJoin":
        case "Minus":
            const variablesMatchedLeftOp = getVariablesMatchedByOperation(operation.inputOperations[0]);
            const variablesMatchedRightOp = getVariablesMatchedByOperation(operation.inputOperations[1]);
            return [...new Set([...variablesMatchedLeftOp, ...variablesMatchedRightOp])];
    }
}
export function getVariablesMentionedByExpression(exp) {
    if ("variable" in exp && exp.variable !== UNBOUND_VARIABLE_NAME) {
        return [exp.variable];
    }
    if ("operation" in exp) {
        return uniq(getVariablesMentionedByOperation(exp.operation));
    }
    if (exp.expressionType === "FunctionCall") {
        if ("expressions" in exp) {
            return uniq(flatten(exp.expressions.map((s) => getVariablesMentionedByExpression(s))));
        }
    }
    return [];
}
export function getVariablesInScopeAfterOperation(algebra) {
    switch (algebra.operationType) {
        case "TriplePattern":
            return algebra.pattern.filter((term) => typeof term === "string");
        case "ZeroOrMorePath":
            return [algebra.boundStart, algebra.end];
        case "EnsureBound":
            return [algebra.variable];
        case "InlineData":
            return flatten(algebra.values.map((binding) => Object.keys(binding)));
        case "Extend":
            return [algebra.variable];
        case "Distinct":
            return [...algebra.variables];
        case "Service":
        case "Minus":
        case "Aggregate":
        case "OrderBy":
        case "Join":
        case "LeftJoin":
        case "Filter":
        case "Union":
        case "Slice":
            return [];
    }
}
export function getVarAndTermFromExpression(leftExpression, rightExpression) {
    if (leftExpression.expressionType === "Variable") {
        if (rightExpression.expressionType !== "Term")
            return;
        if (rightExpression.term.termType !== "NamedNode")
            return;
        return { variable: leftExpression.variable, term: rightExpression.term };
    }
}
//# sourceMappingURL=optimization-utils.js.map