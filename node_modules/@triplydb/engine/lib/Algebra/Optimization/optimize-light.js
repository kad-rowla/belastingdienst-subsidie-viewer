import { cloneDeep } from "lodash-es";
import { IDENTITY, NOTHING } from "../Operation.js";
import { SparqlError } from "../../Errors.js";
import { convertListToAlgebra, optimizeZeroOrMoreOperation } from "./optimize-reorder.js";
import { forEachAlgebraNode } from "../../Helpers.js";
import { getVarAndTermFromExpression, getVariablesMatchedByOperation } from "./optimization-utils.js";
export function optimizeAlgebraLight(operation) {
    const optimizeableAlgebra = cloneDeep(operation);
    optimizeZeroOrMoreOperation(optimizeableAlgebra);
    return rewriteFilterOperation(optimizeableAlgebra);
}
export function rewriteFilterOperation(operation, info = { variablesInScope: new Set([]) }) {
    if (operation.id === IDENTITY.id || operation.id === NOTHING.id)
        return operation;
    if ((operation.operationType === "Extend" || operation.operationType === "Filter") && isNestedOperation(operation)) {
        let nestedOperationList = [
            {
                ...operation,
                inputOperation: IDENTITY,
            },
            { ...rewriteFilterOperation(operation.inputOperation, info) },
        ];
        const optimalFilterOrdering = _rewriteFilterOperation(nestedOperationList, info.variablesInScope).reverse();
        const nestedAlgebra = convertListToAlgebra(optimalFilterOrdering);
        return nestedAlgebra;
    }
    else if ("inputOperation" in operation) {
        const unaryOperation = { ...operation };
        const rewriteInputOperation = rewriteFilterOperation(operation.inputOperation, info);
        unaryOperation.inputOperation = rewriteInputOperation;
        return unaryOperation;
    }
    else if (operation.operationType === "Join") {
        const joinOperation = { ...operation };
        const operationList = [...joinOperation.inputOperations];
        let joinOp = [];
        for (const op of operationList) {
            joinOp.push(rewriteFilterOperation(op, info));
        }
        const optimalFilterOrdering = _rewriteFilterOperation(joinOp, info.variablesInScope);
        return convertListToAlgebra([...optimalFilterOrdering], true);
    }
    else if ("inputOperations" in operation) {
        const updatedOperation = { ...operation };
        let rewrittenOperation = [];
        for (const ope of operation.inputOperations) {
            rewrittenOperation.push(rewriteFilterOperation(ope, info));
        }
        updatedOperation.inputOperations = [...rewrittenOperation];
        return updatedOperation;
    }
    let varsSoFar = [...info.variablesInScope, ...getVariablesMatchedByOperation(operation)];
    info.variablesInScope = new Set(varsSoFar);
    return operation;
}
function _rewriteFilterOperation(operations, variableInScope) {
    let operationList = [];
    let filterToBindOperation = [];
    let variablesAffected = [];
    operations.forEach((operation) => {
        const filterVariableAndTerm = getFilterVariableAndTerm(operation);
        if (filterVariableAndTerm && variableInScope.has(filterVariableAndTerm.variable)) {
            variablesAffected.push(filterVariableAndTerm);
            filterToBindOperation.push({
                operationType: "Extend",
                id: operation.id ?? undefined,
                inputOperation: IDENTITY,
                variable: filterVariableAndTerm.variable,
                expression: {
                    expressionType: "Term",
                    term: filterVariableAndTerm.term,
                },
            });
        }
        else {
            operationList.push(operation);
        }
    });
    if (filterToBindOperation.length === 0 && operationList.length !== operations.length)
        throw new SparqlError("Re-writing filter to bind failed. Contact a developer");
    if (variablesAffected.length > 0) {
        operationList = processOperationListWithNewVars(operationList, variablesAffected);
    }
    operationList = [...filterToBindOperation, ...operationList];
    return operationList;
}
function processOperationListWithNewVars(operationList, variablesAffected) {
    const listOfOperation = [...operationList];
    listOfOperation.forEach(function (op, index, array) {
        forEachAlgebraNode(op, (op) => {
            if (op.operationType === "TriplePattern") {
                const pattern = { ...op.pattern };
                let stp1 = pattern[0];
                let stp2 = pattern[1];
                let stp3 = pattern[2];
                if (typeof stp1 === "string") {
                    for (const varTerm of variablesAffected) {
                        if (varTerm.variable === stp1) {
                            stp1 = varTerm.term;
                            break;
                        }
                    }
                }
                if (typeof stp2 === "string") {
                    for (const varTerm of variablesAffected) {
                        if (varTerm.variable === stp2)
                            stp2 = varTerm.term;
                    }
                }
                if (typeof stp3 === "string") {
                    for (const varTerm of variablesAffected) {
                        if (varTerm.variable === stp3)
                            stp3 = varTerm.term;
                    }
                }
                op.pattern = [stp1, stp2, stp3];
            }
        }, () => { }, undefined);
        array[index] = op;
    });
    return listOfOperation;
}
function getFilterVariableAndTerm(operation) {
    if (operation.operationType !== "Filter")
        return;
    if (operation.expression.expressionType !== "FunctionCall")
        return;
    const expression = operation.expression;
    if (expression.function !== "=")
        return;
    const leftExpr = expression.expressions[0];
    const rightExpr = expression.expressions[1];
    const varTermLeft = getVarAndTermFromExpression(leftExpr, rightExpr);
    if (varTermLeft)
        return varTermLeft;
    const varTermRight = getVarAndTermFromExpression(rightExpr, leftExpr);
    if (varTermRight)
        return varTermRight;
}
function isNestedOperation(operation) {
    const inputOp = operation.inputOperation;
    if (inputOp.id === IDENTITY.id || inputOp.id === NOTHING.id)
        return false;
    return true;
}
//# sourceMappingURL=optimize-light.js.map