import { cloneDeep, flatten, toInteger } from "lodash-es";
import log from "../../Debugging.js";
import { createJoin } from "../ASTtoAlgebra/creation.js";
import { IDENTITY, NOTHING } from "../Operation.js";
import { getVariablesMatchedByOperation, getVariablesMentionedByExpression, getVariablesMentionedByOperation, } from "./optimization-utils.js";
import memoizee from "memoizee";
import { difference, intersection, isSubset } from "mnemonist/set.js";
import { FatalError } from "../../Errors.js";
import { forEachAlgebraNode } from "../../Helpers.js";
import { algebraToString } from "../utils.js";
const DEPTH = 1;
export async function optimizeAlgebra(algebra, statistics) {
    const operationToReorder = cloneDeep(algebra);
    memoizedEstimateComplexity.clear();
    const bestAlgebra = await generateBestAlgebra(operationToReorder, DEPTH, statistics);
    const { timeEstimate } = await memoizedEstimateComplexity(bestAlgebra, statistics);
    const optimizedBasedOnGraphsAlgebra = await optimizeMultipleGraphsOperation(bestAlgebra, statistics);
    return { operation: optimizedBasedOnGraphsAlgebra, estimatedComplexity: timeEstimate };
}
export async function generateBestAlgebra(algebra, depth, statistics) {
    const isJoin = algebra.operationType === "Join";
    const isFlattenedOp = algebra.operationType in ["Filter", "Extend"];
    const algebraAsList = convertAlgebraToList(algebra);
    if (algebraAsList.some((op) => op.operationType === "InlineData"))
        return algebra;
    let { timeEstimate: lowestTimeEstimate } = await memoizedEstimateComplexity(algebra, statistics);
    log("sparql:optimize:reorder:original-algebra", algebraToString(algebra));
    log("sparql:optimize:reorder:original-time-estimate", "%F", lowestTimeEstimate);
    let bestAlgebra = cloneDeep(algebra);
    for await (const op of reorderOperationList(algebraAsList, depth, statistics)) {
        if (isInvalidZeroOrMorePathAlgebra(op))
            continue;
        const reorderedOperation = convertListToAlgebra([...op], isJoin);
        if (isJoin && reorderedOperation.operationType !== "Join")
            continue;
        if (!isJoin && reorderedOperation.operationType === "Join")
            continue;
        const numberOfNestedOperations = numberOfNodes(reorderedOperation);
        if (isFlattenedOp && numberOfNestedOperations !== algebraAsList.length)
            continue;
        const reorderedEstimate = await memoizedEstimateComplexity(reorderedOperation, statistics);
        log("sparql:optimize:reorder:reordered-algebra", algebraToString(reorderedOperation));
        log("sparql:optimize:reorder:reordered-time-estimate", "%F", reorderedEstimate.timeEstimate);
        if (reorderedEstimate.timeEstimate < lowestTimeEstimate) {
            bestAlgebra = cloneDeep(reorderedOperation);
            lowestTimeEstimate = reorderedEstimate.timeEstimate;
        }
    }
    return bestAlgebra;
}
export function convertAlgebraToList(operation) {
    if (operation.operationType === "Join") {
        return flatten(operation.inputOperations.map(convertAlgebraToList));
    }
    if (operation.operationType === "Extend" || operation.operationType === "Filter") {
        return [
            {
                ...operation,
                inputOperation: IDENTITY,
            },
            ...convertAlgebraToList(operation.inputOperation),
        ];
    }
    return [operation];
}
export async function* makeConjunctionsOfDisjunctions(conjunction, depth, statistics) {
    for (const operation of conjunction) {
        yield* getConnectedOperations(operation, conjunction, depth, statistics);
    }
}
export function convertListToAlgebra(operations, isJoin = false) {
    return operations.reduce((partialOperation, opItem) => {
        return convertOperation(partialOperation, Array.isArray(opItem) ? convertListToAlgebra(opItem) : opItem, isJoin);
    }, IDENTITY);
}
export function convertListToLeftJoin(operations) {
    return operations.reduce((partialOperation, opItem) => {
        if (partialOperation.id === IDENTITY.id) {
            return Array.isArray(opItem) ? convertListToLeftJoin(opItem) : opItem;
        }
        return {
            operationType: "LeftJoin",
            inputOperations: [partialOperation, Array.isArray(opItem) ? convertListToLeftJoin(opItem) : opItem],
        };
    }, IDENTITY);
}
export function isInvalidZeroOrMorePathAlgebra(algebra, boundVariables) {
    if (!boundVariables)
        boundVariables = new Set();
    for (const op of algebra) {
        if (Array.isArray(op)) {
            if (isInvalidZeroOrMorePathAlgebra(op, boundVariables))
                return true;
        }
        else {
            if (op.operationType === "Extend" || op.operationType === "EnsureBound")
                boundVariables.add(op.variable);
            if (op.operationType === "ZeroOrMorePath" && !boundVariables.has(op.boundStart))
                return true;
        }
    }
    return false;
}
export async function* reorderOperationList(operations, depth, statistics) {
    for (let index = 0; index < operations.length; index++) {
        const before = operations.slice(0, index);
        const after = operations.slice(index + 1, operations.length);
        const rest = [...before, ...after];
        const fixedOperation = { ...operations[index] };
        if (fixedOperation.id === NOTHING.id || fixedOperation.id === IDENTITY.id) {
            if (rest.length !== 0) {
                throw new Error("Expected identity/nothing to always be in a 1-length conjunction");
            }
            yield [fixedOperation];
            return;
        }
        const firstOperation = await reorderInputOperations(fixedOperation, depth, statistics);
        if (rest.length === 0) {
            yield [firstOperation];
        }
        else {
            for await (const perm of makeConjunctionsOfDisjunctions([...rest], depth, statistics)) {
                yield [firstOperation, ...perm];
            }
        }
    }
}
async function generateBestLeftJoin(operation, hdtStats) {
    const [leftOperation, ...allRightOperations] = flattenLeftJoin(operation);
    const varsInLeftOperation = new Set(getVariablesMentionedByOperation(leftOperation));
    const findConnectedLeftJoins = getConnectedLeftJoins(varsInLeftOperation, allRightOperations);
    let bestReorder = await generateBestLeftJoinReorder(findConnectedLeftJoins, varsInLeftOperation, hdtStats);
    return convertListToLeftJoin([leftOperation, ...bestReorder]);
}
async function estimateOptionalRightOperationsComplexity(allRightOperations, varsInScope, hdtStats) {
    let estimates = [];
    for (let subarray of allRightOperations) {
        let totalEstimate = { ...STARTESTIMATE };
        for (let op of subarray) {
            let individualEstimate = await estimateAlgebraComplexity(op, varsInScope, hdtStats, totalEstimate);
            totalEstimate.spaceEstimate *= 1 + individualEstimate.spaceEstimate;
            totalEstimate.timeEstimate += totalEstimate.spaceEstimate * individualEstimate.timeEstimate;
        }
        estimates.push(totalEstimate.timeEstimate);
    }
    return estimates;
}
const STARTESTIMATE = { spaceEstimate: 1, timeEstimate: 0 };
async function generateBestLeftJoinReorder(rightJoinOps, varsInScope, hdtStats) {
    let complexityArray = await estimateOptionalRightOperationsComplexity(rightJoinOps, varsInScope, hdtStats);
    const sortedArrayIndexes = complexityArray
        .map((value, index) => {
        return {
            value: value,
            index: index,
        };
    })
        .sort((a, b) => a.value - b.value)
        .map((val) => val.index);
    log("sparql:optimize:leftjoin", "Sort Indices for a Nested LeftJoin", sortedArrayIndexes);
    return sortedArrayIndexes.flatMap((i) => rightJoinOps[i]);
}
export function getConnectedLeftJoins(varsInLeftOperation, rightOperations) {
    let allGroupedBlocks = [];
    let variableToGroupMap = new Map();
    for (let op of rightOperations) {
        let opVar = new Set(getVariablesMentionedByOperation(op));
        const variables = difference(opVar, varsInLeftOperation);
        let operationIndices = new Set();
        for (let variable of variables) {
            let index = variableToGroupMap.get(variable);
            if (index) {
                operationIndices.add(index);
            }
        }
        let individualBlock = [];
        for (let index of Array.from(operationIndices).sort()) {
            individualBlock = individualBlock.concat(allGroupedBlocks[index]);
            delete allGroupedBlocks[index];
        }
        individualBlock = [...individualBlock, op];
        allGroupedBlocks.push(individualBlock);
        for (let variable of variables) {
            variableToGroupMap.set(variable, allGroupedBlocks.length - 1);
        }
    }
    allGroupedBlocks = allGroupedBlocks.filter((group) => group !== undefined);
    return allGroupedBlocks;
}
async function reorderInputOperations(operation, depth, statistics) {
    switch (operation.operationType) {
        case "LeftJoin":
            let leftJoinOperation;
            if (isLeftJoinLinear(operation)) {
                const reorderedNestedLeftJoin = await generateBestLeftJoin(operation, statistics);
                leftJoinOperation = { ...reorderedNestedLeftJoin };
            }
            else {
                leftJoinOperation = { ...operation };
            }
            const originalLeftJoinOperation = { ...leftJoinOperation };
            const bestNormalReorder = await generateBestAlgebra(leftJoinOperation.inputOperations[0], depth, statistics);
            const bestOptionalReorder = await generateBestAlgebra(leftJoinOperation.inputOperations[1], depth, statistics);
            originalLeftJoinOperation.inputOperations = [bestNormalReorder, bestOptionalReorder];
            return originalLeftJoinOperation;
        case "Union":
            const operationList = [...operation.inputOperations];
            const unionOperation = { ...operation };
            const bestUnionReorder = await Promise.all(operationList.map((operation) => generateBestAlgebra(operation, depth, statistics)));
            unionOperation.inputOperations = bestUnionReorder;
            return unionOperation;
        case "Minus":
            const normalReorder = await generateBestAlgebra(operation.inputOperations[0], depth, statistics);
            const optionalReorder = await generateBestAlgebra(operation.inputOperations[1], depth, statistics);
            return { ...operation, inputOperations: [normalReorder, optionalReorder] };
        case "Slice":
            const sliceOperation = { ...operation };
            const sliceOp = operation.inputOperation;
            const sliceReorderOp = await generateBestAlgebra(sliceOp, depth, statistics);
            sliceOperation.inputOperation = sliceReorderOp;
            return sliceOperation;
        case "Distinct":
            const distinctOperation = { ...operation };
            const reorderedDistinctOp = await generateBestAlgebra(distinctOperation.inputOperation, depth, statistics);
            distinctOperation.inputOperation = reorderedDistinctOp;
            return distinctOperation;
        case "Aggregate":
            const aggregateOperation = { ...operation };
            const reorderedaggregateOp = await generateBestAlgebra(aggregateOperation.inputOperation, depth, statistics);
            aggregateOperation.inputOperation = reorderedaggregateOp;
            return aggregateOperation;
    }
    return operation;
}
function convertOperation(partialOperation, nextOperation, isJoin = false) {
    if (isJoin)
        return createJoin([partialOperation, nextOperation]);
    if (partialOperation.operationType === "Union" ||
        partialOperation.operationType === "LeftJoin" ||
        partialOperation.operationType === "Minus") {
        return createJoin([partialOperation, nextOperation]);
    }
    if (partialOperation.operationType === "EnsureBound") {
        return createJoin([partialOperation, nextOperation]);
    }
    if ("inputOperation" in nextOperation) {
        const operationInjected = addOperations(partialOperation, nextOperation);
        if (operationInjected)
            return operationInjected;
    }
    return createJoin([partialOperation, nextOperation]);
}
function addOperations(operation, inputOperation) {
    const operationToIndex = { ...inputOperation };
    if ("inputOperation" in operationToIndex) {
        if (operationToIndex.inputOperation === IDENTITY || operationToIndex.inputOperation === NOTHING) {
            operationToIndex.inputOperation = operation;
            return operationToIndex;
        }
        const op = addOperations(operation, operationToIndex.inputOperation);
        if (op) {
            operationToIndex.inputOperation = { ...op };
            return operationToIndex;
        }
    }
}
const countUnboundVars = (varsInExpression, varsInScope) => {
    let count = 0;
    if (varsInExpression.size === 0)
        return 0;
    for (const element of varsInExpression) {
        if (!varsInScope.has(element))
            count++;
    }
    return count;
};
async function* getConnectedOperations(candidateUnit, conjunction, depth, statistics) {
    const connectedUnits = [];
    const independentOperation = [];
    const candidateUnitVars = new Set(getVariablesMentionedByOperation(candidateUnit));
    for (const op of conjunction) {
        const vars = new Set(getVariablesMentionedByOperation(op));
        if (intersection(candidateUnitVars, vars).size !== 0) {
            connectedUnits.push(op);
        }
        else {
            independentOperation.push(op);
        }
    }
    if (connectedUnits.length === 0) {
        yield [...independentOperation];
        return;
    }
    if (connectedUnits.length === 1)
        yield [...connectedUnits, ...independentOperation];
    else if (depth > 0) {
        for await (const reArrangeSubgraph of reorderOperationList(connectedUnits, depth - 1, statistics)) {
            yield [...reArrangeSubgraph, ...independentOperation];
        }
    }
    else
        yield [[...connectedUnits], ...independentOperation];
}
export const memoizedEstimateComplexity = memoizee(async (algebra, statistics) => estimateAlgebraComplexity(algebra, new Set(), statistics, {
    spaceEstimate: 1,
    timeEstimate: 1,
}), {
    primitive: true,
    promise: true,
    max: 100,
    normalizer: function (args) {
        return JSON.stringify(args[0]);
    },
});
export async function estimateAlgebraComplexity(algebra, variablesInScope, statistics, estimate) {
    if (algebra.id === NOTHING.id || algebra.id === IDENTITY.id)
        return {
            spaceEstimate: estimate.spaceEstimate,
            timeEstimate: estimate.timeEstimate + 0.1,
        };
    else {
        switch (algebra.operationType) {
            case "Service":
            case "Aggregate":
                return estimate;
            case "EnsureBound":
                if (variablesInScope.has(algebra.variable))
                    return estimate;
                return {
                    spaceEstimate: estimate.spaceEstimate * ((await statistics.distinctSubjects()) + (await statistics.distinctObjects())),
                    timeEstimate: estimate.timeEstimate,
                };
            case "Slice":
                const limit = algebra.limit;
                const estimateOpComplexity = await estimateAlgebraComplexity(algebra.inputOperation, variablesInScope, statistics, estimate);
                if (limit && limit < estimateOpComplexity.spaceEstimate) {
                    estimate.timeEstimate += limit;
                    estimate.spaceEstimate += limit;
                }
                else {
                    estimate.timeEstimate += estimateOpComplexity.timeEstimate;
                    estimate.spaceEstimate += estimateOpComplexity.spaceEstimate;
                }
                return estimate;
            case "Distinct":
            case "OrderBy":
                return estimateAlgebraComplexity(algebra.inputOperation, variablesInScope, statistics, estimate);
            case "Extend":
            case "Filter":
                estimate = await estimateAlgebraComplexity(algebra.inputOperation, variablesInScope, statistics, estimate);
                variablesInScope = new Set([...variablesInScope, ...getVariablesMatchedByOperation(algebra)]);
                const expressionEstimate = estimateExpressions(algebra, estimate, variablesInScope);
                estimate.timeEstimate += expressionEstimate.timeEstimate;
                estimate.spaceEstimate += expressionEstimate.spaceEstimate;
                return estimate;
            case "InlineData":
                estimate.spaceEstimate += algebra.values.length;
                estimate.timeEstimate += estimate.spaceEstimate * 0.2;
                return estimate;
            case "Join":
                for (const op of algebra.inputOperations) {
                    const individualJoin = await estimateAlgebraComplexity(op, variablesInScope, statistics, {
                        ...STARTESTIMATE,
                    });
                    variablesInScope = new Set([...variablesInScope, ...getVariablesMatchedByOperation(op)]);
                    estimate.spaceEstimate = estimate.spaceEstimate * individualJoin.spaceEstimate;
                    estimate.timeEstimate = estimate.timeEstimate + estimate.spaceEstimate * individualJoin.timeEstimate;
                }
                return estimate;
            case "TriplePattern":
                const branchFactor = await estimateTriplePatternComplexity(algebra, variablesInScope, statistics);
                if (branchFactor) {
                    return branchFactor;
                }
                return estimate;
            case "ZeroOrMorePath":
                const inputEstimate = await estimateAlgebraComplexity(algebra.inputOperation, variablesInScope, statistics, estimate);
                estimate.spaceEstimate = estimate.spaceEstimate * inputEstimate.spaceEstimate ** 2;
                estimate.timeEstimate =
                    estimate.timeEstimate + (inputEstimate.timeEstimate + 10000000) * estimate.spaceEstimate;
                return estimate;
            case "LeftJoin":
                return estimateLeftJoinOperation(algebra, variablesInScope, statistics, estimate);
            case "Minus":
            case "Union":
                return estimateDisjointOperations(algebra, variablesInScope, statistics, { ...STARTESTIMATE });
        }
    }
}
async function estimateLeftJoinOperation(operation, variableInScope, hdtStats, estimate) {
    const leftOp = operation.inputOperations[0];
    const rightOp = operation.inputOperations[1];
    const estimateLeft = await estimateAlgebraComplexity(leftOp, variableInScope, hdtStats, estimate);
    const updatedVarsInScope = new Set([...variableInScope, ...getVariablesMatchedByOperation(leftOp)]);
    const estimateRight = await estimateAlgebraComplexity(rightOp, updatedVarsInScope, hdtStats, estimate);
    const spaceEstimate = estimate.spaceEstimate * estimateLeft.spaceEstimate * estimateRight.spaceEstimate;
    const timeEstimate = estimate.timeEstimate + estimateLeft.timeEstimate + estimateLeft.spaceEstimate * estimateRight.timeEstimate;
    return { spaceEstimate: spaceEstimate, timeEstimate: timeEstimate };
}
async function estimateDisjointOperations(operation, variablesInScope, statistics, estimate) {
    for (const op of operation.inputOperations) {
        const unionEstimate = await estimateAlgebraComplexity(op, variablesInScope, statistics, estimate);
        estimate.spaceEstimate += unionEstimate.spaceEstimate;
        estimate.timeEstimate += unionEstimate.timeEstimate;
    }
    return estimate;
}
function estimateExpressions(operation, estimate, variableInScope) {
    const operationExpression = operation.expression;
    if (operationExpression.expressionType === "FunctionCall" ||
        operationExpression.expressionType === "Exists" ||
        operationExpression.expressionType === "Bound" ||
        operationExpression.expressionType === "Variable") {
        const functionVariables = getVariablesMentionedByExpression(operation.expression);
        const numberOfDisjunctions = countUnboundVars(new Set(functionVariables), variableInScope);
        if (functionVariables.length === 0 && numberOfDisjunctions === 0)
            return { spaceEstimate: estimate.spaceEstimate, timeEstimate: estimate.timeEstimate + 1 };
        return {
            spaceEstimate: estimate.spaceEstimate + estimate.spaceEstimate,
            timeEstimate: estimate.timeEstimate + 10000000 * numberOfDisjunctions + 1,
        };
    }
    else {
        estimate.spaceEstimate += 1;
        estimate.timeEstimate += 0.1;
    }
    return estimate;
}
async function estimateTriplePatternComplexity(tpsOperation, setOfBoundVars, statistics) {
    log("sparql:optimize:reorder:estimation:triple-pattern", "Pattern is", algebraToString(tpsOperation));
    const sub = boundOrUnboundVariable(tpsOperation.pattern[0], setOfBoundVars);
    const pred = boundOrUnboundVariable(tpsOperation.pattern[1], setOfBoundVars);
    const obj = boundOrUnboundVariable(tpsOperation.pattern[2], setOfBoundVars);
    if ((sub === "const" || sub === "boundVar") &&
        (pred === "const" || pred === "boundVar") &&
        (obj === "const" || obj === "boundVar")) {
        log("sparql:optimize:reorder:estimation:triple-pattern", "Patterns are constant, returning 1 as the estimate");
        return {
            timeEstimate: 1,
            spaceEstimate: 1,
        };
    }
    if (pred === "const") {
        if (typeof tpsOperation.pattern[1] === "string")
            return;
        if ((sub === "const" || sub === "boundVar") && obj === "unboundVar") {
            const branchFactor = (await statistics.subjectBranchingFactor(tpsOperation.pattern[1])) || 0;
            log("sparql:optimize:reorder:estimation:triple-pattern", "Predicate is constant, sub is bound or constant, branch factor is %F", branchFactor);
            return {
                timeEstimate: branchFactor,
                spaceEstimate: branchFactor,
            };
        }
        if (sub === "unboundVar" && (obj === "const" || obj === "boundVar")) {
            const branchFactor = (await statistics.objectBranchingFactor(tpsOperation.pattern[1])) || 0;
            log("sparql:optimize:reorder:estimation:triple-pattern", "Predicate is constant, obj is bound or constant, branch factor is %F", branchFactor);
            return {
                timeEstimate: branchFactor,
                spaceEstimate: branchFactor,
            };
        }
        if (sub === "unboundVar" && obj === "unboundVar") {
            const numberOfMatchingTriples = await statistics.numTriplesMatchingPredicate(tpsOperation.pattern[1]);
            log("sparql:optimize:reorder:estimation:triple-pattern", "Predicate is constant, sub and obj are unbound, branch factor is %F", numberOfMatchingTriples);
            return {
                timeEstimate: numberOfMatchingTriples,
                spaceEstimate: numberOfMatchingTriples,
            };
        }
    }
    if (pred === "unboundVar") {
        if ((sub === "boundVar" || sub === "const") && obj === "unboundVar") {
            const totalTriples = await statistics.countTriples();
            const subjectCount = await statistics.distinctSubjects();
            const branchFactor = subjectCount === undefined ? 0 : toInteger(totalTriples / subjectCount);
            log("sparql:optimize:reorder:estimation:triple-pattern", "Predicate is unbound, sub is bound, branch factor is %F", branchFactor);
            return {
                timeEstimate: branchFactor,
                spaceEstimate: branchFactor,
            };
        }
        if (sub === "unboundVar" && (obj === "boundVar" || obj === "const")) {
            const totalTriples = await statistics.countTriples();
            const objectCount = await statistics.distinctObjects();
            const branchFactor = objectCount === undefined ? 0 : toInteger(totalTriples / objectCount);
            log("sparql:optimize:reorder:estimation:triple-pattern", "Predicate is unbound, obj is bound, branch factor is %F", branchFactor);
            return {
                timeEstimate: branchFactor,
                spaceEstimate: branchFactor,
            };
        }
    }
    const estimatedTriples = await statistics.countTriples(tpsOperation.pattern);
    log("sparql:optimize:reorder:estimation:triple-pattern", "Triple pattern doesn't have any bound property variable anywhere, estimated triples %F", estimatedTriples);
    return {
        spaceEstimate: estimatedTriples,
        timeEstimate: estimatedTriples,
    };
}
const numberOfNodes = function (operation, count = 0) {
    if ("inputOperation" in operation)
        return numberOfNodes(operation.inputOperation, count + 1);
    return count;
};
function boundOrUnboundVariable(pattern, setOfBoundVarsBefore) {
    if (typeof pattern === "string")
        return isBoundVariable(pattern, setOfBoundVarsBefore) ? "boundVar" : "unboundVar";
    else
        return "const";
}
function isBoundVariable(variable, setOfVarsBefore) {
    return setOfVarsBefore.has(variable);
}
export function isLeftJoinLinear(operation) {
    const leftOp = operation.inputOperations[0];
    if (leftOp.operationType !== "LeftJoin")
        return false;
    const flattenOp = flattenLeftJoin(operation);
    if (flattenOp.length < 3)
        return false;
    if (flattenOp[0].id === IDENTITY.id)
        return false;
    const leftJoinOp1 = new Set(getVariablesMentionedByOperation(flattenOp[0]));
    const leftJoinOp2 = new Set(getVariablesMentionedByOperation(flattenOp[1]));
    const leftJoinOp3 = new Set(getVariablesMentionedByOperation(flattenOp[2]));
    const intersectionOfOp2AndOp3 = intersection(leftJoinOp2, leftJoinOp3);
    if (intersectionOfOp2AndOp3.size === 0)
        return true;
    if (intersectionOfOp2AndOp3.size > 0 && isSubset(intersectionOfOp2AndOp3, leftJoinOp1))
        return true;
    return false;
}
export function flattenLeftJoin(operation) {
    const copyOfOperation = { ...operation };
    if (copyOfOperation.inputOperations[0].operationType !== "LeftJoin")
        return [...copyOfOperation.inputOperations];
    const leftOp = flattenLeftJoin(copyOfOperation.inputOperations[0]);
    const rightOp = copyOfOperation.inputOperations[1];
    return [...leftOp, rightOp];
}
export async function optimizeMultipleGraphsOperation(operation, statistics) {
    if (operation.operationType === "TriplePattern" &&
        typeof operation.pattern[1] === "object" &&
        operation.pattern[1].termType === "NamedNode" &&
        typeof operation.graphs !== "string") {
        const gotGraphs = await statistics.getGraphsMatchingPredicateIfNotInAllGraphs(operation.pattern[1]);
        if (gotGraphs === undefined) {
            return operation;
        }
        if (!isNonEmptyGraphArray(gotGraphs))
            return NOTHING;
        const optimizedOperation = { ...operation, graphs: gotGraphs };
        return optimizedOperation;
    }
    if ("inputOperation" in operation) {
        const optimizedToBeOperation = { ...operation };
        optimizedToBeOperation.inputOperation = await optimizeMultipleGraphsOperation(optimizedToBeOperation.inputOperation, statistics);
        return optimizedToBeOperation;
    }
    if ("inputOperations" in operation) {
        const optimizedToBeOperation = { ...operation };
        optimizedToBeOperation.inputOperations = (await Promise.all(optimizedToBeOperation.inputOperations.map(async (inputoperations) => {
            return optimizeMultipleGraphsOperation(inputoperations, statistics);
        })));
        return optimizedToBeOperation;
    }
    return operation;
}
function isNonEmptyGraphArray(graphArray) {
    return graphArray.length > 0;
}
export function optimizeZeroOrMoreOperation(algebra) {
    forEachAlgebraNode(algebra, (operation) => {
        if (operation.operationType !== "Join")
            return;
        const joinsOperations = [...operation.inputOperations];
        operation.inputOperations = reWriteInputOperations(joinsOperations);
    }, () => { }, undefined);
}
function reWriteInputOperations(joinsOperations) {
    const shouldOptimizeForPropertyPath = joinsOperations.some(function (operation) {
        return operation.operationType === "ZeroOrMorePath";
    });
    if (!shouldOptimizeForPropertyPath)
        return joinsOperations;
    return joinsOperations.map((operation, index) => {
        if (operation.operationType === "ZeroOrMorePath") {
            if (index === 0) {
                throw new FatalError("Unexpected zero-or-more path operation as the first operation in a group. Please contact a developer.");
            }
            if (joinsOperations.slice(0, index - 1).some((inputOperation) => getVariablesMatchedByOperation(inputOperation).includes(operation.end) &&
                inputOperation.operationType !== "Union")) {
                return {
                    ...operation,
                    boundStart: operation.end,
                    end: operation.boundStart,
                };
            }
        }
        return operation;
    });
}
//# sourceMappingURL=optimize-reorder.js.map