import { FatalError } from "./Errors.js";
export function specificationToMessage(allowed) {
    if (typeof allowed === "string")
        return allowed;
    if (allowed.length === 1)
        return allowed[0];
    return allowed.slice(0, -1).join(", ") + " or " + allowed[allowed.length - 1];
}
export function validateBindings(bindings, specification) {
    for (const variable in bindings) {
        const allowedTermTypes = specification[variable];
        const binding = bindings[variable];
        if (binding === undefined) {
            throw new FatalError(`The variable ?${variable} occurs as a key in the bindings, but has an undefined value.`);
        }
        else if (allowedTermTypes && allowedTermTypes !== "Term" && !allowedTermTypes.includes(binding.termType))
            throw new FatalError(`Expected the variable ?${variable} to be bound to a ${specificationToMessage(allowedTermTypes)}, but it is a ${binding.termType}`);
    }
    for (const variable in specification) {
        if (!specification[variable] || specification[variable].includes("unbound"))
            continue;
        if (!bindings[variable])
            throw new FatalError(`Expected the variable ?${variable} to be bound, but it is unbound.`);
    }
}
export async function* validateAsyncBindingsIterable(bindingses, specification) {
    for await (const bindings of bindingses) {
        validateBindings(bindings, specification);
        yield bindings;
    }
}
//# sourceMappingURL=validateBindings.js.map