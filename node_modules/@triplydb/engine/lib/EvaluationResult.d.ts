import { AggregateFunction } from "./Algebra/Expression.js";
import { Term, Variable } from "./constants.js";
import "@triplydb/data-factory/Terms.js";
export declare const TRUE: {
    readonly evaluationResultType: "value";
    readonly term: import("@triplydb/data-factory/Terms.js").Literal<string>;
};
export declare const FALSE: {
    readonly evaluationResultType: "value";
    readonly term: import("@triplydb/data-factory/Terms.js").Literal<string>;
};
export declare const invalidArgumentTypesError: InvalidArgumentTypes;
interface PartialAverage {
    total: EvaluationResult;
    count: number;
}
export interface PartialGroupConcat {
    data: EvaluationResult;
    count: number;
    separator: string;
}
interface PartialCount {
    count: number;
}
interface PartialSum {
    value: EvaluationResult;
}
interface PartialSample {
    value: Term | undefined;
}
interface PartialMin {
    value: EvaluationResult | undefined;
}
interface PartialMax {
    value: EvaluationResult | undefined;
}
export type AggregationFunctionNames = AggregateFunction["function"];
type IntermediateValue = {
    AVG: PartialAverage;
    COUNT: PartialCount;
    GROUP_CONCAT: PartialGroupConcat;
    SAMPLE: PartialSample;
    SUM: PartialSum;
    MIN: PartialMin;
    MAX: PartialMax;
};
interface IAggregationBody<K extends AggregationFunctionNames> {
    initData: () => IntermediateValue[K];
    partialUpdate: (data: IntermediateValue[K], result: EvaluationResult) => void;
    finalizeResult: (data: IntermediateValue[K]) => EvaluationResult;
}
export type AggregationType<T extends AggregationFunctionNames> = {
    [K in T]: Readonly<IAggregationBody<K>>;
};
export type EvaluationErrorName = "CastError" | "CoalesceError" | "EffectiveBooleanValueError" | "EmptyAggregateError" | "IncompatibleLanguageOperation" | "InError" | "InvalidArgumentTypes" | "InvalidGraphName" | "InvalidLexicalForm" | "InvalidIri" | "InvalidTimezoneCall" | "RDFEqualTypeError" | "UnboundVariableError" | "UndefinedComparisonError";
export type HashAlgorithm = "md5" | "sha1" | "sha256" | "sha384" | "sha512";
export type EvaluationResult = EvaluationError | Value;
export type EvaluationError = CastError | CoalesceError | EffectiveBooleanValueError | EmptyAggregateError | IncompatibleLanguageOperation | InError | InvalidArgumentTypes | InvalidGraphName | InvalidLexicalForm | InvalidIri | InvalidTimezoneCall | RDFEqualTypeError | UnboundVariableError | UndefinedComparisonError;
interface BaseEvaluationResult {
    evaluationResultType: "error" | "value";
}
export interface Value<T extends Term = Term> extends BaseEvaluationResult {
    evaluationResultType: "value";
    term: T;
}
interface BaseEvaluationError extends BaseEvaluationResult {
    evaluationResultType: "error";
    errorType: EvaluationErrorName;
}
export interface UnboundVariableError extends BaseEvaluationError {
    errorType: "UnboundVariableError";
    variable: Variable;
}
export interface UndefinedComparisonError extends BaseEvaluationError {
    errorType: "UndefinedComparisonError";
}
export interface InvalidLexicalForm extends BaseEvaluationError {
    errorType: "InvalidLexicalForm";
}
export interface InvalidIri extends BaseEvaluationError {
    errorType: "InvalidIri";
    value: string;
}
export interface RDFEqualTypeError extends BaseEvaluationError {
    errorType: "RDFEqualTypeError";
}
export interface CoalesceError extends BaseEvaluationError {
    errorType: "CoalesceError";
}
export interface InError extends BaseEvaluationError {
    errorType: "InError";
}
export interface InvalidArgumentTypes extends BaseEvaluationError {
    errorType: "InvalidArgumentTypes";
}
export interface InvalidGraphName extends BaseEvaluationError {
    errorType: "InvalidGraphName";
}
export interface CastError extends BaseEvaluationError {
    errorType: "CastError";
}
export interface InvalidTimezoneCall extends BaseEvaluationError {
    errorType: "InvalidTimezoneCall";
}
export interface IncompatibleLanguageOperation extends BaseEvaluationError {
    errorType: "IncompatibleLanguageOperation";
}
export interface EmptyAggregateError extends BaseEvaluationError {
    errorType: "EmptyAggregateError";
}
export interface EffectiveBooleanValueError extends BaseEvaluationError {
    errorType: "EffectiveBooleanValueError";
}
export {};
//# sourceMappingURL=EvaluationResult.d.ts.map