import { EvaluationError } from "./EvaluationResult.js";
import { Term } from "./constants.js";
import { isNumericDatatype } from "@triplydb/recognized-datatypes/utils/constants.js";
import { NamedNode, Literal, BlankNode } from "@triplydb/data-factory/Terms.js";
import { Operation } from "./Algebra/Operation.js";
import { AggregateFunction, Expression } from "./Algebra/Expression.js";
import { DATA_TYPE_NAME_MAPPING } from "@triplydb/recognized-datatypes/utils/constants.js";
import * as SparqlJs from "sparqljs";
export type Prefixes = SparqlJs.ParserOptions["prefixes"];
export declare function parse(queryString: string, opts: {
    baseIri: string;
    prefixes?: Prefixes;
}): SparqlJs.SparqlQuery;
export declare function basicLanguageTagFilter(tags: string | string[], ranges: string | string[]): string[];
export declare function isSupportedFlag(flag: string): boolean | undefined;
export declare function deplete<T>(iterable: Iterable<T> | AsyncIterable<T>, maxResults?: number): Promise<T[]>;
export declare function next<T>(iterable: Iterable<T> | AsyncIterable<T>): Promise<T | undefined>;
export declare function forEachAlgebraNode<State>(node: Operation | AggregateFunction | Expression, onOperation: (operation: Operation, state: State) => State, onExpression: (expression: AggregateFunction | Expression, state: State) => State, state: State): void;
export declare function getSharedLanguageTag(terms: Term[]): string | NamedNode;
export declare function getMatchingDatatypeOrLanguage(firstvalue: Term, secondvalue: Term): EvaluationError | string | NamedNode;
export declare function changeLiteralValue(literal: Literal, value: string): Literal;
export declare function ValidateLiteralOrNamedNode(terms: Term[], valueType: ValidationType[][]): EvaluationError | undefined;
export declare function canonicalToNumber(n: string): number;
export declare function decimalToRoundedString(value: number, sd?: number): string;
declare function isStringLiteral(term: Term): boolean;
declare function isIntegerLiteral(term: Term): boolean;
declare function isBooleanLiteral(term: Term): boolean;
declare function isDateTimeLiteral(term: Term): boolean;
export declare function isLanguageLiteral(term: Term): term is Literal<(typeof DATA_TYPE_NAME_MAPPING)["RDF_LANG_STRING"]>;
declare function isLiteral(term: Term): term is Literal;
declare function isNamedNode(term: Term): term is NamedNode;
declare function isBlankNode(term: Term): term is BlankNode;
export declare function isDerivedFromIntegerLiteral(term: Term): boolean;
export declare function isDerivedFromStringLiteral(term: Term): boolean;
export declare function isDerivedFromDecimalLiteral(term: Term): boolean;
export declare function isDerivedFromDateTimeLiteral(term: Term): boolean;
export type ValidationType = (term: Term) => boolean;
export declare const validators: {
    literal: typeof isLiteral;
    namedNode: typeof isNamedNode;
    blankNode: typeof isBlankNode;
    stringLiteral: typeof isStringLiteral;
    integerLiteral: typeof isIntegerLiteral;
    languageLiteral: typeof isLanguageLiteral;
    booleanLiteral: typeof isBooleanLiteral;
    dateTimeLiteral: typeof isDateTimeLiteral;
    numericDatatype: typeof isNumericDatatype;
    derivedFromIntegerLiteral: typeof isDerivedFromIntegerLiteral;
    derivedFromStringLiteral: typeof isDerivedFromStringLiteral;
    derivedFromDateTime: typeof isDerivedFromDateTimeLiteral;
};
export declare function throwAggregateError(value: string): void;
export {};
//# sourceMappingURL=Helpers.d.ts.map