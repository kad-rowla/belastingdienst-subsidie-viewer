import { DATA_TYPES } from "../constants.js";
import log from "../Debugging.js";
export function rdfjsTerm2sparqlJsonTerm(term) {
    switch (term.termType) {
        case "NamedNode":
            return { type: "uri", value: term.value };
        case "BlankNode":
            return { type: "bnode", value: term.value };
        case "Literal":
            term.datatype;
            if (term.language) {
                return { type: "literal", value: term.value, "xml:lang": term.language };
            }
            else {
                if (term.datatype.equals(DATA_TYPES.XSD_STRING)) {
                    return { type: "literal", value: term.value };
                }
                else {
                    return { type: "literal", value: term.value, datatype: term.datatype.value };
                }
            }
    }
}
export function toSparqlResults(bindingsAsRdfjs) {
    const bindingsAsJson = [];
    for (let binding of bindingsAsRdfjs) {
        const bindingAsJson = {};
        for (let [variable, term] of Object.entries(binding)) {
            if (!term)
                continue;
            const sparqlJsonTerm = rdfjsTerm2sparqlJsonTerm(term);
            bindingAsJson[variable] = sparqlJsonTerm;
        }
        bindingsAsJson.push(bindingAsJson);
    }
    log("sparql:serialize:toJsonResults", `${bindingsAsJson.length} bindings made`);
    const results = {
        results: {
            bindings: bindingsAsJson,
        },
    };
    return results;
}
export function toSparqlHead(variables) {
    return {
        head: {
            vars: variables,
        },
    };
}
export function selectQuerytoSparqlJson(variables, rows) {
    const boundVariables = [];
    for (let row of rows) {
        for (let variable of Object.keys(row)) {
            if (!boundVariables.includes(variable))
                boundVariables.push(variable);
            if (!variables.includes(variable))
                delete row[variable];
        }
    }
    const unBoundVariables = variables.filter((v) => !boundVariables.includes(v));
    if (unBoundVariables.length) {
        log("sparql:serialize:toSparqlJson:warning", `Unbound variables: '${unBoundVariables}'`);
        log("sparql:serialize:toSparqlJson:success", `Bound variables: '${boundVariables}'`);
    }
    else {
        log("sparql:serialize:toSparqlJson:success", "All variables were bound");
    }
    const sparqlResults = { ...toSparqlHead(variables), ...toSparqlResults(rows) };
    return sparqlResults;
}
//# sourceMappingURL=sparql2json.js.map