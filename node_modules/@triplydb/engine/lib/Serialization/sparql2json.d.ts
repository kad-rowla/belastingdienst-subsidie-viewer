import * as Terms from "@triplydb/data-factory/Terms.js";
import { Bindings, Term, Variable } from "../constants.js";
export type SparqlJsonIri = {
    type: "uri";
    value: string;
};
export type SparqlJsonBlankNode = {
    type: "bnode";
    value: string;
};
type SparqlJsonBaseLiteral = {
    type: "literal";
    value: string;
};
export type SparqlJsonLiteral = ({
    ["xml:lang"]?: never;
} & SparqlJsonBaseLiteral) | ({
    datatype: string;
    ["xml:lang"]?: never;
} & SparqlJsonBaseLiteral) | ({
    datatype?: never;
    ["xml:lang"]: string;
} & SparqlJsonBaseLiteral);
type SelectJsonHead = {
    head: {
        vars: Variable[];
        link?: string[];
    };
};
type SelectJsonResults = {
    results: {
        bindings: Array<{
            [variable: Variable]: SparqlJsonIri | SparqlJsonBlankNode | SparqlJsonLiteral;
        }> | [];
    };
};
export type SelectJson = SelectJsonHead & SelectJsonResults;
export type AskJson = {
    head: {};
    boolean: boolean;
};
export type SparqlJson = SelectJson | AskJson;
type SparqlJsonTerm<T extends Term> = T extends Terms.NamedNode ? SparqlJsonIri : T extends Terms.BlankNode ? SparqlJsonBlankNode : T extends Terms.Literal ? SparqlJsonLiteral : never;
export declare function rdfjsTerm2sparqlJsonTerm<T extends Term>(term: T): SparqlJsonTerm<T>;
export type BindingAsJson = {
    [variable: string]: SparqlJsonIri | SparqlJsonBlankNode | SparqlJsonLiteral;
};
export declare function toSparqlResults(bindingsAsRdfjs: Bindings<Term>[]): SelectJsonResults;
export declare function toSparqlHead(variables: Variable[]): SelectJsonHead;
export declare function selectQuerytoSparqlJson(variables: Variable[], rows: Bindings<Term>[]): SelectJson;
export {};
//# sourceMappingURL=sparql2json.d.ts.map