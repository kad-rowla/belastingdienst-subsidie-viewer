import log from "./Debugging.js";
import { dataFactory, DEFAULT_BASE_IRI } from "./constants.js";
import { BindingsResult, BooleanResult, DebugResult, QuadsResult } from "./QueryResults.js";
import { SparqlError, UnknownFunctionError, UnsupportedError } from "./Errors.js";
import { optimizeAlgebra } from "./Algebra/Optimization/optimize-reorder.js";
import { createHash } from "crypto";
import { deplete } from "./Helpers.js";
import { scopeVariables } from "./Algebra/ASTtoAlgebra/variableScope.js";
import { rewriteDescribeQuery } from "./Algebra/ASTtoAlgebra/translationUtils.js";
import { parse } from "./Helpers.js";
import { operationFromScopedAst, templatesFromAst, } from "./Algebra/ASTtoAlgebra/index.js";
import { getDataDefinedFunctionInfo, getPrefixes } from "./shaclSparqlFunctions.js";
import { optimizeAlgebraLight } from "./Algebra/Optimization/optimize-light.js";
import { validateAsyncBindingsIterable } from "./validateBindings.js";
const magicPrefix = "https://triplydb.com/Triply/sparql/id/value/";
const DEBUG_QUERY_RESULT_TYPE = {
    SELECT: "bindings",
    CONSTRUCT: "quads",
    DESCRIBE: "quads",
    ASK: "bindings",
};
export class QueryEngine {
    executor;
    optimize;
    dataDefinedFunctions = {};
    constructor(executor, opts) {
        this.executor = executor;
        this.optimize = opts.optimize;
    }
    async select(query, bindingsType) {
        return this.query(query, { queryType: "SELECT", bindingsType: bindingsType ?? {} });
    }
    async construct(query) {
        return this.query(query, { queryType: "CONSTRUCT" });
    }
    async describe(query) {
        return this.query(query, { queryType: "DESCRIBE" });
    }
    async ask(query) {
        return (await this.query(query, { queryType: "ASK" })).result();
    }
    async query(query, options) {
        log("sparql:queryString", query);
        const ast = parse(query, { baseIri: options?.baseIri ?? DEFAULT_BASE_IRI });
        if (ast.type !== "query")
            throw new UnsupportedError("Only SELECT, CONSTRUCT, DESCRIBE and ASK queries are supported.");
        if (options?.queryType && ast.queryType !== options.queryType)
            throw new SparqlError(`Expected ${options.queryType} query, but got ${ast.queryType} query.`);
        return this.queryAst(ast, options);
    }
    async queryAst(ast, options) {
        let baseIri = ast.base ?? options?.baseIri ?? DEFAULT_BASE_IRI;
        const magicPrefixOptions = buildPrefixOptions(ast, options);
        const optimize = magicPrefixOptions.optimize ?? this.optimize;
        const isDebugFlagOn = magicPrefixOptions.debugOnly || magicPrefixOptions.debugOnCompletion;
        const rdfDataset = this.executor.getRdfDataset(ast.from);
        const updatedOptions = {
            abortSignal: options?.abortSignal,
            baseIri,
            rdfDataset,
            ...magicPrefixOptions,
        };
        const debugInfo = { optimize };
        let executedQuery;
        const resultType = DEBUG_QUERY_RESULT_TYPE[ast.queryType];
        try {
            log("sparql:translate:ast", "Translating AST:\n%D", ast);
            if (ast.queryType === "DESCRIBE")
                ast = rewriteDescribeQuery(ast);
            ast = scopeVariables(ast);
            let operation = operationFromScopedAst(ast, {
                dataDefinedFunctions: this.dataDefinedFunctions,
                variablesToTranslateWithoutErrorChecking: new Set(),
                namedGraphs: rdfDataset.namedGraphs,
            });
            debugInfo.operation = operation;
            log("sparql:translate:algebra:unoptimized", "Resulting algebra:\n%D", operation);
            if (optimize) {
                const lightOptimization = optimizeAlgebraLight(operation);
                const statistics = this.executor.getPredicateStatsAndGraphs();
                if (!statistics) {
                    throw new SparqlError("Unable to optimize this query, as we are missing statistics.");
                }
                const optimizationResult = await optimizeAlgebra(lightOptimization, statistics);
                debugInfo.optimizedAlgebra = operation = optimizationResult.operation;
                debugInfo.estimatedComplexity = optimizationResult.estimatedComplexity;
                log("sparql:translate:algebra:optimized", "Optimized algebra:\n%D", operation);
            }
            if (magicPrefixOptions.debugOnly) {
                return new DebugResult(resultType, debugInfo);
            }
            executedQuery = this.executor.query(operation, updatedOptions);
            if (updatedOptions?.debugOnCompletion) {
                await deplete(executedQuery.results);
                return new DebugResult(resultType, debugInfo, executedQuery.queryContext);
            }
            switch (ast.queryType) {
                case "SELECT":
                    return new BindingsResult(options?.bindingsType
                        ? validateAsyncBindingsIterable(executedQuery.results, options.bindingsType)
                        : executedQuery.results, ast.variables.map((v) => ("variable" in v ? v.variable : v).value), executedQuery.queryContext);
                case "ASK":
                    return new BooleanResult(executedQuery.results, executedQuery.queryContext);
                case "CONSTRUCT":
                    return new QuadsResult(fillOutConstructTemplates(executedQuery.results, templatesFromAst(ast.template)), executedQuery.queryContext);
            }
        }
        catch (e) {
            const error = e;
            if (isDebugFlagOn) {
                return executedQuery
                    ? new DebugResult(resultType, debugInfo, executedQuery.queryContext, error)
                    : new DebugResult(resultType, debugInfo, undefined, error);
            }
            throw e;
        }
    }
    async initializeShaclSparqlFunctions() {
        const prefixes = await getPrefixes(this);
        const results = await this.select(`
      PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
      PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
      PREFIX sh: <http://www.w3.org/ns/shacl#>
      SELECT * WHERE {
        ?f rdf:type/rdfs:subClassOf* sh:SPARQLFunction
      }
    `, { f: ["NamedNode", "BlankNode"] });
        let queue = [];
        for await (const { f } of results) {
            if (f.termType === "NamedNode")
                queue.push(f);
        }
        let lastQueue;
        do {
            lastQueue = queue;
            queue = [];
            for (const functionNode of lastQueue) {
                try {
                    this.dataDefinedFunctions[functionNode.value] = await getDataDefinedFunctionInfo(this, functionNode, prefixes);
                }
                catch (e) {
                    if (e instanceof UnknownFunctionError) {
                        queue.push(functionNode);
                    }
                    else
                        throw e;
                }
            }
        } while (lastQueue.length > queue.length);
        if (queue.length)
            throw new UnsupportedError("The following SHACL SPARQL functions are (mututally) recursive, which isn't supported: " +
                queue.map(({ id }) => id).join(" "));
    }
}
const buildPrefixOptions = (ast, options) => {
    const disableTermValidation = getQueryOptionBoolean(ast, "triply_disabletermvalidation") ?? options?.disableTermValidation;
    const optimizationOptions = getQueryOptionBoolean(ast, "triply_optimize");
    let debugOnlyFlag = !!getQueryOptionBoolean(ast, "triply_debugonly");
    const debugOnCompletion = !!getQueryOptionBoolean(ast, "triply_debugoncompletion");
    if (debugOnlyFlag && debugOnCompletion) {
        debugOnlyFlag = false;
    }
    return {
        optimize: optimizationOptions,
        disableTermValidation: !!disableTermValidation,
        debugOnly: debugOnlyFlag,
        debugOnCompletion: debugOnCompletion,
    };
};
const getQueryOptionBoolean = (ast, prefixKey) => {
    let value = ast.prefixes[prefixKey]?.split(magicPrefix)[1];
    if (!value)
        return undefined;
    value = value.toLocaleLowerCase();
    return value === "true" ? true : value === "false" ? false : undefined;
};
export function* fillOutTripleTemplates(bindings, templates, mutable, graph) {
    const aliasToBlankNode = new Map();
    function getOrAddBlankNode(alias) {
        let blankNode = aliasToBlankNode.get(alias);
        if (!blankNode) {
            mutable.blankNodeCounter += 1;
            log("sparql:engine:construct:blankNodeCounter", "Blank node counter is :", mutable.blankNodeCounter);
            blankNode = dataFactory.blankNode(mutable.blankNodeCounter.toString());
            aliasToBlankNode.set(alias, blankNode);
        }
        return blankNode;
    }
    for (const triplePattern of templates) {
        let subject;
        let predicate;
        let object;
        if (typeof triplePattern.subject === "string") {
            const term = bindings[triplePattern.subject];
            if (!term) {
                log("sparql:engine:construct:unboundSubject", "Unbound variable", triplePattern.subject, "in subject position.");
                continue;
            }
            if (term.termType === "Literal") {
                log("sparql:engine:construct:illegalSubject", "Illegal literal", term, "in subject position.");
                continue;
            }
            subject = term;
        }
        else if (triplePattern.subject.termType === "BlankNode") {
            subject = getOrAddBlankNode(triplePattern.subject.value);
        }
        else {
            subject = triplePattern.subject;
        }
        if (typeof triplePattern.predicate === "string") {
            const term = bindings[triplePattern.predicate];
            if (!term) {
                log("sparql:engine:construct:unboundPredicate", "Unbound variable", triplePattern.predicate, "in predicate position.");
                continue;
            }
            if (term.termType !== "NamedNode") {
                log("sparql:engine:construct:illegalPredicate", "Illegal term", term, "in predicate position.");
                continue;
            }
            predicate = term;
        }
        else {
            predicate = triplePattern.predicate;
        }
        if (typeof triplePattern.object === "string") {
            const term = bindings[triplePattern.object];
            if (!term) {
                log("sparql:engine:construct:unboundObject", "Unbound variable", triplePattern.object, "in object position.");
                continue;
            }
            object = term;
        }
        else if (triplePattern.object.termType === "BlankNode") {
            object = getOrAddBlankNode(triplePattern.object.value);
        }
        else {
            object = triplePattern.object;
        }
        const quad = dataFactory.quad(subject, predicate, object, graph);
        const hash = createHash("md5").update(quad.id).digest("hex");
        if (mutable.hashedQuads.has(hash)) {
            continue;
        }
        if (mutable.hashedQuads.size > 16000000) {
            mutable.hashedQuads.clear();
        }
        mutable.hashedQuads.add(hash);
        log("sparql:engine:quad", "Quad is: ", quad);
        yield quad;
    }
}
export async function* fillOutConstructTemplates(results, templates, graph) {
    const mutableState = {
        blankNodeCounter: 0,
        hashedQuads: new Set(),
    };
    for await (const bindings of results) {
        yield* fillOutTripleTemplates(bindings, templates, mutableState, graph);
    }
}
//# sourceMappingURL=QueryEngine.js.map