import log from "./Debugging.js";
import { deplete } from "./Helpers.js";
import {
  AskJson,
  BindingAsJson,
  rdfjsTerm2sparqlJsonTerm,
  SelectJson,
  selectQuerytoSparqlJson,
  toSparqlHead,
  toSparqlResults,
} from "./Serialization/sparql2json.js";
import { Bindings, Quad, Term, Variable } from "./constants.js";
import { QueryContext } from "./QueryContext.js";
import { AsyncBindingsIterable } from "./Execution.js";
import { Readable } from "stream";
import { Operation } from "./Algebra/Operation.js";
import { dataFactory, DATA_TYPES } from "./constants.js";
import { DebugInfo, fillOutConstructTemplates } from "./QueryEngine.js";
import { TripleTemplates } from "./Algebra/ASTtoAlgebra/index.js";

abstract class BaseResult<T> {
  // We do some extra bookkeeping to avoid the results being read twice. This is not supported
  abstract type: string;
  protected iteratorCalled = false;
  protected results: T;

  protected markIteratorCalled() {
    if (this.iteratorCalled) throw new Error("Cannot fetch query results multiple times");
    this.iteratorCalled = true;
  }

  public readonly queryContext: QueryContext;
  constructor(results: T, queryContext: QueryContext) {
    this.queryContext = queryContext;
    this.results = results;
  }
}

abstract class BaseIterableResult<E> extends BaseResult<AsyncIterable<E>> implements AsyncIterable<E> {
  [Symbol.asyncIterator]() {
    this.markIteratorCalled();
    return this.results[Symbol.asyncIterator]();
  }
}

export class BooleanResult extends BaseResult<AsyncBindingsIterable> {
  public readonly type = "boolean";

  public async sparqlJson(): Promise<AskJson> {
    const result = await this.result();
    return { head: {}, boolean: result };
  }

  public async result(): Promise<boolean> {
    this.markIteratorCalled();
    for await (const _ of this.results) {
      this.queryContext.logCounts();
      return true;
    }
    this.queryContext.logCounts();
    return false;
  }
}

export class BindingsResult<B extends Bindings<Term> = Bindings<Term>> extends BaseIterableResult<B> {
  public readonly type = "bindings";
  public readonly variables: ReadonlyArray<string>;

  constructor(results: AsyncIterable<B>, variables: string[], queryContext: QueryContext) {
    async function* projectedResults() {
      for await (const unprojectedRow of results) {
        const row: Bindings<Term> = {};
        for (const variable of variables) {
          const binding = unprojectedRow[variable];
          if (binding) row[variable] = binding;
        }
        yield row as B;
      }
    }
    super(projectedResults(), queryContext);
    this.variables = variables;
  }

  public async sparqlJson(): Promise<SelectJson> {
    const bindingsAsRdfjs = await this.toArray();
    const queryResults = selectQuerytoSparqlJson([...this.variables], bindingsAsRdfjs);
    log("sparql:engine:query:select:results", "Select query results: %D ", queryResults);
    return queryResults;
  }

  public serializedSparqlJsonStream() {
    return Readable.from(
      (async function* (
        variables: ReadonlyArray<Variable>,
        iterator: AsyncBindingsIterable,
        queryContext: QueryContext
      ): AsyncGenerator<string> {
        yield `{ "head": { "vars": ${JSON.stringify(variables)} }, "results": {"bindings": [`;
        let isFirst = true;
        for await (const row of iterator) {
          const bindingAsJson: BindingAsJson = {};
          for (const [variable, term] of Object.entries(row)) {
            if (!term) continue;
            const sparqlJsonTerm = rdfjsTerm2sparqlJsonTerm(term);
            bindingAsJson[variable] = sparqlJsonTerm;
          }
          const jsonSerializedBinding = JSON.stringify(bindingAsJson);
          log("sparql:resultstream", "Result: %D", jsonSerializedBinding);
          yield `${isFirst ? "" : ","}${jsonSerializedBinding}`;
          isFirst = false;
        }
        yield "]}}";
        log("sparql:resultstream", "Done!");
        queryContext.logCounts();
      })(this.variables, this, this.queryContext)
    );
  }

  public async toArray() {
    const array = deplete(this);
    this.queryContext.logCounts();
    return array;
  }
}

export class QuadsResult extends BaseIterableResult<Quad> {
  public readonly type = "quads";

  public async quads(): Promise<Quad[]> {
    const quads = deplete(this);
    this.queryContext.logCounts();
    return quads;
  }

  public stream() {
    return Readable.from(
      (async function* (iterator: AsyncIterable<Quad>, queryContext: QueryContext) {
        for await (const quad of iterator) {
          yield quad;
        }
        log("sparql:resultstream", "Done!");
        queryContext.logCounts();
      })(this, this.queryContext)
    );
  }
}

// Special result that will hold debug information and can return sparqlJSON (or) Quads
export class DebugResult {
  protected iteratorCalled = false;
  // We will treat the default debug result as bindings.
  public type: (BooleanResult | BindingsResult | QuadsResult)["type"];
  public readonly queryContext?: QueryContext;
  private debugInfo: DebugInfo;
  private error?: Error;

  constructor(type: DebugResult["type"], debugInfo: DebugInfo, queryContext?: QueryContext, error?: Error) {
    this.type = type;
    this.debugInfo = debugInfo;
    this.queryContext = queryContext;
    this.error = error;
  }
  protected markIteratorCalled() {
    if (this.iteratorCalled) throw new Error("Cannot fetch debug results multiple times");
    this.iteratorCalled = true;
  }

  private constructBindings() {
    let debugBindings: Bindings<Term>;

    if (this.debugInfo.operation === undefined) {
      debugBindings = {
        error: this.error ? dataFactory.literal(this.error.message, DATA_TYPES.XSD_STRING) : undefined,
        errorStack: this.error?.stack ? dataFactory.literal(this.error.stack, DATA_TYPES.XSD_STRING) : undefined,
      };
    } else {
      const algebra: Operation = this.queryContext
        ? this.queryContext.mergeCountsWithAlgebra()
        : this.debugInfo.optimizedAlgebra || this.debugInfo.operation;

      debugBindings = {
        algebra: dataFactory.literal(JSON.stringify(algebra)),
        estimatedComplexity: this.debugInfo.estimatedComplexity
          ? dataFactory.literal(this.debugInfo.estimatedComplexity, DATA_TYPES.XSD_DOUBLE)
          : undefined,
        isOptimized:
          this.debugInfo.optimize === undefined
            ? dataFactory.literal("unknown")
            : dataFactory.literal(this.debugInfo.optimize, DATA_TYPES.XSD_BOOLEAN),
        disableTermValidation: this.queryContext
          ? dataFactory.literal(this.queryContext.disableTermValidation, DATA_TYPES.XSD_BOOLEAN)
          : dataFactory.literal("unknown"),
        error: this.error ? dataFactory.literal(this.error.message) : undefined,
        errorStack: this.error?.stack ? dataFactory.literal(this.error.stack) : undefined,
      };
    }

    // Clean up any undefined properties from the sparqlJson()
    const bindings = Object.keys(debugBindings)
      .filter((a) => debugBindings[a] !== null && debugBindings[a] !== undefined)
      .reduce((c: Bindings<Term>, a) => {
        c[a] = debugBindings[a];
        return c;
      }, {});
    return bindings;
  }

  private async *asyncBindingIterable() {
    yield this.constructBindings();
  }

  public async sparqlJson(): Promise<SelectJson> {
    this.markIteratorCalled();
    const bindings = this.constructBindings();
    const sparqlResults: SelectJson = { ...toSparqlHead(Object.keys(bindings)), ...toSparqlResults([bindings]) };
    return sparqlResults;
  }

  public async quads(): Promise<Quad[]> {
    return deplete(this.asyncQuadsIterable());
  }

  private asyncQuadsIterable() {
    this.markIteratorCalled();
    const templates: TripleTemplates = [
      { subject: dataFactory.namedNode("d:algebra"), predicate: DATA_TYPES.XSD_STRING, object: "algebra" },
      {
        subject: dataFactory.namedNode("d:estimatedComplexity"),
        predicate: DATA_TYPES.XSD_DOUBLE,
        object: "estimatedComplexity",
      },
      { subject: dataFactory.namedNode("d:isOptimized"), predicate: DATA_TYPES.XSD_BOOLEAN, object: "isOptimized" },
      {
        subject: dataFactory.namedNode("d:disableTermValidation"),
        predicate: DATA_TYPES.XSD_BOOLEAN,
        object: "disabletermvalidation",
      },
      { subject: dataFactory.namedNode("d:error"), predicate: DATA_TYPES.XSD_STRING, object: "error" },
      { subject: dataFactory.namedNode("d:errorStack"), predicate: DATA_TYPES.XSD_STRING, object: "errorStack" },
    ];
    return fillOutConstructTemplates(this.asyncBindingIterable(), templates);
  }

  public stream() {
    if (this.type === "bindings") return Readable.from(this.asyncBindingIterable());
    else return Readable.from(this.asyncQuadsIterable());
  }
}
