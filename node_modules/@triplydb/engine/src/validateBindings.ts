import { Bindings, Term } from "./constants.js";
import { FatalError } from "./Errors.js";
import { ElementOf } from "ts-essentials";
import { AsyncBindingsIterable } from "./Execution.js";

type TermTypeToTerm = {
  [T in Term as T["termType"]]: T;
} & {
  Term: Term;
  unbound: undefined;
};
export type BindingsType = { [variable: string]: keyof TermTypeToTerm | readonly (Term["termType"] | "unbound")[] };
type ElementOrArrayToUnion<T> = T extends readonly any[] ? ElementOf<T> : T;

export type SpecificationToBindings<T extends BindingsType> = Expand<
  {
    // If a variable can possibly be undefined, exclude it from the list of required variable bindings
    [K in keyof T as undefined extends TermTypeToTerm[ElementOrArrayToUnion<T[K]>]
      ? never
      : K]: TermTypeToTerm[ElementOrArrayToUnion<T[K]>];
  } & {
    // If a variable can possibly be undefined, but only if it isn't required to be undefined,
    // we add it as an optional binding
    [K in keyof T as undefined extends TermTypeToTerm[ElementOrArrayToUnion<T[K]>]
      ? TermTypeToTerm[ElementOrArrayToUnion<T[K]>] extends undefined
        ? never
        : K
      : K]?: TermTypeToTerm[ElementOrArrayToUnion<T[K]>];
  } & Bindings<Term> // finally, we default to allowing anything that wasn't mentioned
>;

/**
 * Expand a type one level deep
 *
 * From: https://stackoverflow.com/a/57683652
 * Used to make `SpecifcationToBindings<...>` expand to something more readable.
 *
 * For example `Expand<SpecificationToBindings<{a: ["NamedNode", "Literal"]}>>`
 * becomes `{a: Terms.NamedNode | Terms.Literal }`
 */
type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;

export function specificationToMessage(allowed: string | readonly string[]) {
  if (typeof allowed === "string") return allowed;
  if (allowed.length === 1) return allowed[0];
  return allowed.slice(0, -1).join(", ") + " or " + allowed[allowed.length - 1];
}

export function validateBindings<B extends BindingsType>(
  bindings: Bindings<Term>,
  specification: B
): asserts bindings is Expand<SpecificationToBindings<B>> {
  for (const variable in bindings) {
    const allowedTermTypes = specification[variable];
    // @DECISION after some discussion, we decided to allow
    //           additional bindings to be present
    const binding = bindings[variable];
    if (binding === undefined) {
      throw new FatalError(`The variable ?${variable} occurs as a key in the bindings, but has an undefined value.`);
    } else if (allowedTermTypes && allowedTermTypes !== "Term" && !allowedTermTypes.includes(binding.termType))
      throw new FatalError(
        `Expected the variable ?${variable} to be bound to a ${specificationToMessage(allowedTermTypes)}, but it is a ${
          binding.termType
        }`
      );
  }
  for (const variable in specification) {
    if (!specification[variable] || specification[variable].includes("unbound")) continue;
    if (!bindings[variable]) throw new FatalError(`Expected the variable ?${variable} to be bound, but it is unbound.`);
  }
}

export async function* validateAsyncBindingsIterable<B extends BindingsType>(
  bindingses: AsyncBindingsIterable,
  specification: B
) {
  for await (const bindings of bindingses) {
    validateBindings(bindings, specification);
    yield bindings;
  }
}
