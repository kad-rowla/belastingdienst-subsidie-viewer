import { DATA_TYPES, dataFactory, DEFAULT_BASE_IRI, MAX_RESULTS_IN_MEMORY, sh, Term, Variable } from "./constants.js";
import { Terms } from "@triplydb/data-factory";
import { v4 as generateRandomName } from "uuid";
import { QueryEngine } from "./QueryEngine.js";
import { QueryOptions } from "./Execution.js";
import { FatalError, SparqlError, UnsupportedError } from "./Errors.js";
import { scopeVariables, translateVariableNames } from "./Algebra/ASTtoAlgebra/variableScope.js";
import { parse, Prefixes } from "./Helpers.js";
import { DataDefinedFunctionInfo, operationFromScopedAst, ParameterInfo } from "./Algebra/ASTtoAlgebra/index.js";
import eachDeep from "deepdash/eachDeep";
import { default as SparqlJs } from "sparqljs";
import { intersection, isSubset, union } from "mnemonist/set.js";
import { BindingsResult } from "./QueryResults.js";
import { NamedNode } from "@triplydb/data-factory/Terms.js";

/**
 * https://www.w3.org/TR/shacl/#sparql-prefixes
 */
export async function getPrefixes(engine: QueryEngine): Promise<Prefixes> {
  // > The values of the property sh:declare are IRIs or blank nodes, and these
  // > values are called prefix declarations. The SHACL vocabulary includes the
  // > class sh:PrefixDeclaration as type for such prefix declarations although
  // > no rdf:type triple is required for them. Prefix declarations have exactly
  // > one value for the property sh:prefix. The values of sh:prefix are literals
  // > of datatype xsd:string. Prefix declarations have exactly one value for the
  // > property sh:namespace. The values of sh:namespace are literals of datatype
  // > xsd:anyURI. Such a pair of values specifies a single mapping of a prefix
  // > to a namespace.
  // from: https://www.w3.org/TR/shacl/#sparql-prefixes
  const results = await engine.select(
    ` prefix sh: <http://www.w3.org/ns/shacl#>
      prefix xsd: <http://www.w3.org/2001/XMLSchema#>
      SELECT * WHERE {
        ?declaration ^sh:declare [];
                    sh:prefix ?prefix;
                    sh:namespace ?namespace.
        FILTER(datatype(?prefix) = xsd:string)
        FILTER(datatype(?namespace) = xsd:anyURI)
      }
  `,
    { declaration: ["NamedNode", "Literal"], prefix: "Literal", namespace: "Literal" }
  );

  const prefixes: Prefixes = {};
  const declarationIds = new Set<string>();
  for await (const { declaration, prefix, namespace } of results) {
    if (declarationIds.has(declaration.id))
      throw new SparqlError(
        `The prefix declaration ${declaration.id} should have exactly one sh:prefix and sh:namespace property, but it has more.`
      );
    if (prefix.value in prefixes)
      throw new SparqlError(`The prefix ${prefix.value} should not be defined more than once.`);
    prefixes[prefix.value] = namespace.value;
  }
  return prefixes;
}

export async function getDataDefinedFunctionInfo(
  engine: QueryEngine,
  functionNode: Terms.NamedNode,
  prefixes: Prefixes
): Promise<DataDefinedFunctionInfo> {
  //https://www.w3.org/TR/shacl/#sparql-constraints-prebound
  const preBound = new Set(["this", "shapesGraph", "currentShape"]);
  // https://www.w3.org/TR/shacl/#constraint-components-validation
  const selectReserved = new Set(["path", "PATH"]);
  const askReserved = new Set(["value"]);

  const alwaysReservedParameters = new Set([...selectReserved, ...askReserved, ...preBound]);
  const nameTranslation: Parameters<typeof translateVariableNames>[1] = new Map();
  // The keys are the real variable names of the parameters.
  const shaclDefinedParameters: Map<string, ParameterInfo> = await getParameters(
    engine,
    functionNode,
    alwaysReservedParameters
  );
  let ast = await getImplementation(engine, functionNode, prefixes);

  // Do name-sensitive checks here before we randomize variable names.
  validateShaclSparqlFunctionImplementation(
    ast,
    // The real parameters' names
    new Set(shaclDefinedParameters.keys()),
    askReserved,
    alwaysReservedParameters
  );

  for (const reservedName of alwaysReservedParameters) {
    const randomName = generateRandomName();
    nameTranslation.set(reservedName, dataFactory.variable(randomName));
  }
  for (const [reservedName, randomName] of [...shaclDefinedParameters]) {
    if (nameTranslation.has(reservedName))
      throw new FatalError(
        " A parameter in SHACL SPARQL cannot have the same variable name as one of the always reserved paramaters. This is a bug."
      );
    nameTranslation.set(reservedName, dataFactory.variable(randomName.name));
  }

  // Make sure the parameter names don't collide with anything else
  const parametersForAstTranslation: Map<string, Terms.Variable> = new Map(
    [...shaclDefinedParameters.entries()].map((entry) => {
      return [entry[0], dataFactory.variable(entry[1].name)];
    })
  );
  ast = translateVariableNames(ast, parametersForAstTranslation);

  // scope the rest of the variables in the AST. To eliminate coincidental
  // name collisions between the implementation and whatever query the
  // function is used in, all variables are given a random name.
  // We do, however, take care to keep the parameter names intact, no-matter
  // their scoping.
  const parametersInfo = Array.from(shaclDefinedParameters.values());
  const parametersForAlgebraTranslation = new Set(parametersInfo.map((element) => element.name));
  ast = scopeVariables(ast, {
    dontTouchThis: parametersForAlgebraTranslation,
    translateEverything: true,
  });

  // note that we don't optimize. This has two reasons:
  // 1. optimization is data-dependent, and we don't know the data ATM
  // 2. queries that use these functions will be optimized themselves already
  const implementation = operationFromScopedAst(
    ast,
    {
      dataDefinedFunctions: engine.dataDefinedFunctions,
      variablesToTranslateWithoutErrorChecking: parametersForAlgebraTranslation,
      namedGraphs: engine.executor.defaultRdfDataset().namedGraphs,
    },
    "don't set IDs"
  );

  if (ast.queryType === "ASK")
    return {
      implementation,
      parameters: parametersInfo,
    };

  if (ast.variables.length !== 1)
    throw new SparqlError(
      `The sh:select property of <${functionNode.value}> should return exactly one result variable, ` +
        `but it returns ${ast.variables.length}. See https://www.w3.org/TR/shacl-af/#SPARQLFunction`
    );
  const resultVariableTerm = "variable" in ast.variables[0] ? ast.variables[0].variable : ast.variables[0];
  if (resultVariableTerm.termType === "Wildcard")
    throw new SparqlError(
      `The sh:select property of <${functionNode.value}> should not use the ` +
        "`SELECT *` syntax. See https://www.w3.org/TR/shacl-af/#SPARQLFunction"
    );

  return {
    implementation,
    parameters: parametersInfo,
    resultVariable: resultVariableTerm.value,
  };
}

/**
 * Execute a triple pattern that contains exactly one variable.
 *
 * @returns A list of terms, being the values bound to that single variable
 */
export async function oneVarTriplePattern(
  engine: QueryEngine,
  stp:
    | readonly [Variable, Terms.NamedNode, Terms.NamedNode | Terms.Literal]
    | readonly [Terms.NamedNode, Terms.NamedNode | Variable, Terms.NamedNode | Terms.Literal]
    | readonly [Terms.NamedNode, Terms.NamedNode, Variable]
): Promise<Term[]> {
  const variable =
    typeof stp[0] === "string"
      ? stp[0]
      : typeof stp[1] === "string"
      ? stp[1]
      : typeof stp[2] === "string"
      ? stp[2]
      : undefined;
  if (variable === undefined) throw new FatalError("Type Error");
  const results: Term[] = [];
  for await (const row of engine.executor.query({
    operationType: "TriplePattern",
    pattern: stp,
  }).results) {
    const result = row[variable];
    if (!result) throw new FatalError("The engine returned incorrect results. Please contact a developer.");
    results.push(result);
    if (results.length > MAX_RESULTS_IN_MEMORY) throw new UnsupportedError("OOM Code 11");
  }
  return results;
}

function validateShaclSparqlFunctionImplementation(
  ast: SparqlJs.Query,
  shaclDefinedParameters: Set<string>,
  askReserved: Set<string>,
  alwaysReserved: Set<string>
): void {
  /**
   * We do this error handling because eachdeep appends an error to our own.
   */

  let error: SparqlError | undefined = undefined;
  const allPreBound = union(shaclDefinedParameters, alwaysReserved);
  const setOfPreBoundVariablesForLastRule = new Set([
    ...shaclDefinedParameters,
    ...(ast.queryType === "ASK" ? askReserved : []),
    "this",
  ]);
  eachDeep(
    ast,
    (node) => {
      if (typeof node !== "object" || error) {
        return false;
      }

      /**
       * SPARQL queries must not contain a MINUS clause
       * SPARQL queries must not contain a federated query (SERVICE)
       * SPARQL queries must not contain a VALUES clause
       */
      if (node.type === "minus" || node.type === "values" || node.type === "service") {
        error = new SparqlError(
          `SHACL Queries containing "${node.type.toUpperCase()}" operations are illegal. See https://www.w3.org/TR/shacl/#pre-binding`
        );
        return false;
      }

      /**
       * SPARQL queries must not use the syntax form ​​AS ?var for any potentially pre-bound variable
       */
      if (node.expression && node.variable) {
        // allPreBound
        if (allPreBound.has(node.variable.value)) {
          error = new SparqlError(
            `Cannot re-assign the pre-bound SHACL parameter "${node.variable.value}". See https://www.w3.org/TR/shacl/#pre-binding`
          );
          return false;
        }
      }

      /**
       * Subqueries must return all potentially pre-bound variables, except shapesGraph and currentShape
       * which are optional as already mentioned in 5.3.1 Pre-bound Variables in SPARQL Constraints
       * ($this, $shapesGraph, $currentShape)
       * @DECISION: We consider  "return all pre-bound variables" as
       * 1. Binding any prebound variable.
       * 2. Returning it in the projection.
       */

      // A subquery can only be a select
      if (node.queryType) {
        if (node.queryType !== "SELECT") {
          error = new FatalError(`A subquery can only be a SELECT query. This is a bug.`);
          return false;
        }
        // We use scopeVariables with a Wildcard, in order to get in the projection
        // all values that are getting bound inside the query.
        const allVariablesBoundInsideWhere: Set<string> = new Set(
          scopeVariables({
            ...node,
            variables: [new SparqlJs.Wildcard()],
          }).variables.map((variable: SparqlJs.VariableTerm) => variable.value)
        );
        // Gather the preBound that might be included in the bound variables inside the query.
        const preBoundVariablesWeShouldCheck = intersection(
          allVariablesBoundInsideWhere,
          setOfPreBoundVariablesForLastRule
        );

        // Get all the variables that are really in the projection of our query.
        // Notice we don't get variables inside expression because we don't return them.
        // for example in select (?a as ?b){} ,
        // we don't return ?a but only ?b
        const variablesInSubProjection = new Set(
          node.variables.map((v: SparqlJs.Variable) => ("variable" in v ? v.variable : v).value)
        );

        // If variables in the projection do not include preBound from inside the query then we want an error.
        if (!isSubset(preBoundVariablesWeShouldCheck, variablesInSubProjection)) {
          error = new SparqlError(
            `Subqueries should return all prebound variables. See https://www.w3.org/TR/shacl/#pre-binding`
          );
          return false;
        }
      }
    },
    // We don't care about the whole ast as it is, but we are searching in its children and deepest,
    // specifically operations, variables property and subqueries
    { includeRoot: false }
  );
  if (error) throw error;
}

async function getParameters(
  engine: QueryEngine,
  functionNode: Terms.NamedNode,
  alwaysReservedParameters: Set<string>
) {
  const parameterQueryResult = await engine.select(
    ` prefix sh: <http://www.w3.org/ns/shacl#>
      SELECT ?parameter ?local ?optional WHERE {
        # https://www.w3.org/TR/shacl/#constraint-components-parameters
        <${functionNode.value}> sh:parameter ?parameter .
        ?parameter sh:path ?path .

        # > the longest NCNAME at the end of the IRI, not immediately
        # > preceded by the first colon
        # from: https://www.w3.org/TR/shacl/#dfn-local-name
        BIND("^[^:]*?(:.+?)?([^/#]*)$" as ?regex)
        BIND(str(?path) as ?strPath)
        BIND(IF(
            REGEX(?strPath, ?regex),
            REPLACE(?strPath, ?regex, "$2"),
            ""
          ) as ?local)

        FILTER(?local)

        # > using 0 as default value if unspecified.
        # from: https://www.w3.org/TR/shacl-af/#function-parameters
        OPTIONAL {
          ?parameter sh:order ?orderFromData
        }
        BIND(COALESCE(?orderFromData, 0) as ?order)

        # the sh:optional property is optional :)
        # See: https://www.w3.org/TR/shacl-af/#function-parameters
        OPTIONAL {
          ?parameter sh:optional ?optional
        }

      # @DECISION strictly speaking we should order by ?local only
      #           when none of the properties define an ?order, but
      #           that would leave room for undefined orders, and
      #           it's easier to write the query like this.
      } ORDER BY ?order ?local`,
    // `optional` is not specified because we do the type checking later
    { parameter: ["NamedNode", "BlankNode"], local: "Literal" }
  );

  const parameterIds = new Set<string>();
  const shaclDefinedParameters = new Map<string, ParameterInfo>();
  for await (const { parameter, local, optional: optionalTerm } of parameterQueryResult) {
    if (parameterIds.has(parameter.id))
      throw new SparqlError(
        `The parameter ${parameter.id} has duplicate properties. ` +
          "Possible culprits are: sh:path, sh:order and sh:optional. " +
          "Note that repeating the same triple in different graphs could also cause this error."
      );
    parameterIds.add(parameter.id);

    let optional = false;
    if (optionalTerm) {
      if (optionalTerm.termType !== "Literal") {
        throw new SparqlError(
          `The sh:optional property of the parameter ${
            parameter.id
          } is not a literal of type xsd:boolean, but a ${optionalTerm.termType.toLocaleLowerCase()}. See https://www.w3.org/TR/shacl/#constraint-components-parameters`
        );
      }
      if (!optionalTerm.datatype.equals(DATA_TYPES.XSD_BOOLEAN))
        throw new SparqlError(
          `The sh:optional property of the parameter ${parameter.id} is not a literal of type xsd:boolean, but a literal with datatype <${optionalTerm.datatype.value}>. See https://www.w3.org/TR/shacl/#constraint-components-parameters`
        );
      // `true` is the canonical form
      if (optionalTerm.value === "true") optional = true;
    }

    const nameThatCouldCollide = local.value;
    if (alwaysReservedParameters.has(local.value))
      throw new SparqlError(
        `The parameter ${parameter.id} has a sh:path that is either reserved or used by an earlier parameter: "${nameThatCouldCollide}". See https://www.w3.org/TR/shacl/#constraint-components-parameters`
      );
    const name = generateRandomName();
    shaclDefinedParameters.set(nameThatCouldCollide, { name, optional });
  }
  return shaclDefinedParameters;
}

async function getImplementation(engine: QueryEngine, functionNode: Terms.NamedNode, prefixes: Prefixes) {
  let queryType: "SELECT" | "ASK" = "SELECT";
  let implementations = await oneVarTriplePattern(engine, [functionNode, sh("select"), "someVar"]);

  if (implementations.length > 1)
    throw new SparqlError(
      `The function <${functionNode.value}> should have exactly one value for either sh:ask or sh:select, ` +
        `but it has ${implementations.length} values for sh:select. ` +
        "See https://www.w3.org/TR/shacl-af/#h-function-returntype"
    );

  if (implementations.length === 0) {
    queryType = "ASK";
    implementations = await oneVarTriplePattern(engine, [functionNode, sh("ask"), "someVar"]);
    if (implementations.length !== 1)
      throw new SparqlError(
        `The function <${functionNode.value}> should have exactly one value for either sh:ask or sh:select, ` +
          `but it has 0 values for sh:select and ${implementations.length} values for sh:ask. ` +
          "See https://www.w3.org/TR/shacl-af/#h-function-returntype"
      );
  }

  const queryTerm = implementations[0];
  if (queryTerm.termType !== "Literal" || !queryTerm.datatype.equals(DATA_TYPES.XSD_STRING))
    throw new SparqlError(
      `The value of sh:${queryType.toLocaleLowerCase()} of the function <${
        functionNode.value
      }> should be a string literal, but it is a ${
        queryTerm.termType !== "Literal" ? queryTerm.termType.toLocaleLowerCase() : queryTerm.datatype
      }. See https://www.w3.org/TR/shacl-af/#SPARQLFunction`
    );

  let ast = parse(queryTerm.value, { baseIri: DEFAULT_BASE_IRI, prefixes });
  if (ast.type !== "query" || ast.queryType !== queryType)
    throw new SparqlError(
      `The value of sh:${queryType.toLocaleLowerCase()} of the function <${
        functionNode.value
      }> should be a SPARQL ${queryType} query, but it is a SPARQL ${
        ast.type === "update" ? "update operation" : ast.queryType + " query"
      }. See https://www.w3.org/TR/shacl-af/#SPARQLFunction`
    );

  return ast;
}
