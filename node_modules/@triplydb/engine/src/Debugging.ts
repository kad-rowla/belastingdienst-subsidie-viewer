import debugLib from "debug";
import util from "util";

type DebugNamespace =
  | "sparql:counts"
  | "sparql:distinct"
  | "sparql:engine:construct:blankNodeCounter"
  | "sparql:engine:construct:illegalPredicate"
  | "sparql:engine:construct:illegalSubject"
  | "sparql:engine:construct:unboundObject"
  | "sparql:engine:construct:unboundPredicate"
  | "sparql:engine:construct:unboundSubject"
  | "sparql:engine:quad"
  | "sparql:engine:query:select:results"
  | "sparql:executeTriplePattern"
  | "sparql:extend"
  | "sparql:filter:context"
  | "sparql:filter:effectiveBooleanValue"
  | "sparql:filter:error"
  | "sparql:filter:false"
  | "sparql:filter:true"
  | "sparql:filter:variables"
  | "sparql:getTerm"
  | "sparql:graph"
  | "sparql:InlineData"
  | "sparql:match"
  | "sparql:operation"
  | "sparql:optimize:leftjoin"
  | "sparql:optimize:reorder:estimation:triple-pattern"
  | "sparql:optimize:reorder:original-algebra"
  | "sparql:optimize:reorder:original-time-estimate"
  | "sparql:optimize:reorder:reordered-algebra"
  | "sparql:optimize:reorder:reordered-time-estimate"
  | "sparql:project"
  | "sparql:propertyPath:alternative"
  | "sparql:propertyPath:inverse"
  | "sparql:propertyPath:negatedSet"
  | "sparql:propertyPath:oneOrMore"
  | "sparql:propertyPath:predicate"
  | "sparql:propertyPath:sequence:freshVariable"
  | "sparql:propertyPath:sequence:joins"
  | "sparql:propertyPath:sequence:variables"
  | "sparql:propertyPath:sequence"
  | "sparql:queryString"
  | "sparql:resultstream"
  | "sparql:serialize:toJsonResults"
  | "sparql:serialize:toSparqlJson:success"
  | "sparql:serialize:toSparqlJson:warning"
  | "sparql:slice:limit"
  | "sparql:slice:offset"
  | "sparql:slice"
  | "sparql:sort"
  | "sparql:translate:algebra:optimized"
  | "sparql:translate:algebra:unoptimized"
  | "sparql:translate:ast"
  | "sparql:translate"
  | "sparql:triple-pattern"
  | "sparql:updateString"
  | "sparql:update-ast";

debugLib.formatters.D = (value) => {
  if (process.env.CI) {
    return JSON.stringify(value, null, 2);
  } else {
    return util.inspect(value, { depth: 100, colors: true });
  }
};
debugLib.formatters.f = (func: () => any) => debugLib.formatters.D(func());
debugLib.formatters.F = (number: number) => number.toExponential();

const debugNamespaces = new Map<string, debug.IDebugger>();

/**
 * Formatter 	Representation
 * %O 	      Pretty-print an Object on multiple lines.
 * %o 	      Pretty-print an Object all on a single line.
 * %s 	      String.
 * %d 	      Number (both integer and float).
 * %D 	      (Custom) Print colourful object, to depth 10
 * %f         (Custom) Print function output (the function will only be called when necessary)
 * %F         (Custom) Pretty-print a float
 * %j 	      JSON. Replaced with the string '[Circular]' if the argument contains circular references.
 * %% 	      Single percent sign ('%'). This does not consume an argument.
 */
export default function log(namespace: DebugNamespace, ...args: any[]) {
  let debug;
  if (debugNamespaces.has(namespace)) {
    debug = debugNamespaces.get(namespace) as debug.IDebugger;
  } else {
    debug = debugLib(namespace);
    debugNamespaces.set(namespace, debug);
  }
  //@ts-ignore
  debug.apply(null, args);
}
