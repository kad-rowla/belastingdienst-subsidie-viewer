import { getFactory } from "@triplydb/data-factory";
import * as Terms from "@triplydb/data-factory/Terms.js";
import { TermTypeToTerm } from "@triplydb/data-factory/Terms.js";
import {
  DATA_TYPE_NAME_MAPPING,
  NumericDataTypeIri,
  isNumericDatatype,
} from "@triplydb/recognized-datatypes/utils/constants.js";
import { mapValues } from "lodash-es";

/**
 *  The maximum number of results we want to load into memory at once.
 *
 *  Should only be used as a fail-safe that the user should never run in to.
 */
export const MAX_RESULTS_IN_MEMORY = 10_000;

export type Id = number;
export type Variable = string;
export type Term = Terms.NamedNode | Terms.BlankNode | Terms.Literal;
export type GraphName = Terms.NamedNode;
const quadTerms = {
  subject: ["NamedNode" as const, "BlankNode" as const],
  predicate: ["NamedNode" as const],
  object: ["NamedNode" as const, "BlankNode" as const, "Literal" as const],
  graph: ["NamedNode" as const, "DefaultGraph" as const],
};
type QuadTerms = {
  subject: TermTypeToTerm[(typeof quadTerms)["subject"][number]];
  predicate: TermTypeToTerm[(typeof quadTerms)["predicate"][number]];
  object: TermTypeToTerm[(typeof quadTerms)["object"][number]];
  graph: TermTypeToTerm[(typeof quadTerms)["graph"][number]];
};
export type Quad = Terms.Quad<QuadTerms>;
export const dataFactory = getFactory({
  quadTerms,
});
export type DataFactory = typeof dataFactory;
export const dataFactoryWithoutValidation = getFactory({
  quadTerms,
  skipValidation: true,
});
export const dataFactoryWithRewriteOfInvalidLiterals = getFactory({
  quadTerms,
  onInvalidLiteral: (opts) => ({ replaceWith: dataFactoryWithoutValidation.literal(opts.value + "") }),
});
// `undefined` is included in this type, because otherwise the type system
// doesn't warn you that you may be looking up an unbound variable
export type Bindings<BindingValue> = { [variable: string]: BindingValue | undefined };
export type MatchPattern = [Id | undefined, Id | undefined, Id | undefined];

/**
 * The description of the RDF dataset to query.
 *
 * > (...) An RDF Dataset comprises one graph, the default graph, which does not have
 * > a name, and zero or more named graphs, where each named graph is identified
 * > by an IRI. (...)
 * >
 * > An RDF Dataset may contain zero named graphs; an RDF Dataset always
 * > contains one default graph. (...)
 * See https://www.w3.org/TR/sparql11-query/#rdfDataset
 */
export interface RdfDataset {
  /**
   * The names of the graphs that together form the default graph.
   */
  defaultGraph: GraphName[];
  /**
   * All the named graphs in the dataset.
   */
  namedGraphs: GraphName[];
}

/**
 *  @DECISION a SPARQL engine should always define a base IRI:
 *
 *  > Finally, per section 5.1.4, SPARQL Protocol services must define their
 *  > own base URI, which may be the service endpoint.
 *
 *  from: https://www.w3.org/TR/sparql11-protocol/#base-iri
 */
export const DEFAULT_BASE_IRI = "https://www.triplydb.com/";

type NameToType = typeof DATA_TYPE_NAME_MAPPING;
export const DATA_TYPES: { [Name in keyof NameToType]: Terms.NamedNode<NameToType[Name]> } = mapValues(
  DATA_TYPE_NAME_MAPPING,
  (value) => dataFactory.namedNode(value) as any
);

export type NumericDataType = Terms.NamedNode<NumericDataTypeIri>;

/**
 * Find out whether a term is NaN^^xsd:float or NaN^^xsd:double
 */
export function isNaN(term: Terms.Term): boolean {
  return term.termType === "Literal" && isNumericDatatype(term.datatype) && term.value === "NaN";
}

export const sh = dataFactory.prefixer("http://www.w3.org/ns/shacl#");
export const geof = dataFactory.prefixer("http://www.opengis.net/def/function/geosparql/");
export const triplyFunctions = dataFactory.prefixer("https://triplydb.com/Triply/function/");

export const GEO_FUNCTIONS = {
  PROJECT: triplyFunctions("project"),
  // In #8309, we added this function. It is the same as tf:project, but accepts 1 argument.
  TRANSFORM: geof("transform"),
  AREA: geof("area"),
  METRIC_AREA: geof("metricArea"),
} as const;
