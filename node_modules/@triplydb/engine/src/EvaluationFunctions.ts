import {
  EffectiveBooleanValueError,
  EvaluationResult,
  HashAlgorithm,
  InvalidArgumentTypes,
  invalidArgumentTypesError,
} from "./EvaluationResult.js";
import { createHash } from "crypto";
import { resolve } from "relative-to-absolute-iri";
import { EvaluationError, FALSE, TRUE, Value } from "./EvaluationResult.js";
import {
  changeLiteralValue,
  getMatchingDatatypeOrLanguage,
  getSharedLanguageTag,
  isSupportedFlag,
  ValidateLiteralOrNamedNode,
  ValidationType,
  validators,
  canonicalToNumber,
  basicLanguageTagFilter,
  decimalToRoundedString,
  isDerivedFromStringLiteral,
  isDerivedFromDecimalLiteral,
  isDerivedFromIntegerLiteral,
} from "./Helpers.js";
import { dataFactory, DATA_TYPES, NumericDataType, isNaN, Term } from "./constants.js";
import { SUB_TYPES, SUB_TYPE_IRIS, numericDatatypeIris } from "@triplydb/recognized-datatypes/utils/constants.js";
import { Literal, NamedNode } from "@triplydb/data-factory/Terms.js";
import { lexicalToCanonical, lexicalToValue, valueToCanonical } from "@triplydb/recognized-datatypes";
import { timezoneFragmentToCanonical } from "@triplydb/recognized-datatypes/xsd/dateTime.js";
import { durationToCanonical } from "@triplydb/recognized-datatypes/xsd/duration.js";
import { ParseError } from "@triplydb/data-factory/DataFactory.js";
import { round as lodRound, escapeRegExp } from "lodash-es";
import log from "./Debugging.js";

export function lessThan(first: EvaluationResult, second: EvaluationResult): EvaluationResult {
  if (first.evaluationResultType === "error") return first;
  if (second.evaluationResultType === "error") return second;
  // @DECISION we're working around problems with lexical sorting here,
  // but we'll be ignoring them when we're doing disc-based sorting.
  //
  // > If either, or both, operands are NaN, false is returned.
  // from: https://www.w3.org/TR/xpath-functions/#comp.numeric
  if (isNaN(first.term) || isNaN(second.term)) return FALSE;
  return first.term.cmpString < second.term.cmpString ? TRUE : FALSE;
}

export function effectiveBooleanValue(arg: EvaluationResult): boolean | EvaluationError {
  /**
   *  SPARQL Rules for EBV: https://www.w3.org/TR/sparql11-query/#ebv
   *
   * @DECISION Deviation from the spec: https://www.w3.org/TR/sparql11-query/#matchNumber#ebv
   * When returning truthy or falsy values, specifically the spec asks in some cases to return a
   * boolean value in valid 'lexical form' or a boolean value as a 'typed literal'.
   * We have decided that this creates a bad DX.
   * We opt to return the more JS friendly true/false primitives.
   */

  /**
   * As per discussions, our effectiveBooleanValue implementation assumes the correct canonical form.
   * This means that checks for correct lexical form are not needed.
   * We can assume they are already correct and accounted for.
   * https://issues.triply.cc/issues/6932
   */

  log("sparql:filter:effectiveBooleanValue", "Execute with value: %D", arg);

  if (arg.evaluationResultType === "error") {
    log("sparql:filter:effectiveBooleanValue", "error");
    return arg;
  }
  return effectiveBooleanValueOfTerm(arg.term);
}

export function effectiveBooleanValueOfTerm(term: Term): boolean | EffectiveBooleanValueError {
  if (term.termType === "Literal") {
    if (term.datatype.equals(DATA_TYPES.XSD_BOOLEAN)) {
      log("sparql:filter:effectiveBooleanValue", "boolean literal");
      return term.value === "true";
    }
    /**
     * @DECISION Should langString equate to XSD string?
     * We asked ourselves this question and decided that yes `rdf:langString`
     * should be filtered just like 'xsd string'.
     */
    if (term.datatype.equals(DATA_TYPES.XSD_STRING) || term.datatype.equals(DATA_TYPES.RDF_LANG_STRING)) {
      log("sparql:filter:effectiveBooleanValue", "string literal");
      return term.value.length > 0;
    }
    if (validators.numericDatatype(term.datatype)) {
      log("sparql:filter:effectiveBooleanValue", "numeric literal");
      return !["-0.0E0", "0.0E0", "0", "NaN"].includes(term.value);
    }
  }
  log("sparql:filter:effectiveBooleanValue", "type error");
  return {
    evaluationResultType: "error",
    errorType: "EffectiveBooleanValueError",
  };
}

export function compare(terms: Term[]) {
  const validationError = ValidateLiteralOrNamedNode(terms, [
    [validators.stringLiteral, validators.languageLiteral],
    [validators.stringLiteral, validators.languageLiteral],
  ]);
  if (validationError) return validationError;
  // This line is for typescript
  if (!validators.literal(terms[0]) || !validators.literal(terms[1])) return invalidArgumentTypesError;
  // comparison checks
  if (terms[0].value === terms[1].value && terms[0].datatype.value === terms[1].datatype.value)
    return newLiteral("0", DATA_TYPES["XSD_INTEGER"]);
  if (terms[0].cmpString < terms[1].cmpString) return newLiteral("-1", DATA_TYPES["XSD_INTEGER"]);
  return newLiteral("1", DATA_TYPES["XSD_INTEGER"]);
}

//@DECISION: In triplydb, we don't allow simple literal, but we turn them to xsd:string.
// For this reason, we decided that in functions (string,hash etc.) that have simple literals as input according to the spec,
// we should allow literals of xsd:string and xsd:string's derived types, but not rdf:langString.
// Ticket #7248

export function str(terms: Term[]): EvaluationResult {
  /**
   * @DECISION STR() casting returns an error if the termType is not literal or NamedNode(Following Jena, BlazeGraph)
   * since it is not specified in the spec
   */

  const validationError = ValidateLiteralOrNamedNode(terms, [[validators.literal, validators.namedNode]]);
  if (validationError) return validationError;

  return {
    evaluationResultType: "value",
    term: dataFactory.literal(terms[0].value, DATA_TYPES.XSD_STRING),
  };
}

export function strlen(terms: Term[]): EvaluationResult {
  const validationError = ValidateLiteralOrNamedNode(terms, [
    [validators.derivedFromStringLiteral, validators.languageLiteral],
  ]);
  if (validationError) return validationError;
  // Getting str length taking into account unicode characters
  // See the unicode section here for more details: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length#description
  let length = 0;
  const stringIterator = terms[0].value[Symbol.iterator]();
  while (!stringIterator.next().done) length++;
  return {
    evaluationResultType: "value",
    term: dataFactory.literal(length, DATA_TYPES.XSD_INTEGER),
  };
}

export function substr(terms: Term[]): EvaluationResult {
  const valueArray: ValidationType[][] = [
    [validators.derivedFromStringLiteral, validators.languageLiteral],
    [validators.derivedFromIntegerLiteral],
  ];
  if (terms[2]) valueArray.push([validators.derivedFromIntegerLiteral]);

  const validationError = ValidateLiteralOrNamedNode(terms, valueArray);
  if (validationError) return validationError;

  // Spread it into an array. Because we're using an iterator, that means we're going to split unicode characters properly.
  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length#description
  const inputStringArray = [...terms[0].value];
  let zeroIndexedStartingLoc = parseInt(terms[1].value) - 1;

  let substringedValue;
  if (terms[2]) {
    let substrLength = parseInt(terms[2].value);
    if (zeroIndexedStartingLoc < 0) {
      /**
       * Adjust for situation where we have a 0-index of minus substring offset.
       * See https://www.w3.org/TR/xpath-functions/#func-substring, which says
       *    The expression fn:substring("12345", -3, 5) returns "1".
       *    (Characters at positions greater than or equal to -3 and less than 2 are selected.
       *    Since the first position is 1, this is the character at position 1.)
       **/
      substrLength += zeroIndexedStartingLoc;
      zeroIndexedStartingLoc = 0;
    }
    substringedValue = inputStringArray.slice(zeroIndexedStartingLoc, zeroIndexedStartingLoc + substrLength).join("");
  } else {
    substringedValue = inputStringArray.slice(zeroIndexedStartingLoc).join("");
  }

  return {
    evaluationResultType: "value",
    term: changeLiteralValue(terms[0] as Literal, substringedValue),
  };
}

export function ucase(terms: Term[]): EvaluationResult {
  const validationError = ValidateLiteralOrNamedNode(terms, [
    [validators.derivedFromStringLiteral, validators.languageLiteral],
  ]);
  if (validationError) return validationError;

  const upperCasedValue = terms[0].value.toUpperCase();
  const changedLiteral = changeLiteralValue(terms[0] as Literal, upperCasedValue);
  return {
    evaluationResultType: "value",
    term: changedLiteral,
  };
}

export function lcase(terms: Term[]): EvaluationResult {
  const validationError = ValidateLiteralOrNamedNode(terms, [
    [validators.derivedFromStringLiteral, validators.languageLiteral],
  ]);
  if (validationError) return validationError;

  const lowerCasedValue = terms[0].value.toLowerCase();
  const changedLiteral = changeLiteralValue(terms[0] as Literal, lowerCasedValue);
  return {
    evaluationResultType: "value",
    term: changedLiteral,
  };
}

export function strstarts(terms: Term[]): EvaluationResult {
  const validationError = ValidateLiteralOrNamedNode(terms, [
    [validators.derivedFromStringLiteral, validators.languageLiteral],
    [validators.derivedFromStringLiteral, validators.languageLiteral],
  ]);
  if (validationError) return validationError;

  const haveMatchingLanguages = getMatchingDatatypeOrLanguage(terms[0], terms[1]);

  if (typeof haveMatchingLanguages === "object" && "errorType" in haveMatchingLanguages) return haveMatchingLanguages;

  const indexBoolean = terms[0].value.startsWith(terms[1].value);
  return indexBoolean ? TRUE : FALSE;
}

export function strends(terms: Term[]): EvaluationResult {
  const validationError = ValidateLiteralOrNamedNode(terms, [
    [validators.derivedFromStringLiteral, validators.languageLiteral],
    [validators.derivedFromStringLiteral, validators.languageLiteral],
  ]);
  if (validationError) return validationError;

  const haveMatchingLanguages = getMatchingDatatypeOrLanguage(terms[0], terms[1]);

  if (typeof haveMatchingLanguages === "object" && "errorType" in haveMatchingLanguages) return haveMatchingLanguages;

  const indexBoolean = terms[0].value.endsWith(terms[1].value);
  return indexBoolean ? TRUE : FALSE;
}

export function contains(terms: Term[]): EvaluationResult {
  const validationError = ValidateLiteralOrNamedNode(terms, [
    [validators.derivedFromStringLiteral, validators.languageLiteral],
    [validators.derivedFromStringLiteral, validators.languageLiteral],
  ]);
  if (validationError) return validationError;

  const haveMatchingLanguages = getMatchingDatatypeOrLanguage(terms[0], terms[1]);
  if (typeof haveMatchingLanguages === "object" && "errorType" in haveMatchingLanguages) return haveMatchingLanguages;

  const indexBoolean = terms[0].value.includes(terms[1].value);
  return indexBoolean ? TRUE : FALSE;
}

export function concat(terms: Term[]): EvaluationResult {
  // We don't know how many expressions there are but there should all be string literals
  const stringValueArray = Array(terms.length).fill([validators.derivedFromStringLiteral, validators.languageLiteral]);
  const validationError = ValidateLiteralOrNamedNode(terms, stringValueArray);
  if (validationError) return validationError;

  const indexValue = terms.map((term) => term.value).join("");
  return {
    evaluationResultType: "value",
    term: dataFactory.literal(indexValue, terms.length === 0 ? undefined : getSharedLanguageTag(terms)),
  };
}

export function lang(terms: Term[]): EvaluationResult {
  const validationError = ValidateLiteralOrNamedNode(terms, [[validators.literal]]);
  if (validationError) return validationError;

  return newLiteral((terms[0] as Literal).language, DATA_TYPES["XSD_STRING"]);
}

export function langmatches(terms: Term[]): EvaluationResult {
  const validationError = ValidateLiteralOrNamedNode(terms, [
    [validators.derivedFromStringLiteral],
    [validators.derivedFromStringLiteral],
  ]);
  if (validationError) return validationError;
  if (terms[0].value === "") return FALSE;
  const match = basicLanguageTagFilter(terms[0].value, terms[1].value);
  return match.length > 0 ? TRUE : FALSE;
}

export function abs(terms: Term[]): EvaluationResult {
  if (!validators.literal(terms[0]) || !numericDatatypeIris.has(terms[0].datatype.value)) {
    return invalidArgumentTypesError;
  }
  return newLiteral(String(Math.abs(canonicalToNumber(terms[0].value))), terms[0].datatype);
}
export function ceil(terms: Term[]): EvaluationResult {
  if (!validators.literal(terms[0]) || !numericDatatypeIris.has(terms[0].datatype.value)) {
    return invalidArgumentTypesError;
  }
  return newLiteral(String(Math.ceil(canonicalToNumber(terms[0].value))), terms[0].datatype);
}
export function floor(terms: Term[]): EvaluationResult {
  if (!validators.literal(terms[0]) || !numericDatatypeIris.has(terms[0].datatype.value)) {
    return invalidArgumentTypesError;
  }
  return newLiteral(String(Math.floor(canonicalToNumber(terms[0].value))), terms[0].datatype);
}
export function round(terms: Term[]): EvaluationResult {
  if (!validators.literal(terms[0]) || !numericDatatypeIris.has(terms[0].datatype.value)) {
    return invalidArgumentTypesError;
  }
  if (terms.length === 1) return newLiteral(String(Math.round(canonicalToNumber(terms[0].value))), terms[0].datatype);
  /**
   *  xpath fn:round takes a precion integer argument. lodash round caters for that
   *  https://www.w3.org/TR/xpath-functions-31/#func-round
   */
  if (!validators.integerLiteral(terms[1])) return invalidArgumentTypesError;
  return newLiteral(
    String(lodRound(canonicalToNumber(terms[0].value), canonicalToNumber(terms[1].value))),
    terms[0].datatype,
  );
}

export function strbefore(terms: Term[]): EvaluationResult {
  const validationError = ValidateLiteralOrNamedNode(terms, [
    [validators.derivedFromStringLiteral, validators.languageLiteral],
    [validators.derivedFromStringLiteral, validators.languageLiteral],
  ]);
  if (validationError) return validationError;

  const haveMatchingLanguages = getMatchingDatatypeOrLanguage(terms[0], terms[1]);
  if (typeof haveMatchingLanguages === "object" && "errorType" in haveMatchingLanguages) return haveMatchingLanguages;

  //https://github.com/comunica/sparqlee/blob/master/lib/functions/RegularFunctions.ts#L461

  const indexValue = terms[0].value.slice(0, Math.max(0, terms[0].value.indexOf(terms[1].value)));

  return {
    evaluationResultType: "value",
    term: dataFactory.literal(
      indexValue,
      haveMatchingLanguages as string | NamedNode, // it seems that I have to cast here, because it doesn't know if it's an evaluation error.
    ),
  };
}

export function strafter(terms: Term[]): EvaluationResult {
  const validationError = ValidateLiteralOrNamedNode(terms, [
    [validators.derivedFromStringLiteral, validators.languageLiteral],
    [validators.derivedFromStringLiteral, validators.languageLiteral],
  ]);
  if (validationError) return validationError;

  const haveMatchingLanguages = getMatchingDatatypeOrLanguage(terms[0], terms[1]);
  if (typeof haveMatchingLanguages === "object" && "errorType" in haveMatchingLanguages) return haveMatchingLanguages;

  // No need to take empty terms[1] string into account: when empty, we should return the complete terms[0]
  // See here for the explanation and test cases: https://www.w3.org/TR/sparql11-query/#func-strafter
  const stringAfter = terms[0].value.slice(terms[0].value.indexOf(terms[1].value)).slice(terms[1].value.length);

  return {
    evaluationResultType: "value",
    term: dataFactory.literal(stringAfter, haveMatchingLanguages as string | NamedNode),
  };
}

export function encode_for_uri(terms: Term[], useURIComponent?: "useURIComponent"): EvaluationResult {
  const validationError = ValidateLiteralOrNamedNode(terms, [
    [validators.derivedFromStringLiteral, validators.languageLiteral],
  ]);
  if (validationError) return validationError;

  const indexValue = useURIComponent ? encodeURIComponent(terms[0].value) : encodeURI(terms[0].value);
  return {
    evaluationResultType: "value",
    term: dataFactory.literal(indexValue),
  };
}

/**
 * Default flags, used for regex matching and replacing:
 * - `g` because we want to replace all occurances
 * - `u` because we want to be able to perform pattern matching on unicode characters
 */
const DEFAULT_REGEX_FLAGS = `gu`;

export function regex(terms: Term[]): EvaluationResult {
  // Only the first argument can be an xsd string or language literal, the rest only xsd strings
  const valueArray: ValidationType[][] = [
    [validators.derivedFromStringLiteral, validators.languageLiteral],
    [validators.derivedFromStringLiteral],
  ];
  if (terms[2]) valueArray.push([validators.derivedFromStringLiteral]);

  const validationError = ValidateLiteralOrNamedNode(terms, valueArray);
  if (validationError) return validationError;

  const initialString = terms[0].value;
  const pattern = terms[1].value;
  let customFlags = "";
  if (terms[2]) {
    let flag: string = terms[2].value;
    // The only flags that are working correctly now are s, i, m and NOT x and q
    if (!isSupportedFlag(flag)) return { evaluationResultType: "error" } as EvaluationError;
    customFlags = flag;
  }

  let reg;

  try {
    reg = new RegExp(pattern, customFlags + DEFAULT_REGEX_FLAGS);
  } catch (e) {
    // This is an illegal regex
    return { evaluationResultType: "error" } as EvaluationError;
  }
  const indexBoolean = reg.test(initialString);
  return indexBoolean ? TRUE : FALSE;
}

export function replace(terms: Term[]): EvaluationResult {
  // Only the first argument can be an xsd string or language literal, the rest only xsd strings
  const valueArray: ValidationType[][] = [
    [validators.derivedFromStringLiteral, validators.languageLiteral],
    [validators.derivedFromStringLiteral],
    [validators.derivedFromStringLiteral],
  ];
  if (terms[3]) valueArray.push([validators.derivedFromStringLiteral]);

  const validationError = ValidateLiteralOrNamedNode(terms, valueArray);
  if (validationError) return validationError;

  const initialString = terms[0].value;
  const pattern = terms[1].value;
  const replacement = terms[2].value;
  let reg: RegExp;

  let escapedPattern = "";
  let regexCharacters = ["{" /* other characters */];

  escapedPattern = regexCharacters.some((char) => pattern.includes(char)) ? escapeRegExp(pattern) : pattern;

  if (terms[3]) {
    const flag: string = terms[3].value;

    if (!isSupportedFlag(flag)) return { evaluationResultType: "error" } as EvaluationError;
    reg = new RegExp(escapedPattern, flag + DEFAULT_REGEX_FLAGS);
  } else {
    reg = new RegExp(escapedPattern, DEFAULT_REGEX_FLAGS);
  }
  return {
    evaluationResultType: "value",
    // The spec is not clear about retaining the literal lang-tag/datatype. However, the test-suite of the spec _is_ clear, and we should
    // retain these properties. Hence, use changeLiteralValue instead of the datafactory directly.
    term: changeLiteralValue(terms[0] as Literal, initialString.replace(reg, replacement)),
  };
}

export function hashStrings(terms: Term[], algorithm: HashAlgorithm): EvaluationResult {
  const validationError = ValidateLiteralOrNamedNode(terms, [[validators.derivedFromStringLiteral]]);
  if (validationError) return validationError;

  const valueHashed = createHash(algorithm).update(terms[0].value, "utf8").digest("hex");
  return newLiteral(valueHashed, DATA_TYPES.XSD_STRING);
}

export function newLiteral(value: string, dataType: string | NamedNode): EvaluationError | Value<Literal> {
  try {
    // Our data factory takes care of canonicalising and throwing an error when
    // the lexical form isn't valid.
    return {
      evaluationResultType: "value",
      term: dataFactory.literal(value, dataType),
    };
  } catch (e) {
    if (e instanceof ParseError) {
      return {
        evaluationResultType: "error",
        errorType: "InvalidLexicalForm",
      };
    } else {
      throw e;
    }
  }
}

export function strdt(terms: Term[]): EvaluationResult {
  const validationError = ValidateLiteralOrNamedNode(terms, [
    [validators.derivedFromStringLiteral],
    [validators.namedNode],
  ]);
  if (validationError) return validationError;

  return newLiteral(terms[0].value, terms[1] as NamedNode);
}

export function strlang(terms: Term[]): EvaluationResult {
  const validationError = ValidateLiteralOrNamedNode(terms, [[validators.stringLiteral], [validators.stringLiteral]]);
  if (validationError) return validationError;
  return newLiteral(terms[0].value, terms[1].value);
}

export function iri(terms: Term[], baseIri: string): EvaluationResult {
  const validationError = ValidateLiteralOrNamedNode(terms, [
    [validators.derivedFromStringLiteral, validators.namedNode],
  ]);
  if (validationError) return validationError;
  let namedNode;
  // When we have our own resolve function in iri validator, we should replace this function. See #7629
  const resolvedIri = resolve(terms[0].value, baseIri);
  try {
    namedNode = dataFactory.namedNode(resolvedIri);
  } catch (e) {
    if (e instanceof ParseError) return { evaluationResultType: "error", errorType: "InvalidIri", value: resolvedIri };
    throw e;
  }
  return {
    evaluationResultType: "value",
    term: namedNode,
  };
}

export function bnode(terms: Term[]): EvaluationResult {
  if (terms.length > 0) {
    const validationError = ValidateLiteralOrNamedNode(terms, [[validators.derivedFromStringLiteral]]);
    if (validationError) return validationError;
  }
  /**
   * @DECISION - After deliberation, it did not make sense to use a suboptimal way to create BlankNodes in 'argument' form
   * as we would need to keep track of either 'rows' from a resultContext or lookup the bindings everytime to ensure we are adhering to
   * the spec that says 'unique blankNode for each row, but same blankNode within a row of result if same xsd:string is used'.
   * BlankNodes with 'argument' form will not be considered, and each BNODE functional call will result in a unique blank node.
   * This is in parity with Jena, Blazegraph.
   */
  return {
    evaluationResultType: "value",
    term: dataFactory.blankNode(),
  };
}

export function datatype(terms: Term[]): EvaluationResult {
  if (!validators.literal(terms[0])) return invalidArgumentTypesError;
  return {
    evaluationResultType: "value",
    term: terms[0].datatype,
  };
}

export function xsdboolean(terms: Term[]): EvaluationResult {
  if (!validators.literal(terms[0]))
    return {
      evaluationResultType: "error",
      errorType: "InvalidArgumentTypes",
    };

  if (isDerivedFromStringLiteral(terms[0])) return newLiteral(terms[0].value, DATA_TYPES.XSD_BOOLEAN);

  // https://www.w3.org/TR/xpath-functions/#casting-boolean
  switch (terms[0].datatype.value) {
    // @DECISION we treat rdf:langString as xsd:string whenever the spec is
    //           ambiguous about it (BUT WE SHOULD STILL READ THE SPEC!!)
    case DATA_TYPES.RDF_LANG_STRING.value: // doesn't have derived types
    case DATA_TYPES.XSD_UNTYPED_ATOMIC.value: // doesn't have derived types
      return newLiteral(terms[0].value, DATA_TYPES.XSD_BOOLEAN);
    case DATA_TYPES.XSD_BOOLEAN.value:
      // > If ST is xs:boolean, then TV is SV.
      return terms[0].value === "true" ? TRUE : FALSE;
    // > If ST is xs:float, xs:double, xs:decimal or xs:integer and
    // > SV is 0, +0, -0, 0.0, 0.0E0 or NaN, then TV is false.
    // > If ST is xs:float, xs:double, xs:decimal or xs:integer and
    // > SV is not one of the above terms, then TV is true.
    case DATA_TYPES.XSD_FLOAT.value:
    case DATA_TYPES.XSD_DOUBLE.value:
      // +0, -0 and 0.0 are not canonical, so we won't encounter them
      if (["0.0E0", "-0.0E0", "NaN"].includes(terms[0].value)) return FALSE;
      else return TRUE;
    case DATA_TYPES.XSD_DECIMAL.value:
    case DATA_TYPES.XSD_INTEGER.value:
      // +0, -0 and 0.0 are not canonical, so we won't encounter them
      if (terms[0].value === "0") return FALSE;
      else return TRUE;
  }
  return {
    evaluationResultType: "error",
    errorType: "InvalidArgumentTypes",
  };
}

export function xsddatetime(terms: Term[]): EvaluationResult {
  if (!validators.literal(terms[0]))
    return {
      evaluationResultType: "error",
      errorType: "InvalidArgumentTypes",
    };
  if (isDerivedFromStringLiteral(terms[0])) return newLiteral(terms[0].value, DATA_TYPES.XSD_DATE_TIME);

  // https://www.w3.org/TR/xpath-functions/#casting-datetime
  switch (terms[0].datatype.value) {
    // @DECISION we treat rdf:langString as xsd:string whenever the spec is
    //           ambiguous about it (BUT WE SHOULD STILL READ THE SPEC!!)
    case DATA_TYPES.RDF_LANG_STRING.value: // doesn't have derived types
    case DATA_TYPES.XSD_UNTYPED_ATOMIC.value: // doesn't have derived types
      return newLiteral(terms[0].value, DATA_TYPES.XSD_DATE_TIME);
    case DATA_TYPES.XSD_DATE_TIME.value:
      return { evaluationResultType: "value", term: terms[0] };
    // If ST is xs:date, then let SYR be eg:convertYearToString( fn:year-from-date( SV )),
    // let SMO be eg:convertTo2CharString( fn:month-from-date( SV )), let SDA be
    // eg:convertTo2CharString( fn:day-from-date( SV )) and let STZ be
    // eg:convertTZtoString( fn:timezone-from-date( SV )); TV is
    // xs:dateTime( fn:concat( SYR , '-', SMO , '-', SDA , 'T00:00:00 ', STZ ) ).
    case DATA_TYPES.XSD_DATE.value:
      return newLiteral(xsdDateToxsdDatetime(terms[0].value), DATA_TYPES.XSD_DATE_TIME);
  }
  return {
    evaluationResultType: "error",
    errorType: "InvalidArgumentTypes",
  };
}

export function xsddate(terms: Term[]): EvaluationResult {
  if (!validators.literal(terms[0]))
    return {
      evaluationResultType: "error",
      errorType: "InvalidArgumentTypes",
    };
  if (isDerivedFromStringLiteral(terms[0])) return newLiteral(terms[0].value, DATA_TYPES.XSD_DATE);

  switch (terms[0].datatype.value) {
    case DATA_TYPES.XSD_UNTYPED_ATOMIC.value:
    case DATA_TYPES.RDF_LANG_STRING.value:
      return newLiteral(terms[0].value, DATA_TYPES.XSD_DATE);
    case DATA_TYPES.XSD_DATE.value:
      return { evaluationResultType: "value", term: terms[0] };
    case DATA_TYPES.XSD_DATE_TIME.value:
      const dateTime = lexicalToValue(terms[0].value, DATA_TYPES.XSD_DATE_TIME);
      const year = dateTime.year.toString();
      const month = dateTime.month.toString().padStart(2, "0");
      const day = dateTime.day.toString().padStart(2, "0");

      return newLiteral(year + "-" + month + "-" + day, DATA_TYPES.XSD_DATE);
  }

  return {
    evaluationResultType: "error",
    errorType: "InvalidArgumentTypes",
  };
}

export function xsdgYear(terms: Term[]): EvaluationResult {
  if (!validators.literal(terms[0]))
    return {
      evaluationResultType: "error",
      errorType: "InvalidArgumentTypes",
    };

  if (isDerivedFromStringLiteral(terms[0])) return newLiteral(terms[0].value, DATA_TYPES.XSD_G_YEAR);

  switch (terms[0].datatype.value) {
    case DATA_TYPES.RDF_LANG_STRING.value: // doesn't have derived types
    case DATA_TYPES.XSD_UNTYPED_ATOMIC.value: // doesn't have derived types
      return newLiteral(terms[0].value, DATA_TYPES.XSD_G_YEAR);
    case DATA_TYPES.XSD_G_YEAR.value:
      return { evaluationResultType: "value", term: terms[0] };
    case DATA_TYPES.XSD_DATE_TIME.value:
      // Since we do not maintain timezone information in the canonicalized form of dateTime objects(instead, we increase the hours/mins fields),
      // we cannot pass that information when casting from xsd:dateTime to xsd:gYear
      const dateTime = lexicalToValue(terms[0].value, DATA_TYPES.XSD_DATE_TIME);
      return newLiteral(dateTime.year.toString(), DATA_TYPES.XSD_G_YEAR);
    case DATA_TYPES.XSD_DATE.value:
      // On the other hand, timezone information is stored for xsd:date objects and thus we can include it when
      // casting from xsd:date to xsd:gYear
      const date = lexicalToValue(terms[0].value, DATA_TYPES.XSD_DATE);

      if (date.timezone === undefined) return newLiteral(date.year.toString(), DATA_TYPES.XSD_G_YEAR);

      if (date.timezone === 0) {
        // We cast to the canonicalized form of gYear when the timezone is 00:00 or Z,
        return newLiteral(date.year + "Z", DATA_TYPES.XSD_G_YEAR);
      }

      // Otherwise, we convert it to the (+|-)HH:MM format.
      const tzSign = Math.sign(date.timezone) + "" === "1" ? "+" : "-";
      const absTimezone = Math.abs(date.timezone);
      const tzHours = Math.floor(Number(absTimezone) / 60)
        .toString()
        .padStart(2, "0");
      const tzMinutes = (Number(absTimezone) % 60).toString().padStart(2, "0");
      const reconstitutedTimezone = tzSign + tzHours + ":" + tzMinutes;

      return newLiteral(date.year + reconstitutedTimezone, DATA_TYPES.XSD_G_YEAR);
  }

  return {
    evaluationResultType: "error",
    errorType: "InvalidArgumentTypes",
  };
}

export function xsdfloat(terms: Term[]): EvaluationResult {
  if (!validators.literal(terms[0]))
    return {
      evaluationResultType: "error",
      errorType: "InvalidArgumentTypes",
    };

  if (isDerivedFromStringLiteral(terms[0])) return newLiteral(terms[0].value, DATA_TYPES.XSD_FLOAT);

  // https://www.w3.org/TR/xpath-functions/#casting-to-numerics
  switch (terms[0].datatype.value) {
    // @DECISION we treat rdf:langString as xsd:string whenever the spec is
    //           ambiguous about it (BUT WE SHOULD STILL READ THE SPEC!!)
    case DATA_TYPES.RDF_LANG_STRING.value: // doesn't have derived types
    case DATA_TYPES.XSD_UNTYPED_ATOMIC.value: // doesn't have derived types
    //If ST is xs:decimal, or xs:integer, then TV is xs:float( SV cast as xs:string) and the conversion is complete.
    case DATA_TYPES.XSD_DECIMAL.value:
    case DATA_TYPES.XSD_INTEGER.value:
      return newLiteral(terms[0].value, DATA_TYPES.XSD_FLOAT);
    // If ST is xs:boolean, SV is converted to 1.0E0 if SV is true and to 0.0E0 if SV is false and the conversion is complete.
    case DATA_TYPES.XSD_BOOLEAN.value:
      if (terms[0].value === "true") return newLiteral("1.0E0", DATA_TYPES.XSD_FLOAT);
      return newLiteral("0.0E0", DATA_TYPES.XSD_FLOAT);
    //If ST is xs:float, then TV is SV and the conversion is complete.
    // BUT we have to fix the value limits in recognized-datatypes package, based on this: https://www.w3.org/TR/xmlschema-2/#float
    case DATA_TYPES.XSD_FLOAT.value:
    case DATA_TYPES.XSD_DOUBLE.value:
      //@DECISION: We are not going to implement the following part right now, because we think it is too complicated
      // to follow with the representation that we have right now for floats and doubles (including powers of 10 and not 2)
      // Maybe something to be picked up in the future.
      //
      // if m (the mantissa of SV) is outside the permitted range for the mantissa of an xs:float
      // value (-2^24-1 to +2^24-1), then it is divided by 2^N where N is the lowest positive xs:integer
      // that brings the result of the division within the permitted range, and the exponent e is increased
      // by N. This is integer division (in effect, the binary value of the mantissa is truncated on the right).
      // Let M be the mantissa and E the exponent after this adjustment.

      // if E is less than -149 (the minimum exponent value in the value space of xs:float) then TV is the xs:float
      // value positive or negative zero depending on the sign of M
      if (Math.abs(Number(terms[0].value)) < 2.350988701644575e-38)
        return newLiteral(terms[0].value.charAt(0) === "-" ? "-0.0E0" : "0.0E0", DATA_TYPES.XSD_FLOAT);
      // if E exceeds 104 (the maximum exponent value in the value space of xs:float) then TV is the
      // xs:float value INF or -INF depending on the sign of M.
      if (Math.abs(Number(terms[0].value)) > 3.402823669209385e38)
        return newLiteral(terms[0].value.charAt(0) === "-" ? "-INF" : "INF", DATA_TYPES.XSD_FLOAT);
      return newLiteral(terms[0].value, DATA_TYPES.XSD_FLOAT);
  }
  return {
    evaluationResultType: "error",
    errorType: "InvalidArgumentTypes",
  };
}

export function xsddouble(terms: Term[]): EvaluationResult {
  if (!validators.literal(terms[0]))
    return {
      evaluationResultType: "error",
      errorType: "InvalidArgumentTypes",
    };

  if (isDerivedFromStringLiteral(terms[0])) {
    return newLiteral(terms[0].value, DATA_TYPES.XSD_DOUBLE);
  }
  // https://www.w3.org/TR/xpath-functions/#casting-to-numerics
  switch (terms[0].datatype.value) {
    case DATA_TYPES.XSD_DOUBLE.value:
      //If ST is xs:float, then TV is SV and the conversion is complete.
      return { evaluationResultType: "value", term: terms[0] };
    // If ST is xs:float or a type derived from xs:float, then TV is obtained as follows:
    // if SV is the xs:float value INF, -INF, NaN, positive zero, or negative zero, then
    // TV is the xs:double value INF, -INF, NaN, positive zero, or negative zero respectively.
    //-> This is happenign already in our canonicalized xsd:float literals as source terms.
    // otherwise, SV can be expressed in the form m × 2^e where the mantissa m and exponent e
    // are signed xs:integer terms whose value range is defined, and TV is the xs:double value m × 2^e.
    //-> We don't have to act on this, because floats are already in exponent format.
    case DATA_TYPES.XSD_FLOAT.value: //we don't have derived typed from float
    // @DECISION we treat rdf:langString as xsd:string whenever the spec is
    //           ambiguous about it (BUT WE SHOULD STILL READ THE SPEC!!)
    case DATA_TYPES.RDF_LANG_STRING.value: // doesn't have derived types
    case DATA_TYPES.XSD_UNTYPED_ATOMIC.value: // doesn't have derived types
    //If ST is xs:decimal, or xs:integer, then TV is xs:double( SV cast as xs:string) and the conversion is complete.
    case DATA_TYPES.XSD_DECIMAL.value:
    case DATA_TYPES.XSD_INTEGER.value:
      return newLiteral(terms[0].value, DATA_TYPES.XSD_DOUBLE);
    // If ST is xs:boolean, SV is converted to 1.0E0 if SV is true and to 0.0E0 if SV is false and the conversion is complete.
    case DATA_TYPES.XSD_BOOLEAN.value:
      if (terms[0].value === "true") return newLiteral("1.0E0", DATA_TYPES.XSD_DOUBLE);
      return newLiteral("0.0E0", DATA_TYPES.XSD_DOUBLE);
  }
  return {
    evaluationResultType: "error",
    errorType: "InvalidArgumentTypes",
  };
}

export function xsddecimal(terms: Term[]): EvaluationResult {
  if (!validators.literal(terms[0]))
    return {
      evaluationResultType: "error",
      errorType: "InvalidArgumentTypes",
    };

  if (
    isDerivedFromStringLiteral(terms[0]) ||
    // If ST is xs:decimal, xs:integer or a type derived from them, then TV is SV,
    // converted to an xs:decimal value if need be, and the conversion is complete.
    isDerivedFromDecimalLiteral(terms[0])
  ) {
    return newLiteral(terms[0].value, DATA_TYPES.XSD_DECIMAL);
  }
  // https://www.w3.org/TR/xpath-functions/#casting-to-numerics
  switch (terms[0].datatype.value) {
    // @DECISION we treat rdf:langString as xsd:string whenever the spec is
    //           ambiguous about it (BUT WE SHOULD STILL READ THE SPEC!!)
    case DATA_TYPES.RDF_LANG_STRING.value: // doesn't have derived types
    case DATA_TYPES.XSD_UNTYPED_ATOMIC.value: // doesn't have derived types
      return newLiteral(terms[0].value, DATA_TYPES.XSD_DECIMAL);
    case DATA_TYPES.XSD_DOUBLE.value:
    case DATA_TYPES.XSD_FLOAT.value:
      if (["NaN", "INF", "-INF"].includes(terms[0].value))
        return { evaluationResultType: "error", errorType: "InvalidLexicalForm" };
      return newLiteral(decimalToRoundedString(Number(terms[0].value)), DATA_TYPES.XSD_DECIMAL);
    case DATA_TYPES.XSD_BOOLEAN.value:
      if (terms[0].value === "true") return newLiteral("1", DATA_TYPES.XSD_DECIMAL);
      return newLiteral("0", DATA_TYPES.XSD_DECIMAL);
  }
  return {
    evaluationResultType: "error",
    errorType: "InvalidArgumentTypes",
  };
}

export function xsdinteger(terms: Term[]): EvaluationResult {
  if (!validators.literal(terms[0]))
    return {
      evaluationResultType: "error",
      errorType: "InvalidArgumentTypes",
    };

  if (
    isDerivedFromStringLiteral(terms[0]) ||
    // If ST is xs:integer, or a type derived from xs:integer,
    // then TV is SV, converted to an xs:integer value if need be, and the conversion is complete.
    isDerivedFromIntegerLiteral(terms[0])
  )
    return newLiteral(terms[0].value, DATA_TYPES.XSD_INTEGER);

  // https://www.w3.org/TR/xpath-functions/#casting-to-numerics
  switch (terms[0].datatype.value) {
    // @DECISION we treat rdf:langString as xsd:string whenever the spec is
    //           ambiguous about it (BUT WE SHOULD STILL READ THE SPEC!!)
    case DATA_TYPES.RDF_LANG_STRING.value: // doesn't have derived types
    case DATA_TYPES.XSD_UNTYPED_ATOMIC.value: // doesn't have derived types
      return newLiteral(terms[0].value, DATA_TYPES.XSD_INTEGER);
    // If ST is xs:decimal, xs:float or xs:double, then TV is SV with the fractional part discarded
    // and the value converted to xs:integer. Thus, casting 3.1456 returns 3 and -17.89 returns -17.
    // Casting 3.124E1 returns 31. If SV is too large to be accommodated as an integer,
    // a dynamic error is raised [err:FOCA0003].
    // If SV is one of the special xs:float or xs:double terms NaN, INF, or -INF, a dynamic error is raised.
    case DATA_TYPES.XSD_DECIMAL.value:
    case DATA_TYPES.XSD_DOUBLE.value:
    case DATA_TYPES.XSD_FLOAT.value:
      if (["NaN", "INF", "-INF"].includes(terms[0].value))
        return { evaluationResultType: "error", errorType: "InvalidLexicalForm" };
      return newLiteral(parseInt(Number(terms[0].value).toString()).toString(), DATA_TYPES.XSD_INTEGER);
    case DATA_TYPES.XSD_BOOLEAN.value:
      if (terms[0].value === "true") return newLiteral("1", DATA_TYPES.XSD_INTEGER);
      return newLiteral("0", DATA_TYPES.XSD_INTEGER);
  }
  return {
    evaluationResultType: "error",
    errorType: "InvalidArgumentTypes",
  };
}

export function xsdlong(terms: Term[]): EvaluationResult {
  if (!validators.literal(terms[0])) {
    return {
      evaluationResultType: "error",
      errorType: "InvalidArgumentTypes",
    };
  }

  if (isDerivedFromStringLiteral(terms[0]) || isDerivedFromIntegerLiteral(terms[0])) {
    return newLiteral(terms[0].value, DATA_TYPES.XSD_LONG);
  }

  switch (terms[0].datatype.value) {
    case DATA_TYPES.RDF_LANG_STRING.value:
    // @DECISION we treat rdf:langString as xsd:string whenever the spec is
    //           ambiguous about it (BUT WE SHOULD STILL READ THE SPEC!!)
    case DATA_TYPES.XSD_UNTYPED_ATOMIC.value:
      return newLiteral(terms[0].value, DATA_TYPES.XSD_LONG);
    case DATA_TYPES.XSD_DECIMAL.value:
    case DATA_TYPES.XSD_DOUBLE.value:
    case DATA_TYPES.XSD_FLOAT.value:
      if (["NaN", "INF", "-INF"].includes(terms[0].value))
        return { evaluationResultType: "error", errorType: "InvalidLexicalForm" };
      return newLiteral(parseInt(terms[0].value).toString(), DATA_TYPES.XSD_LONG);
    case DATA_TYPES.XSD_BOOLEAN.value:
      return terms[0].value === "true" ? newLiteral("1", DATA_TYPES.XSD_LONG) : newLiteral("0", DATA_TYPES.XSD_LONG);
    default:
      return {
        evaluationResultType: "error",
        errorType: "InvalidArgumentTypes",
      };
  }
}

export function xsdint(terms: Term[]): EvaluationResult {
  if (!validators.literal(terms[0]))
    return {
      evaluationResultType: "error",
      errorType: "InvalidArgumentTypes",
    };

  if (isDerivedFromStringLiteral(terms[0]) || isDerivedFromIntegerLiteral(terms[0])) {
    return newLiteral(terms[0].toString(), DATA_TYPES.XSD_INT);
  }

  // Switch based on the datatype of the term
  switch (terms[0].datatype.value) {
    case DATA_TYPES.XSD_UNTYPED_ATOMIC.value:
    case DATA_TYPES.RDF_LANG_STRING.value:
      return newLiteral(terms[0].value, DATA_TYPES.XSD_INT);
    case DATA_TYPES.XSD_DECIMAL.value:
    case DATA_TYPES.XSD_DOUBLE.value:
    case DATA_TYPES.XSD_FLOAT.value:
      return newLiteral(parseInt(terms[0].value).toString().toString(), DATA_TYPES.XSD_INT);
    case DATA_TYPES.XSD_BOOLEAN.value:
      return terms[0].value === "true" ? newLiteral("1", DATA_TYPES.XSD_INT) : newLiteral("0", DATA_TYPES.XSD_INT);

    default:
      return {
        evaluationResultType: "error",
        errorType: "InvalidArgumentTypes",
      };
  }
}

/**
 *  https://www.w3.org/TR/xpath-functions/#casting-to-string
 */
export function xsdstring(terms: Term[]): EvaluationResult {
  const term = terms[0];
  if (
    term.termType === "Literal" &&
    (term.datatype.value === DATA_TYPES.XSD_FLOAT.value || term.datatype.value === DATA_TYPES.XSD_DOUBLE.value)
  ) {
    // > If ST is xs:float or xs:double, then:
    // > If SV has the value positive or negative zero, TV is "0" or "-0" respectively.
    if (term.value === "0.0E0") return newLiteral("0", DATA_TYPES.XSD_STRING);
    if (term.value === "-0.0E0") return newLiteral("-0", DATA_TYPES.XSD_STRING);
    // note that converting to `number` and back to `string` is not a noop:
    // node doesn't use the scientific notation when printing a string
    const value = +term.value;
    const abs = Math.abs(value);
    if (0.000001 <= abs && abs < 1000000) {
      // the value space of decimals is represented by strings
      return newLiteral(valueToCanonical("" + value, DATA_TYPES.XSD_DECIMAL), DATA_TYPES.XSD_STRING);
    }
  }
  // In all other cases, we can just use the canonical form of the input datatype
  return newLiteral(term.value, DATA_TYPES.XSD_STRING);
}

// It turns out that this is just the same as all the numeric types except for xsd:double
const PROMOTABLE_NUMERIC_TYPES = SUB_TYPES.XSD_FLOAT.concat(SUB_TYPES.XSD_DECIMAL);

/**
 *  Apply number type promotion or sub type substitution to find out what the
 *  output data type of a binary numeric function should be.
 *
 *  The order of the two input arguments shouldn't matter.
 *
 *  This applies to all functions marked as `numeric` in this part of the spec:
 *  https://www.w3.org/TR/sparql11-query/#OperatorMapping.
 *
 *  The special case for `/` (division) should be handled by division itself.
 *
 *  @returns  error if the types aren't compatible,
 */
export function getNumericOutputDataType(
  a: NumericDataType,
  b: NumericDataType,
  alsoTestWithFlippedArguments: boolean = true,
): NumericDataType | InvalidArgumentTypes {
  // The body of this function assumes `a` is going to be the "bigger" type,
  // and we can then call the function again but with the arguments flipped to
  // check the reverse.

  // Type substitution:
  // https://www.w3.org/TR/xpath20/#dt-subtype-substitution
  // we don't have to check the special case of a = b, because SUB_TYPE_IRIS
  // includes every type as a subtype of itself
  if (SUB_TYPE_IRIS[a.value].includes(b.value)) return a; // a is a super type of b

  // Type promotion:
  // > https://www.w3.org/TR/xpath20/#promotion
  // > Numeric type promotion:
  // >  a. A value of type xs:float (or any type derived by restriction from
  // >     xs:float) can be promoted to the type xs:double. The result is the
  // >     xs:double value that is the same as the original value.
  // >  b. A value of type xs:decimal (or any type derived by restriction from
  // >     xs:decimal) can be promoted to either of the types xs:float or
  // >     xs:double. The result of this promotion is created by casting the
  // >     original value to the required type. This kind of promotion may
  // >     cause loss of precision.
  if ((a.equals(DATA_TYPES.XSD_DOUBLE) || a.equals(DATA_TYPES.XSD_FLOAT)) && PROMOTABLE_NUMERIC_TYPES.includes(b.value))
    return a; // b can be promoted to `a`

  // Do the same thing, but with a and b flipped
  if (alsoTestWithFlippedArguments) return getNumericOutputDataType(b, a, false);
  // We tried our best, bet couldn't find a way to make the types align 😔
  else
    return {
      evaluationResultType: "error",
      errorType: "InvalidArgumentTypes",
    };
}

export function validateAndGetNumericDataType(a: Term, b: Term): InvalidArgumentTypes | NumericDataType {
  let numericDataType: Array<NumericDataType> = [];
  for (const term of [a, b]) {
    if (term.termType !== "Literal") return { errorType: "InvalidArgumentTypes", evaluationResultType: "error" };
    if (!numericDatatypeIris.has(term.datatype.value))
      return { errorType: "InvalidArgumentTypes", evaluationResultType: "error" };
    numericDataType.push(term.datatype as NumericDataType);
  }
  return getNumericOutputDataType(numericDataType[0], numericDataType[1]);
}

function splice(str: string, index: number, value: string) {
  return str.slice(0, index) + value + str.slice(index, str.length);
}

export function xsdDateToxsdDatetime(date: string) {
  // Years in dates can have numbers below zero.
  let yearSign: string = "";

  if (date.indexOf("-") === 0) {
    yearSign = "-";
    date = date.substring(1);
  }
  // The timezones that are expected are at the end of the string and of the form : +02:00, -01:00 or Z
  if (date.includes("Z")) return yearSign + splice(date, date.length - 1, "T00:00:00");
  if (date.includes("+")) return yearSign + splice(date, date.indexOf("+"), "T00:00:00");
  const [timezone] = date.split("-").slice(3);
  if (timezone) return yearSign + splice(date, date.lastIndexOf("-"), "T00:00:00");
  //In this case, date does not include timezone
  return yearSign + date + "T00:00:00";
}

export function year(terms: Term[]): EvaluationResult {
  const validationError = ValidateLiteralOrNamedNode(terms, [[validators.dateTimeLiteral]]);
  if (validationError) return validationError;

  return {
    evaluationResultType: "value",
    term: dataFactory.literal(lexicalToValue(terms[0].value, DATA_TYPES.XSD_DATE_TIME).year, DATA_TYPES.XSD_INTEGER),
  };
}

export function month(terms: Term[]): EvaluationResult {
  const validationError = ValidateLiteralOrNamedNode(terms, [[validators.dateTimeLiteral]]);
  if (validationError) return validationError;

  return {
    evaluationResultType: "value",
    term: dataFactory.literal(lexicalToValue(terms[0].value, DATA_TYPES.XSD_DATE_TIME).month, DATA_TYPES.XSD_INTEGER),
  };
}

export function day(terms: Term[]): EvaluationResult {
  const validationError = ValidateLiteralOrNamedNode(terms, [[validators.dateTimeLiteral]]);
  if (validationError) return validationError;

  return {
    evaluationResultType: "value",
    term: dataFactory.literal(lexicalToValue(terms[0].value, DATA_TYPES.XSD_DATE_TIME).day, DATA_TYPES.XSD_INTEGER),
  };
}

export function hours(terms: Term[]): EvaluationResult {
  const validationError = ValidateLiteralOrNamedNode(terms, [[validators.dateTimeLiteral]]);
  if (validationError) return validationError;

  // @DECISION We're calculating the hours based on the UTC value. This is not what the spec expects,
  // as we should use the original hour, before any timezone offsets. Until we resolve #7452,
  // this is acceptable.
  return {
    evaluationResultType: "value",
    term: dataFactory.literal(lexicalToValue(terms[0].value, DATA_TYPES.XSD_DATE_TIME).hour, DATA_TYPES.XSD_INTEGER),
  };
}

export function minutes(terms: Term[]): EvaluationResult {
  const validationError = ValidateLiteralOrNamedNode(terms, [[validators.dateTimeLiteral]]);
  if (validationError) return validationError;

  // @DECISION We're calculating the minutes based on the UTC value. This is not what the spec expects,
  // as we should use the original minute, before any timezone offsets. Until we resolve #7452,
  // this is acceptable.
  return {
    evaluationResultType: "value",
    term: dataFactory.literal(lexicalToValue(terms[0].value, DATA_TYPES.XSD_DATE_TIME).minute, DATA_TYPES.XSD_INTEGER),
  };
}

export function seconds(terms: Term[]): EvaluationResult {
  const validationError = ValidateLiteralOrNamedNode(terms, [[validators.dateTimeLiteral]]);
  if (validationError) return validationError;

  return {
    evaluationResultType: "value",
    term: dataFactory.literal(lexicalToValue(terms[0].value, DATA_TYPES.XSD_DATE_TIME).second, DATA_TYPES.XSD_DECIMAL),
  };
}

export function timezone(terms: Term[]): EvaluationResult {
  const validationError = ValidateLiteralOrNamedNode(terms, [[validators.dateTimeLiteral]]);
  if (validationError) return validationError;

  const timezone = lexicalToValue(terms[0].value, DATA_TYPES.XSD_DATE_TIME).timezone;
  if (timezone === undefined) {
    return {
      evaluationResultType: "error",
      errorType: "InvalidTimezoneCall",
    };
  }
  return {
    evaluationResultType: "value",
    term: dataFactory.literal(
      durationToCanonical({ months: 0, seconds: timezone * 60, isNegative: false, fraction: "" }), // timezone is in minutes
      DATA_TYPES.XSD_DAYTIME_DURATION,
    ),
  };
}

export function tz(terms: Term[]): EvaluationResult {
  const validationError = ValidateLiteralOrNamedNode(terms, [[validators.dateTimeLiteral]]);
  if (validationError) return validationError;

  const timezone = lexicalToValue(terms[0].value, DATA_TYPES.XSD_DATE_TIME).timezone;
  return {
    evaluationResultType: "value",
    term: dataFactory.literal(
      timezone === undefined ? "" : timezoneFragmentToCanonical(timezone),
      DATA_TYPES.XSD_STRING,
    ),
  };
}
