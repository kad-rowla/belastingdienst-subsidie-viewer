import { AggregateFunction } from "./Algebra/Expression.js";
import { DATA_TYPES, dataFactory, Term, Variable } from "./constants.js";
// Needed this import to avoid ts complaining about types that arent portable
import "@triplydb/data-factory/Terms.js";
export const TRUE = {
  evaluationResultType: "value",
  term: dataFactory.literal("true", DATA_TYPES.XSD_BOOLEAN),
} as const;

export const FALSE = {
  evaluationResultType: "value",
  term: dataFactory.literal("false", DATA_TYPES.XSD_BOOLEAN),
} as const;

export const invalidArgumentTypesError: InvalidArgumentTypes = {
  evaluationResultType: "error",
  errorType: "InvalidArgumentTypes",
} as const;

interface PartialAverage {
  total: EvaluationResult;
  count: number;
}
export interface PartialGroupConcat {
  data: EvaluationResult;
  count: number;
  separator: string;
}
interface PartialCount {
  count: number;
}
interface PartialSum {
  value: EvaluationResult;
}
interface PartialSample {
  value: Term | undefined;
}
interface PartialMin {
  value: EvaluationResult | undefined;
}

interface PartialMax {
  value: EvaluationResult | undefined;
}

export type AggregationFunctionNames = AggregateFunction["function"];

type IntermediateValue = {
  AVG: PartialAverage;
  COUNT: PartialCount;
  GROUP_CONCAT: PartialGroupConcat;
  SAMPLE: PartialSample;
  SUM: PartialSum;
  MIN: PartialMin;
  MAX: PartialMax;
};

interface IAggregationBody<K extends AggregationFunctionNames> {
  initData: () => IntermediateValue[K];
  partialUpdate: (data: IntermediateValue[K], result: EvaluationResult) => void;
  finalizeResult: (data: IntermediateValue[K]) => EvaluationResult;
}

export type AggregationType<T extends AggregationFunctionNames> = {
  [K in T]: Readonly<IAggregationBody<K>>;
};

/**
 * This class of error will be returned when an expression errors.
 * Various reasons this could happen are:
 *   - invalid types for the given operator
 *   - unbound variables
 *   - invalid lexical forms
 *   - ...
 *
 * The distinction is made so that one can return this specific type and handle it accordingly to the SPARQL spec
 *  (relevant for e.g. FILTER, EXTEND), while others (programming errors) can be re-thrown.
 */
export type EvaluationErrorName =
  | "CastError"
  | "CoalesceError"
  | "EffectiveBooleanValueError"
  | "EmptyAggregateError"
  | "IncompatibleLanguageOperation"
  | "InError"
  | "InvalidArgumentTypes"
  | "InvalidGraphName"
  | "InvalidLexicalForm"
  | "InvalidIri"
  | "InvalidTimezoneCall"
  | "RDFEqualTypeError"
  | "UnboundVariableError"
  | "UndefinedComparisonError";

export type HashAlgorithm = "md5" | "sha1" | "sha256" | "sha384" | "sha512";

export type EvaluationResult = EvaluationError | Value;
export type EvaluationError =
  | CastError
  | CoalesceError
  | EffectiveBooleanValueError
  | EmptyAggregateError
  | IncompatibleLanguageOperation
  | InError
  | InvalidArgumentTypes
  | InvalidGraphName
  | InvalidLexicalForm
  | InvalidIri
  | InvalidTimezoneCall
  | RDFEqualTypeError
  | UnboundVariableError
  | UndefinedComparisonError;

interface BaseEvaluationResult {
  evaluationResultType: "error" | "value";
}

export interface Value<T extends Term = Term> extends BaseEvaluationResult {
  evaluationResultType: "value";
  term: T;
}

interface BaseEvaluationError extends BaseEvaluationResult {
  evaluationResultType: "error";
  errorType: EvaluationErrorName;
}

/**
 * A variable in the expression was not bound.
 */
export interface UnboundVariableError extends BaseEvaluationError {
  errorType: "UnboundVariableError";
  variable: Variable;
}

/**
 * Two terms are being ordered, but comparisons between them are undefined, according to
 * https://www.w3.org/TR/sparql11-query/#modOrderBy
 */
export interface UndefinedComparisonError extends BaseEvaluationError {
  errorType: "UndefinedComparisonError";
}

/**
 * A literal has an invalid lexical form for the datatype it is accompanied by.
 * This error is only thrown when the term is as function argument that requires
 * a valid lexical form.
 */
export interface InvalidLexicalForm extends BaseEvaluationError {
  errorType: "InvalidLexicalForm";
}
export interface InvalidIri extends BaseEvaluationError {
  errorType: "InvalidIri";
  value: string;
}

/**
 * An equality test was done on literals with unsupported datatypes.
 *
 * See {@link https://www.w3.org/TR/sparql11-query/#func-RDFterm-equal | term equality spec}.
 */
export interface RDFEqualTypeError extends BaseEvaluationError {
  errorType: "RDFEqualTypeError";
}

/**
 * All the expressions in a COALESCE call threw errors.
 */
export interface CoalesceError extends BaseEvaluationError {
  errorType: "CoalesceError";
}

/**
 * No arguments to an IN call where equal, and at least one threw an error.
 */
export interface InError extends BaseEvaluationError {
  errorType: "InError";
}

/**
 * Literals were passed to an operator that doesn't support their datatypes.
 */
export interface InvalidArgumentTypes extends BaseEvaluationError {
  errorType: "InvalidArgumentTypes";
}

/**
 * An invalid term is bound to a graph name. E.g., we're trying to use a Literal in the graph position
 */
export interface InvalidGraphName extends BaseEvaluationError {
  errorType: "InvalidGraphName";
}

/**
 * An invalid typecast happened.
 */
export interface CastError extends BaseEvaluationError {
  errorType: "CastError";
}

export interface InvalidTimezoneCall extends BaseEvaluationError {
  errorType: "InvalidTimezoneCall";
}

export interface IncompatibleLanguageOperation extends BaseEvaluationError {
  errorType: "IncompatibleLanguageOperation";
}

export interface EmptyAggregateError extends BaseEvaluationError {
  errorType: "EmptyAggregateError";
}

/**
 * An invalid argument type was passed to the effectiveBooleanValue function.
 */
export interface EffectiveBooleanValueError extends BaseEvaluationError {
  errorType: "EffectiveBooleanValueError";
}
