import { Variable, DATA_TYPES, GEO_FUNCTIONS } from "../constants.js";
import { NamedNode, Literal } from "@triplydb/data-factory/Terms.js";
import { XPATH_FUNCTIONS } from "@triplydb/recognized-datatypes/utils/constants.js";
import { Operation } from "./Operation.js";

// See `sparql_expression` in: https://git.triply.cc/prolog/reasoning/-/blob/main/doc/types/algebra.org
// `Error` is not included in this type, because it is a possible return value
// of an expression, but not itself an expression.
type ExpressionType = (typeof EXPRESSION_TYPES)[number];
const EXPRESSION_TYPES = [
  "AggregateFunction", // https://www.w3.org/TR/sparql11-query/#rAggregate
  "Exists", // https://www.w3.org/TR/sparql11-query/#rExistsFunc
  "FunctionCall", // https://www.w3.org/TR/sparql11-query/#SparqlOps
  "Term",
  "Variable",
  "Bound", // https://www.w3.org/TR/sparql11-query/#bound
  "Operation", // https://issues.triply.cc/issues/7895
] as const;

/**
 *  We chose to not disambiguate between the different kinds of functions on
 *  the algebra level, but instead keep the knowledge implicit in the implementation.
 *
 *  For instance, functional forms (https://www.w3.org/TR/sparql11-query/#func-forms)
 *  have different evaluation rules of their arguments than "normal" function,
 *  but this is not expressed in the algebra.
 *
 *  Operators are also included, using the name from the left column of the
 *  operator mapping https://www.w3.org/TR/sparql11-query/#OperatorMapping,
 *  but some redundant operators have been left out.
 */
export type FunctionName = FunctionCall["function"];

export interface Bound extends BaseExpression {
  expressionType: "Bound";
  variable: Variable;
}

export type Expression =
  | VariableExpression
  | TermExpression
  | Bound
  | FunctionCall
  | ExistsExpression
  | OperationExpression;
export type AggregateFunction = NormalAggregateFunction | Count | GroupConcat;

/**
 * A non-aggregate function call
 */
export type FunctionCall =
  | NilFunction
  | BNode // zero or one argument
  | UnaryFunction
  | OptionallyBinaryFunction
  | BinaryFunction
  | OptionallyTernaryFunction
  | If // three arguments
  | Replace // three or four arguments
  | Concat // two or more arguments
  | Coalesce; // any number of arguments

interface BaseExpression {
  expressionType: ExpressionType;
}

interface NAryExpression extends BaseExpression {
  expressions: Array<Expression>;
}

interface UnaryExpression extends BaseExpression {
  expression: Expression;
}

export interface VariableExpression extends BaseExpression {
  expressionType: "Variable";
  variable: Variable;
}

export interface TermExpression extends BaseExpression {
  expressionType: "Term";
  // We can't use IDs in the algebra, because the IDs depend on the data and
  // we want to be able to generate the algebra from the query AST without
  // access to the data.
  term: Literal | NamedNode;
}

/**
 *  "NOT EXISTS" is equivalent to `!(EXISTS operation)`
 *
 *  https://www.w3.org/TR/sparql11-query/#func-filter-exists
 */
export interface ExistsExpression extends BaseExpression {
  expressionType: "Exists";
  operation: Operation;
}

/**
 * Return the value bound to `outputVariable` in the first result of `operation`.
 *
 * Used to implement https://www.w3.org/TR/shacl-af/#SPARQLFunction
 */
export interface OperationExpression extends BaseExpression {
  expressionType: "Operation";
  resultVariable: Variable;
  operation: Operation;
}

interface BaseAggregateFunction {
  expressionType: "AggregateFunction";
  distinct: boolean;
}

export const AGGREGATE_FUNCTION_NAMES = ["COUNT", "SUM", "MIN", "MAX", "AVG", "SAMPLE", "GROUP_CONCAT"] as const;
interface NormalAggregateFunction extends BaseAggregateFunction, UnaryExpression {
  expressionType: "AggregateFunction";
  function: Exclude<(typeof AGGREGATE_FUNCTION_NAMES)[number], "COUNT" | "GROUP_CONCAT">;
}

export interface Count extends BaseAggregateFunction {
  function: "COUNT";
  expression: UnaryExpression["expression"] | { expressionType: "WildCard" };
}

export interface GroupConcat extends BaseAggregateFunction, UnaryExpression {
  expressionType: "AggregateFunction";
  function: "GROUP_CONCAT";
  separator: string;
}

interface BaseFunction extends NAryExpression {
  expressionType: "FunctionCall";
}

/**
 *
 *  @DECISION Interface for IN is removed and translation is replaced
 *
 *  1. "IN" is equivalent to disjunction of equivalence.
 *  2. "NOT IN" is equivalent to `!(IN EXPR)`
 *
 * (eg). ?a in (0, 1, 2) => (?a = 0) || (?a = 1) || (?a = 2)
 *  This disjunction is optimized because the execution exits as soon as
 *  the first equivalence is reached.
 *
 *  https://www.w3.org/TR/sparql11-query/#func-not-in
 */

// -------------- Other functions ordered by number of arguments --------------

export const NIL_FUNCTION_NAMES = ["RAND", "NOW", "UUID", "STRUUID"] as const;
export interface NilFunction extends BaseFunction {
  function: (typeof NIL_FUNCTION_NAMES)[number];
  expressions: [];
}

export interface BNode extends BaseFunction {
  function: "BNODE";
  expressions: [] | [Expression];
}

export const UNARY_FUNCTION_NAMES = [
  "!",
  "STR",
  "LANG",
  "DATATYPE",
  "IRI",
  // "URI",
  // > The URI function is a synonym for IRI.
  // https://www.w3.org/TR/sparql11-query/#func-iri
  "ABS",
  "CEIL",
  "FLOOR",
  "ROUND",
  "STRLEN",
  "UCASE",
  "LCASE",
  "ENCODE_FOR_URI",
  "YEAR",
  "MONTH",
  "DAY",
  "HOURS",
  "MINUTES",
  "SECONDS",
  "TIMEZONE",
  "TZ",
  "MD5",
  "SHA1",
  "SHA256",
  "SHA384",
  "SHA512",
  "isIRI",
  // "isURI" is equivalent to "isIRI"
  // > isURI is an alternate spelling for the isIRI operator.
  // https://www.w3.org/TR/sparql11-query/#func-isIRI
  "isBlank",
  "isLiteral",
  "isNumeric",
  DATA_TYPES.XSD_BOOLEAN.value,
  DATA_TYPES.XSD_DOUBLE.value,
  DATA_TYPES.XSD_FLOAT.value,
  DATA_TYPES.XSD_DECIMAL.value,
  DATA_TYPES.XSD_INTEGER.value,
  DATA_TYPES.XSD_INT.value,
  DATA_TYPES.XSD_LONG.value,
  DATA_TYPES.XSD_DATE_TIME.value,
  DATA_TYPES.XSD_DATE.value,
  DATA_TYPES.XSD_G_YEAR.value,
  DATA_TYPES.XSD_STRING.value,
  XPATH_FUNCTIONS.BOOLEAN,
  XPATH_FUNCTIONS.LANG,
  XPATH_FUNCTIONS.ENCODE_FOR_URI,
  GEO_FUNCTIONS.METRIC_AREA.value,
] as const;
export interface UnaryFunction extends BaseFunction {
  function: (typeof UNARY_FUNCTION_NAMES)[number];
  expressions: [Expression];
}

export interface OptionallyBinaryFunction extends BaseFunction {
  function: "+" | "-" | typeof GEO_FUNCTIONS.TRANSFORM.value | (typeof XPATH_FUNCTIONS)["ROUND"];
  expressions: [Expression] | [Expression, Expression];
}

export const BINARY_FUNCTION_NAMES = [
  "||",
  "&&",
  // "!=" is equivalent to `!(EXPR1 = EXPR2)`
  // "<=" is equivalent to `!(EXPR1 > EXPR2)`
  // ">=" is equivalent to `!(EXPR1 < EXPR2)`
  // ">"  is equivalent to `EXPR2 < EXPR1`
  "=",
  "<",
  "*",
  "/",
  "LANGMATCHES",
  "CONTAINS",
  "STRSTARTS",
  "STRENDS",
  "STRBEFORE",
  "STRAFTER",
  "STRLANG",
  "STRDT",
  "sameTerm",
  XPATH_FUNCTIONS.COMPARE,
  XPATH_FUNCTIONS.ROUND,
  GEO_FUNCTIONS.PROJECT.value,
  GEO_FUNCTIONS.AREA.value,
] as const;

export interface BinaryFunction extends BaseFunction {
  function: (typeof BINARY_FUNCTION_NAMES)[number];
  expressions: [Expression, Expression];
}
export interface OptionallyTernaryFunction extends BaseFunction {
  function: "SUBSTR" | "REGEX";
  expressions: [Expression, Expression] | [Expression, Expression, Expression];
}

interface If extends BaseFunction {
  function: "IF";
  expressions: [Expression, Expression, Expression];
}
interface Replace extends BaseFunction {
  function: "REPLACE";
  expressions: [Expression, Expression, Expression] | [Expression, Expression, Expression, Expression];
}

export interface Coalesce extends BaseFunction {
  function: "COALESCE";
}
export interface Concat extends BaseFunction {
  function: "CONCAT";
  expressions: Expression[];
}
