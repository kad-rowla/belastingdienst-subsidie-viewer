import * as SparqlJs from "sparqljs";

/**
 *  NB the following url says sparqlQuery, but it refers to the Algebra...
 *  See https://www.w3.org/TR/sparql11-query/#sparqlQuery
 *  Graph Pattern | Solution Modifiers | Property Path
 *  ------------- | ------------------ | -------------
 *  BGP           | ToList             | PredicatePath
 *  Join          | OrderBy            | InversePath
 *  LeftJoin      | Project            | SequencePath
 *  Filter        | Distinct           | AlternativePath
 *  Union         | Reduced            | ZeroOrMorePath
 *  Graph         | Slice              | OneOrMorePath
 *  Extend        | ToMultiSet         | ZeroOrOnePath
 *  Minus         |                    | NegatedPropertySet
 *  Group         |
 *  Aggregation   |
 *  AggregateJoin |
 *
 *  It also seems like there is a `Path` graph pattern that is not mentioned in
 *  this table, but is mentioned here:
 *  https://www.w3.org/TR/sparql11-query/#sparqlTranslatePathPatterns
 */

import { Bindings, GraphName, Term, Variable } from "../constants.js";
import { Literal, NamedNode } from "@triplydb/data-factory/Terms.js";
import { AggregateFunction, Expression } from "./Expression.js";

/**
 *  Inspired by:
 *  - https://www.w3.org/TR/sparql11-query/#sparqlAlgebra
 *  - https://git.triply.cc/prolog/reasoning/-/blob/main/doc/types/algebra.org
 *
 *  With the following considerations:
 *  - All the operations related to aggregating are combined into a single Aggregate operation.
 *  - Distinct and Reduced are left separate
 *  - a SubSelect is just a Project, but
 *  - because of the way we scope variables, we don't need the Project operation at all
 *  - ToMultiset is ignored
 */

type OperationType = Operation["operationType"];
export type Operation =
  | TriplePattern
  | ZeroOrMorePath
  | EnsureBound
  | Service
  | InlineData
  | Join
  | LeftJoin
  | Filter
  | Union
  | Extend
  | Minus
  | Aggregate
  | OrderBy
  | Distinct
  | Slice;

/**
 *  An operation that returns exactly those result contexts that it received.
 *
 *  This is essentially a no-op.
 */
export const IDENTITY = Object.freeze({
  operationType: "Join",
  inputOperations: [],
  id: "identity",
} as const) satisfies Join;

export type Identity = typeof IDENTITY;

/**
 *  An operation that never returns results.
 *
 *  Useful for short-circuiting during Algebra optimisation.
 */
export const NOTHING = Object.freeze({
  operationType: "Union",
  inputOperations: [],
  id: "nothing",
} as const) satisfies Union;

export type Nothing = typeof NOTHING;

/**
 *  https://www.w3.org/TR/sparql11-query/#GraphPattern
 *  https://www.w3.org/TR/sparql11-query/#sparqlTranslatePathPatterns
 *  https://www.w3.org/TR/sparql11-query/#defn_PropertyPathPattern
 *
 *  > A property path does not span multiple graphs in a dataset.
 *  from: https://www.w3.org/TR/sparql11-query/#sparqlPropertyPaths
 */
export type SimpleTriplePattern = Readonly<
  [NamedNode | Variable, NamedNode | Variable, NamedNode | Literal | Variable]
>;
export interface TriplePattern extends BaseOperation {
  operationType: "TriplePattern";
  /** We removed the Graph operation in #7878 and included the graphs property.
   * This property is:
   * A. `undefined` when we want to query the default graph*.
   * B. `Variable` when triple pattern is a child of GRAPH operation with graph value a variable.
   * C. `[GraphName]` when triple pattern is a child of GRAPH operation with graph value an IRI.
   * D. `[GraphName, ...GraphName[]]` when the triple pattern is being multigraph optimized.
   *
   * * NB "default graph" is _not_ the rdfjs DefaultGraph term. With "default graph", we mean what
   *      the SPARQL spec calls the default graph. For TriplyDB, this is the collection of all named
   *      graphs taken together.
   */
  graphs?: Variable | [GraphName, ...GraphName[]];
  pattern: SimpleTriplePattern;
}

export interface ZeroOrMorePath extends UnaryOperation {
  operationType: "ZeroOrMorePath";
  // Our zero-or-more-path implementation requires the start to be a bound variable
  boundStart: Variable;
  end: Variable;
}

/**
 *  Make sure that the mentioned variables is bound.
 *
 *  This is NOT an operation from the standard.
 *
 *  If, during execution, the variable is already bound, then this acts as a
 *  noop (IDENTITY). Otherwise, returns a result for every node in the data:
 *
 *  > Definition: Node set of a graph
 *  >
 *  > The node set of a graph G, nodes(G), is:
 *  >
 *  > nodes(G) = { n | n is an RDF term that is used as a subject or object of a triple of G}
 *  from: https://www.w3.org/TR/sparql11-query/#defn_nodeSet
 */
export interface EnsureBound extends BaseOperation {
  /**
   * During execution, we might want to create a new TriplePattern operation, which needs a graphs property.
   */
  graphs?: Variable | [GraphName];
  operationType: "EnsureBound";
  variable: Variable;
}

interface BaseOperation {
  operationType: OperationType;
  id?: string;
}

interface UnaryOperation extends BaseOperation {
  inputOperation: Operation;
}

/**
 *  An operation that can have any number of child operations.
 */
interface NAryOperation extends BaseOperation {
  inputOperations: ReadonlyArray<Operation>;
}

interface BinaryOperation extends NAryOperation {
  inputOperations: readonly [Operation, Operation];
}

/**
 *  https://www.w3.org/TR/2013/REC-sparql11-federated-query-20130321/
 *
 *  Using VALUES clauses to communicate with the other endpoint is going to be
 *  fun
 */

export interface Service extends BaseOperation {
  operationType: "Service";
  runTimeInformation: serviceRunTimeInfo;
  silent: boolean;
}
export interface serviceRunTimeInfo {
  endpoint: SparqlJs.IriTerm | Variable;
  query: SparqlJs.SelectQuery;
}

/**
 *  The translation of a VALUES clause, AKA ToMultiSet.
 */
export interface InlineData extends BaseOperation {
  operationType: "InlineData";
  values: ReadonlyArray<Bindings<Term>>;
}

/**
 *  This is an _inner_ join
 *  https://www.w3.org/TR/sparql11-query/#defn_algJoin
 */
export interface Join extends NAryOperation {
  operationType: "Join";
  inputOperations: readonly Exclude<Operation, Join>[];
}

/**
 *  Given a solution from the first operand, do a join with the second operand.
 *  However, if no compatible solution is found from the second operand, the
 *  solution from the first operand is returned as is.
 *
 *  https://www.w3.org/TR/sparql11-query/#optionals
 *  https://www.w3.org/TR/sparql11-query/#defn_algLeftJoin
 */
export interface LeftJoin extends BinaryOperation {
  operationType: "LeftJoin";
}

/**
 *  https://www.w3.org/TR/sparql11-query/#evaluation
 *  https://www.w3.org/TR/sparql11-query/#defn_algFilter
 *
 *  @DECISION
 *  Each Filter operation should have a list of variables that are within its scope.
 *  These are determined as we translate group graph patterns to operations.
 *  During the filter execution, a new results context is created, with only those variables
 *  that should be within it's scope.
 *  https://issues.triply.cc/issues/7044
 *
 *  This is a decision as the spec calls for a DIFF function that would deal with this duriing 'left join'
 *  operations. The diff function would be very difficult to implement, and is only used in one place.
 *  That is why we went with this approach
 *  https://www.w3.org/TR/sparql11-query/#defn_algLeftJoin
 */
export interface Filter extends UnaryOperation {
  operationType: "Filter";
  expression: Expression;
}

/**
 *  Concatenate all the solutions from all the operands, i.e.:
 *
 *    for operand of union:
 *      for solution of evaluate(operand):
 *        yield solution
 *
 *  https://www.w3.org/TR/sparql11-query/#defn_algUnion
 */
export interface Union extends NAryOperation {
  operationType: "Union";
  inputOperations: readonly Exclude<Operation, Union>[];
}

/**
 *  Every solution F from the first operand, excluding those for which there
 *  exists a solution S from the second operand s.t. S and F share at least
 *  one variable AND S and F are compatible.
 *
 *  https://www.w3.org/TR/sparql11-query/#defn_algMinus
 */
export interface Minus extends BinaryOperation {
  operationType: "Minus";
}

/**
 *  Bind the evaluation of `expression` to `variable` and add it to the current
 *  solution.
 *
 *  E.g. `BIND("expression" as ?variable)`
 *
 *  https://www.w3.org/TR/sparql11-query/#defn_extend
 *
 *  Translated to English:
 *  > if var not in dom(μ)
 *  means "if the variable isn't already bound"
 *
 *  So these quotes translate as follows:
 *
 *  > Extend(μ, var, expr) = μ ∪ { (var,value) | var not in dom(μ) and value = expr(μ) }
 *  if `var` is not bound and `expr` evaluates to `value`, then bind `var` to `value`
 *
 *  > Extend(μ, var, expr) = μ if var not in dom(μ) and expr(μ) is an error
 *  if `var` is not bound and `expr` evaluates to an error, do nothing
 *
 *  > Extend is undefined when var in dom(μ).
 *  if `var` is bound, the standard does not define what to do (we should throw an Error)
 *  PS. this is something we can already detect at parsing time (and sparqljs does!)
 *
 *  > Extend(Ω, var, expr) = { Extend(μ, var, expr) | μ in Ω }
 *  Blabla mathematics for pedantic people. It boils down to something like:
 *
 *      function extend(bindingses: Bindings[], var, expr) {
 *        return bindingses.map((bindings) => extend(bindings, var, expr))
 *      }
 */
export interface Extend extends UnaryOperation {
  operationType: "Extend";
  variable: Variable;
  expression: Expression;
}

export interface OrderingKey {
  direction: "ascending" | "descending";
  expression: Expression;
}

/**
 *  Order lexicographically by the expressions.
 *
 *  https://www.w3.org/TR/sparql11-query/#defn_algOrdered
 */
export interface OrderBy extends UnaryOperation {
  operationType: "OrderBy";
  ordering: ReadonlyArray<OrderingKey>;
}

/**
 *  > choose certain variables
 *  from: https://www.w3.org/TR/sparql11-query/#sparqlSolMod
 *
 *  Basically the part of the query between SELECT and WHERE:
 *
 *     SELECT ?p ?o WHERE { ?s ?p ?o }
 *            ^^^^^
 *          this part
 *
 *  https://www.w3.org/TR/sparql11-query/#defn_algProjection
 *
 *  Because of the way we scope variables, we don't need a Project operation
 */

/**
 *  > ensure solutions in the sequence are unique
 *  from: https://www.w3.org/TR/sparql11-query/#sparqlSolMod
 *
 *  https://www.w3.org/TR/sparql11-query/#defn_algDistinct
 */
export interface Distinct extends UnaryOperation {
  operationType: "Distinct";
  /**
   * The variables that we want to keep distinct
   */
  variables: Variable[];
}

/**
 *  The combination of LIMIT and OFFSET clauses.
 *
 *  `offset` is not optional, because it defaults to 0:
 *  > An `OFFSET` of zero has no effect.
 *  from: https://www.w3.org/TR/sparql11-query/#modOffset
 *
 *  https://www.w3.org/TR/sparql11-query/#defn_algSlice
 */
export interface Slice extends UnaryOperation {
  operationType: "Slice";
  offset: number;
  limit?: number;
  /**
   *  Whether to load all result of this subquery into memory before doing a
   *  join. This is a fix for https://issues.triply.cc/issues/7276.
   */
  loadIntoMemory: boolean;
}
export type AggregatingExpressions = { [variable: Variable]: AggregateFunction };
/**
 *  https://www.w3.org/TR/sparql11-query/#defn_algGroup
 */
export interface Aggregate extends UnaryOperation {
  operationType: "Aggregate";

  /**
   *  The expressions appearing after GROUP BY
   *  https://www.w3.org/TR/sparql11-query/#groupby
   */
  groupingExpressions: Expression[];

  /**
   *  The expressions that appear in the grouped projection, e.g.:
   *
   *      SELECT (AVG(?size) - 10 AS ?asize)
   *              ^^^^^^^^^^^^^^^
   *                 this part
   */
  aggregatingExpressions: AggregatingExpressions;
}
