/**
 * Contains all optimization that does not require a 'stats' file. These are common optimization that can yield a lot of performance improvement
 */

import { cloneDeep, compact, flatten } from "lodash-es";
import { Extend, Filter, IDENTITY, Minus, NOTHING, Operation } from "../Operation.js";
import { SparqlError } from "../../Errors.js";
import { NamedNode } from "@triplydb/data-factory/Terms.js";
import { convertListToAlgebra, optimizeZeroOrMoreOperation } from "./optimize-reorder.js";
import { forEachAlgebraNode } from "../../Helpers.js";
import { getVarAndTermFromExpression, getVariablesMatchedByOperation } from "./optimization-utils.js";
import { Expression, FunctionCall } from "../Expression.js";

type RewriteOpInfo = {
  variablesInScope: Set<string>;
};

/**
 * Performs the following optimization on the algebra level
 * 1. ZeroOrMorePath Optimization - Checks if the boundStart and end can be interchanged based on the bound variables of the previous operations
 * 2. Filter Equality Rewrite
 *      a. Rewrite a filter(?var = NamedNode) to a Bind(NamedNode as var)
 */

export function optimizeAlgebraLight(operation: Operation): Operation {
  const optimizeableAlgebra = cloneDeep(operation);
  optimizeZeroOrMoreOperation(optimizeableAlgebra);
  return rewriteFilterOperation(optimizeableAlgebra);
}

export function rewriteFilterOperation(
  operation: Operation,
  info: RewriteOpInfo = { variablesInScope: new Set([]) }
): Operation {
  if (operation.id === IDENTITY.id || operation.id === NOTHING.id) return operation;

  // Handle Nested Operation (Filter->Extend (or) Extend->Filter)
  if ((operation.operationType === "Extend" || operation.operationType === "Filter") && isNestedOperation(operation)) {
    let nestedOperationList: Array<Operation> = [
      {
        ...operation,
        inputOperation: IDENTITY,
      } as Operation,
      { ...rewriteFilterOperation(operation.inputOperation, info) },
    ];
    /**
     * Re-order the new Operation. Rewrite operation returns the first executing operation at the start,
     * while convertList needs it at the end(Since there is nesting involved, we need the last operation at the beginning to easily construct the Nested Operation)
     */
    const optimalFilterOrdering = _rewriteFilterOperation(nestedOperationList, info.variablesInScope).reverse();
    const nestedAlgebra = convertListToAlgebra(optimalFilterOrdering);
    return nestedAlgebra;
  } else if ("inputOperation" in operation) {
    const unaryOperation = { ...operation };
    const rewriteInputOperation = rewriteFilterOperation(operation.inputOperation, info);
    unaryOperation.inputOperation = rewriteInputOperation;
    return unaryOperation;
  } else if (operation.operationType === "Join") {
    const joinOperation = { ...operation };
    const operationList = [...joinOperation.inputOperations];
    let joinOp = [];
    // Flatten and map each of the operation to build the 'variableInScope'
    for (const op of operationList) {
      joinOp.push(rewriteFilterOperation(op, info));
    }
    // Get the optimal Filter ordering
    const optimalFilterOrdering = _rewriteFilterOperation(joinOp, info.variablesInScope);
    return convertListToAlgebra([...optimalFilterOrdering], true);
  } else if ("inputOperations" in operation) {
    const updatedOperation = { ...operation };
    let rewrittenOperation: Array<Operation> = [];
    // Treat each of the individual operation in the list as a branch and re-write the Filter Op within it
    for (const ope of operation.inputOperations) {
      rewrittenOperation.push(rewriteFilterOperation(ope, info));
    }
    updatedOperation.inputOperations = [...rewrittenOperation] as Exclude<Minus, Operation>[];
    return updatedOperation;
  }

  // Should take care of updating the variables for all the Leaf operation.
  let varsSoFar = [...info.variablesInScope, ...getVariablesMatchedByOperation(operation)];
  info.variablesInScope = new Set(varsSoFar);
  // For all the other operation, return it without performing any additional changes
  return operation;
}

function _rewriteFilterOperation(operations: Array<Operation>, variableInScope: Set<string>) {
  // For each of the operation in the array, collect the variables that are present
  let operationList: Array<Operation> = [];
  let filterToBindOperation: Array<Extend> = [];
  let variablesAffected: Array<{ variable: string; term: NamedNode<string> }> = [];

  operations.forEach((operation) => {
    const filterVariableAndTerm = getFilterVariableAndTerm(operation);
    // Also check if the 'variable' mentioned by 'filter' is indeed 'bound' in the scope of the operation list.
    // If not, don't re-write the filter to avoid introducing new bindings.
    if (filterVariableAndTerm && variableInScope.has(filterVariableAndTerm.variable)) {
      variablesAffected.push(filterVariableAndTerm);
      filterToBindOperation.push({
        operationType: "Extend",
        id: operation.id ?? undefined,
        inputOperation: IDENTITY,
        variable: filterVariableAndTerm.variable,
        expression: {
          expressionType: "Term",
          term: filterVariableAndTerm.term,
        },
      });
    } else {
      operationList.push(operation);
    }
  });

  if (filterToBindOperation.length === 0 && operationList.length !== operations.length)
    throw new SparqlError("Re-writing filter to bind failed. Contact a developer");
  if (variablesAffected.length > 0) {
    operationList = processOperationListWithNewVars(operationList, variablesAffected);
  }
  // Post process. Move all the new bind operations to the top and remove the FilterOperations. We can freely move the bind to the top because all the terms are bound within this scope.
  operationList = [...filterToBindOperation, ...operationList];

  // Before sending it out
  return operationList;
}

function processOperationListWithNewVars(
  operationList: Array<Operation>,
  variablesAffected: Array<{ variable: string; term: NamedNode<string> }>
) {
  // Loop through the list
  // For every variable, replace with the term we have change it to
  const listOfOperation = [...operationList];
  listOfOperation.forEach(function (op, index, array) {
    forEachAlgebraNode(
      op,
      (op) => {
        if (op.operationType === "TriplePattern") {
          const pattern = { ...op.pattern };
          let stp1 = pattern[0];
          let stp2 = pattern[1];
          let stp3 = pattern[2];
          if (typeof stp1 === "string") {
            for (const varTerm of variablesAffected) {
              if (varTerm.variable === stp1) {
                stp1 = varTerm.term;
                break;
              }
            }
          }
          if (typeof stp2 === "string") {
            for (const varTerm of variablesAffected) {
              if (varTerm.variable === stp2) stp2 = varTerm.term;
            }
          }
          if (typeof stp3 === "string") {
            for (const varTerm of variablesAffected) {
              if (varTerm.variable === stp3) stp3 = varTerm.term;
            }
          }
          op.pattern = [stp1, stp2, stp3];
        }
      },
      () => {},
      undefined
    );
    array[index] = op;
  });
  return listOfOperation;
}

function getFilterVariableAndTerm(operation: Operation) {
  if (operation.operationType !== "Filter") return;
  // Check if the operation has expression
  if (operation.expression.expressionType !== "FunctionCall") return;
  const expression = operation.expression;

  // Check for equality in the functional call
  if (expression.function !== "=") return;
  // Check for the presence of a variable on the left and a Term on the right. We have to be careful about the 'term.literal' on the right because we cannot be sure when the literal will be bound.
  // For example ?x :p ?b filter(?x = 2) cannot be re-written to 2 :b ?b because subject cannot be a literal.
  const leftExpr = expression.expressions[0];
  const rightExpr = expression.expressions[1];
  const varTermLeft = getVarAndTermFromExpression(leftExpr, rightExpr);
  if (varTermLeft) return varTermLeft;
  // Try the other direction
  const varTermRight = getVarAndTermFromExpression(rightExpr, leftExpr);
  if (varTermRight) return varTermRight;
}

function isNestedOperation(operation: Filter | Extend) {
  const inputOp = operation.inputOperation;
  if (inputOp.id === IDENTITY.id || inputOp.id === NOTHING.id) return false;
  return true;
}
