import { cloneDeep, flatten, toInteger } from "lodash-es";
import log from "../../Debugging.js";
import { createJoin } from "../ASTtoAlgebra/creation.js";
import { Extend, Filter, IDENTITY, LeftJoin, Minus, NOTHING, Operation, TriplePattern, Union } from "../Operation.js";
import {
  getVariablesMatchedByOperation,
  getVariablesMentionedByExpression,
  getVariablesMentionedByOperation,
} from "./optimization-utils.js";
import { PredicateStatsAndGraphs } from "../../Execution.js";
import { Variable } from "../../constants.js";
import memoizee from "memoizee";
import { difference, intersection, isSubset } from "mnemonist/set.js";
import { NamedNode, Literal } from "@triplydb/data-factory/Terms.js";
import { FatalError } from "../../Errors.js";
import { forEachAlgebraNode } from "../../Helpers.js";
import { algebraToString } from "../utils.js";

/**
 *  Inspired by: https://git.triply.cc/triply/hdt/-/tree/master/prolog/sparql/prolog/sparql/optimize
 *  Make use of the statistics that is queried from hdt-stats to perform Algebra optimization.
 *  We can re-arrange the algebra and constrain it against a cost function and a time function to generate a performant
 *  algebra.
 *
 *  1. As a first step we re-arrange the algebra, by generating all semantically equivalent operations
 *  2. For each algebra compute the cost, is it cheap? Then keep that as the optimal algebra
 *  3. Constraint on both the time and the search space(estimate of the total bindings that could be returned), we do
 *     not want the re-order to happen forever.
 *
 * Semantic equivalence is when algebra before and after performing the reorder produces the same bindings and does not
 * change the meaning of the initial query.
 */

/**
 * Any intermediate algebra can be represented as a conjunction of disjunction. Eg, Join[Union(TP, TP), Extend->Filter]
 * can be considered as Join[Join[Union(TP, TP), Extend], Filter] and the meaning still remains the same
 */
export type ConjunctionsOfDisjunctions = Array<Operation | Operation[]>;
type OptimizedAlgebraEstimate = { operation: Operation; estimatedComplexity?: number };
// Default is to keep the depth to 1 which covers all equivalent re-arrangements for simple algebra but acts as an
// upper limit for complex algebra and prevents reordering forever
const DEPTH = 1;

export async function optimizeAlgebra(
  algebra: Operation,
  statistics: PredicateStatsAndGraphs
): Promise<OptimizedAlgebraEstimate> {
  const operationToReorder = cloneDeep(algebra);
  // Clear the cache if any before we begin the algebra generation
  memoizedEstimateComplexity.clear();
  // This should return a single Algebra that is the cheapest to execute.
  const bestAlgebra = await generateBestAlgebra(operationToReorder, DEPTH, statistics);
  // We are doing a memoized call here, this is not going to take a lot of time and won't alter the return signature
  // for the generateBestAlgebra()
  const { timeEstimate } = await memoizedEstimateComplexity(bestAlgebra, statistics);
  const optimizedBasedOnGraphsAlgebra: Operation = await optimizeMultipleGraphsOperation(bestAlgebra, statistics);
  return { operation: optimizedBasedOnGraphsAlgebra, estimatedComplexity: timeEstimate };
}

/**
 * This function generates algebras that are semantically equivalent to the given algebra.
 * It is a recursive function that performs the following steps:
 *        1. Convert the algebra to a list
 *        2. Re-arrange their positions to get all combinations of semantically equivalent list
 *        3. Convert the list back to an algebra
 * @param algebra
 */
export async function generateBestAlgebra(
  algebra: Operation,
  depth: number,
  statistics: PredicateStatsAndGraphs
): Promise<Operation> {
  // Know if the operation Type is Join or not. This is helpful to know if we are allowed to 'nest' the operations.
  // Eg, Join[Extend, Filter, TP] -> [Filter, Extend, TP], [TP, Filter, Extend] are possible re-orders. We do not lose
  // the scope by suddenly doing (Filter(Extend(TP)))
  const isJoin = algebra.operationType === "Join";
  const isFlattenedOp = algebra.operationType in ["Filter", "Extend"];
  const algebraAsList = convertAlgebraToList(algebra);

  // Re-ordering InlineData can lead to invalid algebra's we don't yet take into account. This happens for the case
  // where we're translating a GRAPH clause with a variable, which requires an InlineData operation to guarantee we
  // don't query invalid graphs.
  if (algebraAsList.some((op) => op.operationType === "InlineData")) return algebra;

  /**
   * Need to look up for the memoized estimate. Note that we are interested only in the timeEstimate at this point,
   * as the intent of algebra optimization is to find the best algebra that can reduce the time it takes to obtain the
   * bindings. The spaceEstimate measures the total number of possible bindings that will be stored in memory. This can
   * be optimised but might not neccessarily reduce the time. For documentation purpose we will leave the unused
   * spaceEstimate here. Interal working of 'cost estimation' uses the spaceEstimate to derive timeEstimate in some
   * cases. So we cannot reduce this to a single Estimate(number). If there is a need to optimize for space, switch
   * the condition below to achieve that.
   */
  let { timeEstimate: lowestTimeEstimate } = await memoizedEstimateComplexity(algebra, statistics);
  log("sparql:optimize:reorder:original-algebra", algebraToString(algebra));
  log("sparql:optimize:reorder:original-time-estimate", "%F", lowestTimeEstimate);

  let bestAlgebra: Operation = cloneDeep(algebra);
  for await (const op of reorderOperationList(algebraAsList, depth, statistics)) {
    // Discard invalid algebras
    if (isInvalidZeroOrMorePathAlgebra(op)) continue;
    const reorderedOperation = convertListToAlgebra([...op], isJoin);
    // We check if we end up with a Join again, if there is a re-order that does not satisfy this, we will discard it
    if (isJoin && reorderedOperation.operationType !== "Join") continue;
    // The opposite is also true, do not Join if there is no need to Join
    if (!isJoin && reorderedOperation.operationType === "Join") continue;

    // Additionally check if the number of operations that was produced after re-ordering matches the number of
    // operations that are nested. This is a good check to ensure we are not missing out on a deeply nested join.
    const numberOfNestedOperations = numberOfNodes(reorderedOperation);
    if (isFlattenedOp && numberOfNestedOperations !== algebraAsList.length) continue;
    const reorderedEstimate = await memoizedEstimateComplexity(reorderedOperation, statistics);
    log("sparql:optimize:reorder:reordered-algebra", algebraToString(reorderedOperation));
    log("sparql:optimize:reorder:reordered-time-estimate", "%F", reorderedEstimate.timeEstimate);
    if (reorderedEstimate.timeEstimate < lowestTimeEstimate) {
      bestAlgebra = cloneDeep(reorderedOperation);
      lowestTimeEstimate = reorderedEstimate.timeEstimate;
    }
  }
  return bestAlgebra;
}

/**
 * We flatten the nested algebra so an array of operations
 * @param operation
 * @returns
 */
export function convertAlgebraToList(operation: Operation): Operation[] {
  // As a simple rule, we will only 'flatten' operations that can be re-arranged without leaving its scope.
  // Eg: LeftJoin cannot interchange its left and right operation
  if (operation.operationType === "Join") {
    return flatten(operation.inputOperations.map(convertAlgebraToList));
  }
  if (operation.operationType === "Extend" || operation.operationType === "Filter") {
    return [
      {
        ...operation,
        inputOperation: IDENTITY,
      },
      ...convertAlgebraToList(operation.inputOperation),
    ];
  }
  return [operation];
}

/**
 * This is a generator that is responsible for making valid subgraphs for given list of operations
 *        1. A subgraph can either be disjoint, represented as [G1],[G2] or connected represented as [G1, G2]
 *        2. Operations are connected if they have at least one common variable between them
 *        3. Get all the subgraphs satisfying this criteria
 * @param conjunction
 * @returns
 */
export async function* makeConjunctionsOfDisjunctions(
  conjunction: Array<Operation>,
  depth: number,
  statistics: PredicateStatsAndGraphs
): AsyncGenerator<ConjunctionsOfDisjunctions> {
  for (const operation of conjunction) {
    // If there are connected pairs, then check for possible reachable vertices that can be connected together
    yield* getConnectedOperations(operation, conjunction, depth, statistics);
  }
}

/**
 * Function to convert a list of possible NestedOperationList back to an algebra.
 * Eg. [TriplePattern, Extend, [Filter, TriplePattern]] -> Join(TriplePattern, Extend, Filter(TriplePattern)) will be
 *   the resulting algebra.
 * Handles deeply nested lists by converting it to a equivalent Algebra.
 * @param operations
 */
export function convertListToAlgebra(operations: ConjunctionsOfDisjunctions, isJoin: boolean = false): Operation {
  return operations.reduce<Operation>((partialOperation, opItem) => {
    // We are worried about the 'Join' at the top-leve (Join[filter, extend->tp, Tp])
    // should be properly put back as Join[extend-tp, filter, tp] and not Join[Join[extend, tp], filter, tp]
    return convertOperation(partialOperation, Array.isArray(opItem) ? convertListToAlgebra(opItem) : opItem, isJoin);
  }, IDENTITY);
}

export function convertListToLeftJoin(operations: Array<Operation | Operation[]>): LeftJoin {
  // Reduce the array to a NestedLeftJoin
  return operations.reduce<Operation>((partialOperation, opItem) => {
    if (partialOperation.id === IDENTITY.id) {
      return Array.isArray(opItem) ? convertListToLeftJoin(opItem) : opItem;
    }
    return {
      operationType: "LeftJoin",
      inputOperations: [partialOperation, Array.isArray(opItem) ? convertListToLeftJoin(opItem) : opItem],
    };
  }, IDENTITY) as LeftJoin;
}

/**
 * Helper function to check a candidate algebra for invalid operation orderings when a ZeroOrMorePath is present.
 *
 * The creation of a ZeroOrMorePath operation will always place an Extent or EnsureBound operation preceding it, to
 * ensure the start is bound. A re-order could make this invalid, if the start is not bound before the ZeroOrMorePath
 * operation.
 */
export function isInvalidZeroOrMorePathAlgebra(algebra: ConjunctionsOfDisjunctions, boundVariables?: Set<Variable>) {
  if (!boundVariables) boundVariables = new Set<Variable>();
  for (const op of algebra) {
    if (Array.isArray(op)) {
      if (isInvalidZeroOrMorePathAlgebra(op, boundVariables)) return true;
    } else {
      if (op.operationType === "Extend" || op.operationType === "EnsureBound") boundVariables.add(op.variable);
      if (op.operationType === "ZeroOrMorePath" && !boundVariables.has(op.boundStart)) return true;
    }
  }
  return false;
}

/**
 * This is a generator to get all semantically equivalent permutations for the given array of operations.
 *        1. For the array of operations, pick an operation to be moved to the beginning of the array
 *        2. Get all the remaining operations and make subgraphs. Append this subgraph with the operation held out at
 *           the beginning
 *        3. Subgraphs are all valid nested operations that can be made with a given list. Eg, [TriplePattern,
 *           TriplePattern, TriplePattern] produces 3! combinations of subgraphs
 * @param operations
 */
export async function* reorderOperationList(
  operations: Array<Operation>,
  depth: number,
  statistics: PredicateStatsAndGraphs
): AsyncGenerator<ConjunctionsOfDisjunctions> {
  // An operation can be viewed as a conjunction of its input operations
  // (or sometimes, if no input operations, a 'unit conjunction')
  // If the units of a conjunction happen to have no overlap in their variables,
  // then it's allowed to replace the conjunction with a disjunction of two or more conjunctions

  // For each operation in the list, pick an operation to the front and rearrange the remaining operations
  for (let index = 0; index < operations.length; index++) {
    // Before and after index
    const before = operations.slice(0, index);
    const after = operations.slice(index + 1, operations.length);
    // Rest of the elements
    const rest = [...before, ...after];

    // we 'fix' one operation. This should probably/sometimes allow us to create a bigger number of disconnected
    // graphs / disjunctions.
    const fixedOperation = { ...operations[index] } as Operation;
    // If any of the empty operations are present, yield and do not continue
    // This is a leaf on the operation tree. Nothing to do.
    if (fixedOperation.id === NOTHING.id || fixedOperation.id === IDENTITY.id) {
      if (rest.length !== 0) {
        throw new Error("Expected identity/nothing to always be in a 1-length conjunction");
      }
      yield [fixedOperation];
      return;
    }

    // for each legal re-arrangement of the fixed operations:
    const firstOperation = await reorderInputOperations(fixedOperation, depth, statistics);
    // If prefixOperation is the only operation that is present in the list, only yield that
    if (rest.length === 0) {
      // we don't include ...rest, because we know it's an empty array.
      yield [firstOperation];
    } else {
      // Yield all the subgraph of the rest of the conjunction
      // Note that the generator might produce no new disjunctions, if there's no legal disjunction to make.
      // (i.e. there's no subsets of units of the conjunctions which do not overlap between each other)
      for await (const perm of makeConjunctionsOfDisjunctions([...rest], depth, statistics)) {
        yield [firstOperation, ...perm];
      }
    }
  }
}

/**
 * To generate the BestLeftJoin for a Deeply Nested Linear LeftJoin of the form LeftJoin(LeftJoin(LeftJoin(A,B),C),D),
 * 1. Flatten the LeftJoin to obtain easily orderable operations - [Op(A), Op(B), Op(C), Op(D)]
 * 2. The left most operation is fixed and cannot be reordered - [Op(A)]
 * 3. For all the right operations, [Op(B), Op(C), Op(D)], find the connected operations that have the 'same' common
 *    variable that is unbound
 * 4. Using these blocks of operation, re-order based on the complexity of individual blocks, (e.g) [Op(C), Op(D), Op(B)]
 * 5. Convert the list of operation back to a nested leftjoin, LeftJoin(LeftJoin(LeftJoin(A, C), D), B)
 */
async function generateBestLeftJoin(operation: LeftJoin, hdtStats: PredicateStatsAndGraphs): Promise<LeftJoin> {
  // Returns an array of an array, containing only the nested LeftJoins that are allowed to be re-ordered,
  const [leftOperation, ...allRightOperations] = flattenLeftJoin(operation);
  // LeftJoin(LeftJoin(LeftJoin(A,B),C),D) -> A, [B,C,D]
  const varsInLeftOperation = new Set(getVariablesMentionedByOperation(leftOperation));
  const findConnectedLeftJoins = getConnectedLeftJoins(varsInLeftOperation, allRightOperations);
  // For each of the array in findConnectedLeftJoins, then perform the following
  let bestReorder = await generateBestLeftJoinReorder(findConnectedLeftJoins, varsInLeftOperation, hdtStats);
  return convertListToLeftJoin([leftOperation, ...bestReorder]);
}

// Estimate the complexity of the array, push it to an array
async function estimateOptionalRightOperationsComplexity(
  allRightOperations: Operation[][],
  varsInScope: Set<string>,
  hdtStats: PredicateStatsAndGraphs
): Promise<number[]> {
  // Initialize an empty array to store the estimates
  let estimates: number[] = [];

  // Loop through the subarrays of the list
  for (let subarray of allRightOperations) {
    let totalEstimate: Estimate = { ...STARTESTIMATE };
    for (let op of subarray) {
      let individualEstimate = await estimateAlgebraComplexity(op, varsInScope, hdtStats, totalEstimate);
      // Complexity of LeftJoin(LeftJoin(A, B), C) = Estimate of A + (Estimate of B)+(Estimate of B)* (Estimate of C)
      // (or) Estimate(B) (1+Estimate(C))
      totalEstimate.spaceEstimate *= 1 + individualEstimate.spaceEstimate;
      totalEstimate.timeEstimate += totalEstimate.spaceEstimate * individualEstimate.timeEstimate;
    }
    estimates.push(totalEstimate.timeEstimate);
  }
  return estimates;
}

// Act as the 'starting' estimate for handling Join related operations
const STARTESTIMATE: Estimate = { spaceEstimate: 1, timeEstimate: 0 };

/**
 * Obtain the best Reorder of a nested LeftJoin, by arranging the complexity estimate in ascending order
 */
async function generateBestLeftJoinReorder(
  rightJoinOps: Array<Array<Operation>>,
  varsInScope: Set<string>,
  hdtStats: PredicateStatsAndGraphs
) {
  // For each of the operation in the Array, get the 'complexity' and arrange it in ascending order, least to complex
  // operations.
  let complexityArray: Array<number> = await estimateOptionalRightOperationsComplexity(
    rightJoinOps,
    varsInScope,
    hdtStats
  );
  const sortedArrayIndexes = complexityArray
    .map((value, index) => {
      return {
        value: value,
        index: index,
      };
    })
    .sort((a, b) => a.value - b.value)
    .map((val) => val.index);
  log("sparql:optimize:leftjoin", "Sort Indices for a Nested LeftJoin", sortedArrayIndexes);
  // Strip the individual 'array blocks' to accomodate easier convertion back to a LeftJoin operation
  return sortedArrayIndexes.flatMap((i) => rightJoinOps[i]);
}

/**
 * Create a group of operations of the form [[B], [C,F], [D], [E,G,H]] where the 'block' represent a fixed order of
 * operations that cannot be re-ordered amongst themselves, while the blocks themselves can be re-ordered.
 * 1. If there is a common variable between 2 or more operations, that is unbound(not present in the leftOperation),
 *    add it to a block.
 * 2. If the operation has no common variables with other operation (or) no variables at all, it becomes an individual
 *    block with 1 operation.
 */
export function getConnectedLeftJoins(
  varsInLeftOperation: Set<string>,
  rightOperations: Array<Operation>
): Operation[][] {
  let allGroupedBlocks: Operation[][] = [];
  let variableToGroupMap: Map<string, number> = new Map();

  /**
   * For every operation in the rightOperation list
   * 1. Get the difference in variable between the varsInLeftOperation and the current operation
   * 2. Populate 2 arrays, 'allGroupedBlocks' and 'individualBlock', where individual block holds all operations that
   *    have 1 variable in common and allGroupedBlocks has list of individualBlock
   * 3. Store the index of the allGroupedBlocks to 'annotate' the common variable within it
   * 4. If 2 or more individualBlocks have a common operation (There could be more than 1 variable that is unbound),
   *    then merge it as a single block and update the map.
   * 5. Repeat for every operation, such that it can be assigned to only 1 block
   */
  for (let op of rightOperations) {
    let opVar = new Set(getVariablesMentionedByOperation(op));

    const variables = difference(opVar, varsInLeftOperation);
    // We will use the index of the allGroupedBlock as value for every variable to determine what is grouped and what
    // isn't.
    let operationIndices: Set<number> = new Set();
    for (let variable of variables) {
      let index = variableToGroupMap.get(variable);
      if (index) {
        operationIndices.add(index);
      }
    }
    let individualBlock: Operation[] = [];
    for (let index of Array.from(operationIndices).sort()) {
      individualBlock = individualBlock.concat(allGroupedBlocks[index]);
      // Prune the blocks
      delete allGroupedBlocks[index];
    }
    // Update the individual block with the new operation
    individualBlock = [...individualBlock, op];
    // Also update all grouped blocks with the new individual block information
    allGroupedBlocks.push(individualBlock);
    for (let variable of variables) {
      variableToGroupMap.set(variable, allGroupedBlocks.length - 1);
    }
  }
  // Filter out any undefined values from the grouped array
  allGroupedBlocks = allGroupedBlocks.filter((group) => group !== undefined);

  return allGroupedBlocks;
}

/**
 * This function handles some of the Operations that cannot be flattened to an array easily.
 * @param operation
 * @returns
 */
async function reorderInputOperations(
  operation: Operation,
  depth: number,
  statistics: PredicateStatsAndGraphs
): Promise<Operation> {
  // If the operation is of a specific type(Union, LeftJoin) we handle it differently
  switch (operation.operationType) {
    case "LeftJoin":
      let leftJoinOperation;
      // To optimize LeftJoins further, check for presence of a nested LeftJoin (a minimum of 3 operations within a
      // nested LeftJoin) before we can optimize this further.
      if (isLeftJoinLinear(operation)) {
        // LinearizeLeftJoin and optimize the operation list
        const reorderedNestedLeftJoin = await generateBestLeftJoin(operation, statistics);
        // We only find the best order of the LeftJoin, the individual operation in each of the operand can be
        // optimized further
        leftJoinOperation = { ...reorderedNestedLeftJoin };
      } else {
        // We keep the order of the operation in this case
        leftJoinOperation = { ...operation };
      }
      const originalLeftJoinOperation = { ...leftJoinOperation };
      const bestNormalReorder = await generateBestAlgebra(leftJoinOperation.inputOperations[0], depth, statistics);
      const bestOptionalReorder = await generateBestAlgebra(leftJoinOperation.inputOperations[1], depth, statistics);
      originalLeftJoinOperation.inputOperations = [bestNormalReorder, bestOptionalReorder];
      return originalLeftJoinOperation;
    case "Union":
      const operationList = [...operation.inputOperations];
      const unionOperation = { ...operation };
      const bestUnionReorder = await Promise.all(
        operationList.map((operation) => generateBestAlgebra(operation, depth, statistics))
      );
      unionOperation.inputOperations = bestUnionReorder as Exclude<Minus, Operation>;
      return unionOperation;
    case "Minus":
      const normalReorder = await generateBestAlgebra(operation.inputOperations[0], depth, statistics);
      const optionalReorder = await generateBestAlgebra(operation.inputOperations[1], depth, statistics);
      return { ...operation, inputOperations: [normalReorder, optionalReorder] };
    case "Slice":
      // Slice is a unary operation and has to be within the scope of the select
      const sliceOperation = { ...operation };
      const sliceOp = operation.inputOperation;
      const sliceReorderOp = await generateBestAlgebra(sliceOp, depth, statistics);
      sliceOperation.inputOperation = sliceReorderOp;
      return sliceOperation;
    case "Distinct":
      const distinctOperation = { ...operation };
      const reorderedDistinctOp = await generateBestAlgebra(distinctOperation.inputOperation, depth, statistics);
      distinctOperation.inputOperation = reorderedDistinctOp;
      return distinctOperation;
    case "Aggregate":
      const aggregateOperation = { ...operation };
      const reorderedaggregateOp = await generateBestAlgebra(aggregateOperation.inputOperation, depth, statistics);
      aggregateOperation.inputOperation = reorderedaggregateOp;
      return aggregateOperation;
  }
  return operation;
}

/**
 * Helper for the reducer function to convert 2 operations to a single operation by either Joining or nesting them
 * appropriately.
 * @param partialOperation
 * @param nextOperation
 * @returns
 */
function convertOperation(partialOperation: Operation, nextOperation: Operation, isJoin: boolean = false) {
  // If it is a Join op at the top level, then return a simple Join() without trying to do anything with nesting

  if (isJoin) return createJoin([partialOperation, nextOperation]);

  if (
    partialOperation.operationType === "Union" ||
    partialOperation.operationType === "LeftJoin" ||
    partialOperation.operationType === "Minus"
  ) {
    return createJoin([partialOperation, nextOperation]);
  }

  // EnsureBound will live inside a join
  if (partialOperation.operationType === "EnsureBound") {
    return createJoin([partialOperation, nextOperation]);
  }

  // If partialOperation has inputOperation then add to it and return
  if ("inputOperation" in nextOperation) {
    const operationInjected = addOperations(partialOperation, nextOperation);
    if (operationInjected) return operationInjected;
  }

  // If not, any other operation, create a Join and return
  return createJoin([partialOperation, nextOperation]);
}

function addOperations(operation: Operation, inputOperation: Operation) {
  const operationToIndex = { ...inputOperation };
  // We do not handle 'inputOperations' here because we do not want to disturb their order
  if ("inputOperation" in operationToIndex) {
    if (operationToIndex.inputOperation === IDENTITY || operationToIndex.inputOperation === NOTHING) {
      operationToIndex.inputOperation = operation;
      return operationToIndex;
    }

    // If at some depth there is a free inputOperation available then put the operation after that
    const op = addOperations(operation, operationToIndex.inputOperation);
    if (op) {
      operationToIndex.inputOperation = { ...op };
      return operationToIndex;
    }
  }
}

const countUnboundVars = (varsInExpression: Set<String | Variable>, varsInScope: Set<String | Variable>): number => {
  let count: number = 0;
  if (varsInExpression.size === 0) return 0;
  // If the varsInExpression is more than 1, check if each of the variables are bound, if not increment the count
  for (const element of varsInExpression) {
    if (!varsInScope.has(element)) count++;
  }
  return count;
};

/**
 * This is a generator that gets all the operations that are connected by some variable between them.
 * Note: this does not require one common variable for all the operations, instead
 * any 2 operations that have some variable in common are connected together to form a list of connected operations.
 * We recurse based on the depth if needed
 * @param candidateUnit an Operation guaranteed to be found somewhere within `conjunction`
 * @param conjunction
 * @returns
 */
async function* getConnectedOperations(
  candidateUnit: Operation,
  conjunction: Array<Operation>,
  depth: number,
  statistics: PredicateStatsAndGraphs
): AsyncGenerator<ConjunctionsOfDisjunctions> {
  // items in this list will always be in a conjunction along with other items. never in a conjunction on their own:
  //  [..., unit, ...]
  const connectedUnits: Operation[] = [];
  // items in this list will always be in a conjunction on their own
  const independentOperation: Operation[] = [];
  const candidateUnitVars = new Set(getVariablesMentionedByOperation(candidateUnit));
  // For each operation, check if there is any intersection with the given inputOperation
  for (const op of conjunction) {
    const vars = new Set(getVariablesMentionedByOperation(op));
    // Do they intersect?, then add it to the array
    if (intersection(candidateUnitVars, vars).size !== 0) {
      connectedUnits.push(op);
    } else {
      // There is no intersection, so can be an independent operation
      independentOperation.push(op);
    }
  }

  // If there are no connected units, it denotes operations that don't have any common variables between them, their
  // order does not matter anymore because re-arranging them will always produce the same complexity estimate.
  if (connectedUnits.length === 0) {
    yield [...independentOperation];
    return;
  }

  // If there is only 1 connected unit, it is same as the original operationList, their order does not affect the
  // complexity.
  if (connectedUnits.length === 1) yield [...connectedUnits, ...independentOperation];
  // For anything more than 1 connected units, we denote that a subgraph of operations by putting it within a list,
  // herefore making it easy to re-order only the subgraph freely.
  else if (depth > 0) {
    // At this point, we know the the connectedUnits can be freely re-arranged and it produces a valid algebra
    for await (const reArrangeSubgraph of reorderOperationList(connectedUnits, depth - 1, statistics)) {
      yield [...reArrangeSubgraph, ...independentOperation];
    }
  } else yield [[...connectedUnits], ...independentOperation];
}

// Memoizing the complexity estimation here
export const memoizedEstimateComplexity = memoizee(
  async (algebra: Operation, statistics: PredicateStatsAndGraphs): Promise<Estimate> =>
    estimateAlgebraComplexity(algebra, new Set(), statistics, {
      // MARTIN new Set() is wrong here, since there could already be bound variables
      spaceEstimate: 1,
      timeEstimate: 1,
    }),
  {
    primitive: true,
    promise: true,
    max: 100,
    normalizer: function (args: [algebra: Operation, statistics: PredicateStatsAndGraphs]) {
      return JSON.stringify(args[0]);
    },
  }
);

interface Estimate {
  /**
   * This refers to the number of 'possible' bindings that will be produced by an operation.
   */
  spaceEstimate: number;
  /**
   * This refers to the time it will take to 'query' + 'process' + 'yield' all the possible 'bindings' for the
   * operation. This is an **abstract scale** where we count fetching a triple from the HDT document as unit time.
   */
  timeEstimate: number;
}

export async function estimateAlgebraComplexity(
  algebra: Operation,
  variablesInScope: Set<Variable>,
  statistics: PredicateStatsAndGraphs,
  estimate: Estimate
): Promise<Estimate> {
  // We want to perform a post-order traversal of the tree as the order of operations to also keep track of variables
  // that are bound.
  if (algebra.id === NOTHING.id || algebra.id === IDENTITY.id)
    return {
      spaceEstimate: estimate.spaceEstimate,
      // No new bindings will be added here, and the timeEstimate is kept at the lowest of 0.1
      timeEstimate: estimate.timeEstimate + 0.1,
    };
  else {
    // Recurse through the whole thing and eventually obtain the cost per operation (Cumulation of all the cost from
    // within it)
    switch (algebra.operationType) {
      case "Service":
      case "Aggregate":
        return estimate;
      case "EnsureBound":
        // EnsureBound has negligible cost if the variable is already bound (in scope)
        if (variablesInScope.has(algebra.variable)) return estimate;
        // EnsureBound will return all distinct subjects and objects if the variable is unbound, while querying
        // all triples in the dataset.
        return {
          spaceEstimate:
            estimate.spaceEstimate * ((await statistics.distinctSubjects()) + (await statistics.distinctObjects())),
          timeEstimate: estimate.timeEstimate,
        };
      case "Slice":
        // If there is a limit of x < the 'spaceEstimate' return the limit as the estimate, else return the
        // 'spaceEstimate' as it is.
        const limit = algebra.limit;
        const estimateOpComplexity = await estimateAlgebraComplexity(
          algebra.inputOperation,
          variablesInScope,
          statistics,
          estimate
        );
        if (limit && limit < estimateOpComplexity.spaceEstimate) {
          estimate.timeEstimate += limit;
          estimate.spaceEstimate += limit;
        } else {
          estimate.timeEstimate += estimateOpComplexity.timeEstimate;
          estimate.spaceEstimate += estimateOpComplexity.spaceEstimate;
        }
        return estimate;
      // The following operations do not contribute towards the complexity. So, continue walking through their
      // input operations.
      case "Distinct":
      case "OrderBy":
        // Return the estimate of the input operation
        return estimateAlgebraComplexity(algebra.inputOperation, variablesInScope, statistics, estimate);
      case "Extend":
      case "Filter":
        // For these operations, estimate the cost of expression before continuing
        estimate = await estimateAlgebraComplexity(algebra.inputOperation, variablesInScope, statistics, estimate);
        variablesInScope = new Set([...variablesInScope, ...getVariablesMatchedByOperation(algebra)]);
        // Add the estimate from the expression as well
        const expressionEstimate = estimateExpressions(algebra, estimate, variablesInScope);

        estimate.timeEstimate += expressionEstimate.timeEstimate;
        estimate.spaceEstimate += expressionEstimate.spaceEstimate;
        return estimate;
      case "InlineData":
        estimate.spaceEstimate += algebra.values.length;
        // Numbers borrowed from the swi-prolog optimizer. Might not be applicable for the context of speedy, trial
        // and error is the best approach here.
        estimate.timeEstimate += estimate.spaceEstimate * 0.2;
        return estimate;
      case "Join":
        for (const op of algebra.inputOperations) {
          // This is in-line with how a 'Left-Join' is estimated. Instead of merely adding the 'time estimate', use the
          // 'spaceEstimate' as an indicator of the expected results that gets Joined with the current operation.
          const individualJoin = await estimateAlgebraComplexity(op, variablesInScope, statistics, {
            ...STARTESTIMATE,
          });
          // Changes in #7652 ensures that the variables are normalized. Therefore, include it irrespective of the type
          // of operation.
          variablesInScope = new Set([...variablesInScope, ...getVariablesMatchedByOperation(op)]);
          estimate.spaceEstimate = estimate.spaceEstimate * individualJoin.spaceEstimate;
          estimate.timeEstimate = estimate.timeEstimate + estimate.spaceEstimate * individualJoin.timeEstimate;
        }
        return estimate;
      case "TriplePattern":
        // Get all bound variables from the operations input operation
        const branchFactor = await estimateTriplePatternComplexity(algebra, variablesInScope, statistics);
        if (branchFactor) {
          // MARTIN: in this `else` case, it seems like we should short-circuit
          //         because somehow the stats are telling us that there will be
          //         no results
          return branchFactor;
        }
        return estimate;
      case "ZeroOrMorePath":
        // Presence of an unbounded variable within the expression is punished severly.
        const inputEstimate = await estimateAlgebraComplexity(
          algebra.inputOperation,
          variablesInScope,
          statistics,
          estimate
        );
        // We use the space estimate of the input operations as an estimate of how many rows we're returning.
        // Ideally, we'd raise this to the power of the depth, but we don't have statistics to determing what that
        // would be, so we use 2 as a guesstimate.
        estimate.spaceEstimate = estimate.spaceEstimate * inputEstimate.spaceEstimate ** 2;
        // Similar to Join time estimate, we take the time estimate of the inner operations and multiple it with the
        // new space estimate. We add a large constant to the time estimate, as we couldn't make the operation more
        // expensive in other ways. See benchmark test query "issue-8239", which can run instantly.
        estimate.timeEstimate =
          estimate.timeEstimate + (inputEstimate.timeEstimate + 10000000) * estimate.spaceEstimate;
        return estimate;
      // Handle the Disjoint Operations
      case "LeftJoin":
        return estimateLeftJoinOperation(algebra, variablesInScope, statistics, estimate);
      case "Minus":
      case "Union":
        return estimateDisjointOperations(algebra, variablesInScope, statistics, { ...STARTESTIMATE });
    }
  }
}

// For a leftJoin, pass the variables on the left to the right to estimate it correctly
async function estimateLeftJoinOperation(
  operation: LeftJoin,
  variableInScope: Set<string | Variable>,
  hdtStats: PredicateStatsAndGraphs,
  estimate: Estimate
): Promise<Estimate> {
  const leftOp = operation.inputOperations[0];
  const rightOp = operation.inputOperations[1];
  // Get the estimate of the left operation
  const estimateLeft: Estimate = await estimateAlgebraComplexity(leftOp, variableInScope, hdtStats, estimate);
  // Get the estimate of the right operation
  // update the varsInScope before continuing
  const updatedVarsInScope = new Set([...variableInScope, ...getVariablesMatchedByOperation(leftOp)]);
  const estimateRight: Estimate = await estimateAlgebraComplexity(rightOp, updatedVarsInScope, hdtStats, estimate);
  const spaceEstimate = estimate.spaceEstimate * estimateLeft.spaceEstimate * estimateRight.spaceEstimate;
  // During a LeftJoin, the left is instantiated, and the time to complete the join is now based on the number of
  // results from the left operation times the time it will take to complete the right operation.
  const timeEstimate =
    estimate.timeEstimate + estimateLeft.timeEstimate + estimateLeft.spaceEstimate * estimateRight.timeEstimate;
  return { spaceEstimate: spaceEstimate, timeEstimate: timeEstimate };
}

/**
 * Estimate the complexity of the Disjoint Operations by computing the sum of the two complexity estimates of the
 * operations(left, right).
 * @param operation Union, LeftJoin, Minus (Disjoint Operations)
 * @param variablesInScope
 * @param estimate
 * @returns Estimate
 */
async function estimateDisjointOperations(
  operation: Union | Minus,
  variablesInScope: Set<string | Variable>,
  statistics: PredicateStatsAndGraphs,
  estimate: Estimate
): Promise<Estimate> {
  for (const op of operation.inputOperations) {
    const unionEstimate = await estimateAlgebraComplexity(op, variablesInScope, statistics, estimate);
    estimate.spaceEstimate += unionEstimate.spaceEstimate;
    estimate.timeEstimate += unionEstimate.timeEstimate;
  }
  return estimate;
}

// We estimate the complexity of various expressions
function estimateExpressions(operation: Extend | Filter, estimate: Estimate, variableInScope: Set<string | Variable>) {
  const operationExpression = operation.expression;
  if (
    operationExpression.expressionType === "FunctionCall" ||
    operationExpression.expressionType === "Exists" ||
    operationExpression.expressionType === "Bound" ||
    operationExpression.expressionType === "Variable"
  ) {
    const functionVariables = getVariablesMentionedByExpression(operation.expression);
    // Check the intersection between variablesInScope and the variables mentioned
    const numberOfDisjunctions = countUnboundVars(new Set(functionVariables), variableInScope);
    // Check if any variables are mentioned within the extend and also check if
    // there is no variables within its scope. This is a simple extend operation that does not take any time
    if (functionVariables.length === 0 && numberOfDisjunctions === 0)
      return { spaceEstimate: estimate.spaceEstimate, timeEstimate: estimate.timeEstimate + 1 };
    // Presence of an unbound variable within the expression is punished severly.
    return {
      spaceEstimate: estimate.spaceEstimate + estimate.spaceEstimate,
      timeEstimate: estimate.timeEstimate + 10000000 * numberOfDisjunctions + 1,
    };
    // All functional calls will have unit space (As it does not add any new bindings), but increased time complexity
  } else {
    // Return constant estimate for a term
    estimate.spaceEstimate += 1;
    estimate.timeEstimate += 0.1;
  }
  return estimate;
}

/**
 * Set of functions to only handle TriplePattern (BGP) operations.
 * We check for the presence of an unbound or a bound variable in the triple pattern
 * Space and Time complexity is linearly dependent based on the type of triple pattern.
 */
async function estimateTriplePatternComplexity(
  tpsOperation: TriplePattern,
  setOfBoundVars: Set<Variable | string>,
  statistics: PredicateStatsAndGraphs
): Promise<Estimate | undefined> {
  log("sparql:optimize:reorder:estimation:triple-pattern", "Pattern is", algebraToString(tpsOperation));
  const sub = boundOrUnboundVariable(tpsOperation.pattern[0], setOfBoundVars);
  const pred = boundOrUnboundVariable(tpsOperation.pattern[1], setOfBoundVars);
  const obj = boundOrUnboundVariable(tpsOperation.pattern[2], setOfBoundVars);
  // When all the three patterns are constant, then only 1 binding is returned
  if (
    (sub === "const" || sub === "boundVar") &&
    (pred === "const" || pred === "boundVar") &&
    (obj === "const" || obj === "boundVar")
  ) {
    log("sparql:optimize:reorder:estimation:triple-pattern", "Patterns are constant, returning 1 as the estimate");
    return {
      timeEstimate: 1,
      spaceEstimate: 1,
    };
  }

  // When predicate is known
  if (pred === "const") {
    // Remove the type that does not match
    if (typeof tpsOperation.pattern[1] === "string") return;
    // If subject is a constant/bound variable and object is unbound
    if ((sub === "const" || sub === "boundVar") && obj === "unboundVar") {
      const branchFactor = (await statistics.subjectBranchingFactor(tpsOperation.pattern[1])) || 0;
      log(
        "sparql:optimize:reorder:estimation:triple-pattern",
        "Predicate is constant, sub is bound or constant, branch factor is %F",
        branchFactor
      );
      return {
        timeEstimate: branchFactor,
        spaceEstimate: branchFactor,
      };
    }
    // If subject is unbound but object is bound/constant
    if (sub === "unboundVar" && (obj === "const" || obj === "boundVar")) {
      const branchFactor = (await statistics.objectBranchingFactor(tpsOperation.pattern[1])) || 0;
      log(
        "sparql:optimize:reorder:estimation:triple-pattern",
        "Predicate is constant, obj is bound or constant, branch factor is %F",
        branchFactor
      );
      return {
        timeEstimate: branchFactor,
        spaceEstimate: branchFactor,
      };
    }

    // If both subject and object is unbound
    if (sub === "unboundVar" && obj === "unboundVar") {
      const numberOfMatchingTriples = await statistics.numTriplesMatchingPredicate(tpsOperation.pattern[1]);
      log(
        "sparql:optimize:reorder:estimation:triple-pattern",
        "Predicate is constant, sub and obj are unbound, branch factor is %F",
        numberOfMatchingTriples
      );
      // Return number of matching predicate as the complexity
      return {
        timeEstimate: numberOfMatchingTriples,
        spaceEstimate: numberOfMatchingTriples,
      };
    }
  }

  if (pred === "unboundVar") {
    // if the object is unbound and subject is bound/const
    if ((sub === "boundVar" || sub === "const") && obj === "unboundVar") {
      const totalTriples = await statistics.countTriples();
      // Count the number of unique subjects in the entire hdt
      const subjectCount = await statistics.distinctSubjects();
      const branchFactor = subjectCount === undefined ? 0 : toInteger(totalTriples / subjectCount);
      log(
        "sparql:optimize:reorder:estimation:triple-pattern",
        "Predicate is unbound, sub is bound, branch factor is %F",
        branchFactor
      );
      return {
        timeEstimate: branchFactor,
        spaceEstimate: branchFactor,
      };
    }
    // If the object is bound/constant and subject is unbound
    if (sub === "unboundVar" && (obj === "boundVar" || obj === "const")) {
      const totalTriples = await statistics.countTriples();
      const objectCount = await statistics.distinctObjects();
      const branchFactor = objectCount === undefined ? 0 : toInteger(totalTriples / objectCount);
      log(
        "sparql:optimize:reorder:estimation:triple-pattern",
        "Predicate is unbound, obj is bound, branch factor is %F",
        branchFactor
      );
      return {
        timeEstimate: branchFactor,
        spaceEstimate: branchFactor,
      };
    }
  }

  // For all other cases, it is not longer possible to estimate the branchfactor with accuracy,
  // so estimate the total number of matching triples for the given triple pattern
  const estimatedTriples = await statistics.countTriples(tpsOperation.pattern);
  log(
    "sparql:optimize:reorder:estimation:triple-pattern",
    "Triple pattern doesn't have any bound property variable anywhere, estimated triples %F",
    estimatedTriples
  );

  return {
    spaceEstimate: estimatedTriples,
    timeEstimate: estimatedTriples,
  };
}

// Counts only the nestedOperation (all operation that has 'inputOperation' and nested with the parent)
const numberOfNodes = function (operation: Operation, count: number = 0): number {
  // Recurse the number whenever we identify a 'inputOperation' (Denoting that it is nested)
  if ("inputOperation" in operation) return numberOfNodes(operation.inputOperation, count + 1);
  return count;
};

// Returns the type of the variable in the triple pattern. This is to ensure we know how to define the branchFactor
function boundOrUnboundVariable(
  pattern: string | NamedNode | Literal,
  setOfBoundVarsBefore: Set<Variable | string>
): "boundVar" | "unboundVar" | "const" {
  if (typeof pattern === "string") return isBoundVariable(pattern, setOfBoundVarsBefore) ? "boundVar" : "unboundVar";
  else return "const";
}

// Check if the variable is present in the set of vars that have been defined before.
function isBoundVariable(variable: Variable | string, setOfVarsBefore: Set<Variable | string>): boolean {
  return setOfVarsBefore.has(variable);
}

//
/**
 * A small helper to check if the leftJoin can be linearized. This checks for a minimum of 3 nested leftjoins with the
 * following conditions:
 * 1. Allow NestedJoin of the form LeftJoin(LeftJoin(A, B), C)
 * 2. LeftJoin(A, LeftJoin(B,C)) is not considered linear
 * 3. The common variables between Op(B), Op(C) should be bound in Op(A)
 * @param operation
 * @returns
 */
export function isLeftJoinLinear(operation: LeftJoin) {
  const leftOp = operation.inputOperations[0];
  if (leftOp.operationType !== "LeftJoin") return false;
  // To make it easier, flatten the operation from LeftJoin(A, B), C to [A, B, C]
  const flattenOp = flattenLeftJoin(operation);
  if (flattenOp.length < 3) return false;

  //Condition 1. If there is an empty LeftJoin, of the form LeftJoin(LeftJoin(IDENTITY, A), B), we will not reorder
  if (flattenOp[0].id === IDENTITY.id) return false;

  // Additional conditions to ensure that the reordering of 'B' and 'C' is allowed
  const leftJoinOp1 = new Set(getVariablesMentionedByOperation(flattenOp[0]));
  const leftJoinOp2 = new Set(getVariablesMentionedByOperation(flattenOp[1]));
  const leftJoinOp3 = new Set(getVariablesMentionedByOperation(flattenOp[2]));

  const intersectionOfOp2AndOp3 = intersection(leftJoinOp2, leftJoinOp3);
  // Condition 2, no common variables makes it easy to re-order the leftjoin and the bindings are not affected by it
  if (intersectionOfOp2AndOp3.size === 0) return true;

  // Condition 3
  // If there is an intersection of variables between leftJoinOp2 and leftJoinOp3, then all the variables should also
  // be present in leftJoinOp1.
  if (intersectionOfOp2AndOp3.size > 0 && isSubset(intersectionOfOp2AndOp3, leftJoinOp1)) return true;

  // For all other cases, where there is a difference in the variables in left and right return false
  return false;
}

// Recursively flatten the NestedLeftJoin
export function flattenLeftJoin(operation: LeftJoin): Array<Operation> {
  // LeftJoin(LeftJoin(LeftJoin(A, B), C), D)
  const copyOfOperation = { ...operation };
  if (copyOfOperation.inputOperations[0].operationType !== "LeftJoin") return [...copyOfOperation.inputOperations];
  const leftOp = flattenLeftJoin(copyOfOperation.inputOperations[0]);
  const rightOp = copyOfOperation.inputOperations[1];
  return [...leftOp, rightOp];
}

export async function optimizeMultipleGraphsOperation(
  operation: Operation,
  statistics: PredicateStatsAndGraphs
): Promise<Operation> {
  // If the operation is triple pattern AND the predicate is a namednode and not a variable.
  if (
    operation.operationType === "TriplePattern" &&
    typeof operation.pattern[1] === "object" &&
    operation.pattern[1].termType === "NamedNode" &&
    typeof operation.graphs !== "string"
  ) {
    const gotGraphs = await statistics.getGraphsMatchingPredicateIfNotInAllGraphs(operation.pattern[1]);

    // If it's in all graphs present or we only have the default graph in suite tests,
    // then we don't need to rewrite the algebra.
    if (gotGraphs === undefined) {
      return operation;
    }

    // If this query belong to no graph, then we return the nothing operation
    if (!isNonEmptyGraphArray(gotGraphs)) return NOTHING;

    const optimizedOperation = { ...operation, graphs: gotGraphs };
    return optimizedOperation;
  }
  if ("inputOperation" in operation) {
    const optimizedToBeOperation = { ...operation };
    optimizedToBeOperation.inputOperation = await optimizeMultipleGraphsOperation(
      optimizedToBeOperation.inputOperation,
      statistics
    );
    return optimizedToBeOperation;
  }
  if ("inputOperations" in operation) {
    const optimizedToBeOperation = { ...operation };
    optimizedToBeOperation.inputOperations = (await Promise.all(
      optimizedToBeOperation.inputOperations.map(async (inputoperations) => {
        return optimizeMultipleGraphsOperation(inputoperations, statistics);
      })
    )) as Exclude<Minus, Operation>[];
    return optimizedToBeOperation;
  }

  return operation;
}

function isNonEmptyGraphArray(graphArray: Array<NamedNode>): graphArray is [NamedNode, ...NamedNode[]] {
  return graphArray.length > 0;
}

export function optimizeZeroOrMoreOperation(algebra: Operation) {
  forEachAlgebraNode(
    algebra,
    (operation) => {
      if (operation.operationType !== "Join") return;
      // Spread syntax because we cannot change readonly operations.
      const joinsOperations = [...operation.inputOperations];
      operation.inputOperations = reWriteInputOperations(joinsOperations) as Exclude<Minus, Operation>;
    },
    () => {},
    undefined
  );
}

function reWriteInputOperations(joinsOperations: Operation[]) {
  const shouldOptimizeForPropertyPath = joinsOperations.some(function (operation) {
    return operation.operationType === "ZeroOrMorePath";
  });
  if (!shouldOptimizeForPropertyPath) return joinsOperations;

  return joinsOperations.map((operation, index) => {
    if (operation.operationType === "ZeroOrMorePath") {
      // There will always be an EnsureBound of Extend operation preceding a ZeroOrMorePath.
      if (index === 0) {
        throw new FatalError(
          "Unexpected zero-or-more path operation as the first operation in a group. Please contact a developer."
        );
      }
      // Check whether <end> is bound in any other operation preceding the current one.
      if (
        joinsOperations.slice(0, index - 1).some(
          (inputOperation) =>
            getVariablesMatchedByOperation(inputOperation).includes(operation.end) &&
            // we exclude union for now. See ticket #7959
            inputOperation.operationType !== "Union"
        )
      ) {
        // We know that the end is bound. So, optimize the path traversal by starting from the end
        return {
          ...operation,
          boundStart: operation.end,
          end: operation.boundStart,
        };
      }
    }
    return operation;
  });
}
