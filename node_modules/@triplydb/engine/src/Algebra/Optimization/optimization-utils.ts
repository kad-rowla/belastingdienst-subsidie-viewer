import { compact, flatten, uniq } from "lodash-es";
import { Variable } from "../../constants.js";
import { FatalError, UnsupportedError } from "../../Errors.js";
import { Expression, FunctionCall } from "../Expression.js";
import { Operation } from "../Operation.js";
import { UNBOUND_VARIABLE_NAME, scopeVariables } from "../ASTtoAlgebra/variableScope.js";
import { NamedNode } from "@triplydb/data-factory/Terms.js";

// TODO: This function includes both read and binding variables. There is already a function for the latter,
// thus we should refactor. See #8023

/**
 * @param operation an algebra node.
 * @returns a list of all variables which occur at any depth under the Operation tree
 */
export function getVariablesMentionedByOperation(operation: Operation): Variable[] {
  switch (operation.operationType) {
    case "Aggregate":
      return [
        ...Object.keys(operation.aggregatingExpressions),
        ...flatten(operation.groupingExpressions.map(getVariablesMentionedByExpression)),
        ...getVariablesMentionedByOperation(operation.inputOperation),
      ];
    case "Distinct":
      return [...operation.variables, ...getVariablesMentionedByOperation(operation.inputOperation)];
    case "EnsureBound":
      return [operation.variable];
    case "Extend":
      return [
        operation.variable,
        ...getVariablesMentionedByOperation(operation.inputOperation),
        ...getVariablesMentionedByExpression(operation.expression),
      ];
    case "Filter":
      return [
        ...getVariablesMentionedByOperation(operation.inputOperation),
        ...getVariablesMentionedByExpression(operation.expression),
      ];
    case "InlineData":
      return operation.values.flatMap((bindings) => Object.keys(bindings));
    case "Join":
      return flatten(operation.inputOperations.map(getVariablesMentionedByOperation));
    case "LeftJoin":
      return flatten(operation.inputOperations.map(getVariablesMentionedByOperation));
    case "Minus":
      return flatten(operation.inputOperations.map(getVariablesMentionedByOperation));
    case "OrderBy":
      return [
        ...flatten(operation.ordering.map((o) => getVariablesMentionedByExpression(o.expression))),
        ...getVariablesMentionedByOperation(operation.inputOperation),
      ];
    case "Service":
      // We don't care about the read variables, because the service outside of speedy will take care of them.
      const scopedVariables: Variable[] = scopeVariables(operation.runTimeInformation.query).variables.map(
        (variableOrVariableExpression) => {
          if ("termType" in variableOrVariableExpression && variableOrVariableExpression.termType === "Wildcard")
            throw new FatalError("Wildcard found in scoping variables. This is a bug.");
          // SELECT (?a as ?b) ... ==> { expression: '?a', variable: '?b' }
          if ("expression" in variableOrVariableExpression) return variableOrVariableExpression.variable.value;
          return variableOrVariableExpression.value;
        }
      );
      return scopedVariables;
    case "Slice":
      return getVariablesMentionedByOperation(operation.inputOperation);
    case "TriplePattern":
      return operation.pattern.filter((a) => typeof a === "string") as string[];
    case "Union":
      return flatten(operation.inputOperations.map(getVariablesMentionedByOperation));
    case "ZeroOrMorePath":
      return [...getVariablesMentionedByOperation(operation.inputOperation), operation.boundStart, operation.end];
    default:
      throw new FatalError("Unrecognized operation type");
  }
}

export function getVariablesMatchedByOperation(operation: Operation): string[] {
  switch (operation.operationType) {
    case "Aggregate":
      const varsInScope = getVariablesMatchedByOperation(operation.inputOperation);
      const aggregatingExpressionVars = new Set(
        compact(operation.groupingExpressions.map((e) => (e.expressionType === "Variable" ? e.variable : undefined)))
      );

      return [...new Set([...varsInScope, ...aggregatingExpressionVars])];
    case "Distinct":
      const varsOfDistinct = getVariablesMatchedByOperation(operation.inputOperation);
      return [...new Set([...varsOfDistinct, ...operation.variables])];
    case "EnsureBound":
      return [operation.variable];
    case "Extend":
      const varsOfExtend = getVariablesMatchedByOperation(operation.inputOperation);
      return [...new Set([...varsOfExtend, operation.variable])];
    case "InlineData":
      return [...new Set([...flatten(operation.values.map((binding) => Object.keys(binding)))])];
    // Operations that do not affect the list of variables are assigned a value.
    case "Slice":
    case "Filter":
    case "OrderBy":
      // The variables used as part of filter do not assign any value, therefore it shouldn't be included.
      return getVariablesMatchedByOperation(operation.inputOperation);
    case "Service":
      const scopedVariables: Variable[] = scopeVariables(operation.runTimeInformation.query).variables.map(
        (variableOrVariableExpression) => {
          if ("termType" in variableOrVariableExpression && variableOrVariableExpression.termType === "Wildcard")
            throw new FatalError("Wildcard found in scoping variables. This is a bug.");
          //   SELECT (?a as ?b) ... ==> { expression: '?a', variable: '?b' }
          if ("expression" in variableOrVariableExpression) return variableOrVariableExpression.variable.value;
          return variableOrVariableExpression.value;
        }
      );
      return scopedVariables;
    case "TriplePattern":
      // Variables that are present within a triple-pattern are always trying to 'assign' some term.
      const varsInTps = operation.pattern.filter((term) => typeof term === "string") as string[];
      return varsInTps;
    case "ZeroOrMorePath":
      // Unary operation
      // operation.boundStart and operation.end will for sure be inside inputOperation.
      // But inside inputOperation we might have randomized variables
      // that cannot be considered as bound outside of this operation.
      // Thus we will exclude variables from inside inputOperation
      return [operation.end, operation.boundStart];

    // Treat the N-ary operation similarly
    // Include the variablesAssigned in each of the operation and return
    case "Join":
    case "Union":
      let variablesAssignedByJoin: Array<string> = [];
      for (const op of operation.inputOperations) {
        variablesAssignedByJoin.push(...getVariablesMatchedByOperation(op));
      }
      return [...new Set(variablesAssignedByJoin)];
    // Binary operation
    case "LeftJoin":
    case "Minus":
      const variablesMatchedLeftOp = getVariablesMatchedByOperation(operation.inputOperations[0]);
      const variablesMatchedRightOp = getVariablesMatchedByOperation(operation.inputOperations[1]);
      return [...new Set([...variablesMatchedLeftOp, ...variablesMatchedRightOp])];
  }
}

/**
 *
 * @param exp An Expression
 * @returns a list of all variables which occur at any depth under the Expression tree
 */
export function getVariablesMentionedByExpression(exp: Expression): Variable[] {
  if ("variable" in exp && exp.variable !== UNBOUND_VARIABLE_NAME) {
    // Expression is 'Variable' or 'Bound', in both cases the only mentioned variable will be `variable`.
    return [exp.variable];
  }

  if ("operation" in exp) {
    // Expression is 'Exists'. We must recurse into the operation and find all mentioned variables.
    return uniq(getVariablesMentionedByOperation(exp.operation));
  }
  if (exp.expressionType === "FunctionCall") {
    // Function call, recurse into the child expressions.
    if ("expressions" in exp) {
      return uniq(flatten(exp.expressions.map((s) => getVariablesMentionedByExpression(s))));
    }
  }
  // Expression is a Term, which doesn't have any variables.
  return [];
}

/**
 * @param algebra
 * @returns A subset of variables in scope after the operation.
 * There may be more variables in scope.
 * If so those, would have been returned by previous calls to this function,
 * With a earlier sibling operation as input.
 *
 * The union of returned variables from calling this functions over all inputOperations
 * of a Join should be identical to the variablesInScope of the Join.
 */
export function getVariablesInScopeAfterOperation(algebra: Operation): Variable[] {
  switch (algebra.operationType) {
    case "TriplePattern":
      return algebra.pattern.filter((term) => typeof term === "string") as string[];
    case "ZeroOrMorePath":
      return [algebra.boundStart, algebra.end];
    case "EnsureBound":
      return [algebra.variable];
    case "InlineData":
      return flatten(algebra.values.map((binding) => Object.keys(binding)));
    case "Extend":
      return [algebra.variable];
    case "Distinct":
      return [...algebra.variables];
    case "Service":
    case "Minus":
    case "Aggregate":
    case "OrderBy":
    case "Join":
    case "LeftJoin":
    case "Filter":
    case "Union":
    case "Slice":
      return [];
  }
}

type varAndTerm = { variable: Variable; term: NamedNode<string> };
// Helper function to get the 'variable' and 'Term' from the two expression(Left and Right)
export function getVarAndTermFromExpression(
  leftExpression: Expression,
  rightExpression: Expression
): varAndTerm | undefined {
  if (leftExpression.expressionType === "Variable") {
    if (rightExpression.expressionType !== "Term") return;
    if (rightExpression.term.termType !== "NamedNode") return;
    return { variable: leftExpression.variable, term: rightExpression.term };
  }
}
