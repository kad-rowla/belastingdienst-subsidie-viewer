import { IDENTITY, NOTHING, Operation, TriplePattern } from "./Operation.js";
import { forEachAlgebraNode } from "../Helpers.js";
import { AggregateFunction, Expression } from "./Expression.js";
import { readJsonFromStdin } from "@triplydb/utils/stdin.js";
import { last } from "lodash-es";
import chalk from "chalk";

function triplePatternToString(stp: TriplePattern): string {
  return stp.pattern
    .map((v) => (typeof v === "string" ? `?${v}` : chalk.grey(`<${last(last(v.value.split("/"))!.split("#"))}>`)))
    .join("   ");
}

function operationToString(op: Operation): string {
  if (op.operationType === "TriplePattern") return triplePatternToString(op);
  if (op.operationType === "EnsureBound") return chalk.white("EnsureBound") + ` ?${op.variable}`;
  if ([IDENTITY.id, NOTHING.id as string | undefined].includes(op.id)) return op.id!;
  return chalk.white(op.operationType);
}

export function algebraToString(node: Operation | Expression | AggregateFunction): string {
  const strings: string[] = [];
  type C = { received: number; yielded: number };
  forEachAlgebraNode(
    node,
    (op, indent) => {
      const indentation = indent ? "  ".repeat(indent - 1) + "- " : "";
      const description = operationToString(op);
      const counts = "counts" in op ? ` (in: ${(op.counts as C).received}, out: ${(op.counts as C).yielded})` : "";
      strings.push(indentation + description + counts);
      return indent + 1;
    },
    (_ex, indent) => indent,
    0
  );
  return strings.join("\n");
}

export async function logStdinAlgebra(): Promise<void> {
  const algebra = (await readJsonFromStdin()) as Operation;
  console.info(algebraToString(algebra));
}
