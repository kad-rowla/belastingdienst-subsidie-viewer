/**
 *  This file contains all helper functions related to Aggregation
 */
import * as SparqlJs from "sparqljs";
import { Aggregate, Operation } from "../Operation.js";
import { Variable } from "../../constants.js";
import { translatePossiblyAggregateExpression } from "./translateExpression.js";
import { FatalError } from "../../Errors.js";
import { ExtraTranslationInfo } from "./index.js";

/**
 *  Translate a SparqlJs.Expression to be used in aggregation, and add it to
 *  the current algebra. This will definitely modify the `aggregate` and could
 *  return a new Operation.
 */
export function addAggregateExpression(
  name: string,
  expression: SparqlJs.Expression,
  aggregate: Aggregate,
  inputOperation: Operation,
  aggregatedVariables: ReadonlySet<Variable>,
  info: ExtraTranslationInfo
) {
  // If the variable that we're adding (`name`) has already been aggregated,
  // we don't need to do anything, e.g. when we're doing:
  // SELECT ?s WHERE {...} GROUP BY ?s
  if (aggregatedVariables.has(name)) return inputOperation;
  const translation = translatePossiblyAggregateExpression(expression, "aggregate", aggregatedVariables, info);

  const nAggregates = Object.keys(translation.aggregates).length;
  if (nAggregates > 0 && translation.expression.expressionType === "Variable") {
    // If the translated expression is a single variable, it means that the
    // aggregate expression was a "simple" aggregate function call, so we can
    // simplify it.
    // E.g. we want to avoid translating `SUM(?a) as ?b` into an algebra that
    // looks like this:
    //
    //    Extend(?randomvar as ?b)
    //      - Aggregate(SUM(?a) as ?randomvar)
    //
    // but instead create an algebra that looks like this:
    //
    //    Aggregate(SUM(?a) as ?b)
    //
    const variable = translation.expression.variable;
    if (nAggregates !== 1 || !(variable in translation.aggregates)) {
      throw new FatalError("Something got lost in translation");
    }
    aggregate.aggregatingExpressions[name] = translation.aggregates[variable];
  } else {
    // `expr` was a complex aggregate, like `SUM(?a) / 15 as ?b`, or something
    // that didn't contain any aggregate expression, like `"hello" as ?b`.
    // We rewrite those into a combination of aggregate functions and an
    // `Extend`, e.g.:
    //
    //    SUM(?a) / 15 as ?b
    //
    //  translates into:
    //
    //    {
    //      expression: ?randomVar / 15,
    //      aggregates: { randomVar: SUM(?a) },
    //    }
    //
    //  which we use for this operation:
    //
    //    Extend(?randomvar / 15 as ?b)
    //      - Aggregate(SUM(?a) as ?randomvar)
    //
    aggregate.aggregatingExpressions = { ...aggregate.aggregatingExpressions, ...translation.aggregates };
    inputOperation = {
      operationType: "Extend",
      variable: name,
      expression: translation.expression,
      inputOperation: inputOperation,
    };
  }
  return inputOperation;
}
