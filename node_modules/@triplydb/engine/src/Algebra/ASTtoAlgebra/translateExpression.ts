/**
 *  This file contains all functions that take a sparql-js type as input and
 *  return (at least) an Expression as output.
 */
import * as SparqlJs from "sparqljs";
import {
  AggregateFunction,
  AGGREGATE_FUNCTION_NAMES,
  FunctionCall,
  Expression,
  VariableExpression,
  TermExpression,
  OperationExpression,
  ExistsExpression,
} from "../Expression.js";
import { IDENTITY } from "../Operation.js";
import { createFunctionCall, createOperationExpression, makeNameTranslation } from "./creation.js";
import { dataFactory, DATA_TYPES, Variable } from "../../constants.js";
import { v4 as randumUuid } from "uuid";
import { translateSparqljsPattern } from "./translateOperation.js";
import { FatalError, SparqlError, UnknownFunctionError, UnsupportedError } from "../../Errors.js";
import { ExtraTranslationInfo } from "./index.js";

type EmptyObject<T> = { [K in keyof T]?: never };
/**
 *  Translate a SparqlJs.Expression into an Expression.
 *
 *  Throws if any aggregate functions are encountered.
 */
export function translateExpression(expression: SparqlJs.Expression, info: ExtraTranslationInfo): Expression {
  return translatePossiblyAggregateExpression(expression, "non-aggregate", new Set(), info).expression;
}

/**
 *  Helper type that says there aren't allowed to be any aggregates when we're
 *  requesting "non-aggregate".
 */
type Aggregates<Type extends "aggregate" | "non-aggregate"> = Type extends "aggregate"
  ? {
      [variable: Variable]: AggregateFunction;
    }
  : EmptyObject<any>;

/**
 *  The plural version of the function below. Just does a for-loop and merges
 *  any collected aggregates.
 */
function translatePossiblyAggregateExpressions<Type extends "aggregate" | "non-aggregate">(
  expressions: SparqlJs.Expression[],
  type: Type,
  aggregatedVariables: ReadonlySet<Variable>,
  info: ExtraTranslationInfo
): {
  expressions: Expression[];
  aggregates: Aggregates<Type>;
} {
  let aggregates = {};
  const translated: Expression[] = [];
  for (const expression of expressions) {
    const t = translatePossiblyAggregateExpression(expression, type, aggregatedVariables, info);
    aggregates = { ...aggregates, ...t.aggregates };
    translated.push(t.expression);
  }
  return { expressions: translated, aggregates };
}

/**
 *  Translate a SparqlJs.Expression into an Expression and possibly a
 *  collection of aggregates, depending on whether the caller wanted an
 *  aggregate expression or not.
 */
export function translatePossiblyAggregateExpression<Type extends "aggregate" | "non-aggregate">(
  expression: SparqlJs.Expression,
  type: Type,
  aggregatedVariables: ReadonlySet<Variable>,
  info: ExtraTranslationInfo
): {
  expression: Expression;
  aggregates: Aggregates<Type>;
} {
  if ("type" in expression) {
    switch (expression.type) {
      // BlockPatterns
      case "graph":
      case "group":
      case "minus":
      case "service":
      case "union":
      case "optional":
      // Other patterns
      case "query":
      case "bgp":
      case "bind":
      case "values":
      case "filter":
        // This should only happen with EXISTS expressions, which are handled
        // separately below
        throw new FatalError(`Encountered a SparqlJs ${expression.type}, which shouldn't happen here.`);
      case "functionCall":
        return translateFunctionCall(expression, type, aggregatedVariables, info);
      case "operation":
        const specialCases = translateSpecialCases(expression, type, aggregatedVariables, info);
        if (specialCases) return specialCases;
        return translateFunctionCall(expression, type, aggregatedVariables, info);
      case "aggregate": {
        if (type !== "aggregate")
          throw new SparqlError("Cannot have an aggregate expression when requesting a non-aggregate expression.");
        const { expression: translatedExpression, aggregates } = translateAggregateFunction(expression, info);
        // somehow the type system is too stupid to understand that `Type` must now
        // always be "aggregate"...
        return { expression: translatedExpression, aggregates: aggregates as Aggregates<Type> };
      }
    }
  } else if ("termType" in expression) {
    return translateTerm(expression, type, aggregatedVariables, info);
  } else {
    // This should only happen with IN expressions that are handled separately above
    throw new FatalError("Encountered an unexpected SparqlJs.Tuple");
  }
}

/**
 *  translate a Term that is used in a SparqlJs.Expression
 */
function translateTerm<Type extends "aggregate" | "non-aggregate">(
  expression: SparqlJs.IriTerm | SparqlJs.VariableTerm | SparqlJs.LiteralTerm,
  type: Type,
  aggregatedVariables: ReadonlySet<Variable>,
  info: ExtraTranslationInfo
): {
  expression: VariableExpression | TermExpression;
  aggregates: Aggregates<Type>;
} {
  switch (expression.termType) {
    case "Variable":
      const variableExpression: VariableExpression = {
        expressionType: "Variable",
        variable: expression.value,
      };
      return { expression: variableExpression, aggregates: {} };
    default:
      return { expression: { expressionType: "Term", term: expression }, aggregates: {} };
  }
}

/**
 * This is a function to expand an 'IN' functional call and convert it to an
 * equivalent disjunction of equivalence.
 */
function translateInExpression(lhsArg: Expression, rhsArgs: Expression[]): Expression {
  // If there is no expression on the rhs, return False
  // Spec - https://www.w3.org/TR/sparql11-query/#func-in
  if (rhsArgs.length == 0)
    return {
      expressionType: "Term",
      term: dataFactory.literal(false, DATA_TYPES.XSD_BOOLEAN),
    };

  if (rhsArgs.length == 1)
    return {
      expressionType: "FunctionCall",
      function: "=",
      expressions: [lhsArg, rhsArgs[0]],
    };

  return {
    expressionType: "FunctionCall",
    function: "||",
    expressions: [
      {
        expressionType: "FunctionCall",
        function: "=",
        expressions: [lhsArg, rhsArgs[0]],
      },
      translateInExpression(lhsArg, rhsArgs.slice(1)), // Recursively expand all the remaining rhsArg after the first element
    ],
  };
}

/**
 *  There's a few special cases for SparqlJs.OperationExpression that negatively
 *  impact readability because of their verbosity. This function is just here
 *  for readability of the calling code.
 */
function translateSpecialCases<Type extends "aggregate" | "non-aggregate">(
  expression: SparqlJs.OperationExpression,
  type: Type,
  aggregatedVariables: ReadonlySet<Variable>,
  info: ExtraTranslationInfo
):
  | undefined
  | {
      expression: Expression;
      aggregates: Aggregates<Type>;
    } {
  switch (expression.operator) {
    case "notexists": {
      if (expression.args.length !== 1) {
        throw new SparqlError("Wrong number of arguments for NOT EXISTS: " + JSON.stringify(expression.args));
      }
      return {
        aggregates: {},
        expression: {
          expressionType: "FunctionCall",
          function: "!",
          expressions: [
            {
              expressionType: "Exists",
              // The types are wrong. This is unit-tested and works
              operation: translateSparqljsPattern(expression.args[0] as SparqlJs.Pattern, IDENTITY, info),
            },
          ],
        },
      };
    }

    case "exists": {
      if (expression.args.length !== 1)
        throw new SparqlError("Wrong number of arguments for EXISTS: " + JSON.stringify(expression.args));
      return {
        aggregates: {},
        expression: {
          expressionType: "Exists",
          // The types are wrong. This is unit-tested and works
          operation: translateSparqljsPattern(expression.args[0] as SparqlJs.Pattern, IDENTITY, info),
        },
      };
    }

    case "in": {
      if (expression.args[2] || !Array.isArray(expression.args[1]))
        throw new SparqlError("Bad arguments for IN " + JSON.stringify(expression.args));
      const { expression: leftHandSide, aggregates: lhsAgg } = translatePossiblyAggregateExpression(
        expression.args[0],
        type,
        aggregatedVariables,
        info
      );
      const { expressions: rightHandSide, aggregates: rhsAgg } = translatePossiblyAggregateExpressions(
        expression.args[1],
        type,
        aggregatedVariables,
        info
      );

      return {
        aggregates: { ...lhsAgg, ...rhsAgg },
        expression: translateInExpression(leftHandSide, rightHandSide),
      };
    }

    case "notin": {
      if (expression.args[2] || !Array.isArray(expression.args[1]))
        throw new SparqlError("Bad arguments for IN " + JSON.stringify(expression.args));
      const { expression: leftHandSide, aggregates: lhsAgg } = translatePossiblyAggregateExpression(
        expression.args[0],
        type,
        aggregatedVariables,
        info
      );
      const { expressions: rightHandSide, aggregates: rhsAgg } = translatePossiblyAggregateExpressions(
        expression.args[1],
        type,
        aggregatedVariables,
        info
      );
      return {
        aggregates: { ...lhsAgg, ...rhsAgg },
        expression: {
          expressionType: "FunctionCall",
          function: "!",
          expressions: [translateInExpression(leftHandSide, rightHandSide)],
        },
      };
    }

    case "bound":
      const [variableTerm] = expression.args;
      if (expression.args[1] || !(variableTerm && "termType" in variableTerm && variableTerm.termType === "Variable")) {
        throw new FatalError("Bad arguments for BOUND: " + JSON.stringify(expression.args));
      }
      return {
        expression: {
          expressionType: "Bound",
          variable: variableTerm.value,
        },
        aggregates: {},
      };
  }
}

/**
 *  the translation of aggregate function names.
 */
const AGGREGATE_FUNCTION_NAME_TRANSLATION = makeNameTranslation(AGGREGATE_FUNCTION_NAMES);

/**
 *  Translate a SparqlJs.AggregateExpression into an AggregateFunction
 *  associated with a freshly created random variable.
 *
 *  This function is used a kind of base-case in
 *  `translatePossiblyAggregateExpression`: it flips from asking for an
 *  aggregate expression (which will be the returned AggregateFunction) to
 *  asking for a non-aggregate expression (for the argument of the returned
 *  AggregateFunction).
 */
function translateAggregateFunction(
  sparqljsExpression: SparqlJs.AggregateExpression,
  info: ExtraTranslationInfo
): {
  expression: VariableExpression;
  aggregates: { [variable: string]: AggregateFunction };
} {
  const translatedName = AGGREGATE_FUNCTION_NAME_TRANSLATION[sparqljsExpression.aggregation];
  if (!translatedName)
    throw new UnsupportedError(`Encountered unsupported aggregate function: ${sparqljsExpression.aggregation}`);

  const variable = randumUuid();
  const distinct = sparqljsExpression.distinct ?? false;

  if ("termType" in sparqljsExpression.expression && sparqljsExpression.expression.termType === "Wildcard") {
    if (translatedName !== "COUNT") {
      // See the 'Special Case' of https://www.w3.org/TR/sparql11-query/#defn_algAggregation
      throw new SparqlError("COUNT is the only function that accepts a wildcard (*) as argument.");
    }
    if (distinct === true) throw new UnsupportedError("COUNT(DISTINCT *) is not supported yet");
    return {
      expression: {
        expressionType: "Variable",
        variable,
      },
      aggregates: {
        [variable]: {
          expressionType: "AggregateFunction",
          function: "COUNT",
          distinct: false,
          expression: { expressionType: "WildCard" },
        },
      },
    };
  }

  const expression = translateExpression(sparqljsExpression.expression, info);

  return {
    expression: {
      expressionType: "Variable",
      variable,
    },
    aggregates: {
      [variable]:
        translatedName === "GROUP_CONCAT"
          ? {
              expressionType: "AggregateFunction",
              function: "GROUP_CONCAT",
              distinct,
              expression,
              // > If the "separator" scalar argument is absent from GROUP_CONCAT then
              // > it is taken to be the "space" character, unicode codepoint U+0020.
              // from: https://www.w3.org/TR/sparql11-query/#defn_aggGroupConcat
              // Issue during AST translation results in not having empty string as a separator:
              // - https://github.com/RubenVerborgh/SPARQL.js/issues/161
              separator: sparqljsExpression.separator ?? " ",
            }
          : {
              expressionType: "AggregateFunction",
              function: translatedName,
              distinct,
              expression,
            },
    },
  };
}

/**
 *  translate some SparqlJs stuff into a FunctionCall.
 */
function translateFunctionCall<Type extends "aggregate" | "non-aggregate">(
  expression: SparqlJs.FunctionCallExpression | SparqlJs.OperationExpression,
  type: Type,
  aggregatedVariables: ReadonlySet<Variable>,
  info: ExtraTranslationInfo
): { expression: FunctionCall | OperationExpression | ExistsExpression; aggregates: Aggregates<Type> } {
  // the types are wrong: this can also be a NamedNode
  let functionName = "function" in expression ? expression.function : expression.operator;
  if (typeof functionName === "object") {
    // This is a named node and we just want to use the full IRI as the name.
    // IRIs are case-sensitive, so we shouldn't lowercase it.
    functionName = functionName.value;
  } else {
    // sparqljs doesn't do this in all cases, so just to be sure...
    functionName = functionName.toLowerCase();
  }
  const { expressions: args, aggregates } = translatePossiblyAggregateExpressions(
    expression.args,
    type,
    aggregatedVariables,
    info
  );
  let functionCall: FunctionCall | OperationExpression | ExistsExpression | undefined = createFunctionCall(
    functionName,
    args
  );

  // If this wasn't a built-in function call, maybe it's a data-defined function
  if (!functionCall) {
    const dataDefinedFunctionInfo = info.dataDefinedFunctions[functionName];
    if (dataDefinedFunctionInfo) {
      functionCall = createOperationExpression(dataDefinedFunctionInfo, args);
    }
  }

  // If this also wasn't a data defined function, it's time to throw an error.
  if (!functionCall)
    throw new UnknownFunctionError(
      `Unknown function or wrong number of arguments: ${functionName} with ${args.length} arguments`
    );
  return { expression: functionCall, aggregates };
}
