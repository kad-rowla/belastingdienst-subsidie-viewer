import { default as SparqlJs } from "sparqljs";
import { Term, Variable, dataFactory } from "../../constants.js";
import { FatalError, SparqlError } from "../../Errors.js";
import { v4 as randomUuid } from "uuid";
import { factory } from "@triplydb/data-factory";
import { cloneDeep, mapKeys } from "lodash-es";
import { IIterateeContext } from "deepdash/IIterateeContext";
import mapKeysDeep from "deepdash/mapKeysDeep";
import mapValuesDeep from "deepdash/mapValuesDeep";
import { fixSparqlJsValues, isAggregateQuery, isWildCard } from "./translationUtils.js";
import { throwAggregateError } from "../../Helpers.js";

/**
 * This variable name is improbable enough that hopefully no-one in their right
 * minds would consider using it in a query.
 */
export const UNBOUND_VARIABLE_NAME = "???" as const satisfies Variable;
const UNBOUND_VARIABLE = factory.variable(UNBOUND_VARIABLE_NAME);

/**

 *  18.2.1 Variable Scope
 *  https://www.w3.org/TR/sparql11-query/#variableScope
 *
 *
 *  Syntax Form               | In-scope variables
 *  -----------               | ------------------
 *  Basic Graph Pattern (BGP) | v occurs in the BGP
 *  Path                      | v occurs in the path
 *  Group { P1 P2 ... }       | v is in-scope if it is in-scope in one or more of P1, P2, ...
 *  GRAPH term { P }          | v is term or v is in-scope in P
 *  { P1 } UNION { P2 }       | v is in-scope in P1 or in-scope in P2
 *  OPTIONAL {P}              | v is in-scope in P
 *  SERVICE term {P}          | v is term or v is in-scope in P
 *  BIND (expr AS v)          | v is in-scope
 *  SELECT .. v .. { P }      | v is in-scope
 *  SELECT ... (expr AS v)    | v is in-scope
 *  GROUP BY (expr AS v)      | v is in-scope
 *  SELECT * { P }            | v is in-scope in P
 *  VALUES v { values }       | v is in-scope
 *  VALUES varlist { values } | v is in-scope if v is in varlist
 */

/**
 * This function does the following four tasks:
 * - rewrite all wildcards into lists of variables
 * - throw an error when a variable is bound for a second time
 * - replace all variables that will always be unbound by a magically named
 *   variable that we guarantee will always be unbound
 * - rename variables s.t. variables are uniquely identifyable by their name,
 *   irrespective of scoping. In other words, the different scopes are encoded
 *   into the variable names. We also take care to not rename the variables that
 *   will be part of the projection of a SELECT query.
 *
 * This operation is [idempotent][]. This means that calling `scopeVariables`
 * a second time should not change the input any more. EXCEPT when one of the
 * things in the `GROUP BY` clause is a variable that will always be unbound.
 *
 * The `variables` property of SELECT queries is used to determine the
 * projection, that's why we can't remove variables that are always unbound from
 * that property. In the case of aggregate queries, this will cause an error
 * when calling `scopeVariables` on its own output.
 *
 * [idempotent]: https://en.wikipedia.org/wiki/Idempotence
 */
export function scopeVariables<Q extends SparqlJs.Query>(
  query: Q,
  opts?: ConstructorParameters<typeof Variables>[0]
): Q {
  const variables = new Variables(opts);

  // Make sure we don't modify the input
  query = cloneDeep(query);
  // The types are s.t. we can just jam this in and it'll work
  (query as any).variables = (query as any).variables ?? [new SparqlJs.Wildcard()];

  select(variables, query as SparqlJs.SelectQuery, "keep unbound variables in projection");

  if (!opts?.translateEverything && query.queryType === "SELECT") {
    // We want to make sure that the outermost variables weren't renamed,
    // even in the case of a wildcard. Luckily, by now, variables are
    // uniquely identified by their name, even across scopes!
    const translationToBeDone: typeof variables.inScopeBoundVariableTranslation = new Map();
    for (const variable of variables.untranslatedVariablesInScope) {
      const translation = variables.inScopeBoundVariableTranslation.get(variable);
      if (translation && translation.value !== variable) {
        translationToBeDone.set(translation.value, dataFactory.variable(variable));
        translationToBeDone.set(variable, dataFactory.variable(randomUuid()));
      }
    }
    query = translateVariableNames(query, translationToBeDone);
  } else if (query.queryType === "CONSTRUCT") {
    for (const triple of query.template ?? []) {
      triple.subject = variables.onTermRead(triple.subject);
      if (!("termType" in triple.predicate)) {
        throw new FatalError("Triple pattern templates cannot contain property paths");
      }
      triple.predicate = variables.onTermRead(triple.predicate);
      triple.object = variables.onTermRead(triple.object);
    }
  }

  return query;
}

export function translateVariableNames<Q>(query: Q, translation: Variables["inScopeBoundVariableTranslation"]): Q {
  // Mapping keys is only necessary for Values clauses

  query = mapKeysDeep(query, (value: unknown, key, _parentValue, context: IIterateeContext) => {
    if (typeof key !== "string") return key;
    const grandParent: unknown = context.parents?.slice(-3)[0]?.value;
    if (
      (value === undefined || (value && typeof value === "object" && "termType" in value)) &&
      grandParent &&
      typeof grandParent === "object" &&
      "type" in grandParent &&
      (grandParent.type === "query" || grandParent.type === "values")
    ) {
      return translation.get(key)?.value ?? key;
    }
    return key;
  });

  query = mapValuesDeep(query, (unknown: unknown, _key, _parentValue, context: IIterateeContext) => {
    if (unknown && typeof unknown === "object" && "termType" in unknown && unknown.termType === "Variable") {
      const variable = unknown as SparqlJs.VariableTerm;
      (context as any).skipChildren(true);
      return translation.get(variable.value) ?? variable;
    }
    return unknown;
  });

  return query;
}

class Variables {
  /**
   * Variable names that shouldn't change. Ever.
   */
  dontTouchThis: Set<Term["value"]>;

  translateEverything: boolean;

  /**
   * A map from untranslated variables to their translation.
   *
   * This map only contains the variables that are both bound _and_ in the
   * current scope. E.g. for this query:
   *
   * SELECT * WHERE {
   *   { SELECT ?s WHERE { ?s :p ?o } }
   *   ?s :p :o
   *   {
   *     ?s :p ?o .
   *     # at this point in processing
   *   }
   * }
   *
   * It would contain {"s": ?s, "o": ?someRandomHash }
   */
  inScopeBoundVariableTranslation: Map<Term["value"], SparqlJs.VariableTerm> = new Map();

  /**
   * A map from untranslated variables to their translation.
   *
   * This map only contains the variables that are both bound _and_ occur in one
   * of the ancestors of the current scope E.g. for this query:
   *
   * SELECT * WHERE {
   *   { SELECT ?s WHERE { ?s :p ?o } }
   *   ?s :p :o
   *   {
   *     ?s :p ?o .
   *     # at this point in processing
   *   }
   * }
   *
   * It would contain {"s": ?s }.
   */
  ancestorScopeBoundVariableTranslation: Map<Term["value"], SparqlJs.VariableTerm> = new Map();

  /**
   * A set of translated variables used anywhere up until the current point.
   *
   * For example for this query:
   *
   * SELECT * WHERE {
   *   { SELECT ?s WHERE { ?s :p ?o } }
   *   ?s :p :o
   *   {
   *     ?s :p ?o .
   *     # at this point in processing
   *   }
   * }
   *
   * it would contain {"s", "o"}, since the randomly chosen translation of
   * the currently in-scope ?o is not (yet) in an unrelated scope.
   */
  translatedVariablesNotInScope: Set<Term["value"]> = new Set();

  /**
   * A set of (untranslated names of) the variables currently in scope,
   * irrespective of whether they are bound. This is used to make sure
   * we have the correct projection.
   *
   * For example for this query:
   *
   * SELECT * WHERE {
   *   { SELECT ?s WHERE { ?s :p ?o } }
   *   ?s :p :o
   *   {
   *     ?s :p ?o .
   *     # at this point in processing
   *   }
   * }
   *
   * it would contain {"s", "o"}, since even though the translation of
   * the current ?o is something random, the original name was "o".
   */
  untranslatedVariablesInScope: Set<Term["value"]> = new Set();
  /**
   * We need to know when we're in a service clause, so that we don't
   * use unbound variables accidently.
   */
  insideServiceClause: boolean;

  constructor(opts?: {
    dontTouchThis?: Variables["dontTouchThis"];
    translateEverything?: boolean;
    insideServiceClause?: boolean;
  }) {
    this.dontTouchThis = opts?.dontTouchThis ?? new Set();
    this.translateEverything = !!opts?.translateEverything;
    this.insideServiceClause = !!opts?.insideServiceClause;
  }

  /**
   * Merge the contents of another `Variables` object into this one.
   */
  add(other: Variables) {
    this.mergeChildScope(other);
    for (const entry of other.ancestorScopeBoundVariableTranslation.entries()) {
      this.ancestorScopeBoundVariableTranslation.set(...entry);
    }
  }

  /**
   * Create a shallow copy of this `Variables` object.
   */
  copy() {
    const copy = new Variables(this);
    copy.add(this);
    return copy;
  }

  /**
   * Merge the contents of `other.translatedVariablesNotInScope` into this one.
   */
  private addUnrelatedScope(other: Variables) {
    for (const name of other.translatedVariablesNotInScope) {
      this.translatedVariablesNotInScope.add(name);
    }
  }

  /**
   * This function should only be called on the direct parent of `other`.
   */
  mergeChildScope(other: Variables) {
    for (const entry of other.inScopeBoundVariableTranslation.entries()) {
      this.inScopeBoundVariableTranslation.set(...entry);
    }
    for (const variable of other.untranslatedVariablesInScope) {
      this.untranslatedVariablesInScope.add(variable);
    }
    this.addUnrelatedScope(other);
  }

  /**
   * This function should only be called on the direct parent of `other`.
   */
  mergeUnrelatedScope(other: Variables) {
    this.addUnrelatedScope(other);
    for (const variable of other.inScopeBoundVariableTranslation.values()) {
      this.translatedVariablesNotInScope.add(variable.value);
    }
  }

  /**
   * Get a new Variables object to be used for a child scope
   */
  newScope(insideServiceClause?: "insideServiceClause") {
    const copy = new Variables(insideServiceClause ? { ...this, insideServiceClause: true } : this);
    copy.addUnrelatedScope(this);
    // We are an ancestor of our child
    for (const entry of this.inScopeBoundVariableTranslation.entries()) {
      copy.ancestorScopeBoundVariableTranslation.set(...entry);
    }
    // our ancestors are also our children's ancestors
    for (const entry of this.ancestorScopeBoundVariableTranslation.entries()) {
      copy.ancestorScopeBoundVariableTranslation.set(...entry);
    }
    return copy;
  }

  project(untranslatedVariablesToKeep: Set<SparqlJs.VariableTerm["value"]>) {
    for (const [untranslatedVariable, translation] of this.inScopeBoundVariableTranslation) {
      if (!untranslatedVariablesToKeep.has(untranslatedVariable)) {
        this.translatedVariablesNotInScope.add(translation.value);
        this.inScopeBoundVariableTranslation.delete(untranslatedVariable);
        this.untranslatedVariablesInScope.delete(untranslatedVariable);
      }
    }
    this.projectAncestorScope(untranslatedVariablesToKeep);
  }

  projectAncestorScope(untranslatedVariablesToKeep: Set<SparqlJs.VariableTerm["value"]>) {
    for (const [untranslatedVariable, translation] of this.ancestorScopeBoundVariableTranslation) {
      if (!untranslatedVariablesToKeep.has(untranslatedVariable)) {
        this.translatedVariablesNotInScope.add(translation.value);
        this.ancestorScopeBoundVariableTranslation.delete(untranslatedVariable);
        this.untranslatedVariablesInScope.delete(untranslatedVariable);
      }
    }
  }

  /**
   * Call this when a term is read (but not matched or written to)
   */
  onTermRead<T extends SparqlJs.Term>(term: T): T;
  onTermRead(term: SparqlJs.Term): SparqlJs.Term {
    if (term.termType !== "Variable" || this.dontTouchThis.has(term.value)) return term;

    if (this.insideServiceClause) {
      this.translatedVariablesNotInScope.add(term.value);
      return term;
    }
    const existingTranslation = this.inScopeBoundVariableTranslation.get(term.value);
    if (existingTranslation !== undefined) return existingTranslation;

    return UNBOUND_VARIABLE;
  }

  /**
   * Call this when a term will be bound by the current operation (if it wasn't already)
   */
  onTermBind<T extends SparqlJs.Term>(term: T): T;
  onTermBind(term: SparqlJs.Term): SparqlJs.Term {
    if (term.termType !== "Variable" || this.dontTouchThis.has(term.value)) return term;

    this.untranslatedVariablesInScope.add(term.value);

    const existingTranslation = this.inScopeBoundVariableTranslation.get(term.value);
    if (existingTranslation !== undefined) return existingTranslation;

    let newVariable = this.ancestorScopeBoundVariableTranslation.get(term.value);
    if (newVariable === undefined) {
      // If the name isn't in use yet, we don't have to make up a new one
      // Except, of course, when we explicitly always want new names
      newVariable =
        this.translateEverything || this.translatedVariablesNotInScope.has(term.value)
          ? factory.variable(randomUuid())
          : term;
    }

    this.inScopeBoundVariableTranslation.set(term.value, newVariable);
    return newVariable;
  }
}

function select(
  variables: Variables,
  query: SparqlJs.SelectQuery,
  keepUnboundVariablesInProjection: undefined | "keep unbound variables in projection" = undefined
): void {
  // Project out any variables used outside of this part of the query that
  // shouldn't be accessible
  if (!isWildCard(query.variables)) {
    const variablesToKeep = new Set<string>();
    for (const variable of query.variables) {
      if ("termType" in variable && variable.termType === "Variable") variablesToKeep.add(variable.value);
    }
    // > Note that a subquery with a projection can hide variables;
    variables.project(variablesToKeep);
  }

  // 18.2.2 Converting Graph Patterns
  if (query.where) {
    groupGraphPattern(variables, query.where);
  }

  // 18.2.4.1 Grouping and Aggregation
  const untranslatedGroupedVariables = new Set<string>();
  /**
   * isAggregate is used to keep track of whether this is an aggregate query and, if so,
   * which variables are aggregated/grouped variables. This is important for expression
   * validation: if a query is `non-aggregate`, we don't do any checks. If we pass a
   * Set, then we check whether the variables that are used outside of an aggregate
   * function are indeed mentioned in the set.
   *
   * E.g. for this query:
   *
   *    SELECT (?o1 as ?o2)
   *    WHERE { :s :p ?o1 } group by ?o1 order by ?o2
   *
   * ?o2 should be added to `isAggregate` when processing `query.variables`, s.t. we will
   * not get an error when processing the `ORDER BY`.
   */
  const isAggregate = isAggregateQuery(query) ? untranslatedGroupedVariables : "non-aggregate";
  if (query.group) {
    const queryGroup: typeof query.group = [];
    for (const group of query.group) {
      // We are allowed to project:
      // A. If we have a variable which gets bound inside an AS expression
      if (group.variable) {
        // > Within `GROUP BY` clauses the binding keyword, `AS`, may be used, such
        // > as `GROUP BY (?x + ?y AS ?z)`. This is equivalent to
        // > `{ ... BIND(?x + ?y AS ?z) } GROUP BY ?z`.
        //
        // from: https://www.w3.org/TR/sparql11-query/#groupby
        // This means that we should check that the bound variable isn't already bound.
        if (variables.inScopeBoundVariableTranslation.has(group.variable.value)) {
          throw new SparqlError(`The variable ?${group.variable.value} cannot be bound more than once`);
        }
        untranslatedGroupedVariables.add(group.variable.value);
        group.variable = variables.onTermBind(group.variable);
        // B. If we have a simple variable expression, like GROUP BY ?s
      } else if ("termType" in group.expression && group.expression.termType === "Variable") {
        untranslatedGroupedVariables.add(group.expression.value);
      }
      group.expression = expression(variables, group.expression, "non-aggregate");

      if (group.expression !== UNBOUND_VARIABLE) queryGroup.push(group);
    }
    query.group = queryGroup;
  }

  // 18.2.4.2 HAVING
  // > Note that, due to the logic position in which the HAVING clause is
  // > evaluated, expressions projected by the SELECT clause are not
  // > visible to the HAVING clause.
  //
  // from: https://www.w3.org/TR/sparql11-query/#sparqlHavingClause
  // So this means we should do HAVING before doing the PROJECT
  if (query.having) query.having = expression(variables, query.having, untranslatedGroupedVariables);

  // 18.2.4.3 VALUES
  if (query.values) query.values = values(variables, query.values);

  // 18.2.4.4 SELECT Expressions
  // > The syntax error arises for use of a variable as the named target of
  // > AS (e.g. ... AS ?x), when the variable is used inside the WHERE clause
  // > of the SELECT or if already used as the target of AS in this SELECT
  // > expression.
  //
  // from: https://www.w3.org/TR/sparql11-query/#sparqlSelectExpressions
  if (isWildCard(query.variables)) {
    if (isAggregate !== "non-aggregate")
      throw new SparqlError("Wildcards are not allowed in combination with GROUP BY");
    query.variables = [...variables.inScopeBoundVariableTranslation.values()];
  } else {
    const translatedProjection: typeof query.variables = [];
    const untranslatedProjection = new Set<string>();

    for (let variable of query.variables) {
      if ("variable" in variable) {
        // > The syntax error arises for use of a variable as the named target of
        // > AS (e.g. ... AS ?x), when the variable is used inside the WHERE clause
        // > of the SELECT or if already used as the target of AS in this SELECT
        // > expression.
        //
        // from: https://www.w3.org/TR/sparql11-query/#sparqlSelectExpressions
        if (variables.inScopeBoundVariableTranslation.has(variable.variable.value)) {
          throw new SparqlError(`The variable ?${variable.variable.value} cannot be bound more than once`);
        }
        untranslatedProjection.add(variable.variable.value);

        // always mark the ?variable in (... as ?variabe) as grouped, because:
        // - if this query is an aggregate query, this is the correct thing to do
        // - if this query is not an aggregate query, then untranslatedGroupedVariables will just be ignored
        untranslatedGroupedVariables.add(variable.variable.value);

        variable.variable = variables.onTermBind(variable.variable);

        variable.expression = expression(variables, variable.expression, isAggregate);
      } else if (variable.termType === "Variable") {
        const untranslatedVariable = variable;
        untranslatedProjection.add(untranslatedVariable.value);
        // We call `expression` here to make sure we throw the correct error for
        // ungrouped variables
        variable = expression(variables, variable, isAggregate);
        if (keepUnboundVariablesInProjection && variable === UNBOUND_VARIABLE)
          translatedProjection.push(untranslatedVariable);
      }
      if (variable !== UNBOUND_VARIABLE) translatedProjection.push(variable);
    }
    variables.untranslatedVariablesInScope = untranslatedProjection;
    query.variables = translatedProjection;
  }

  // 18.2.5.1 ORDER BY
  for (const order of query.order ?? []) {
    order.expression = expression(variables, order.expression, isAggregate);
  }

  // We should project out any variables used inside this part of the query
  variables.project(variables.untranslatedVariablesInScope);
}

function groupGraphPattern(
  variables: Variables,
  patterns: SparqlJs.Pattern[],
  existsExpressionWorkaroud?: "bind in filter exists"
): void {
  const filterPatterns: SparqlJs.FilterPattern[] = [];
  for (const pattern of patterns) {
    if (pattern.type === "filter") {
      // skip over the filter patterns for now
      filterPatterns.push(pattern);
    } else {
      graphPattern(variables, pattern, existsExpressionWorkaroud);
    }
  }
  // Do filter patterns last
  for (const pattern of filterPatterns) {
    pattern.expression = expression(variables, pattern.expression, "non-aggregate");
  }
}

function triple(variables: Variables, triples: SparqlJs.Triple[]) {
  for (const triple of triples) {
    triple.subject = variables.onTermBind(triple.subject);
    // Property paths cannot contain variables
    if ("termType" in triple.predicate) triple.predicate = variables.onTermBind(triple.predicate);
    triple.object = variables.onTermBind(triple.object);
  }
}

function expression<E extends SparqlJs.Expression>(
  variables: Variables,
  expr: E,
  isAggregate: Set<string> | "non-aggregate"
): E;
function expression(
  variables: Variables,
  expr: SparqlJs.Expression,
  isAggregate: Set<string> | "non-aggregate"
): SparqlJs.Expression {
  if (Array.isArray(expr)) {
    return expr.map((exp) => expression(variables, exp, isAggregate));
  }
  if ("termType" in expr) {
    const term = variables.onTermRead(expr);
    if (
      term.termType === "Variable" &&
      !variables.dontTouchThis.has(term.value) &&
      isAggregate !== "non-aggregate" &&
      !isAggregate.has(expr.value)
    ) {
      /**
       *  @DECISION
       *  > For each unaggregated variable V in X
       *  >   Replace V with Sample(V)
       *  >   End
       *  (...)
       *  > For each variable V appearing outside of an aggregate
       *  >    Ai := Aggregation(V, Sample, {}, G)
       *  >    E := E append (V, aggi)
       *  >    i := i + 1
       *  >    End
       *  from: https://www.w3.org/TR/sparql11-query/#sparqlGroupAggregate
       *
       *  We're interpreting that as recursively wrapping any unaggregated
       *  variable in a SAMPLE.
       *
       *  However, the SAMPLE doesn't do anything. SAMPLE is a
       *  way to get a single value from a collection of values by just randomly
       *  picking one. Whenever we (legally) end up in this case, however,
       *  all the values in the collection are the same, because the only legal
       *  "unaggregated variable V in X" is one that was used for grouping:
       *
       *  > In a query level which uses aggregates, only expressions consisting
       *  > of aggregates and constants may be projected, with one exception.
       *  > When GROUP BY is given with one or more simple expressions
       *  > consisting of just a variable, those variables may be projected
       *  > from the level.
       *
       *  from: https://www.w3.org/TR/sparql11-query/#aggregateRestrictions
       *
       *  We raise an error when the variable is unaggregated but it is projected.
       *  Note that the cases when an aggregated variable is reused is handled explicity as part of `select` function above.
       */
      throwAggregateError(expr.value);
    }
    return term;
  } else {
    switch (expr.type) {
      case "aggregate":
        if (!("termType" in expr.expression && expr.expression.termType === "Wildcard")) {
          expr.expression = expression(variables, expr.expression, "non-aggregate");
        }
        break;
      case "operation":
      case "functionCall":
        expr.args = expr.args.map((exp) => expression(variables, exp, isAggregate));
        break;

      /*
       * These cases only happen with EXISTS expressions.
       * Notice that the scoping for FILTER EXISTS is a bit different. The spec says:
       *
       * > `xsd:boolean  EXISTS { pattern }
       * > Variables in the pattern that are bound in the current solution mapping
       * > take the value that they have from the solution mapping. Variables in the
       * > pattern pattern that are not bound in the current solution mapping take part
       * > in pattern matching.`
       *
       * See https://www.w3.org/TR/sparql11-query/#func-filter-exists
       * This means that in the case of bind inside exists we DO NOT want to throw an error if it tries to
       * bind a variable with the same name as a variable that gets bound in
       * the scope of FILTER.
       */

      // BlockPatterns
      case "group": // this is what you get most of the time
      // all of the following we only get because sparqljs inlines a group if the group only contains one thing
      case "graph":
      case "minus":
      case "service":
      case "union":
      case "optional":
      // Other patterns
      case "query":
      case "bgp":
      case "bind":
      case "values":
      case "filter":
        /**
         *  We should take care of the special scoping for EXISTS expressions,
         * i.e. we can access all the variables in the current scope, but none
         * of our ancestors'.
         * Because `group` would normally introduce a new scope but it shouldn't
         * now, we inline it here.
         */
        const existsVariables = variables.copy();
        existsVariables.projectAncestorScope(new Set());
        groupGraphPattern(existsVariables, expr.type === "group" ? expr.patterns : [expr], "bind in filter exists");
        variables.mergeUnrelatedScope(existsVariables);
        break;
    }
    return expr;
  }
}

function values(variables: Variables, values: SparqlJs.ValuesPattern["values"]) {
  // VALUES v { values }       | v is in-scope
  // VALUES varlist { values } | v is in-scope if v is in varlist
  return fixSparqlJsValues(values, "remove undefined").map((oldRow) =>
    mapKeys(oldRow, (_, oldVariable) => variables.onTermBind(dataFactory.variable(oldVariable)).value)
  );
}

function graphPattern(
  variables: Variables,
  pattern: Exclude<SparqlJs.Pattern, SparqlJs.FilterPattern>,
  existsExpressionWorkaround?: "bind in filter exists"
): void {
  switch (pattern.type) {
    case "bgp":
      // Basic Graph Pattern (BGP) | v occurs in the BGP
      // Path                      | v occurs in the path
      triple(variables, pattern.triples);
      break;
    case "bind":
      // BIND (expr AS v)          | v is in-scope
      if (!existsExpressionWorkaround && variables.inScopeBoundVariableTranslation.has(pattern.variable.value)) {
        // The variable introduced by the BIND clause must not have been used in the group graph pattern up to the point of use in BIND.
        // https://www.w3.org/TR/sparql11-query/#bind
        throw new SparqlError(`The variable ?${pattern.variable.value} cannot be bound more than once`);
      }
      pattern.variable = variables.onTermBind(pattern.variable);
      pattern.expression = expression(variables, pattern.expression, "non-aggregate");
      break;
    case "query":
      // SELECT .. v .. { P }      | v is in-scope
      // SELECT ... (expr AS v)    | v is in-scope
      // GROUP BY (expr AS v)      | v is in-scope
      // SELECT * { P }            | v is in-scope in P
      // We do need a new scope here in case the subselect is not
      // inside their group pattern based on the AST.
      // In other words, NOT ALL subselects are inside a scope restricting {}.
      // For example,  OPTIONAL { SELECT * WHERE{}} equals OPTIONAL{{SELECT * WHERE{}}}
      // See https://www.w3.org/TR/sparql11-query/#rGroupGraphPattern
      const queryVariables = variables.newScope();
      select(queryVariables, pattern);
      variables.mergeChildScope(queryVariables);
      break;
    case "values":
      pattern.values = values(variables, pattern.values);
      break;
    case "optional":
      // OPTIONAL {P}              | v is in-scope in P
      // no new scope here! (despite the `{` and `}` in the syntax)
      groupGraphPattern(variables, pattern.patterns);
      break;
    case "service":
      // SERVICE term {P}          | v is term or v is in-scope in P
      pattern.name = variables.onTermRead(pattern.name);
      const serviceVariables = variables.newScope("insideServiceClause");
      groupGraphPattern(serviceVariables, pattern.patterns);
      variables.mergeChildScope(serviceVariables);
      break;
    case "graph":
      // GRAPH term { P }          | v is term or v is in-scope in P
      pattern.name = variables.onTermBind(pattern.name);
    // intentional fall-through to `group`
    case "group":
      // Group { P1 P2 ... }       | v is in-scope if it is in-scope in one or more of P1, P2, ...
      const patternVariables = variables.newScope();
      groupGraphPattern(patternVariables, pattern.patterns);
      variables.mergeChildScope(patternVariables);
      break;
    case "union":
      // { P1 } UNION { P2 }       | v is in-scope in P1 or in-scope in P2
      pattern.patterns
        .map((pattern) => {
          const unionVariables = variables.newScope();
          // If the only operation in a group is a filter, it won't change the results,
          // because that part of the union will just return no results
          if (pattern.type === "filter") {
            pattern.expression = expression(unionVariables, pattern.expression, "non-aggregate");
          } else {
            graphPattern(unionVariables, pattern);
          }
          return unionVariables;
          // It's really important for correctness that the whole map is executed
          // before the forEach starts. But luckily it does!
        })
        .forEach((v) => variables.mergeChildScope(v));
      break;
    case "minus": {
      const patternVariables = variables.newScope();
      groupGraphPattern(patternVariables, pattern.patterns);
      // > use of a variable in FILTER, or in MINUS does not cause a variable to be in-scope outside of those forms.
      variables.mergeUnrelatedScope(patternVariables);
      break;
    }
  }
}
