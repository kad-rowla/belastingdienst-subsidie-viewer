/**
 *  This file contains all utility functions to create Algebra objects. They're
 *  different from "translators" because they don't take a SparqlJs type as
 *  input, but already translated arguments instead (except maybe for a name).
 */
import { IDENTITY, NOTHING, Operation } from "../Operation.js";
import { flatten, fromPairs, zip } from "lodash-es";
import { XPATH_FUNCTIONS } from "@triplydb/recognized-datatypes/utils/constants.js";
import {
  BINARY_FUNCTION_NAMES,
  FunctionCall,
  NIL_FUNCTION_NAMES,
  Expression,
  UNARY_FUNCTION_NAMES,
  OperationExpression,
  ExistsExpression,
} from "../Expression.js";
import { SparqlError } from "../../Errors.js";
import { DataDefinedFunctionInfo } from "./index.js";
import { UUID_REGEX } from "./translateOperation.js";
import { v4 as randomUuid } from "uuid";
import mapKeysDeep from "deepdash/mapKeysDeep";
import mapValuesDeep from "deepdash/mapValuesDeep";
import { GEO_FUNCTIONS } from "../../constants.js";

export function createJoin(operations: Operation[]): Operation {
  const flattenedOperations = operations.flatMap((operation) => {
    return operation.operationType === "Join" ? operation.inputOperations : [operation];
  });
  if (flattenedOperations.length === 0) return IDENTITY;
  if (flattenedOperations.length === 1) return flattenedOperations[0];
  if (flattenedOperations.includes(NOTHING)) return NOTHING;

  return {
    operationType: "Join",
    inputOperations: flattenedOperations,
  };
}

export function createUnion(operations: Operation[]): Operation {
  const flattenedOperations = flatten(
    operations.map((operation) => (operation.operationType === "Union" ? operation.inputOperations : [operation]))
  );
  if (flattenedOperations.length === 0) return NOTHING;
  if (flattenedOperations.length === 1) return flattenedOperations[0];
  return {
    operationType: "Union",
    inputOperations: flattenedOperations,
  };
}

/**
 *  Vaguely looking at the code of sparqljs, it seems that they just call
 *  toLower on the function name that they encounter in the query string
 */
export function makeNameTranslation<T extends string>(names: ReadonlyArray<T>) {
  // IRIs are case-sensitive!
  return fromPairs(
    names.map((name) => [name.startsWith("http://") || name.startsWith("https://") ? name : name.toLowerCase(), name])
  );
}

/**
 * The following functions can be run with no arguments, but some accept more. This is what the "possibly" implies.
 */
const POSSIBLY_NIL_FUNCTION_NAME_TRANSLATION = makeNameTranslation([...NIL_FUNCTION_NAMES, "BNODE"] as const);
POSSIBLY_NIL_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.CURRENT_DATE_TIME] = "NOW";

/**
 * These functions can only be run with a single argument. No more, no less.
 */
const UNARY_FUNCTION_NAME_TRANSLATION = makeNameTranslation(UNARY_FUNCTION_NAMES);
UNARY_FUNCTION_NAME_TRANSLATION["isuri"] = "isIRI";
UNARY_FUNCTION_NAME_TRANSLATION["uri"] = "IRI";
/*
 * creating xpath function name aliases here.
 */
UNARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.STRING] = "STR";
UNARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.STRING_LENGTH] = "STRLEN";
UNARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.UPPER_CASE] = "UCASE";
UNARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.LOWER_CASE] = "LCASE";
UNARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.ABS] = "ABS";
UNARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.CEILING] = "CEIL";
UNARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.FLOOR] = "FLOOR";
UNARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.ROUND] = "ROUND";
UNARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.NOT] = "!";

/**
 * The following functions accept 2 arguments. Some accept less, while others accept more, this is what the "possibly"
 * implies. Functions in the list are sorted on this basis.
 */
const POSSIBLY_BINARY_FUNCTION_NAME_TRANSLATION = makeNameTranslation([
  "+",
  "-",
  GEO_FUNCTIONS.TRANSFORM.value,
  ...BINARY_FUNCTION_NAMES,
  "SUBSTR",
  "REGEX",
] as const);

/*
 * creating xpath function name aliases here.
 */
POSSIBLY_BINARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.SUBSTRING] = "SUBSTR";
POSSIBLY_BINARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.SUBSTRING_BEFORE] = "STRBEFORE";
POSSIBLY_BINARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.SUBSTRING_AFTER] = "STRAFTER";
POSSIBLY_BINARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.STARTS_WITH] = "STRSTARTS";
POSSIBLY_BINARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.ENDS_WITH] = "STRENDS";
POSSIBLY_BINARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.CONTAINS] = "CONTAINS";
POSSIBLY_BINARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.MATCHES] = "REGEX";

/**
 * The following functions accept 3 arguments. Some accept less, while others accept more, this is what the "possibly"
 * implies. Functions in the list are sorted on this basis.
 */
const POSSIBLY_TERNARY_FUNCTION_NAME_TRANSLATION = makeNameTranslation(["SUBSTR", "REGEX", "IF", "REPLACE"] as const);
/*
 * creating xpath function name aliases here.
 */
POSSIBLY_TERNARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.SUBSTRING] = "SUBSTR";
POSSIBLY_TERNARY_FUNCTION_NAME_TRANSLATION[XPATH_FUNCTIONS.REPLACE] = "REPLACE";

export function createFunctionCall(functionName: string, args: Expression[]): FunctionCall | undefined {
  // n-ary functions
  if (functionName === "coalesce" || functionName === "concat")
    return {
      expressionType: "FunctionCall",
      function: functionName.toUpperCase() as "COALESCE" | "CONCAT",
      expressions: args,
    };
  if (functionName === XPATH_FUNCTIONS.CONCAT) {
    if (args.length < 2)
      throw new SparqlError("Syntax error: CONCAT accepts two or more arguments. Got " + args.length);
    return {
      expressionType: "FunctionCall",
      function: "CONCAT",
      expressions: args as [Expression, Expression, ...Expression[]],
    };
  }

  // Other functions
  switch (args.length) {
    case 0: {
      const translation = POSSIBLY_NIL_FUNCTION_NAME_TRANSLATION[functionName];
      if (!translation) break;
      return { expressionType: "FunctionCall", function: translation, expressions: args as [] };
    }
    case 1: {
      // Somehow the type system doesn't like the dictionary trick in the length 1 case....??
      if (functionName === "bnode")
        return { expressionType: "FunctionCall", function: "BNODE", expressions: args as [Expression] };
      if (functionName === "+")
        return { expressionType: "FunctionCall", function: "+", expressions: args as [Expression] };
      if (functionName === "-")
        return { expressionType: "FunctionCall", function: "-", expressions: args as [Expression] };
      if (functionName === GEO_FUNCTIONS.TRANSFORM.value)
        return {
          expressionType: "FunctionCall",
          function: functionName,
          expressions: args as [Expression],
        };
      const translation = UNARY_FUNCTION_NAME_TRANSLATION[functionName];
      if (!translation) break;
      return { expressionType: "FunctionCall", function: translation, expressions: args as [Expression] };
    }
    case 2: {
      if (functionName === "!=")
        return {
          expressionType: "FunctionCall",
          function: "!",
          expressions: [
            {
              expressionType: "FunctionCall",
              function: "=",
              expressions: args as [Expression, Expression],
            },
          ],
        };
      if (functionName === "<=")
        return {
          expressionType: "FunctionCall",
          function: "!",
          expressions: [
            {
              expressionType: "FunctionCall",
              function: "<",
              expressions: [args[1], args[0]],
            },
          ],
        };
      if (functionName === ">=")
        return {
          expressionType: "FunctionCall",
          function: "!",
          expressions: [
            {
              expressionType: "FunctionCall",
              function: "<",
              expressions: args as [Expression, Expression],
            },
          ],
        };
      if (functionName === ">")
        return {
          expressionType: "FunctionCall",
          function: "<",
          expressions: [args[1], args[0]],
        };
      const translation = POSSIBLY_BINARY_FUNCTION_NAME_TRANSLATION[functionName];
      if (!translation) break;
      return {
        expressionType: "FunctionCall",
        function: translation,
        expressions: args as [Expression, Expression],
      };
    }
    case 3: {
      const translation = POSSIBLY_TERNARY_FUNCTION_NAME_TRANSLATION[functionName];
      if (!translation) break;
      return {
        expressionType: "FunctionCall",
        function: translation,
        expressions: args as [Expression, Expression, Expression],
      };
    }
    case 4: {
      if (functionName === "replace" || functionName === XPATH_FUNCTIONS.REPLACE)
        return {
          expressionType: "FunctionCall",
          function: "REPLACE",
          expressions: args as [Expression, Expression, Expression, Expression],
        };
    }
  }
}

export function createOperationExpression(
  dataDefinedFunctionInfo: DataDefinedFunctionInfo,
  args: Expression[]
): OperationExpression | ExistsExpression | undefined {
  // The resulting operation will be something like this:
  // Join:
  // - nested Extends for the parameters
  // - dataDefinedFunctionInfo.implementation
  // First do the parameters
  let operation: Operation = IDENTITY;
  const variableTranslation: { [uuid: string]: string } = {};

  for (const [variableTerm, expression] of zip(dataDefinedFunctionInfo.parameters, args)) {
    // Too many arguments => not okay
    if (variableTerm === undefined) return;
    if (expression === undefined)
      if (variableTerm.optional)
        // optional argument that wasn't specified => okay
        // but there may be later required arguments, since the spec says
        // nothing about the order of optional or required parameters
        // see: https://www.w3.org/TR/shacl-af/#function-parameters
        continue;
      else return; // required argument that wasn't specified => not okay
    const variable = randomUuid();
    variableTranslation[variableTerm.name] = variable;
    operation = { operationType: "Extend", variable, expression, inputOperation: operation };
  }

  // We should take care not to rerandomize `operation`, since the expressions
  // could contain variables that are also used outside of this OperationExpression
  operation = createJoin([
    operation,
    rerandomizeVariables(dataDefinedFunctionInfo.implementation, variableTranslation),
  ]);
  if (!dataDefinedFunctionInfo.resultVariable)
    // this function had a sh:ask property
    return {
      expressionType: "Exists",
      operation,
    };

  // thus function had a sh:select property
  return {
    expressionType: "Operation",
    operation: operation,
    resultVariable: variableTranslation[dataDefinedFunctionInfo.resultVariable],
  };
}

/**
 * Find all random variables and give them new random names.
 */
function rerandomizeVariables<T>(object: T, randomVariables: { [uuid: string]: string }): T {
  function derandomize<T>(variable: T): T {
    if (typeof variable === "string" && UUID_REGEX.test(variable)) {
      if (!(variable in randomVariables)) randomVariables[variable] = randomUuid();
      variable = randomVariables[variable] as T;
    }
    return variable;
  }
  object = mapKeysDeep(object, (_value, key) => {
    return derandomize(key);
  });
  object = mapValuesDeep(object, (value) => {
    return derandomize(value);
  });
  return object;
}
