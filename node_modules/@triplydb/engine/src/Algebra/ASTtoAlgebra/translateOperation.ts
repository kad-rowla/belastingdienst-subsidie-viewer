/**
 *  This file contains all functions that take a sparql-js type as input and
 *  return an Operation as output, except those functions that translate a
 *  query form.
 */
import { default as SparqlJs } from "sparqljs";

import { IDENTITY, InlineData, Operation, NOTHING, Join } from "../Operation.js";
import { createJoin, createUnion } from "./creation.js";
import { compact } from "lodash-es";
import { translateExpression } from "./translateExpression.js";
import { translateSelectQuery } from "./translateQuery.js";
import { v4 as randomUUID } from "uuid";
import { Variable } from "../../constants.js";
import * as Terms from "@triplydb/data-factory/Terms.js";
import { FatalError, SparqlError, UnsupportedError } from "../../Errors.js";
import { getVariablesMatchedByOperation } from "../Optimization/optimization-utils.js";
import { fixSparqlJsValues } from "./translationUtils.js";
import { ExtraTranslationInfo } from "./index.js";
import { forEachAlgebraNode } from "../../Helpers.js";

export const UUID_REGEX = /^[a-f0-9]+-[a-f0-9]+-[a-f0-9]+-[a-f0-9]+-[a-f0-9]+$/;

/**
 *  Translate a group of patterns. Uses every translated pattern as the input
 *  to the next Operation, but picks out the filter patterns and applies them
 *  last.
 *
 *  This implements both of the following sections:
 *
 *    18.2.2.2 Collect FILTER Elements
 *             =======================
 *    https://www.w3.org/TR/sparql11-query/#sparqlCollectFilters
 *
 *    18.2.2.6 Translate Graph Patterns
 *             ========================
 *    https://www.w3.org/TR/sparql11-query/#sparqlTranslateGraphPatterns
 *
 */
export function translateSparqljsPatterns(patterns: SparqlJs.Pattern[], info: ExtraTranslationInfo): Operation {
  if (!patterns.length) return IDENTITY;
  const filterPatterns: SparqlJs.Pattern[] = [];
  const operation = patterns.reduce((operation: Operation, pattern) => {
    if (pattern.type === "filter") {
      // skip over the filter patterns for now
      filterPatterns.push(pattern);
      return operation;
    } else {
      return translateSparqljsPattern(pattern, operation, info);
    }
  }, IDENTITY);

  // Now it's the filter pattern's turn!
  return filterPatterns.reduce((operation, pattern) => {
    return translateSparqljsPattern(pattern, operation, info);
  }, operation);
}

/**
 *  18.2.2 Converting Graph Patterns
 *         =========================
 *  https://www.w3.org/TR/sparql11-query/#convertGraphPattern
 *
 *  @param  pattern             The pattern to translate
 *  @param  inputOperation      The `Operation` representing the part of the
 *                              query that came before the current pattern.
 *  @param  info                Any extra information that may be needed during translation.
 */
export function translateSparqljsPattern(
  pattern: SparqlJs.Pattern,
  inputOperation: Operation,
  info: ExtraTranslationInfo
): Operation {
  if (inputOperation === NOTHING) return NOTHING;
  switch (pattern.type) {
    case "bind":
      return {
        operationType: "Extend",
        variable: pattern.variable.value,
        expression: translateExpression(pattern.expression, info),
        inputOperation,
      };
    case "filter":
      return {
        operationType: "Filter",
        expression: translateExpression(pattern.expression, info),
        inputOperation,
      };
    case "minus": {
      const innerOperation = translateSparqljsPatterns(pattern.patterns, info);
      const outerOperation = inputOperation;
      const outerVariables = new Set(getVariablesMatchedByOperation(outerOperation));

      /**
       * If no common variables between inner and outer operation, then return only the outer operation.
       */
      for (const innerVariable of getVariablesMatchedByOperation(innerOperation)) {
        if (outerVariables.has(innerVariable)) {
          return {
            operationType: "Minus",
            inputOperations: [outerOperation, innerOperation],
          };
        }
      }
      return outerOperation;
    }
    case "bgp": {
      return createJoin([inputOperation, ...pattern.triples.map(translateTriplePattern)]) as Join;
      // See translation of zero or more property path
    }
    case "graph": {
      // @DECISION we accept that the algebra is data-dependent because of the way we translate
      //           GRAPH clauses. Moreover, we should also make sure that we only pass existing
      //           graph names, because we may not be doing any validation at the lower levels.
      const operations = [inputOperation];
      let graphFromAST: string | [Terms.NamedNode];
      if (pattern.name.termType === "Variable") {
        /**
         * If the graph value is a variable, we join the operation with a VALUES
         * operation including all the named graphs in the RDF dataset. It
         * protects against invalid graph names at run-time, and also unbound
         * variables
         */
        operations.push({
          operationType: "InlineData",
          values: info.namedGraphs.map((graphName) => ({ [pattern.name.value]: graphName })),
        });
        graphFromAST = pattern.name.value;
      } else if (!info.namedGraphs.some((g) => g.equals(pattern.name))) {
        // someone is trying to query a graph that doesn't exist,
        // so we know that there won't be any results.
        return NOTHING;
      } else {
        graphFromAST = [pattern.name];
      }

      const insidePatterns = translateSparqljsPatterns(pattern.patterns, info);
      operations.push(insidePatterns);

      /**
       * We do recursion to apply the graph information in every triple pattern
       * that might exist inside the algebra.
       */
      forEachAlgebraNode(
        insidePatterns,
        (operation) => {
          if (operation.operationType === "TriplePattern" || operation.operationType === "EnsureBound") {
            // If there is already a value for the graphs, then there was
            // probably a nested GRAPH clause so we shouldn't change whatever
            // the value is.
            if (operation.graphs) return;
            operation.graphs = graphFromAST;
          }
        },
        () => {},
        undefined
      );
      return createJoin(operations);
    }
    case "optional":
      const optionalPart = translateSparqljsPatterns(pattern.patterns, info);
      if (optionalPart === NOTHING || optionalPart === IDENTITY) return inputOperation;
      return {
        operationType: "LeftJoin",
        inputOperations: [inputOperation, optionalPart],
      };
    case "service":
      /**
       * @DECISION
       * Let's store the AST of the service clause instead of the algebra. This has a number of benefits:
       * - It would be tricky to use the algebra instead, because in some places we reuse functionality.
       *   For example, in property paths we reuse FILTER'S algebra.
       * - We cannot use the query string, because we need variable binding. Instead, we can leverage
       *   existing functionality from core to do variable binding on the AST.
       */
      const ASTquery: SparqlJs.SelectQuery = {
        type: "query",
        queryType: "SELECT",
        variables: [new SparqlJs.Wildcard()],
        where: pattern.patterns,
        /**
         * We don't need prefixes, and everything will be in the form of full
         * IRIS. But we will pass the baseIri during execution.
         */
        prefixes: {},
      };

      return createJoin([
        inputOperation,
        {
          operationType: "Service",
          runTimeInformation: {
            query: ASTquery,
            endpoint: pattern.name.termType === "Variable" ? pattern.name.value : pattern.name,
          },
          silent: pattern.silent,
        },
      ]);
    case "union":
      return createJoin([
        inputOperation,
        createUnion(pattern.patterns.map((p) => translateSparqljsPattern(p, IDENTITY, info))),
      ]);
    case "values":
      return translateInlineData(pattern.values, inputOperation);
    case "group":
      return createJoin([inputOperation, translateSparqljsPatterns(pattern.patterns, info)]);
    case "query":
      if (inputOperation !== IDENTITY)
        throw new FatalError("Expected 'query' to always be alone inside its 'group'. Please contact a developer.");
      return translateSelectQuery(pattern, info, "loadResultsInMemoryForLimit");
  }
}

type PathItems = (SparqlJs.PropertyPath | SparqlJs.IriTerm)[];

/**
 * This function is used to assert that there is only 1 path item in the `pathItems` array
 * The return value is the path item in question
 */
function getOnlyPathItem(
  /**
   * The path type is only used for generating an informative error message
   */
  pathName: "Inverse" | "Zero or more" | "One or more" | "Zero or one" | "Negated",
  pathItems: PathItems
) {
  if (pathItems.length != 1) {
    const errorMessage = `${pathName} property paths is unary, but more than one argument was given.`;
    throw new SparqlError(errorMessage);
  }
  return pathItems[0];
}

export function translatePropertyPath(
  start: Terms.NamedNode | Terms.Literal | Variable,
  term: SparqlJs.PropertyPath | SparqlJs.IriTerm,
  end: Terms.NamedNode | Terms.Literal | Variable
): Operation {
  // Predicate property path
  if ("termType" in term) {
    if (typeof start === "object" && start.termType === "Literal") return NOTHING;
    return {
      operationType: "TriplePattern",
      pattern: [start, term, end],
    };
  }
  const freshVariable = randomUUID();
  switch (term.pathType) {
    case "^": // Inverse property path
      return translatePropertyPath(end, getOnlyPathItem("Inverse", term.items), start);

    case "/": // Sequence property path
      const paths = term.items;
      const joins: Parameters<typeof translatePropertyPath>[] = [];
      const lastIndex = paths.length - 1;
      let lastFreshVariable = freshVariable;
      for (const [i, propertyPath] of paths.entries()) {
        const newFreshVariable = randomUUID();
        joins.push([i === 0 ? start : lastFreshVariable, propertyPath, i === lastIndex ? end : newFreshVariable]);
        lastFreshVariable = newFreshVariable;
      }
      return createJoin(joins.map((pattern) => translatePropertyPath(...pattern)));

    case "|": // Alternative property path
      return createUnion(term.items.map((item) => translatePropertyPath(start, item, end)));

    case "*": // Zero or more property paths
      if (typeof start === "string" && typeof end === "string") {
        return {
          operationType: "Join",
          inputOperations: [
            { operationType: "EnsureBound", variable: start },
            {
              operationType: "ZeroOrMorePath",
              inputOperation: translatePropertyPath(start, getOnlyPathItem("Zero or more", term.items), end),
              boundStart: start,
              end,
            },
          ],
        };
      } else if (typeof start === "string" && typeof end !== "string") {
        return translatePropertyPath(
          end,
          { ...term, items: [{ type: "path", pathType: "^", items: term.items }] },
          start
        );
      } else if (typeof start !== "string" && typeof end === "string") {
        // The ZeroOrMorePath implementation assumes a bound variable to start from.
        // So, first assigning the start term as a variable (`EXTEND`) and using the result in the property path
        // detect whether <end> is bound. If it is:
        // boundStart: end,
        // end:freshVariable,
        // If it isn't:
        // boundStart: freshVariable,
        // end:end,
        // We cannot know at this stage whether <end> is bound,
        // so we are doing this check in translateSparqljsPattern under
        //"bgp" case, where we are doing the upper join between zeroOrMore operation and others.
        return createJoin([
          {
            operationType: "Extend",
            inputOperation: IDENTITY,
            variable: freshVariable,
            expression: { expressionType: "Term", term: start },
          },
          {
            operationType: "ZeroOrMorePath",
            inputOperation: translatePropertyPath(freshVariable, getOnlyPathItem("Zero or more", term.items), end),
            boundStart: freshVariable,
            end: end,
          },
        ]);
      } else if (typeof start !== "string" && typeof end !== "string") {
        return createJoin([
          {
            operationType: "Extend",
            inputOperation: IDENTITY,
            variable: freshVariable,
            expression: { expressionType: "Term", term: end },
          },
          translatePropertyPath(start, term, freshVariable),
        ]);
      }

    case "+": // One or more property paths
      return {
        operationType: "Distinct",
        variables: compact([typeof start === "string" ? start : undefined, typeof end === "string" ? end : undefined]),
        inputOperation: createJoin([
          translatePropertyPath(start, getOnlyPathItem("One or more", term.items), freshVariable),
          translatePropertyPath(freshVariable, { ...term, pathType: "*" }, end),
        ]),
      };

    case "?": // Zero or one property paths
      if (typeof start === "object" && typeof end === "object") {
        // > eval(Path(X:term, ZeroOrOnePath(P), Y:term)) =
        // >     { {} } if X = Y or eval(Path(X,P,Y)) is not empty
        // >     { } othewise
        if (start.equals(end)) {
          return IDENTITY;
        } else {
          return {
            operationType: "Distinct",
            variables: [], // essentially a 'limit 1'
            inputOperation: translatePropertyPath(start, getOnlyPathItem("Zero or one", term.items), end),
          };
        }
      } else if (typeof start === "object" && typeof end === "string") {
        return {
          operationType: "Distinct",
          variables: compact([
            typeof start === "string" ? start : undefined,
            typeof end === "string" ? end : undefined,
          ]),
          inputOperation: createUnion([
            {
              operationType: "Extend",
              inputOperation: IDENTITY,
              variable: end,
              expression: { expressionType: "Term", term: start },
            },
            translatePropertyPath(start, getOnlyPathItem("Zero or one", term.items), end),
          ]),
        };
      } else if (typeof start === "string" && typeof end === "object") {
        return translatePropertyPath(
          end,
          { ...term, items: [{ type: "path", pathType: "^", items: term.items }] },
          start
        );
      } else if (typeof start === "string" && typeof end === "string") {
        return createJoin([
          { operationType: "EnsureBound", variable: start },
          {
            operationType: "Distinct",
            variables: compact([
              typeof start === "string" ? start : undefined,
              typeof end === "string" ? end : undefined,
            ]),
            inputOperation: createUnion([
              {
                operationType: "Extend",
                inputOperation: IDENTITY,
                variable: end,
                expression: { expressionType: "Variable", variable: start },
              },
              translatePropertyPath(start, getOnlyPathItem("Zero or one", term.items), end),
            ]),
          },
        ]);
      }
    case "!": // Negated property set
      // We need to store the initial values of start and end,
      // because we want to compare them to the output of translatePropertyPath, for whether we have a regular [start, term,end] or a reverse [end,term,start] path.
      const initStart = start,
        initEnd = end;

      // We know that translatePropertyPath in our case returns either TriplePattern (one negated property path) operation or Union operation (more than one negated property paths).
      const operationPropertyPath = translatePropertyPath(start, getOnlyPathItem("Negated", term.items), end);

      let appendOperations: ReadonlyArray<Operation>;
      if (operationPropertyPath.operationType === "TriplePattern") {
        appendOperations = [operationPropertyPath];
      } else if (operationPropertyPath.operationType === "Union") {
        appendOperations = operationPropertyPath.inputOperations;
      } else {
        throw Error(`This operation should not be any other than Union or TriplePattern. Contact a developer.`);
      }

      // We want two lists of operations because we want to store the regular path operations and reverse path operations
      const operationRegular: Operation[] = [],
        operationReversed: Operation[] = [];
      for (let appendOperation of appendOperations) {
        if (appendOperation.operationType !== "TriplePattern") {
          throw Error(`This operation should not be any other than TriplePattern. Contact a developer`);
        }
        if (appendOperation.pattern[0] === initStart && appendOperation.pattern[2] === initEnd) {
          // if the operation is about a regular path.
          operationRegular.push(appendOperation);
        } else {
          // If the operation is about a reverse path.
          operationReversed.push(appendOperation);
        }
      }

      if (operationReversed.length > 0 && operationRegular.length > 0) {
        // If we have reverse and regular negated property paths
        return createUnion([
          translateNegatedPathUsingFilter(start, freshVariable, end, operationRegular),
          translateNegatedPathUsingFilter(end, freshVariable, start, operationReversed),
        ]);
      } else if (operationReversed.length > 0 && operationRegular.length === 0) {
        // If we only have reverse negated property paths
        return translateNegatedPathUsingFilter(end, freshVariable, start, operationReversed);
      }
      // the condition left is if we have regular negated property paths
      return translateNegatedPathUsingFilter(start, freshVariable, end, operationRegular);
  }
}

function translateNegatedPathUsingFilter(
  start: Terms.NamedNode | Terms.Literal | Variable,
  term: string,
  end: Terms.NamedNode | Terms.Literal | Variable,
  insideOperations: Operation[]
): Operation {
  if (typeof start === "object" && start.termType === "Literal") return NOTHING;
  return {
    operationType: "Filter",
    expression: {
      expressionType: "FunctionCall",
      function: "!",
      expressions: [
        {
          expressionType: "Exists",
          operation: createUnion(insideOperations),
        },
      ],
    },
    inputOperation: {
      operationType: "TriplePattern",
      pattern: [start, term, end],
    },
  };
}

/**
 *  Helper for translateTriplePattern. Don't use this for expressions.
 */
function translateTerm<T extends SparqlJs.Term>(
  term: T
): T extends SparqlJs.BlankTerm | SparqlJs.Variable ? string : Exclude<T, SparqlJs.QuadTerm>;
function translateTerm(term: SparqlJs.Term): Exclude<SparqlJs.Term, SparqlJs.BlankTerm | SparqlJs.Variable> | string {
  if (term.termType === "Variable") return term.value;
  /**
   * We're replacing SPARQL blanknodes with a variable that we're not projecting
   * To make sure there isn't a naming collission, we are use this blank node ID
   * That ensures we don't collide with variable names, as `_:` are forbidden characters in variables
   */
  if (term.termType === "BlankNode") return term.id;

  if (term.termType === "Quad") {
    throw new UnsupportedError(`SPARQL* is not supported.`);
  }

  // We want the regular term for anything except variables and blank nodes
  return term;
}

export function translateTriplePattern(triple: SparqlJs.Triple): Operation {
  const subject = translateTerm(triple.subject);
  const object = translateTerm(triple.object);

  if ("termType" in triple.predicate) {
    const predicate = triple.predicate.termType === "Variable" ? triple.predicate.value : triple.predicate;
    return {
      operationType: "TriplePattern",
      pattern: [subject, predicate, object],
    };
  } else {
    return translatePropertyPath(subject, triple.predicate, object);
  }
}

/**
 *    18.2.4.3 VALUES
 *             ======
 *    https://www.w3.org/TR/sparql11-query/#sparqlAlgebraFinalValues
 */
export function translateInlineData(values: InlineData["values"], inputOperation: Operation) {
  values = fixSparqlJsValues(values, "remove undefined");
  // The order of this join is _very_ important for which results are returned.
  // See the w3c/bindings/values07 test.
  return createJoin([inputOperation, { operationType: "InlineData", values }]);
}
