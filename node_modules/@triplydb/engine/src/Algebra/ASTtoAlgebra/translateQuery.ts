import * as SparqlJs from "sparqljs";
import { Aggregate, NOTHING, Operation, OrderingKey } from "../Operation.js";
import log from "../../Debugging.js";
import { Variable } from "../../constants.js";
import { v4 as randomUUID } from "uuid";
import { addAggregateExpression } from "./aggregation.js";
import { translateExpression } from "./translateExpression.js";
import { translateInlineData, translateSparqljsPatterns } from "./translateOperation.js";
import { compact } from "lodash-es";
import { FatalError, SparqlError } from "../../Errors.js";
import { isAggregateQuery, isWildCard } from "./translationUtils.js";
import { ExtraTranslationInfo } from "./index.js";

/**
 *    18.2 Translation to the SPARQL Algebra
 *         =================================
 *    https://www.w3.org/TR/sparql11-query/#sparqlQuery
 */
export function translateSelectQuery(
  query: SparqlJs.SelectQuery,
  info: ExtraTranslationInfo,
  loadResultsInMemoryForLimit?: "loadResultsInMemoryForLimit"
): Operation {
  if (query.limit === 0) {
    log("sparql:translate", "Found LIMIT 0, thus resulting algebra is NOTHING");
    return NOTHING;
  }

  if (isWildCard(query.variables)) throw new FatalError("We were promised no wildcards. This is a bug.");

  /**
   *    18.2.2 Converting Graph Patterns
   *           =========================
   *    https://www.w3.org/TR/sparql11-query/#convertGraphPattern
   */
  query.where = query.where ?? [];

  let operation = translateSparqljsPatterns(query.where, info);

  const isAggregate = isAggregateQuery(query);
  if (isAggregate) {
    query.group = query.group ?? [];
    /**
     *    18.2.4.1 Grouping and Aggregation
     *             ========================
     *    https://www.w3.org/TR/sparql11-query/#sparqlGroupAggregate
     */
    // > Within `GROUP BY` clauses the binding keyword, `AS`, may be used, such
    // > as `GROUP BY (?x + ?y AS ?z)`. This is equivalent to
    // > `{ ... BIND(?x + ?y AS ?z) } GROUP BY ?z`.
    //
    // from: https://www.w3.org/TR/sparql11-query/#groupby
    for (const { variable, expression } of query.group) {
      if (!variable) continue;
      operation = {
        operationType: "Extend",
        variable: variable.value,
        expression: translateExpression(expression, info),
        inputOperation: operation,
      };
    }

    const aggregate: Aggregate = (operation = {
      operationType: "Aggregate",
      groupingExpressions: query.group.map(({ variable, expression }) =>
        variable ? { expressionType: "Variable", variable: variable.value } : translateExpression(expression, info)
      ),
      aggregatingExpressions: {}, // this is just an initialisation
      inputOperation: operation,
    });

    const aggregatedVariables = new Set(
      compact(aggregate.groupingExpressions.map((e) => (e.expressionType === "Variable" ? e.variable : undefined)))
    );

    // Make sure all grouped variables are visible outside of the `Aggregate`
    // operation. This is important to do for all grouped variables and not
    // just the projected ones, because the grouped variable could be used in
    // an aggregate expression
    for (const variable of aggregatedVariables) {
      aggregate.aggregatingExpressions[variable] = {
        expressionType: "AggregateFunction",
        function: "SAMPLE",
        expression: { expressionType: "Variable", variable },
        distinct: false, // this value doesn't matter for the result, but `false` is easier to compute
      };
    }

    // > For each (X AS Var) in SELECT, each HAVING(X), and each ORDER BY X in Q
    for (const expression of query.variables) {
      // For each (X as Var) in SELECT
      let name: string;
      let expr: SparqlJs.Expression;
      if ("variable" in expression) {
        name = expression.variable.value;
        expr = expression.expression;
      } else {
        // someone typed a bare `?variable` in the projection, e.g.
        // SELECT ?s where {?s ?p ?o} group by ?o
        name = expression.value;
        // `translateExpression` converts any non-aggregated variables to a
        // SAMPLE when requesting an aggregate expression
        expr = expression;
      }
      operation = addAggregateExpression(name, expr, aggregate, operation, aggregatedVariables, info);
      aggregatedVariables.add(name);
    }

    /**
     *    18.2.4.2 HAVING
     *             ======
     *    https://www.w3.org/TR/sparql11-query/#sparqlHavingClause
     *
     *    > HAVING operates over grouped solution sets, in the same way that
     *    > FILTER operates over un-grouped ones.
     *    from: https://www.w3.org/TR/sparql11-query/#having
     *
     *    So we're just going to rewrite them to normal filters:
     *    1. aggregate the `having` expression to a new variable
     *    2. add a filter with that variable
     *    3. the introduced variable will be projected out automatically
     */
    if (query.having) {
      // > Note that, due to the logic position in which the HAVING clause is
      // > evaluated, expressions projected by the SELECT clause are not
      // > visible to the HAVING clause.
      //
      // from: https://www.w3.org/TR/sparql11-query/#sparqlHavingClause
      // So therefore we pass the empty set as `aggregatedVariables` this time.
      const emptySet = new Set<Variable>();
      for (const having of query.having) {
        // for each HAVING(X)
        const variable = randomUUID();
        operation = addAggregateExpression(variable, having, aggregate, operation, emptySet, info);
        operation = {
          operationType: "Filter",
          expression: { expressionType: "Variable", variable },
          inputOperation: operation,
        };
      }
    }

    /**
     *    18.2.5.1 ORDER BY
     *             ========
     *    https://www.w3.org/TR/sparql11-query/#sparqlOrderBy
     */
    if (query.order) {
      // > For each ORDER BY X in Q
      const ordering: OrderingKey[] = [];
      for (const { expression, descending } of query.order) {
        const variable = randomUUID();
        ordering.push({
          direction: descending ? "descending" : "ascending",
          expression: { expressionType: "Variable", variable },
        });
        operation = addAggregateExpression(variable, expression, aggregate, operation, aggregatedVariables, info);
      }

      operation = {
        operationType: "OrderBy",
        inputOperation: operation,
        ordering,
      };
    }
  }

  /**
   *    18.2.4.3 VALUES
   *             ======
   *    https://www.w3.org/TR/sparql11-query/#sparqlAlgebraFinalValues
   */
  if (query.values) {
    operation = translateInlineData(query.values, operation);
  }

  /**
   *    18.2.4.4 SELECT Expressions
   *             ==================
   *    https://www.w3.org/TR/sparql11-query/#sparqlSelectExpressions
   */
  if (!isAggregate) {
    /**
     *  @DECISION After a long discussion we reached the following conclusions:
     *   - The spec clearly states that this is not an aggregate query
     *   - We do not want to support it
     *
     *  We reached no conclusion on whether the spec intends for this query to
     *  be legal.
     *  See also sparql/triply/aggregation/having-without-aggregate and
     *  sparql/triply/aggregation/having-with-aggregate.
     *
     *    SELECT ?o where {
     *      ?s ?p ?o
     *    } having (?o)
     */
    if (query.having?.length)
      throw new SparqlError("Using the HAVING clause for non-aggregate queries is not supported.");

    for (const exprAsVar of query.variables) {
      if (!("variable" in exprAsVar)) continue;
      const variable = exprAsVar.variable.value;
      operation = {
        operationType: "Extend",
        variable,
        expression: translateExpression(exprAsVar.expression, info),
        inputOperation: operation,
      };
    }
  }

  /**
   *    18.2.5 Converting Solution Modifiers
   *           =============================
   *    https://www.w3.org/TR/sparql11-query/#convertSolMod
   *
   *    18.2.5.1 ORDER BY
   *             ========
   *    https://www.w3.org/TR/sparql11-query/#sparqlOrderBy
   */
  if (query.order) {
    operation = {
      operationType: "OrderBy",
      inputOperation: operation,
      ordering: query.order.map(({ descending, expression }) => ({
        direction: descending ? "descending" : "ascending",
        expression: translateExpression(expression, info),
      })),
    };
  }

  /**
   *    18.2.5.2 Projection
   *             ==========
   *    https://www.w3.org/TR/sparql11-query/#sparqlProjection
   */
  // Because of the way we scope variables, we don't need a Project operation

  /**
   *    18.2.5.3 DISTINCT
   *             ========
   *    https://www.w3.org/TR/sparql11-query/#sparqlDistinct
   */
  if (query.distinct) {
    const projection = query.variables.map((v) => ("variable" in v ? v.variable : v).value);
    operation = { operationType: "Distinct", inputOperation: operation, variables: projection };
  }

  /**
   *    18.2.5.4 REDUCED
   *             =======
   *    https://www.w3.org/TR/sparql11-query/#sparqlReduced
   *
   *    @DECISION We ignore reduced, which is a compliant implementation.
   */

  /**
   *    18.2.5.5 OFFSET and LIMIT
   *             ======     =====
   *    https://www.w3.org/TR/sparql11-query/#sparqlOffsetLimit
   */
  if (query.offset !== undefined || query.limit !== undefined) {
    operation = {
      operationType: "Slice",
      offset: query.offset ?? 0,
      ...(query.limit ? { limit: query.limit } : {}),
      inputOperation: operation,
      loadIntoMemory: !!loadResultsInMemoryForLimit,
    };
  }

  return operation;
}
