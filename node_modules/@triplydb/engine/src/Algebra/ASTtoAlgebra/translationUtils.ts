import { forEach } from "lodash-es";
import { default as SparqlJs } from "sparqljs";
import { IDENTITY, NOTHING, Operation } from "../Operation.js";
import { forEachAlgebraNode } from "../../Helpers.js";
import { dataFactory } from "../../constants.js";
import { v4 as randomUUID } from "uuid";
import { scopeVariables } from "./variableScope.js";
import { FatalError, UnsupportedError } from "../../Errors.js";

/**
 *  Make sure variable names indeed do not contain the leading `?` or `$`, as
 *  the spec dictates: http://rdf.js.org/data-model-spec/#variable-interface.
 *
 *  At first glance this not-quite-compliant behaviour seems to be intentional:
 *  https://github.com/RubenVerborgh/SPARQL.js/blob/main/lib/sparql.jison#L787,
 *  but for us it's really annoying.
 *
 *  Also, depending on the use-case, we want to filter out any unbound variables,
 *  s.t. we don't have objects like this: `{ a: undefined, b: <something> }`, but
 *  objects like this: `{ b: <something> }`.
 */
export function fixSparqlJsValues(
  values: readonly SparqlJs.ValuePatternRow[],
  removeUndefined: "remove undefined" | "keep undefined"
) {
  return values.map((bindings) => {
    const values: SparqlJs.ValuePatternRow = {};
    forEach(bindings, (value, name) => {
      // we're also filtering out keys that have an `undefined` value
      if (removeUndefined === "keep undefined" || value) {
        if (["?", "$"].includes(name.charAt(0))) {
          name = name.slice(1);
        }
        values[name] = value;
      }
    });
    return values;
  });
}

export function isWildCard(
  element: (SparqlJs.DescribeQuery | SparqlJs.SelectQuery)["variables"]
): element is [SparqlJs.Wildcard] {
  return element.length === 1 && "termType" in element[0] && element[0].termType === "Wildcard";
}

/**
 *  18.2.4.1 Grouping and Aggregation
 *           ========================
 *  https://www.w3.org/TR/sparql11-query/#sparqlGroupAggregate
 *
 *  > If Q contains GROUP BY exprlist
 *  >    Let G := Group(exprlist, P)
 *  > Else If Q contains an aggregate in SELECT, HAVING, ORDER BY
 *  >    Let G := Group((1), P)
 *  > Else
 *  >    skip the rest of the aggregate step
 *  >    End
 */
export function isAggregateQuery(query: SparqlJs.SelectQuery): boolean {
  return (
    !!query.group ||
    // SELECT
    query.variables.some((variable) => "expression" in variable && isAggregateExpression(variable.expression)) ||
    !!query.having?.some(isAggregateExpression) ||
    !!query.order?.some((variable) => "expression" in variable && isAggregateExpression(variable.expression))
  );
}

function isAggregateExpression(expression: SparqlJs.Expression): boolean {
  if (Array.isArray(expression)) return expression.some(isAggregateExpression);
  if ("termType" in expression) return false;
  switch (expression.type) {
    case "aggregate":
      return true;
    case "operation":
    case "functionCall":
      return expression.args.some(isAggregateExpression);
    // BlockPatterns
    case "graph":
    case "group":
    case "minus":
    case "service":
    case "union":
    case "optional":
    // Other patterns
    case "query":
    case "bgp":
    case "bind":
    case "values":
    case "filter":
      // This happens in an Exists expression
      return false;
  }
}

export function setIdsInPlace(operation: Operation): void {
  // to make sure siblings don't have the same ID, we mutate the data object
  // that will be passed to them.
  type Data = { parentId: string | undefined; siblingCount: number };
  forEachAlgebraNode<Data>(
    operation,
    (operation, data) => {
      // we don't want to modify a shared object, and identity doesn't have any
      // children
      if (operation === IDENTITY || operation === NOTHING) return {} as Data;

      // Set the ID of the current operation
      if (data.parentId === undefined) {
        operation.id = "";
      } else if (data.parentId === "") {
        operation.id = `${data.siblingCount++}`;
      } else {
        operation.id = data.parentId + "." + data.siblingCount++;
      }
      return { parentId: operation.id, siblingCount: 0 };
    },
    (_expression, data) => {
      let id: string;
      if (data.parentId === undefined) {
        id = "";
      } else if (data.parentId === "") {
        id = `${data.siblingCount++}`;
      } else {
        id = data.parentId + "." + data.siblingCount++;
      }

      return { parentId: id, siblingCount: 0 };
    },
    { parentId: undefined, siblingCount: 0 }
  );
}

const EMPTY_CONSTRUCT = {
  type: "query",
  queryType: "CONSTRUCT",
  where: [],
  prefixes: {},
} satisfies SparqlJs.ConstructQuery;

function hasOnlyIrisNotVariableTerm(
  element: SparqlJs.IriTerm[] | SparqlJs.VariableTerm[]
): element is SparqlJs.IriTerm[] {
  if (element.some((element) => element.termType === "Variable")) return false;
  return true;
}

interface DescribleToConstructTriple {
  subject: SparqlJs.IriTerm | SparqlJs.VariableTerm;
  predicate: SparqlJs.VariableTerm;
  object: SparqlJs.VariableTerm;
}
export function rewriteDescribeQuery(describeQuery: SparqlJs.DescribeQuery): SparqlJs.ConstructQuery {
  // @DECISION The spec says: The description is determined by the query service.
  // We chose to translate only describe queries of two cases (see #7361), using though
  // the structure of construct queries.

  // Below we are taking an AST of a describe query and transforming it into the AST of a construct query.
  // Then we are calling translateConstructQuery() to do the rest of the
  // job for us (meaning translation of construct query's AST to algebra).
  // Of course, at the end we return the algebra along with templates.

  // When * , we return no results
  if (isWildCard(describeQuery.variables)) {
    describeQuery = scopeVariables(describeQuery);
  }
  // Typescript doesn't know that we removed the WildCard, that's why we have to check again :(
  if (isWildCard(describeQuery.variables)) throw new FatalError("Scope didn't work. This is a bug.");
  // This is what we are going to use in templates field, regarding the triples that we are constructing.
  const triples: DescribleToConstructTriple[] = describeQuery.variables.map((variable) => {
    return {
      subject: variable.termType === "Variable" ? dataFactory.variable(variable.value) : variable,
      predicate: dataFactory.variable(randomUUID()),
      object: dataFactory.variable(randomUUID()),
    };
  });

  // Two different cases include one query with where clause and one without one.
  if ("where" in describeQuery) {
    // We don't support these cases, and we return no results
    if (describeQuery.where!.length > 1 || !(describeQuery.where![0].type === "bgp")) return EMPTY_CONSTRUCT;

    // We need to have a construct with:
    // A) A subselect of the triple(s)
    // B) A union of triple patterns regarding etc variable in the projection.
    return {
      queryType: "CONSTRUCT",
      template: triples,
      where: [
        {
          type: "group",
          patterns: [
            // Here we have (A)
            {
              type: "query",
              queryType: "SELECT",
              variables: [new SparqlJs.Wildcard()], // we want to select all our variables
              // If I don't include it (as it's defined below), I get an error because of the types.
              prefixes: describeQuery.prefixes,
              where: [
                {
                  type: "bgp",
                  triples: describeQuery.where![0].triples,
                },
              ],
            },
          ],
        },
        // Here we have (B)
        {
          type: "union",
          patterns: triples.map((triple) => {
            return {
              type: "bgp",
              triples: [triple],
            };
          }),
        },
      ],
      type: describeQuery.type,
      base: describeQuery.base,
      prefixes: describeQuery.prefixes,
    };
  } else {
    // We don't support queries like
    // describe ?s, and we return no results.
    if (!hasOnlyIrisNotVariableTerm(describeQuery.variables))
      throw new UnsupportedError(
        `We don't support DESCRIBE queries including projected variables and without a WHERE clause, for example 'DESCRIBE ?s'. `
      );
    return {
      queryType: "CONSTRUCT",
      template: triples,
      where: [
        {
          type: "values",
          values: describeQuery.variables.map((variable) => {
            return { [triples[0].subject.value]: variable };
          }),
        },
        { type: "bgp", triples: triples },
      ],
      type: describeQuery.type,
      base: describeQuery.base,
      prefixes: describeQuery.prefixes,
    };
  }
}
