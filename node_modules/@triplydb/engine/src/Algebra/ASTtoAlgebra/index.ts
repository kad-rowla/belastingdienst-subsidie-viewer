/**
 *  This file is the main entrypoint to algebra translation
 */
import * as Terms from "@triplydb/data-factory/Terms.js";
import { default as sparqljs } from "sparqljs";
import { GraphName, Term, Variable } from "../../constants.js";
import { FatalError, SparqlError } from "../../Errors.js";
import { BlankNode, NamedNode } from "@triplydb/data-factory/Terms.js";
import { translateSelectQuery } from "./translateQuery.js";
import { Operation } from "../Operation.js";
import { setIdsInPlace } from "./translationUtils.js";

interface TripleTemplate {
  subject: NamedNode | BlankNode | Variable;
  predicate: NamedNode | Variable;
  object: Term | Variable;
}

export type TripleTemplates = ReadonlyArray<TripleTemplate>;
export type ParameterInfo = { name: Variable; optional: boolean };
export type DataDefinedFunctionInfo = {
  parameters: Array<ParameterInfo>;
  implementation: Operation;
  /** If this is left out, it means the function had a sh:ask property. Otherwise it has a sh:select property. */
  resultVariable?: Variable;
};

export type ExtraTranslationInfo = {
  dataDefinedFunctions: {
    [iri: string]: DataDefinedFunctionInfo | undefined;
  };
  variablesToTranslateWithoutErrorChecking: Set<Variable>;
  namedGraphs: GraphName[];
};

export function operationFromScopedAst(
  ast: sparqljs.AskQuery | sparqljs.ConstructQuery | sparqljs.SelectQuery,
  info: ExtraTranslationInfo,
  dontSetIds?: "don't set IDs"
): Operation {
  if (!("variables" in ast))
    throw new FatalError("Variable scoping should have introduced a `.variables` property to all queries.");

  const operation = translateSelectQuery(ast as sparqljs.SelectQuery, info);
  if (!dontSetIds) setIdsInPlace(operation);
  return operation;
}

export function templatesFromAst(template: sparqljs.ConstructQuery["template"]): TripleTemplates {
  if (!template) return [];

  // Type-check the SPARQL-JS types, and narrow them to our types.
  return template.map((triple) => {
    let subject: Terms.NamedNode | Terms.BlankNode | Variable;
    if (triple.subject.termType === "Variable") {
      subject = triple.subject.value;
    } else if (triple.subject.termType === "Quad") {
      throw new SparqlError("Quads cannot be in subject position of CONSTRUCT template.");
    } else {
      subject = triple.subject;
    }

    let predicate: Terms.NamedNode | Variable;
    if ("type" in triple.predicate) {
      throw new SparqlError("Property paths cannot be in predicate position of CONSTRUCT template.");
    } else if ("termType" in triple.predicate && triple.predicate.termType === "Variable") {
      predicate = triple.predicate.value;
    } else {
      predicate = triple.predicate;
    }

    let object: Term | Variable;
    if (triple.object.termType === "Variable") {
      object = triple.object.value;
    } else if (triple.object.termType === "Quad") {
      throw new SparqlError("Quads cannot be in object position of CONSTRUCT template.");
    } else {
      object = triple.object;
    }
    return { subject, predicate, object };
  });
}
