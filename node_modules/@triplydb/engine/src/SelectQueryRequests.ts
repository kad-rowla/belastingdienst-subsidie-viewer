import { stringify } from "@triply/utils/sparqlVarUtils.js";
import fetch, { FetchError, Response } from "node-fetch";
import { SelectQuery } from "sparqljs";
import { mapValues } from "lodash-es";
import { factory } from "@triplydb/data-factory";
import { NamedNode } from "@triplydb/data-factory/Terms.js";
import { Bindings, Term } from "./constants.js";
import { SelectJson, SparqlJsonBlankNode, SparqlJsonIri, SparqlJsonLiteral } from "./Serialization/sparql2json.js";
import { FederationError } from "./Errors.js";

export interface SendRequestOpts {
  query: SelectQuery;
  endpoint: string;
}
/**
 *  Instead of following the standard, Virtuoso returns "typed-literal" for typed literals :(
 */
type VirtuosoTypedLiteral = {
  type: "typed-literal";
  value: string;
  datatype: string;
};

type DirtyLiteral = SparqlJsonLiteral | VirtuosoTypedLiteral;

export type DirtyTerm = SparqlJsonIri | DirtyLiteral | SparqlJsonBlankNode;

function isNotValidUrl(url: string) {
  //  Check whether the url is empty
  if (!url || url.trim() === "") true;

  url = url.trim();
  const urlRegex =
    /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:[/?#]\S*)?$/i;

  // Check whether the URL is valid and not a localhost
  return !urlRegex.test(url);
}

export async function* sendSparqlSelectRequest(opts: SendRequestOpts): AsyncGenerator<Bindings<Term>> {
  /* JSON may be malformed in these known cases:
    - The service returns results in a stream for select-queries (e.g. Jena),
      and an error occurs during query execution (e.g. a federated-to service returns empty result set)
      (https://git.triply.cc/triplydb/errors/-/issues/34428)
 */
  const parsedJson = parseJson(await fetchResponseText(opts), opts.endpoint);

  for (const binding of parsedJson.results.bindings) {
    try {
      yield mapValues(binding, (term) => (term ? sparqlJsonToBindings(term) : undefined));
    } catch (e) {
      const error = e as Error;
      throw new FederationError(
        `Failed to transform to bindings from endpoint ${opts.endpoint} (${error.name}, ${error.message})`
      );
    }
  }
}

function parseJson(receivedResponseText: string, endpoint: string): SelectJson {
  let parsedJson: any;
  try {
    parsedJson = JSON.parse(receivedResponseText);
  } catch (e) {
    const error = e as Error;
    throw new FederationError(`Failed to parse response from ${endpoint} as JSON (${error.name}, ${error.message})`);
  }

  if (!("results" in parsedJson) || !("bindings" in parsedJson.results)) {
    throw new FederationError(`Failed to parse response from ${endpoint} as SPARQL JSON.`);
  }

  return parsedJson;
}

function sparqlJsonToBindings(term: DirtyTerm): Term {
  switch (term.type) {
    case "uri":
      return factory.namedNode(term.value);
    case "bnode":
      return factory.blankNode(term.value);
    case "literal":
    case "typed-literal": // virtuoso returns this for typed literals
      let datatypeOrLangString: string | NamedNode | undefined;
      if ("xml:lang" in term) {
        datatypeOrLangString = term["xml:lang"];
      } else if ("datatype" in term) {
        datatypeOrLangString = factory.namedNode(term.datatype);
      }
      return factory.literal(term.value, datatypeOrLangString);
  }
  /**
   * The term is not valid but we won't get an error during runtime.
   */
  throw new Error(`Invalid term type.${term}`);
}

async function fetchResponseText(opts: SendRequestOpts) {
  /** SPEC: https://www.w3.org/TR/2013/REC-sparql11-federated-query-20130321/
   *  The execution of a SERVICE pattern may fail due to several reasons:
   *  the remote service may be down, the service IRI may not be dereferenceable,
   * or the endpoint may return an error to the query.
   */
  if (isNotValidUrl(opts.endpoint)) {
    throw new FederationError(`Invalid endpoint provided (${opts.endpoint})`);
  }

  const requestHeaders = {
    "content-type": "application/x-www-form-urlencoded",
    accept: "application/sparql-results+json; charset=UTF-8",
  };
  let response: Response;
  try {
    response = await fetch(opts.endpoint, {
      method: "POST",
      headers: requestHeaders,
      body: new URLSearchParams({ query: stringify(opts.query) }),
    });
  } catch (e) {
    /**
     * We decided to not be more detailed about the error handling, maybe some work for the future.
     */
    if (e instanceof FetchError) {
      throw new FederationError(`Failed to query ${opts.endpoint} (${e.code}, ${e.errno}, ${e.name}, ${e.message})`);
    } else {
      // In principle, all errors should be instances of Error class.
      const error = e as Error;
      throw new FederationError(`Failed to query ${opts.endpoint} (${error.name}, ${error.message})`);
    }
  }
  // See https://www.w3.org/TR/sparql11-protocol/#query-failure
  if (response.status >= 300) {
    let message = `Unsuccessful query operation with status code ` + response.status + ` (endpoint:${opts.endpoint}).`;
    try {
      const responseText = await response.text();
      if (responseText) {
        message += `\n\nResponse body: ${
          responseText.length > 10000 ? responseText.slice(0, 10000) + "..." : responseText
        }`;
      }
    } catch (e) {
      // Do nothing if we can't parse the body, or if it's empty.
    }
    throw new FederationError(message);
  }

  return response.text();
}
