import { EvaluationError } from "./EvaluationResult.js";
import { dataFactory, dataFactoryWithRewriteOfInvalidLiterals, DATA_TYPES, Term } from "./constants.js";
import { SUB_TYPES, isNumericDatatype } from "@triplydb/recognized-datatypes/utils/constants.js";
import { NamedNode, Literal, BlankNode } from "@triplydb/data-factory/Terms.js";
import { Operation } from "./Algebra/Operation.js";
import { AggregateFunction, Expression } from "./Algebra/Expression.js";
import { SparqlError, SpeedyError } from "./Errors.js";

import { DATA_TYPE_NAME_MAPPING } from "@triplydb/recognized-datatypes/utils/constants.js";
import * as SparqlJs from "sparqljs";

export type Prefixes = SparqlJs.ParserOptions["prefixes"];

export function parse(queryString: string, opts: { baseIri: string; prefixes?: Prefixes }) {
  const parser = new SparqlJs.Parser({
    factory: dataFactoryWithRewriteOfInvalidLiterals,
    skipUngroupedVariableCheck: true,
    baseIRI: opts.baseIri,
    prefixes: opts.prefixes,
  });
  parser._resetBlanks();
  dataFactory.resetBnodeCounter();
  return parser.parse(queryString);
}

/**
 * Basic Filtering (Section 3.3.1) matches a language priority list consisting
 * of basic language ranges (Section 2.1) to sets of language tags.
 *
 * This function was adapted from this library: https://github.com/wooorm/bcp-47-match
 *
 * @param tags One or more BCP-47 langauge tags.
 * @param ranges One or more RFC 4647 ranges.
 * @returns List of BCP-47 tags, or an empty array if none match.
 */
export function basicLanguageTagFilter(tags: string | string[], ranges: string | string[]): string[] {
  function check(tag: string, range: string) {
    return range === "*" || tag === range || tag.includes(range + "-");
  }
  let left = typeof tags === "string" ? [tags] : tags;
  const right = typeof ranges === "string" ? [ranges] : ranges;
  const matches: string[] = [];
  let rightIndex = -1;

  while (++rightIndex < right.length) {
    const range = right[rightIndex].toLowerCase();
    let leftIndex = -1;
    const next: string[] = [];
    while (++leftIndex < left.length) {
      if (check(left[leftIndex].toLowerCase(), range)) {
        matches.push(left[leftIndex]);
      } else {
        next.push(left[leftIndex]);
      }
    }
    left = next;
  }
  return matches;
}

/**
 *  For now, we only support m,s,i flags and their combinations.
 */
export function isSupportedFlag(flag: string) {
  // We have to be strict with the combination we allow, else we get an error from RegExp.
  // We allow combinations of i,s,m with one to three characters, no matter the order.
  if (/^[smi]+$/.test(flag)) return new Set(flag).size === flag.length;
}

export async function deplete<T>(iterable: Iterable<T> | AsyncIterable<T>, maxResults?: number): Promise<T[]> {
  const result: T[] = [];
  for await (const element of iterable) {
    if (maxResults !== undefined && result.length >= maxResults)
      throw new SpeedyError(`Cannot load more than ${maxResults} results into memory.`);
    result.push(element);
  }
  return result;
}

export async function next<T>(iterable: Iterable<T> | AsyncIterable<T>): Promise<T | undefined> {
  for await (const element of iterable) {
    return element;
  }
}

/**
 *  Recursively apply `onOperation` and `onExpression` to every Operation and
 *  Expression in the passed algebra, respectively. Use the `State` type if you
 *  want to keep track of some kind of state.
 */
export function forEachAlgebraNode<State>(
  node: Operation | AggregateFunction | Expression,
  onOperation: (operation: Operation, state: State) => State,
  onExpression: (expression: AggregateFunction | Expression, state: State) => State,
  state: State
) {
  if ("operationType" in node) {
    // Operations
    state = onOperation(node, state);

    if ("inputOperation" in node) {
      forEachAlgebraNode(node.inputOperation, onOperation, onExpression, state);
    }
    if ("inputOperations" in node) {
      node.inputOperations.forEach((operation) => forEachAlgebraNode(operation, onOperation, onExpression, state));
    }
    if ("expression" in node) {
      forEachAlgebraNode(node.expression, onOperation, onExpression, state);
    }
    if ("ordering" in node) {
      node.ordering.forEach(({ expression }) => forEachAlgebraNode(expression, onOperation, onExpression, state));
    }
    if ("groupingExpressions" in node) {
      node.groupingExpressions.forEach((expression) =>
        forEachAlgebraNode(expression, onOperation, onExpression, state)
      );
      Object.values(node.aggregatingExpressions).forEach((expression) =>
        forEachAlgebraNode(expression, onOperation, onExpression, state)
      );
    }
  } else {
    // Expressions
    state = onExpression(node, state);
    if ("operation" in node) {
      forEachAlgebraNode(node.operation, onOperation, onExpression, state);
    }
    if ("expressions" in node) {
      node.expressions.forEach((expression) => forEachAlgebraNode(expression, onOperation, onExpression, state));
    }
  }
}

/** https://www.w3.org/TR/sparql11-query/#func-concat */
export function getSharedLanguageTag(terms: Term[]): string | NamedNode {
  // We check whether all values have the same language tag, if yes I return the language tag, if not I get the
  // datatype xsd_string.
  const firstElementLanguage = (terms[0] as Literal).language;
  const sharedLanguage = terms.every(
    (term) => (term as Literal).language && (term as Literal).language === firstElementLanguage
  );
  return sharedLanguage ? firstElementLanguage : DATA_TYPES.XSD_STRING;
}

/** Compatibility rules: https://www.w3.org/TR/sparql11-query/#func-arg-compatibility */
export function getMatchingDatatypeOrLanguage(
  firstvalue: Term,
  secondvalue: Term
): EvaluationError | string | NamedNode {
  if ((firstvalue as Literal).language && (secondvalue as Literal).language) {
    return (firstvalue as Literal).language === (secondvalue as Literal).language
      ? (firstvalue as Literal).language
      : ({
          evaluationResultType: "error",
          errorType: "IncompatibleLanguageOperation",
        } as EvaluationError);
  }

  // If the second term is included or it's an empty string, then we want the language tag. If not, xsd-string
  if ((firstvalue as Literal).language)
    return firstvalue.value.includes(secondvalue.value)
      ? (firstvalue as Literal).language
      : (secondvalue as Literal).datatype;

  //if the secondvalue has Literalanguage tag but not the first then we return an error.
  if ((secondvalue as Literal).language)
    return {
      evaluationResultType: "error",
      errorType: "IncompatibleLanguageOperation",
    } as EvaluationError;

  //In all other cases, we want the xsd-string datatype
  return DATA_TYPES.XSD_STRING;
}

export function changeLiteralValue(literal: Literal, value: string): Literal {
  return dataFactory.literal(value, literal.language || literal.datatype);
}

export function ValidateLiteralOrNamedNode(terms: Term[], valueType: ValidationType[][]): EvaluationError | undefined {
  if (valueType.length !== terms.length) throw Error("Arrays for validation of types have different lengths");

  for (let i = 0; i < terms.length; ++i) {
    let validationPasses = true;
    for (let validator of valueType[i]) {
      validationPasses = validator(terms[i]);
      if (validationPasses) break;
    }
    if (!validationPasses) return { evaluationResultType: "error", errorType: "InvalidArgumentTypes" };
  }
}

export function canonicalToNumber(n: string): number {
  if (n === "INF") return Infinity;
  if (n === "-INF") return -Infinity;
  return Number(n);
}

/**
 * https://www.w3.org/TR/xpath-functions/#op.numeric states the following
 *  For xs:decimal values, let N be the number of digits of precision supported by the implementation,
 *  and let M (M <= N) be the minimum limit on the number of digits required for conformance
 *  (18 digits for XSD 1.0, 16 digits for XSD 1.1).
 * @DECISION The convertion to cap the decimal to significant digits will result in a acceptable minor precision loss if more than 15 digits are
 * present as part of the fraction. We want to handle Decimal Values to not have more than 15 significant digits to prevent underflow/overflow
 */

export function decimalToRoundedString(value: number, sd: number = 16): string {
  if (value === Number.POSITIVE_INFINITY) return "INF";
  if (value === Number.NEGATIVE_INFINITY) return "-INF";
  const decimalValue = +value;
  if (!decimalValue) return decimalValue.toString();
  // We want to count the number of digits present in the given value
  const digits = Math.floor(Math.log10(decimalValue));
  const significantDigit = sd - (digits > 0 ? digits : 0);
  /**
   * Localestring removes the 'e' notation when performing the Math operations from above. Decimal parsing does not include scientific notation
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString
   * If there is a positive significant digit which means there are values after the decimal then keep the maximumFractionDigits to 1 less than allowed significant digit to handle overflow/underflow
   * This handles underflow/overflow but will result in a minor precision loss when more than 15 digits are present
   * in fractional part which is acceptable
   */
  const props =
    significantDigit > 0
      ? { useGrouping: false, maximumFractionDigits: significantDigit - 1 }
      : { useGrouping: false, maximumSignificantDigits: sd };
  return (Math.round(decimalValue * 10 ** significantDigit) / 10 ** significantDigit).toLocaleString("fullwide", props);
}

function isStringLiteral(term: Term) {
  return term.termType === "Literal" && term.datatype.value === DATA_TYPES.XSD_STRING.value;
}

function isIntegerLiteral(term: Term) {
  return term.termType === "Literal" && term.datatype.value === DATA_TYPES.XSD_INTEGER.value;
}

function isBooleanLiteral(term: Term) {
  return term.termType === "Literal" && term.datatype.value === DATA_TYPES.XSD_BOOLEAN.value;
}

function isDateTimeLiteral(term: Term) {
  return term.termType === "Literal" && term.datatype.value === DATA_TYPES.XSD_DATE_TIME.value;
}

export function isLanguageLiteral(term: Term): term is Literal<(typeof DATA_TYPE_NAME_MAPPING)["RDF_LANG_STRING"]> {
  return term.termType === "Literal" && term.datatype.value === DATA_TYPES.RDF_LANG_STRING.value;
}

function isLiteral(term: Term): term is Literal {
  return term.termType === "Literal";
}

function isNamedNode(term: Term): term is NamedNode {
  return term.termType === "NamedNode";
}

function isBlankNode(term: Term): term is BlankNode {
  return term.termType === "BlankNode";
}

export function isDerivedFromIntegerLiteral(term: Term) {
  return term.termType === "Literal" && SUB_TYPES.XSD_INTEGER.includes(term.datatype.value);
}

export function isDerivedFromStringLiteral(term: Term) {
  return term.termType === "Literal" && SUB_TYPES.XSD_STRING.includes(term.datatype.value);
}

export function isDerivedFromDecimalLiteral(term: Term) {
  return term.termType === "Literal" && SUB_TYPES.XSD_DECIMAL.includes(term.datatype.value);
}

export function isDerivedFromDateTimeLiteral(term: Term) {
  return term.termType === "Literal" && SUB_TYPES.XSD_DATE_TIME.includes(term.datatype.value);
}

export type ValidationType = (term: Term) => boolean;

export const validators = {
  literal: isLiteral,
  namedNode: isNamedNode,
  blankNode: isBlankNode,
  stringLiteral: isStringLiteral,
  integerLiteral: isIntegerLiteral,
  languageLiteral: isLanguageLiteral,
  booleanLiteral: isBooleanLiteral,
  dateTimeLiteral: isDateTimeLiteral,
  numericDatatype: isNumericDatatype,
  derivedFromIntegerLiteral: isDerivedFromIntegerLiteral,
  derivedFromStringLiteral: isDerivedFromStringLiteral,
  derivedFromDateTime: isDerivedFromDateTimeLiteral,
};

export function throwAggregateError(value: string): void {
  throw new SparqlError(
    `Syntactically invalid query: the variable ?${value} is projected from an aggregate SPARQL query, but is not used for grouping. Include ?${value} in the 'GROUP BY' to make the query valid. See https://www.w3.org/TR/sparql11-query/#aggregateRestrictions`
  );
}
