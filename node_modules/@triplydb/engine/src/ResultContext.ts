import { GraphName, Bindings, Variable } from "./constants.js";
import { SimpleTriplePattern } from "./Algebra/Operation.js";

export type ResultContexts<BindingValue> =
  | Iterable<ResultContext<BindingValue>>
  | AsyncIterable<ResultContext<BindingValue>>;

export interface ResultContextOptions<BindingValue> {
  bindings: ResultContext<BindingValue>["bindings"];
}

/**
 *  It's important that this object isn't mutated, to make sure different
 *  branches of query execution don't mess with each other.
 */
export default class ResultContext<BindingValue> {
  readonly bindings: Readonly<Bindings<BindingValue>>;

  constructor({ bindings }: ResultContextOptions<BindingValue>) {
    this.bindings = bindings;
  }

  addBindings(bindings: Bindings<BindingValue>) {
    return new ResultContext({
      bindings: { ...this.bindings, ...bindings },
    });
  }

  addBinding(variable: Variable, value: BindingValue) {
    return new ResultContext({
      bindings: { ...this.bindings, [variable]: value },
    });
  }

  removeBinding(variable: Variable) {
    const bindings = { ...this.bindings };
    delete bindings[variable];
    return new ResultContext({ bindings });
  }

  /**
   *  Extract what bindings are implied by a match for a given triple, and create
   *  a new context with those implied bindings added to the already existing ones.
   *
   *  Does not check whether anything conflicts, and instead blindly overwrites old information.
   */
  applyMatch(match: [BindingValue, BindingValue, BindingValue], triple: SimpleTriplePattern) {
    const newBindings = { ...this.bindings };
    for (let i = 0; i < 3; i++) {
      const variable = triple[i];
      if (typeof variable === "string") {
        newBindings[variable] = match[i];
      }
    }
    return new ResultContext({
      bindings: newBindings,
    });
  }
}
