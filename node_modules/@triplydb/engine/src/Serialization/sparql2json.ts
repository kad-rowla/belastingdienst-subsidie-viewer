/**
 * SPARQL Standard for serialization to json
 * https://www.w3.org/TR/2013/REC-sparql11-results-json-20130321/
 *
 */
import * as Terms from "@triplydb/data-factory/Terms.js";
import { DATA_TYPES, Bindings, Term, Variable, dataFactory } from "../constants.js";
import log from "../Debugging.js";

export type SparqlJsonIri = {
  type: "uri";
  value: string;
};
export type SparqlJsonBlankNode = {
  type: "bnode";
  value: string;
};
type SparqlJsonBaseLiteral = {
  type: "literal";
  value: string;
};
export type SparqlJsonLiteral =
  | ({
      ["xml:lang"]?: never;
    } & SparqlJsonBaseLiteral)
  | ({
      datatype: string;
      ["xml:lang"]?: never;
    } & SparqlJsonBaseLiteral)
  | ({
      datatype?: never;
      ["xml:lang"]: string;
    } & SparqlJsonBaseLiteral);

type SelectJsonHead = {
  head: {
    vars: Variable[];
    link?: string[];
  };
};
type SelectJsonResults = {
  results: {
    bindings: Array<{ [variable: Variable]: SparqlJsonIri | SparqlJsonBlankNode | SparqlJsonLiteral }> | [];
  };
};
export type SelectJson = SelectJsonHead & SelectJsonResults;
export type AskJson = { head: {}; boolean: boolean };
export type SparqlJson = SelectJson | AskJson;

type SparqlJsonTerm<T extends Term> = T extends Terms.NamedNode
  ? SparqlJsonIri
  : T extends Terms.BlankNode
  ? SparqlJsonBlankNode
  : T extends Terms.Literal
  ? SparqlJsonLiteral
  : never;

export function rdfjsTerm2sparqlJsonTerm<T extends Term>(term: T): SparqlJsonTerm<T>;
export function rdfjsTerm2sparqlJsonTerm(term: Term): SparqlJsonTerm<Term> {
  switch (term.termType) {
    case "NamedNode":
      return { type: "uri", value: term.value };
    case "BlankNode":
      return { type: "bnode", value: term.value };
    case "Literal":
      term.datatype;
      if (term.language) {
        return { type: "literal", value: term.value, "xml:lang": term.language };
      } else {
        if (term.datatype.equals(DATA_TYPES.XSD_STRING)) {
          /**
           * @DECISION For the Json serialization we are removing the datatype for string values.
           * The [SPARQL results json spec] does not specify exactly what to do in the case of returning a string
           * with a datatype of XSD_STRING:value.
           * As all other implemetations remove the datatype, we have decided to do the same.
           *
           * [SPARQL results json spec]: https://www.w3.org/TR/2013/REC-sparql11-results-json-20130321/
           */
          return { type: "literal", value: term.value };
        } else {
          return { type: "literal", value: term.value, datatype: term.datatype.value };
        }
      }
  }
}

export type BindingAsJson = { [variable: string]: SparqlJsonIri | SparqlJsonBlankNode | SparqlJsonLiteral };
export function toSparqlResults(bindingsAsRdfjs: Bindings<Term>[]): SelectJsonResults {
  /**
   * Each binding constitues a row of bound/unbound variables
   * We loop over each variable, converting only bound variables to sparqlJsonTerm
   */
  const bindingsAsJson: BindingAsJson[] = [];
  for (let binding of bindingsAsRdfjs) {
    const bindingAsJson: BindingAsJson = {};
    for (let [variable, term] of Object.entries(binding)) {
      if (!term) continue;
      const sparqlJsonTerm = rdfjsTerm2sparqlJsonTerm(term);
      bindingAsJson[variable] = sparqlJsonTerm;
    }
    bindingsAsJson.push(bindingAsJson);
  }

  log("sparql:serialize:toJsonResults", `${bindingsAsJson.length} bindings made`);
  const results: SelectJsonResults = {
    results: {
      bindings: bindingsAsJson,
    },
  };
  return results;
}

export function toSparqlHead(variables: Variable[]): SelectJsonHead {
  return {
    head: {
      vars: variables,
    },
  };
}

/** TAKE HEED: this function modifies its second argument in-place */
export function selectQuerytoSparqlJson(variables: Variable[], rows: Bindings<Term>[]) {
  /**
   * Checking here to make sure that any bound variable also appears as a variable in the Head property of the Json output.
   */
  const boundVariables: Variable[] = [];
  for (let row of rows) {
    for (let variable of Object.keys(row)) {
      if (!boundVariables.includes(variable)) boundVariables.push(variable);
      if (!variables.includes(variable))
        // this is just some variable that isn't part of the projection,
        // let's ignore it!
        delete row[variable];
    }
  }
  const unBoundVariables = variables.filter((v) => !boundVariables.includes(v));
  if (unBoundVariables.length) {
    log("sparql:serialize:toSparqlJson:warning", `Unbound variables: '${unBoundVariables}'`);
    log("sparql:serialize:toSparqlJson:success", `Bound variables: '${boundVariables}'`);
  } else {
    log("sparql:serialize:toSparqlJson:success", "All variables were bound");
  }
  const sparqlResults: SelectJson = { ...toSparqlHead(variables), ...toSparqlResults(rows) };
  return sparqlResults;
}
