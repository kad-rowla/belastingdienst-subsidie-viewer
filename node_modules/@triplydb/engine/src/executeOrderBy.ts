import { OrderBy } from "./Algebra/Operation.js";
import log from "./Debugging.js";
import { FatalError, UnsupportedError } from "./Errors.js";
import { lessThan } from "./EvaluationFunctions.js";
import { EvaluationResult } from "./EvaluationResult.js";
import { Executor } from "./Execution.js";
import { deplete } from "./Helpers.js";
import { QueryContext } from "./QueryContext.js";
import ResultContext, { ResultContexts } from "./ResultContext.js";

type SortableContext<BindingValue> = { context: ResultContext<BindingValue>; sortKey: Array<EvaluationResult> };

/**
 *  check if the expression evaluation results at index i of a and b satisfy the lessThan relation
 */
function lt<BindingValue>(a: SortableContext<BindingValue>, b: SortableContext<BindingValue>, i: number): boolean {
  // > SPARQL also fixes an order between some kinds of RDF terms that would not otherwise be ordered:
  // >  1. (Lowest) no value assigned to the variable or expression in this solution.
  // >  2. Blank nodes
  // >  3. IRIs
  // >  4. RDF literals
  // from: https://www.w3.org/TR/sparql11-query/#modOrderBy
  // @DECISION we're interpreting error values as "no value assigned to the variable or expression", so
  // they should sort first.
  if (a.sortKey[i].evaluationResultType === "error") return true;
  const comparison = lessThan(a.sortKey[i], b.sortKey[i]);
  if (comparison.evaluationResultType === "error") return false; // this means b.vals[i] was an error
  return comparison.term.value === "true";
}

/**
 *  comparator function for the in-memory sort operation
 */
function getComparator<BindingValue>(ordering: OrderBy["ordering"]) {
  return (a: SortableContext<BindingValue>, b: SortableContext<BindingValue>): 1 | 0 | -1 => {
    if (a.sortKey.length !== b.sortKey.length || a.sortKey.length !== ordering.length) {
      throw new FatalError("Expected same lengths, implementation error.");
    }
    for (const [i, { direction }] of ordering.entries()) {
      if (lt(a, b, i)) return direction === "descending" ? 1 : -1;
      if (lt(b, a, i)) return direction === "descending" ? -1 : 1;
    }
    return 0;
  };
}

/**
 * Load all results into memory and then sort them.
 */
export async function* executeOrderByInMemory<BindingValue>(
  operation: OrderBy,
  inputContexts: ResultContexts<BindingValue>,
  queryContext: QueryContext,
  executor: Executor<BindingValue>
): ResultContexts<BindingValue> {
  const allInputContexts = await deplete(
    executor.executeOperation(operation.inputOperation, inputContexts, queryContext)
  );
  yield* await orderByInMemory(operation, allInputContexts, queryContext, executor);
}

/**
 * Using `Array.sort` is not possible with async comparator functions.
 * Therefore we resolve all our expression evaluations first.
 * The resulting values will be used by the synchronous comparator.
 */
async function getSortKey<BindingValue>(
  context: ResultContext<BindingValue>,
  operation: OrderBy,
  queryContext: QueryContext,
  executor: Executor<BindingValue>
): Promise<SortableContext<BindingValue>["sortKey"]> {
  return Promise.all(
    operation.ordering.map((orderByPart) => executor.evaluateExpression(orderByPart.expression, context, queryContext))
  );
}

/**
 * Sort a bunch of ResultContexts that have already been loaded into memory.
 */
async function orderByInMemory<BindingValue>(
  operation: OrderBy,
  contexts: ResultContext<BindingValue>[],
  queryContext: QueryContext,
  executor: Executor<BindingValue>
): Promise<ResultContext<BindingValue>[]> {
  const sortableContexts: SortableContext<BindingValue>[] = await Promise.all(
    contexts.map(async (context) => ({
      context,
      sortKey: await getSortKey(context, operation, queryContext, executor),
    }))
  );
  log("sparql:sort", "Number of things that will be sorted: " + sortableContexts.length);
  return sortableContexts.sort(getComparator(operation.ordering)).map((bla) => bla.context);
}

/**
 * Implementation of ORDER BY that falls back to disk-based sorting
 * backed by gnu-sort if there are too many results to hold in memory.
 */
export async function* executeOrderByOnDisk<BindingValue>(
  operation: OrderBy,
  inputContexts: ResultContexts<BindingValue>,
  queryContext: QueryContext,
  executor: Executor<BindingValue>
): ResultContexts<BindingValue> {
  const pendingContexts = executor.executeOperation(operation.inputOperation, inputContexts, queryContext);

  let useMemory = true;
  const loadedContexts: ResultContext<BindingValue>[] = [];
  for await (const context of pendingContexts) {
    loadedContexts.push(context);
    if (loadedContexts.length >= 10_000) {
      useMemory = false;
      break;
    }
  }
  if (useMemory) {
    yield* await orderByInMemory(operation, loadedContexts, queryContext, executor);
    return;
  }

  throw new UnsupportedError("Disk-based sorting is not supported yet");
}
