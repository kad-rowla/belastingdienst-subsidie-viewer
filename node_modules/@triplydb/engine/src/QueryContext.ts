import { IDENTITY, NOTHING, Operation } from "./Algebra/Operation.js";
import { DEFAULT_BASE_IRI, RdfDataset } from "./constants.js";
import log from "./Debugging.js";
import { forEachAlgebraNode } from "./Helpers.js";
import { ResultContexts } from "./ResultContext.js";

/**
 * This context is scoped to a query. Any functions within the engine should be
 * able to access this. We should only store things that we think will persist
 * for the duration of the query. For now, we should consider the query
 * context as a read-only thing, because we haven't given thought to the
 * complications that mutating it could give.
 */
export class QueryContext {
  /**
   * The IRI() function can make use of a base IRI, to resolve relative IRI's.
   */
  public readonly baseIri: string;
  /**
   * This abort signal allows us to cancel queries (especially long-running
   * ones). It's currently checked while executing triple patterns, as those
   * should be the biggest context switch from the engine code, i.e. waiting
   * on data from disk.
   */
  public readonly abortSignal?: AbortSignal;
  public readonly now = new Date();
  public readonly counts: {
    [operationId: string]: { received: number; yielded: number } | undefined;
  } = {};
  public readonly algebra: Operation;
  public readonly disableTermValidation: boolean;
  public readonly rdfDataset: RdfDataset;

  constructor(options: QueryContextOptions) {
    this.algebra = options.algebra;
    this.baseIri = options.baseIri ?? DEFAULT_BASE_IRI;
    this.abortSignal = options?.abortSignal;
    this.disableTermValidation = !!options.disableTermValidation;
    this.rdfDataset = options.rdfDataset;
  }

  /**
   *  Keep track of the number of rows that an operation received as input, and
   *  the number of rows that the operation returned. This is done by wrapping
   *  the `resultContexts` iterators.
   */
  public countResults<BindingValue>(
    operation: Operation,
    resultContexts: ResultContexts<BindingValue>,
    execute: (resultContexts: ResultContexts<BindingValue>) => ResultContexts<BindingValue>
  ) {
    if (operation.id === undefined) {
      return execute(resultContexts);
    }
    if (operation.id === IDENTITY.id || operation.id === NOTHING.id) return execute(resultContexts);
    if (!this.counts[operation.id]) this.counts[operation.id] = { received: 0, yielded: 0 };
    const counts = this.counts[operation.id]!;
    async function* count(resultContexts: ResultContexts<BindingValue>, what: "received" | "yielded") {
      for await (const r of resultContexts) {
        counts[what]++;
        yield r;
      }
    }
    return count(execute(count(resultContexts, "received")), "yielded");
  }

  public logCounts() {
    this.mergeCountsWithAlgebra();
    log("sparql:counts", "%D", this.algebra);
  }

  public mergeCountsWithAlgebra() {
    forEachAlgebraNode(
      this.algebra,
      (operation) => {
        if (operation !== IDENTITY && operation !== NOTHING) (operation as any).counts = this.counts[operation.id!];
      },
      () => {},
      undefined
    );
    return this.algebra;
  }
}

export interface QueryContextOptions {
  algebra: Operation;
  /** defaults to `false` */
  disableTermValidation?: boolean;
  baseIri?: string;
  abortSignal?: AbortSignal;
  rdfDataset: QueryContext["rdfDataset"];
}
