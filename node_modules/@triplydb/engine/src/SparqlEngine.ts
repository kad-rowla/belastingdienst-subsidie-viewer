import { QueryEngine, fillOutTripleTemplates } from "./QueryEngine.js";
import { BgpPattern, GraphPattern, Pattern, default as sparqljs } from "sparqljs";
import { Executor, QueryOptions } from "./Execution.js";
import { DEFAULT_BASE_IRI, Term, dataFactory } from "./constants.js";
import { Store, Terms } from "@triplydb/data-factory";
import { FatalError, UnsupportedError, UpdateFailureError } from "./Errors.js";
import { templatesFromAst } from "./Algebra/ASTtoAlgebra/index.js";
import { parse } from "./Helpers.js";
import log from "./Debugging.js";
import { NamedNode } from "@triplydb/data-factory/Terms.js";

async function deleteGraph(store: Store, graph: sparqljs.IriTerm | Terms.DefaultGraph) {
  return new Promise<void>((resolve, reject) => store.deleteGraph(graph).on("end", resolve).on("error", reject));
}

type UpdateResult = typeof updateSuccess;
const updateSuccess = "success" as const;
/** This engine includes both queries and update queries */
export class SparqlEngine extends QueryEngine {
  readonly store: Store;
  constructor(executor: Executor<Term>, opts: { store: Store; optimize: boolean }) {
    super(executor, { optimize: opts.optimize });
    this.store = opts.store;
  }

  /*
   *  Note: We don't support existence of empty graphs.
   */

  // NOTE: we don't have suite tests for this engine, until #8325 is implemented.
  public async update(updateString: string, opts?: Omit<QueryOptions, "rdfDataset">): Promise<UpdateResult> {
    log("sparql:updateString", updateString);
    const update = parse(updateString, { baseIri: opts?.baseIri ?? DEFAULT_BASE_IRI });
    if (update.type !== "update")
      throw new UnsupportedError(
        `Only SPARQL UPDATE is supported using this method. For queries, you can use 'engine.query()'`
      );
    for (const op of update.updates) {
      if ("type" in op) {
        switch (op.type) {
          case "create": // https://www.w3.org/TR/sparql12-update/#create
            // > Stores that do not record empty named graphs will always return
            // > success on creation of a non-existing graph.
            if (op.silent) continue;
            if (op.graph.name && this.store.some(() => true, null, null, null, op.graph.name)) {
              throw new UpdateFailureError(
                `Cannot create the graph named "${op.graph.name.value}", because this graph already exists.`
              );
            } else continue;
          case "drop": // https://www.w3.org/TR/sparql12-update/#drop
          // The spec says:
          // > If the store records the existence of empty graphs,
          // > then the SPARQL 1.2 Update service, by default, should return failure if the specified named graph does not exist.
          // > If SILENT is present, the result of the operation will always be success.
          // Our implementation doesn't support the existence of empty graphs, thus we don't throw an error for this.
          // > Stores that do not record empty graphs will always return success.
          case "clear": // https://www.w3.org/TR/sparql12-update/#clear
            // The spec says:
            // > If the store records the existence of empty graphs, then the SPARQL 1.2
            // > Update service, by default, should return failure if the specified graph does not exist.
            // Our implementation doesn't support the existence of empty graphs, thus we don't through an error for this.
            // > Stores that do not record empty graphs will always return success.
            if (op.graph.all) this.store.removeMatches();
            if (op.graph.default) this.store.removeMatches(undefined, undefined, undefined, dataFactory.defaultGraph());
            // Be aware: if you don't use our wrapper you will not get the results expected!
            if (op.graph.name) await deleteGraph(this.store, op.graph.name);
            if (op.graph.named) {
              const promises: Promise<void>[] = [];
              this.store.forGraphs(
                (graph) => {
                  if (graph.termType === "BlankNode" || graph.termType === "Variable")
                    throw new FatalError("The graph to remove cannot be a blanknode or a variable.");
                  if (graph.termType !== "DefaultGraph") promises.push(deleteGraph(this.store, graph));
                },
                null,
                null,
                null
              );
              await Promise.all(promises);
            }

            continue;

          case "copy": {
            // https://www.w3.org/TR/sparql12-update/#copy
            // > The difference between COPY and the DROP/INSERT combination is
            // > that if COPY is used to copy a graph onto itself then no
            // > operation will be performed and the data will be left as it was.
            // > Using DROP/INSERT in this situation would result in an empty
            // > graph.
            // >
            // > If the destination graph does not exist, it will be created. By
            // > default, the service MAY return failure if the input graph does
            // > not exist. If SILENT is present, the result of the operation will
            // > always be success.
            // Our implementation doesn't support the existence of empty graphs, thus we don't through an error for this.

            if ((op.source.default && op.destination.default) || op.source.name?.equals(op.destination.name)) continue; // don't do anything
            const source = op.source.default ? dataFactory.defaultGraph() : op.source.name!;
            const destination = op.destination.default ? dataFactory.defaultGraph() : op.destination.name!;
            await deleteGraph(this.store, destination);
            this.store.addQuads(
              this.store
                .getQuads(null, null, null, source)
                .map((q) => this.store.factory.quad(q.subject, q.predicate, q.object, destination))
            );
            continue;
          }

          case "move": {
            // https://www.w3.org/TR/sparql12-update/#move
            // > By default, the service may return failure, if the input graph does not exist.
            // > If SILENT is present, the result of the operation will always be success.
            // Our implementation doesn't support the existence of empty graphs, thus we don't through an error for this.

            if ((op.source.default && op.destination.default) || op.source.name?.equals(op.destination.name)) continue; // don't do anything
            const source = op.source.default ? dataFactory.defaultGraph() : op.source.name!;
            const destination = op.destination.default ? dataFactory.defaultGraph() : op.destination.name!;
            await deleteGraph(this.store, destination);
            this.store.addQuads(
              this.store
                .getQuads(null, null, null, source)
                .map((q) => this.store.factory.quad(q.subject, q.predicate, q.object, destination))
            );
            await deleteGraph(this.store, source);

            continue; // success
          }
          case "add": {
            // https://www.w3.org/TR/sparql12-update/#add
            const source = op.source.default ? dataFactory.defaultGraph() : op.source.name!;
            const destination = op.destination.default ? dataFactory.defaultGraph() : op.destination.name!;
            this.store.addQuads(
              this.store
                .getQuads(null, null, null, source)
                .map((q) => this.store.factory.quad(q.subject, q.predicate, q.object, destination))
            );
            continue;
          }
          case "load":
            throw new UnsupportedError("The SPARQL LOAD operation is not supported.");
        }
      } else {
        if (op.graph)
          throw new UnsupportedError(
            "Toplevel GRAPH not yet supported. Please report your use-case to a Triply developer."
          );
        if ("using" in op && op.using)
          throw new UnsupportedError("USING is not yet supported. Please report your use-case to a Triply developer.");

        if (op.updateType === "deletewhere") {
          // Deletewhere has patterns in the delete property ðŸ˜¢
          op.where = op.delete.map<BgpPattern | GraphPattern>((p) =>
            p.type === "bgp" ? p : { type: "graph", name: p.name, patterns: [{ type: "bgp", triples: p.triples }] }
          );
        }

        // > This operation identifies data with the WHERE clause, which will be
        // > used to compute solution sequences of bindings for a set of
        // > variables. The bindings for each solution are then substituted into
        // > the DELETE template to remove triples, and then in the INSERT
        // > template to create new triples
        // from: https://www.w3.org/TR/sparql12-update/#deleteInsert
        const results = await this.queryAst(
          {
            queryType: "SELECT",
            prefixes: {},
            type: "query",
            variables: [new sparqljs.Wildcard()],
            where: "where" in op ? op.where : undefined,
          },
          opts
        );

        const mutableState = {
          blankNodeCounter: 0,
          hashedQuads: new Set<string>(),
        };
        for await (const bindings of results) {
          // > The deletion of the triples happens before the insertion.
          // > from: https://www.w3.org/TR/sparql12-update/#deleteInsert
          const deleteOp = "delete" in op && op.delete ? op.delete : [];
          for (const deleteInfo of deleteOp) {
            let graph: undefined | NamedNode;
            if (deleteInfo.type === "graph") {
              if (deleteInfo.name.termType === "Variable") {
                const unverifiedGraph = bindings[deleteInfo.name.value];
                // skip results if the variable used for the graph isn't bound
                // to a named node
                if (unverifiedGraph?.termType !== "NamedNode") continue;
                graph = unverifiedGraph;
              } else {
                graph = deleteInfo.name;
              }
            }
            const quads = [
              ...fillOutTripleTemplates(bindings, templatesFromAst(deleteInfo.triples), mutableState, graph),
            ];
            this.store.removeQuads(quads);
          }

          const insert = "insert" in op && op.insert ? op.insert : [];
          for (const insertInfo of insert) {
            let graph: undefined | NamedNode;
            if (insertInfo.type === "graph") {
              if (insertInfo.name.termType === "Variable") {
                const unverifiedGraph = bindings[insertInfo.name.value];
                // skip results if the variable used for the graph isn't bound
                // to a named node
                if (unverifiedGraph?.termType !== "NamedNode") continue;
                graph = unverifiedGraph;
              } else {
                graph = insertInfo.name;
              }
            }
            const quads = [
              ...fillOutTripleTemplates(bindings, templatesFromAst(insertInfo.triples), mutableState, graph),
            ];
            try {
              this.store.addQuads(quads);
            } catch (e: any) {
              // The spec says:
              // If the graph does not exist and it can not be created for any reason, then a failure must be returned.
              throw new UpdateFailureError("The graph could not be created. The reason is: " + e.message);
            }
          }
        }
      }
    }
    return updateSuccess;
  }
}
