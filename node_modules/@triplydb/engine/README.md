# What is going on?

The engine consists of the following parts:

- the engine: the big thing that sticks everything together, and is what the user will interact with. Exposes a query() method, and combines parsing, algebra translation, optimization, evaluation and results serialization.
- the algebra: a more unambiguous representation of what needs to be done. All our TypeScript types are for the algebra. Query optimization is done over the algebra.
- bindings: a collection of key-value pairs, where the keys are variables and the values are nodes in an RDF graph (i.e. IRIs, literals or blank nodes). NB: bindings are not always represented by a `Term`.
- the executor: the thing that eats algebras and spits out a sequence of bindings
- result context stuff: information that is important during execution of a query which can change during execution, e.g. we could be adding bindings during execution, or changing which graph is focussed.
- query context: The information that's scoped to the whole query, which is usually static.
- (async) generators: a javascript construct which allows us to create a sequence of elements without creating the whole sequence at once.

## Magic Prefix

To be able to change the behaviour of speedy at query execution time, we allow for magix prefixes in the query itself.

| Prefix name                    | Prefix                                         | Values            | Default       | Explanation                                                                                                                                                                                                                                |
| ------------------------------ | ---------------------------------------------- | ----------------- | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `triply_optimize`              | `https://triplydb.com/Triply/sparql/id/value/` | `true` \| `false` | it depends... | If set to `true`, the the algebra (SPARQL engine instructions) will be modified to try to reduce the query run-time.                                                                                                                       |
| `triply_disabletermvalidation` | `https://triplydb.com/Triply/sparql/id/value/` | `true` \| `false` | it depends... | Whether to skip validation of terms that come from HDT files. If set to `false`, terms from HDTs will be validated, and Speedy will throw an error when they are invalid.                                          |
| `triply_debugonly`             | `https://triplydb.com/Triply/sparql/id/value/` | `true` \| `false` | `false`       | If set to true, the query will return with debugging information after AST translation (or) optimized AST if `triply_optimize` is set. This will not execute the query and no result binding should be expected                            |
| `triply_debugoncompletion`     | `https://triplydb.com/Triply/sparql/id/value/` | `true` \| `false` | `false`       | If set to true, the query will return with debugging information after executing the query. If any error occurs, it will return debug information along with the type of error and/or partially executed Algebra before the error occured. |

Example usage within a SPARQL query:

```sparql
# The following line will enable algebra optimization for the following query.
prefix triply_optimize: <https://triplydb.com/Triply/sparql/id/value/true>

select * where {
  ?s ?p ?o .
  ?s skos:name "Bob" .
}
```

## The Algebra

The algebra consists of three kinds of things:

- Triple patterns: Triple patterns are the things that you're used to in queries, for example `?s ?p ?o` or `?s rdf:type ?type`.
- Operations: Operations are things that output a(n arbitrarily sized) sequence of bindings.
- Expressions: Expressions are things that output a single value (or an error).

Mostly an operation has other operations as "input", and mostly an expression has other expressions as "input", e.g. the `+` operator needs two expressions as input before it becomes an expression (e.g. `1` is an expression and `1 + 1` is an expression).

So you may have noticed now that a triple pattern is also an operation, because it results in a sequence of bindings!

When you're reading a sparql query, you should think of any previous lines as being the "input" to any following lines. The following example first binds `<http://example/john>` to the variable `john` and then, given that binding, finds matches for the simple triple pattern `?john foaf:knows ?jack`.

```rq
BIND(<http://example/john> as ?john)
?john foaf:knows ?jack
```

In "pseudo" algebra, this would look something like this:

```
Join:
- Extend:
    expression: <http://example/john>
    variable: john
    operation: IDENTITY  # IDENTITY is our NOOP. The sparql standard calls it `Z`
- ?john foaf:knows ?jack
```

Or maybe a more complicated example using `FILTER`:

```
?john foaf:knows ?jack
?jack foaf:knows ?john
FILTER(?john = <http://example/john>)
?jack foaf:knows <http://example/joanne>
```

Looks like this (if you very very literally follow the steps top to bottom, which isn't quite standards-compliant but let's ignore that for now):

```
Join:
  - Filter:
      expression: ?john = <http://example/john>
      operation:
        Join:
          - ?john foaf:knows ?jack
          - ?jack foaf:knows ?john
  - ?jack foaf:knows <http://example/joanne>
```
