(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _isReactNative = _interopRequireDefault(require("./isReactNative"));

var _uriToBlob = _interopRequireDefault(require("./uriToBlob"));

var _isCordova = _interopRequireDefault(require("./isCordova"));

var _readAsByteArray = _interopRequireDefault(require("./readAsByteArray"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var FileSource = /*#__PURE__*/function () {
  // Make this.size a method
  function FileSource(file) {
    _classCallCheck(this, FileSource);

    this._file = file;
    this.size = file.size;
  }

  _createClass(FileSource, [{
    key: "slice",
    value: function slice(start, end) {
      // In Apache Cordova applications, a File must be resolved using
      // FileReader instances, see
      // https://cordova.apache.org/docs/en/8.x/reference/cordova-plugin-file/index.html#read-a-file
      if ((0, _isCordova["default"])()) {
        return (0, _readAsByteArray["default"])(this._file.slice(start, end));
      }

      var value = this._file.slice(start, end);

      return Promise.resolve({
        value: value
      });
    }
  }, {
    key: "close",
    value: function close() {// Nothing to do here since we don't need to release any resources.
    }
  }]);

  return FileSource;
}();

var StreamSource = /*#__PURE__*/function () {
  function StreamSource(reader, chunkSize) {
    _classCallCheck(this, StreamSource);

    this._chunkSize = chunkSize;
    this._buffer = undefined;
    this._bufferOffset = 0;
    this._reader = reader;
    this._done = false;
  }

  _createClass(StreamSource, [{
    key: "slice",
    value: function slice(start, end) {
      if (start < this._bufferOffset) {
        return Promise.reject(new Error("Requested data is before the reader's current offset"));
      }

      return this._readUntilEnoughDataOrDone(start, end);
    }
  }, {
    key: "_readUntilEnoughDataOrDone",
    value: function _readUntilEnoughDataOrDone(start, end) {
      var _this = this;

      var hasEnoughData = end <= this._bufferOffset + len(this._buffer);

      if (this._done || hasEnoughData) {
        var value = this._getDataFromBuffer(start, end);

        var done = value == null ? this._done : false;
        return Promise.resolve({
          value: value,
          done: done
        });
      }

      return this._reader.read().then(function (_ref) {
        var value = _ref.value,
            done = _ref.done;

        if (done) {
          _this._done = true;
        } else if (_this._buffer === undefined) {
          _this._buffer = value;
        } else {
          _this._buffer = concat(_this._buffer, value);
        }

        return _this._readUntilEnoughDataOrDone(start, end);
      });
    }
  }, {
    key: "_getDataFromBuffer",
    value: function _getDataFromBuffer(start, end) {
      // Remove data from buffer before `start`.
      // Data might be reread from the buffer if an upload fails, so we can only
      // safely delete data when it comes *before* what is currently being read.
      if (start > this._bufferOffset) {
        this._buffer = this._buffer.slice(start - this._bufferOffset);
        this._bufferOffset = start;
      } // If the buffer is empty after removing old data, all data has been read.


      var hasAllDataBeenRead = len(this._buffer) === 0;

      if (this._done && hasAllDataBeenRead) {
        return null;
      } // We already removed data before `start`, so we just return the first
      // chunk from the buffer.


      return this._buffer.slice(0, end - start);
    }
  }, {
    key: "close",
    value: function close() {
      if (this._reader.cancel) {
        this._reader.cancel();
      }
    }
  }]);

  return StreamSource;
}();

function len(blobOrArray) {
  if (blobOrArray === undefined) return 0;
  if (blobOrArray.size !== undefined) return blobOrArray.size;
  return blobOrArray.length;
}
/*
  Typed arrays and blobs don't have a concat method.
  This function helps StreamSource accumulate data to reach chunkSize.
*/


function concat(a, b) {
  if (a.concat) {
    // Is `a` an Array?
    return a.concat(b);
  }

  if (a instanceof Blob) {
    return new Blob([a, b], {
      type: a.type
    });
  }

  if (a.set) {
    // Is `a` a typed array?
    var c = new a.constructor(a.length + b.length);
    c.set(a);
    c.set(b, a.length);
    return c;
  }

  throw new Error('Unknown data type');
}

var FileReader = /*#__PURE__*/function () {
  function FileReader() {
    _classCallCheck(this, FileReader);
  }

  _createClass(FileReader, [{
    key: "openFile",
    value: function openFile(input, chunkSize) {
      // In React Native, when user selects a file, instead of a File or Blob,
      // you usually get a file object {} with a uri property that contains
      // a local path to the file. We use XMLHttpRequest to fetch
      // the file blob, before uploading with tus.
      if ((0, _isReactNative["default"])() && input && typeof input.uri !== 'undefined') {
        return (0, _uriToBlob["default"])(input.uri).then(function (blob) {
          return new FileSource(blob);
        })["catch"](function (err) {
          throw new Error("tus: cannot fetch `file.uri` as Blob, make sure the uri is correct and accessible. ".concat(err));
        });
      } // Since we emulate the Blob type in our tests (not all target browsers
      // support it), we cannot use `instanceof` for testing whether the input value
      // can be handled. Instead, we simply check is the slice() function and the
      // size property are available.


      if (typeof input.slice === 'function' && typeof input.size !== 'undefined') {
        return Promise.resolve(new FileSource(input));
      }

      if (typeof input.read === 'function') {
        chunkSize = +chunkSize;

        if (!isFinite(chunkSize)) {
          return Promise.reject(new Error('cannot create source for stream without a finite value for the `chunkSize` option'));
        }

        return Promise.resolve(new StreamSource(input, chunkSize));
      }

      return Promise.reject(new Error('source object may only be an instance of File, Blob, or Reader in this environment'));
    }
  }]);

  return FileReader;
}();

exports["default"] = FileReader;

},{"./isCordova":5,"./isReactNative":6,"./readAsByteArray":7,"./uriToBlob":8}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = fingerprint;

var _isReactNative = _interopRequireDefault(require("./isReactNative"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // TODO: Differenciate between input types

/**
 * Generate a fingerprint for a file which will be used the store the endpoint
 *
 * @param {File} file
 * @param {Object} options
 * @param {Function} callback
 */


function fingerprint(file, options) {
  if ((0, _isReactNative["default"])()) {
    return Promise.resolve(reactNativeFingerprint(file, options));
  }

  return Promise.resolve(['tus-br', file.name, file.type, file.size, file.lastModified, options.endpoint].join('-'));
}

function reactNativeFingerprint(file, options) {
  var exifHash = file.exif ? hashCode(JSON.stringify(file.exif)) : 'noexif';
  return ['tus-rn', file.name || 'noname', file.size || 'nosize', exifHash, options.endpoint].join('/');
}

function hashCode(str) {
  // from https://stackoverflow.com/a/8831937/151666
  var hash = 0;

  if (str.length === 0) {
    return hash;
  }

  for (var i = 0; i < str.length; i++) {
    var _char = str.charCodeAt(i);

    hash = (hash << 5) - hash + _char;
    hash &= hash; // Convert to 32bit integer
  }

  return hash;
}

},{"./isReactNative":6}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* global window */


var XHRHttpStack = /*#__PURE__*/function () {
  function XHRHttpStack() {
    _classCallCheck(this, XHRHttpStack);
  }

  _createClass(XHRHttpStack, [{
    key: "createRequest",
    value: function createRequest(method, url) {
      return new Request(method, url);
    }
  }, {
    key: "getName",
    value: function getName() {
      return 'XHRHttpStack';
    }
  }]);

  return XHRHttpStack;
}();

exports["default"] = XHRHttpStack;

var Request = /*#__PURE__*/function () {
  function Request(method, url) {
    _classCallCheck(this, Request);

    this._xhr = new XMLHttpRequest();

    this._xhr.open(method, url, true);

    this._method = method;
    this._url = url;
    this._headers = {};
  }

  _createClass(Request, [{
    key: "getMethod",
    value: function getMethod() {
      return this._method;
    }
  }, {
    key: "getURL",
    value: function getURL() {
      return this._url;
    }
  }, {
    key: "setHeader",
    value: function setHeader(header, value) {
      this._xhr.setRequestHeader(header, value);

      this._headers[header] = value;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this._headers[header];
    }
  }, {
    key: "setProgressHandler",
    value: function setProgressHandler(progressHandler) {
      // Test support for progress events before attaching an event listener
      if (!('upload' in this._xhr)) {
        return;
      }

      this._xhr.upload.onprogress = function (e) {
        if (!e.lengthComputable) {
          return;
        }

        progressHandler(e.loaded);
      };
    }
  }, {
    key: "send",
    value: function send() {
      var _this = this;

      var body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      return new Promise(function (resolve, reject) {
        _this._xhr.onload = function () {
          resolve(new Response(_this._xhr));
        };

        _this._xhr.onerror = function (err) {
          reject(err);
        };

        _this._xhr.send(body);
      });
    }
  }, {
    key: "abort",
    value: function abort() {
      this._xhr.abort();

      return Promise.resolve();
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      return this._xhr;
    }
  }]);

  return Request;
}();

var Response = /*#__PURE__*/function () {
  function Response(xhr) {
    _classCallCheck(this, Response);

    this._xhr = xhr;
  }

  _createClass(Response, [{
    key: "getStatus",
    value: function getStatus() {
      return this._xhr.status;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this._xhr.getResponseHeader(header);
    }
  }, {
    key: "getBody",
    value: function getBody() {
      return this._xhr.responseText;
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      return this._xhr;
    }
  }]);

  return Response;
}();

},{}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "enableDebugLog", {
  enumerable: true,
  get: function get() {
    return _logger.enableDebugLog;
  }
});
Object.defineProperty(exports, "canStoreURLs", {
  enumerable: true,
  get: function get() {
    return _urlStorage.canStoreURLs;
  }
});
Object.defineProperty(exports, "HttpStack", {
  enumerable: true,
  get: function get() {
    return _httpStack["default"];
  }
});
exports.isSupported = exports.defaultOptions = exports.Upload = void 0;

var _upload = _interopRequireDefault(require("../upload"));

var _noopUrlStorage = _interopRequireDefault(require("../noopUrlStorage"));

var _logger = require("../logger");

var _urlStorage = require("./urlStorage");

var _httpStack = _interopRequireDefault(require("./httpStack"));

var _fileReader = _interopRequireDefault(require("./fileReader"));

var _fingerprint = _interopRequireDefault(require("./fingerprint"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
/* global window */


var defaultOptions = _objectSpread(_objectSpread({}, _upload["default"].defaultOptions), {}, {
  httpStack: new _httpStack["default"](),
  fileReader: new _fileReader["default"](),
  urlStorage: _urlStorage.canStoreURLs ? new _urlStorage.WebStorageUrlStorage() : new _noopUrlStorage["default"](),
  fingerprint: _fingerprint["default"]
});

exports.defaultOptions = defaultOptions;

var Upload = /*#__PURE__*/function (_BaseUpload) {
  _inherits(Upload, _BaseUpload);

  var _super = _createSuper(Upload);

  function Upload() {
    var file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Upload);

    options = _objectSpread(_objectSpread({}, defaultOptions), options);
    return _super.call(this, file, options);
  }

  _createClass(Upload, null, [{
    key: "terminate",
    value: function terminate(url, options, cb) {
      options = _objectSpread(_objectSpread({}, defaultOptions), options);
      return _upload["default"].terminate(url, options, cb);
    }
  }]);

  return Upload;
}(_upload["default"]);

exports.Upload = Upload;
var _window = window,
    XMLHttpRequest = _window.XMLHttpRequest,
    Blob = _window.Blob;
var isSupported = XMLHttpRequest && Blob && typeof Blob.prototype.slice === 'function';
exports.isSupported = isSupported;

},{"../logger":11,"../noopUrlStorage":12,"../upload":13,"./fileReader":1,"./fingerprint":2,"./httpStack":3,"./urlStorage":9}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var isCordova = function isCordova() {
  return typeof window != 'undefined' && (typeof window.PhoneGap != 'undefined' || typeof window.Cordova != 'undefined' || typeof window.cordova != 'undefined');
};

var _default = isCordova;
exports["default"] = _default;

},{}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var isReactNative = function isReactNative() {
  return typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative';
};

var _default = isReactNative;
exports["default"] = _default;

},{}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = readAsByteArray;
/**
 * readAsByteArray converts a File object to a Uint8Array.
 * This function is only used on the Apache Cordova platform.
 * See https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-file/index.html#read-a-file
 */

function readAsByteArray(chunk) {
  return new Promise(function (resolve, reject) {
    var reader = new FileReader();

    reader.onload = function () {
      var value = new Uint8Array(reader.result);
      resolve({
        value: value
      });
    };

    reader.onerror = function (err) {
      reject(err);
    };

    reader.readAsArrayBuffer(chunk);
  });
}

},{}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = uriToBlob;
/**
 * uriToBlob resolves a URI to a Blob object. This is used for
 * React Native to retrieve a file (identified by a file://
 * URI) as a blob.
 */

function uriToBlob(uri) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.responseType = 'blob';

    xhr.onload = function () {
      var blob = xhr.response;
      resolve(blob);
    };

    xhr.onerror = function (err) {
      reject(err);
    };

    xhr.open('GET', uri);
    xhr.send();
  });
}

},{}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebStorageUrlStorage = exports.canStoreURLs = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* global window, localStorage */


var hasStorage = false;

try {
  hasStorage = 'localStorage' in window; // Attempt to store and read entries from the local storage to detect Private
  // Mode on Safari on iOS (see #49)

  var key = 'tusSupport';
  localStorage.setItem(key, localStorage.getItem(key));
} catch (e) {
  // If we try to access localStorage inside a sandboxed iframe, a SecurityError
  // is thrown. When in private mode on iOS Safari, a QuotaExceededError is
  // thrown (see #49)
  if (e.code === e.SECURITY_ERR || e.code === e.QUOTA_EXCEEDED_ERR) {
    hasStorage = false;
  } else {
    throw e;
  }
}

var canStoreURLs = hasStorage;
exports.canStoreURLs = canStoreURLs;

var WebStorageUrlStorage = /*#__PURE__*/function () {
  function WebStorageUrlStorage() {
    _classCallCheck(this, WebStorageUrlStorage);
  }

  _createClass(WebStorageUrlStorage, [{
    key: "findAllUploads",
    value: function findAllUploads() {
      var results = this._findEntries('tus::');

      return Promise.resolve(results);
    }
  }, {
    key: "findUploadsByFingerprint",
    value: function findUploadsByFingerprint(fingerprint) {
      var results = this._findEntries("tus::".concat(fingerprint, "::"));

      return Promise.resolve(results);
    }
  }, {
    key: "removeUpload",
    value: function removeUpload(urlStorageKey) {
      localStorage.removeItem(urlStorageKey);
      return Promise.resolve();
    }
  }, {
    key: "addUpload",
    value: function addUpload(fingerprint, upload) {
      var id = Math.round(Math.random() * 1e12);
      var key = "tus::".concat(fingerprint, "::").concat(id);
      localStorage.setItem(key, JSON.stringify(upload));
      return Promise.resolve(key);
    }
  }, {
    key: "_findEntries",
    value: function _findEntries(prefix) {
      var results = [];

      for (var i = 0; i < localStorage.length; i++) {
        var _key = localStorage.key(i);

        if (_key.indexOf(prefix) !== 0) continue;

        try {
          var upload = JSON.parse(localStorage.getItem(_key));
          upload.urlStorageKey = _key;
          results.push(upload);
        } catch (e) {// The JSON parse error is intentionally ignored here, so a malformed
          // entry in the storage cannot prevent an upload.
        }
      }

      return results;
    }
  }]);

  return WebStorageUrlStorage;
}();

exports.WebStorageUrlStorage = WebStorageUrlStorage;

},{}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

var DetailedError = /*#__PURE__*/function (_Error) {
  _inherits(DetailedError, _Error);

  var _super = _createSuper(DetailedError);

  function DetailedError(message) {
    var _this;

    var causingErr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var req = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var res = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    _classCallCheck(this, DetailedError);

    _this = _super.call(this, message);
    _this.originalRequest = req;
    _this.originalResponse = res;
    _this.causingError = causingErr;

    if (causingErr != null) {
      message += ", caused by ".concat(causingErr.toString());
    }

    if (req != null) {
      var requestId = req.getHeader('X-Request-ID') || 'n/a';
      var method = req.getMethod();
      var url = req.getURL();
      var status = res ? res.getStatus() : 'n/a';
      var body = res ? res.getBody() || '' : 'n/a';
      message += ", originated from request (method: ".concat(method, ", url: ").concat(url, ", response code: ").concat(status, ", response text: ").concat(body, ", request id: ").concat(requestId, ")");
    }

    _this.message = message;
    return _this;
  }

  return DetailedError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var _default = DetailedError;
exports["default"] = _default;

},{}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.enableDebugLog = enableDebugLog;
exports.log = log;
/* eslint no-console: "off" */

var isEnabled = false;

function enableDebugLog() {
  isEnabled = true;
}

function log(msg) {
  if (!isEnabled) return;
  console.log(msg);
}

},{}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* eslint no-unused-vars: "off" */


var NoopUrlStorage = /*#__PURE__*/function () {
  function NoopUrlStorage() {
    _classCallCheck(this, NoopUrlStorage);
  }

  _createClass(NoopUrlStorage, [{
    key: "listAllUploads",
    value: function listAllUploads() {
      return Promise.resolve([]);
    }
  }, {
    key: "findUploadsByFingerprint",
    value: function findUploadsByFingerprint(fingerprint) {
      return Promise.resolve([]);
    }
  }, {
    key: "removeUpload",
    value: function removeUpload(urlStorageKey) {
      return Promise.resolve();
    }
  }, {
    key: "addUpload",
    value: function addUpload(fingerprint, upload) {
      return Promise.resolve(null);
    }
  }]);

  return NoopUrlStorage;
}();

exports["default"] = NoopUrlStorage;

},{}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jsBase = require("js-base64");

var _urlParse = _interopRequireDefault(require("url-parse"));

var _error = _interopRequireDefault(require("./error"));

var _logger = require("./logger");

var _uuid = _interopRequireDefault(require("./uuid"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* global window */


var defaultOptions = {
  endpoint: null,
  uploadUrl: null,
  metadata: {},
  fingerprint: null,
  uploadSize: null,
  onProgress: null,
  onChunkComplete: null,
  onSuccess: null,
  onError: null,
  _onUploadUrlAvailable: null,
  overridePatchMethod: false,
  headers: {},
  addRequestId: false,
  onBeforeRequest: null,
  onAfterResponse: null,
  onShouldRetry: null,
  chunkSize: Infinity,
  retryDelays: [0, 1000, 3000, 5000],
  parallelUploads: 1,
  storeFingerprintForResuming: true,
  removeFingerprintOnSuccess: false,
  uploadLengthDeferred: false,
  uploadDataDuringCreation: false,
  urlStorage: null,
  fileReader: null,
  httpStack: null
};

var BaseUpload = /*#__PURE__*/function () {
  function BaseUpload(file, options) {
    _classCallCheck(this, BaseUpload); // Warn about removed options from previous versions


    if ('resume' in options) {
      console.log('tus: The `resume` option has been removed in tus-js-client v2. Please use the URL storage API instead.'); // eslint-disable-line no-console
    } // The default options will already be added from the wrapper classes.


    this.options = options; // The storage module used to store URLs

    this._urlStorage = this.options.urlStorage; // The underlying File/Blob object

    this.file = file; // The URL against which the file will be uploaded

    this.url = null; // The underlying request object for the current PATCH request

    this._req = null; // The fingerpinrt for the current file (set after start())

    this._fingerprint = null; // The key that the URL storage returned when saving an URL with a fingerprint,

    this._urlStorageKey = null; // The offset used in the current PATCH request

    this._offset = null; // True if the current PATCH request has been aborted

    this._aborted = false; // The file's size in bytes

    this._size = null; // The Source object which will wrap around the given file and provides us
    // with a unified interface for getting its size and slice chunks from its
    // content allowing us to easily handle Files, Blobs, Buffers and Streams.

    this._source = null; // The current count of attempts which have been made. Zero indicates none.

    this._retryAttempt = 0; // The timeout's ID which is used to delay the next retry

    this._retryTimeout = null; // The offset of the remote upload before the latest attempt was started.

    this._offsetBeforeRetry = 0; // An array of BaseUpload instances which are used for uploading the different
    // parts, if the parallelUploads option is used.

    this._parallelUploads = null; // An array of upload URLs which are used for uploading the different
    // parts, if the parallelUploads option is used.

    this._parallelUploadUrls = null;
  }
  /**
   * Use the Termination extension to delete an upload from the server by sending a DELETE
   * request to the specified upload URL. This is only possible if the server supports the
   * Termination extension. If the `options.retryDelays` property is set, the method will
   * also retry if an error ocurrs.
   *
   * @param {String} url The upload's URL which will be terminated.
   * @param {object} options Optional options for influencing HTTP requests.
   * @return {Promise} The Promise will be resolved/rejected when the requests finish.
   */


  _createClass(BaseUpload, [{
    key: "findPreviousUploads",
    value: function findPreviousUploads() {
      var _this = this;

      return this.options.fingerprint(this.file, this.options).then(function (fingerprint) {
        return _this._urlStorage.findUploadsByFingerprint(fingerprint);
      });
    }
  }, {
    key: "resumeFromPreviousUpload",
    value: function resumeFromPreviousUpload(previousUpload) {
      this.url = previousUpload.uploadUrl || null;
      this._parallelUploadUrls = previousUpload.parallelUploadUrls || null;
      this._urlStorageKey = previousUpload.urlStorageKey;
    }
  }, {
    key: "start",
    value: function start() {
      var _this2 = this;

      var file = this.file;

      if (!file) {
        this._emitError(new Error('tus: no file or stream to upload provided'));

        return;
      }

      if (!this.options.endpoint && !this.options.uploadUrl) {
        this._emitError(new Error('tus: neither an endpoint or an upload URL is provided'));

        return;
      }

      var retryDelays = this.options.retryDelays;

      if (retryDelays != null && Object.prototype.toString.call(retryDelays) !== '[object Array]') {
        this._emitError(new Error('tus: the `retryDelays` option must either be an array or null'));

        return;
      }

      if (this.options.parallelUploads > 1) {
        // Test which options are incompatible with parallel uploads.
        ['uploadUrl', 'uploadSize', 'uploadLengthDeferred'].forEach(function (optionName) {
          if (_this2.options[optionName]) {
            _this2._emitError(new Error("tus: cannot use the ".concat(optionName, " option when parallelUploads is enabled")));
          }
        });
      }

      this.options.fingerprint(file, this.options).then(function (fingerprint) {
        if (fingerprint == null) {
          (0, _logger.log)('No fingerprint was calculated meaning that the upload cannot be stored in the URL storage.');
        } else {
          (0, _logger.log)("Calculated fingerprint: ".concat(fingerprint));
        }

        _this2._fingerprint = fingerprint;

        if (_this2._source) {
          return _this2._source;
        }

        return _this2.options.fileReader.openFile(file, _this2.options.chunkSize);
      }).then(function (source) {
        _this2._source = source; // If the upload was configured to use multiple requests or if we resume from
        // an upload which used multiple requests, we start a parallel upload.

        if (_this2.options.parallelUploads > 1 || _this2._parallelUploadUrls != null) {
          _this2._startParallelUpload();
        } else {
          _this2._startSingleUpload();
        }
      })["catch"](function (err) {
        _this2._emitError(err);
      });
    }
    /**
     * Initiate the uploading procedure for a parallelized upload, where one file is split into
     * multiple request which are run in parallel.
     *
     * @api private
     */

  }, {
    key: "_startParallelUpload",
    value: function _startParallelUpload() {
      var _this3 = this;

      var totalSize = this._size = this._source.size;
      var totalProgress = 0;
      this._parallelUploads = [];
      var partCount = this._parallelUploadUrls != null ? this._parallelUploadUrls.length : this.options.parallelUploads; // The input file will be split into multiple slices which are uploaded in separate
      // requests. Here we generate the start and end position for the slices.

      var parts = splitSizeIntoParts(this._source.size, partCount, this._parallelUploadUrls); // Create an empty list for storing the upload URLs

      this._parallelUploadUrls = new Array(parts.length); // Generate a promise for each slice that will be resolve if the respective
      // upload is completed.

      var uploads = parts.map(function (part, index) {
        var lastPartProgress = 0;
        return _this3._source.slice(part.start, part.end).then(function (_ref) {
          var value = _ref.value;
          return new Promise(function (resolve, reject) {
            // Merge with the user supplied options but overwrite some values.
            var options = _objectSpread(_objectSpread({}, _this3.options), {}, {
              // If available, the partial upload should be resumed from a previous URL.
              uploadUrl: part.uploadUrl || null,
              // We take manually care of resuming for partial uploads, so they should
              // not be stored in the URL storage.
              storeFingerprintForResuming: false,
              removeFingerprintOnSuccess: false,
              // Reset the parallelUploads option to not cause recursion.
              parallelUploads: 1,
              metadata: {},
              // Add the header to indicate the this is a partial upload.
              headers: _objectSpread(_objectSpread({}, _this3.options.headers), {}, {
                'Upload-Concat': 'partial'
              }),
              // Reject or resolve the promise if the upload errors or completes.
              onSuccess: resolve,
              onError: reject,
              // Based in the progress for this partial upload, calculate the progress
              // for the entire final upload.
              onProgress: function onProgress(newPartProgress) {
                totalProgress = totalProgress - lastPartProgress + newPartProgress;
                lastPartProgress = newPartProgress;

                _this3._emitProgress(totalProgress, totalSize);
              },
              // Wait until every partial upload has an upload URL, so we can add
              // them to the URL storage.
              _onUploadUrlAvailable: function _onUploadUrlAvailable() {
                _this3._parallelUploadUrls[index] = upload.url; // Test if all uploads have received an URL

                if (_this3._parallelUploadUrls.filter(function (u) {
                  return !!u;
                }).length === parts.length) {
                  _this3._saveUploadInUrlStorage();
                }
              }
            });

            var upload = new BaseUpload(value, options);
            upload.start(); // Store the upload in an array, so we can later abort them if necessary.

            _this3._parallelUploads.push(upload);
          });
        });
      });
      var req; // Wait until all partial uploads are finished and we can send the POST request for
      // creating the final upload.

      Promise.all(uploads).then(function () {
        req = _this3._openRequest('POST', _this3.options.endpoint);
        req.setHeader('Upload-Concat', "final;".concat(_this3._parallelUploadUrls.join(' '))); // Add metadata if values have been added

        var metadata = encodeMetadata(_this3.options.metadata);

        if (metadata !== '') {
          req.setHeader('Upload-Metadata', metadata);
        }

        return _this3._sendRequest(req, null);
      }).then(function (res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this3._emitHttpError(req, res, 'tus: unexpected response while creating upload');

          return;
        }

        var location = res.getHeader('Location');

        if (location == null) {
          _this3._emitHttpError(req, res, 'tus: invalid or missing Location header');

          return;
        }

        _this3.url = resolveUrl(_this3.options.endpoint, location);
        (0, _logger.log)("Created upload at ".concat(_this3.url));

        _this3._emitSuccess();
      })["catch"](function (err) {
        _this3._emitError(err);
      });
    }
    /**
     * Initiate the uploading procedure for a non-parallel upload. Here the entire file is
     * uploaded in a sequential matter.
     *
     * @api private
     */

  }, {
    key: "_startSingleUpload",
    value: function _startSingleUpload() {
      // First, we look at the uploadLengthDeferred option.
      // Next, we check if the caller has supplied a manual upload size.
      // Finally, we try to use the calculated size from the source object.
      if (this.options.uploadLengthDeferred) {
        this._size = null;
      } else if (this.options.uploadSize != null) {
        this._size = +this.options.uploadSize;

        if (isNaN(this._size)) {
          this._emitError(new Error('tus: cannot convert `uploadSize` option into a number'));

          return;
        }
      } else {
        this._size = this._source.size;

        if (this._size == null) {
          this._emitError(new Error("tus: cannot automatically derive upload's size from input and must be specified manually using the `uploadSize` option"));

          return;
        }
      } // Reset the aborted flag when the upload is started or else the
      // _performUpload will stop before sending a request if the upload has been
      // aborted previously.


      this._aborted = false; // The upload had been started previously and we should reuse this URL.

      if (this.url != null) {
        (0, _logger.log)("Resuming upload from previous URL: ".concat(this.url));

        this._resumeUpload();

        return;
      } // A URL has manually been specified, so we try to resume


      if (this.options.uploadUrl != null) {
        (0, _logger.log)("Resuming upload from provided URL: ".concat(this.options.url));
        this.url = this.options.uploadUrl;

        this._resumeUpload();

        return;
      } // An upload has not started for the file yet, so we start a new one


      (0, _logger.log)('Creating a new upload');

      this._createUpload();
    }
    /**
     * Abort any running request and stop the current upload. After abort is called, no event
     * handler will be invoked anymore. You can use the `start` method to resume the upload
     * again.
     * If `shouldTerminate` is true, the `terminate` function will be called to remove the
     * current upload from the server.
     *
     * @param {boolean} shouldTerminate True if the upload should be deleted from the server.
     * @return {Promise} The Promise will be resolved/rejected when the requests finish.
     */

  }, {
    key: "abort",
    value: function abort(shouldTerminate) {
      var _this4 = this; // Count the number of arguments to see if a callback is being provided in the old style required by tus-js-client 1.x, then throw an error if it is.
      // `arguments` is a JavaScript built-in variable that contains all of the function's arguments.


      if (arguments.length > 1 && typeof arguments[1] === 'function') {
        throw new Error('tus: the abort function does not accept a callback since v2 anymore; please use the returned Promise instead');
      } // Stop any parallel partial uploads, that have been started in _startParallelUploads.


      if (this._parallelUploads != null) {
        this._parallelUploads.forEach(function (upload) {
          upload.abort(shouldTerminate);
        });
      } // Stop any current running request.


      if (this._req !== null) {
        this._req.abort();

        this._source.close();
      }

      this._aborted = true; // Stop any timeout used for initiating a retry.

      if (this._retryTimeout != null) {
        clearTimeout(this._retryTimeout);
        this._retryTimeout = null;
      }

      if (!shouldTerminate || this.url == null) {
        return Promise.resolve();
      }

      return BaseUpload.terminate(this.url, this.options) // Remove entry from the URL storage since the upload URL is no longer valid.
      .then(function () {
        return _this4._removeFromUrlStorage();
      });
    }
  }, {
    key: "_emitHttpError",
    value: function _emitHttpError(req, res, message, causingErr) {
      this._emitError(new _error["default"](message, causingErr, req, res));
    }
  }, {
    key: "_emitError",
    value: function _emitError(err) {
      var _this5 = this; // Do not emit errors, e.g. from aborted HTTP requests, if the upload has been stopped.


      if (this._aborted) return; // Check if we should retry, when enabled, before sending the error to the user.

      if (this.options.retryDelays != null) {
        // We will reset the attempt counter if
        // - we were already able to connect to the server (offset != null) and
        // - we were able to upload a small chunk of data to the server
        var shouldResetDelays = this._offset != null && this._offset > this._offsetBeforeRetry;

        if (shouldResetDelays) {
          this._retryAttempt = 0;
        }

        if (shouldRetry(err, this._retryAttempt, this.options)) {
          var delay = this.options.retryDelays[this._retryAttempt++];
          this._offsetBeforeRetry = this._offset;
          this._retryTimeout = setTimeout(function () {
            _this5.start();
          }, delay);
          return;
        }
      }

      if (typeof this.options.onError === 'function') {
        this.options.onError(err);
      } else {
        throw err;
      }
    }
    /**
     * Publishes notification if the upload has been successfully completed.
     *
     * @api private
     */

  }, {
    key: "_emitSuccess",
    value: function _emitSuccess(data) {
      if (this.options.removeFingerprintOnSuccess) {
        // Remove stored fingerprint and corresponding endpoint. This causes
        // new uploads of the same file to be treated as a different file.
        this._removeFromUrlStorage();
      }

      if (typeof this.options.onSuccess === 'function') {
        this.options.onSuccess(data);
      }
    }
    /**
     * Publishes notification when data has been sent to the server. This
     * data may not have been accepted by the server yet.
     *
     * @param {number} bytesSent  Number of bytes sent to the server.
     * @param {number} bytesTotal Total number of bytes to be sent to the server.
     * @api private
     */

  }, {
    key: "_emitProgress",
    value: function _emitProgress(bytesSent, bytesTotal) {
      if (typeof this.options.onProgress === 'function') {
        this.options.onProgress(bytesSent, bytesTotal);
      }
    }
    /**
     * Publishes notification when a chunk of data has been sent to the server
     * and accepted by the server.
     * @param {number} chunkSize  Size of the chunk that was accepted by the server.
     * @param {number} bytesAccepted Total number of bytes that have been
     *                                accepted by the server.
     * @param {number} bytesTotal Total number of bytes to be sent to the server.
     * @api private
     */

  }, {
    key: "_emitChunkComplete",
    value: function _emitChunkComplete(chunkSize, bytesAccepted, bytesTotal) {
      if (typeof this.options.onChunkComplete === 'function') {
        this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal);
      }
    }
    /**
     * Create a new upload using the creation extension by sending a POST
     * request to the endpoint. After successful creation the file will be
     * uploaded
     *
     * @api private
     */

  }, {
    key: "_createUpload",
    value: function _createUpload() {
      var _this6 = this;

      if (!this.options.endpoint) {
        this._emitError(new Error('tus: unable to create upload because no endpoint is provided'));

        return;
      }

      var req = this._openRequest('POST', this.options.endpoint);

      if (this.options.uploadLengthDeferred) {
        req.setHeader('Upload-Defer-Length', 1);
      } else {
        req.setHeader('Upload-Length', this._size);
      } // Add metadata if values have been added


      var metadata = encodeMetadata(this.options.metadata);

      if (metadata !== '') {
        req.setHeader('Upload-Metadata', metadata);
      }

      var promise;

      if (this.options.uploadDataDuringCreation && !this.options.uploadLengthDeferred) {
        this._offset = 0;
        promise = this._addChunkToRequest(req);
      } else {
        promise = this._sendRequest(req, null);
      }

      promise.then(function (res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this6._emitHttpError(req, res, 'tus: unexpected response while creating upload');

          return;
        }

        var location = res.getHeader('Location');

        if (location == null) {
          _this6._emitHttpError(req, res, 'tus: invalid or missing Location header');

          return;
        }

        if (_this6.options.mapUrl) {
          _this6.url = _this6.options.mapUrl(resolveUrl(_this6.options.endpoint, location));
        } else {
          _this6.url = resolveUrl(_this6.options.endpoint, location);
        }

        (0, _logger.log)("Created upload at ".concat(_this6.url));

        if (typeof _this6.options._onUploadUrlAvailable === 'function') {
          _this6.options._onUploadUrlAvailable();
        }

        if (_this6._size === 0) {
          // Nothing to upload and file was successfully created
          _this6._emitSuccess(res.getBody());

          _this6._source.close();

          return;
        }

        _this6._saveUploadInUrlStorage();

        if (_this6.options.uploadDataDuringCreation) {
          _this6._handleUploadResponse(req, res);
        } else {
          _this6._offset = 0;

          _this6._performUpload();
        }
      })["catch"](function (err) {
        _this6._emitHttpError(req, null, 'tus: failed to create upload', err);
      });
    }
    /*
     * Try to resume an existing upload. First a HEAD request will be sent
     * to retrieve the offset. If the request fails a new upload will be
     * created. In the case of a successful response the file will be uploaded.
     *
     * @api private
     */

  }, {
    key: "_resumeUpload",
    value: function _resumeUpload() {
      var _this7 = this;

      var req = this._openRequest('HEAD', this.url);

      var promise = this._sendRequest(req, null);

      promise.then(function (res) {
        var status = res.getStatus();

        if (!inStatusCategory(status, 200)) {
          if (inStatusCategory(status, 400)) {
            // Remove stored fingerprint and corresponding endpoint,
            // on client errors since the file can not be found
            _this7._removeFromUrlStorage();
          } // If the upload is locked (indicated by the 423 Locked status code), we
          // emit an error instead of directly starting a new upload. This way the
          // retry logic can catch the error and will retry the upload. An upload
          // is usually locked for a short period of time and will be available
          // afterwards.


          if (status === 423) {
            _this7._emitHttpError(req, res, 'tus: upload is currently locked; retry later');

            return;
          }

          if (!_this7.options.endpoint) {
            // Don't attempt to create a new upload if no endpoint is provided.
            _this7._emitHttpError(req, res, 'tus: unable to resume upload (new upload cannot be created without an endpoint)');

            return;
          } // Try to create a new upload


          _this7.url = null;

          _this7._createUpload();

          return;
        }

        var offset = parseInt(res.getHeader('Upload-Offset'), 10);

        if (isNaN(offset)) {
          _this7._emitHttpError(req, res, 'tus: invalid or missing offset value');

          return;
        }

        var length = parseInt(res.getHeader('Upload-Length'), 10);

        if (isNaN(length) && !_this7.options.uploadLengthDeferred) {
          _this7._emitHttpError(req, res, 'tus: invalid or missing length value');

          return;
        }

        if (typeof _this7.options._onUploadUrlAvailable === 'function') {
          _this7.options._onUploadUrlAvailable();
        } // Upload has already been completed and we do not need to send additional
        // data to the server


        if (offset === length) {
          _this7._emitProgress(length, length);

          _this7._emitSuccess(res.getBody());

          return;
        }

        _this7._offset = offset;

        _this7._performUpload();
      })["catch"](function (err) {
        _this7._emitHttpError(req, null, 'tus: failed to resume upload', err);
      });
    }
    /**
     * Start uploading the file using PATCH requests. The file will be divided
     * into chunks as specified in the chunkSize option. During the upload
     * the onProgress event handler may be invoked multiple times.
     *
     * @api private
     */

  }, {
    key: "_performUpload",
    value: function _performUpload() {
      var _this8 = this; // If the upload has been aborted, we will not send the next PATCH request.
      // This is important if the abort method was called during a callback, such
      // as onChunkComplete or onProgress.


      if (this._aborted) {
        return;
      }

      var req; // Some browser and servers may not support the PATCH method. For those
      // cases, you can tell tus-js-client to use a POST request with the
      // X-HTTP-Method-Override header for simulating a PATCH request.

      if (this.options.overridePatchMethod) {
        req = this._openRequest('POST', this.url);
        req.setHeader('X-HTTP-Method-Override', 'PATCH');
      } else {
        req = this._openRequest('PATCH', this.url);
      }

      req.setHeader('Upload-Offset', this._offset);

      var promise = this._addChunkToRequest(req);

      promise.then(function (res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this8._emitHttpError(req, res, 'tus: unexpected response while uploading chunk');

          return;
        }

        _this8._handleUploadResponse(req, res);
      })["catch"](function (err) {
        // Don't emit an error if the upload was aborted manually
        if (_this8._aborted) {
          return;
        }

        _this8._emitHttpError(req, null, "tus: failed to upload chunk at offset ".concat(_this8._offset), err);
      });
    }
    /**
     * _addChunktoRequest reads a chunk from the source and sends it using the
     * supplied request object. It will not handle the response.
     *
     * @api private
     */

  }, {
    key: "_addChunkToRequest",
    value: function _addChunkToRequest(req) {
      var _this9 = this;

      var start = this._offset;
      var end = this._offset + this.options.chunkSize;
      req.setProgressHandler(function (bytesSent) {
        _this9._emitProgress(start + bytesSent, _this9._size);
      });
      req.setHeader('Content-Type', 'application/offset+octet-stream'); // The specified chunkSize may be Infinity or the calcluated end position
      // may exceed the file's size. In both cases, we limit the end position to
      // the input's total size for simpler calculations and correctness.

      if ((end === Infinity || end > this._size) && !this.options.uploadLengthDeferred) {
        end = this._size;
      }

      return this._source.slice(start, end).then(function (_ref2) {
        var value = _ref2.value,
            done = _ref2.done; // If the upload length is deferred, the upload size was not specified during
        // upload creation. So, if the file reader is done reading, we know the total
        // upload size and can tell the tus server.

        if (_this9.options.uploadLengthDeferred && done) {
          _this9._size = _this9._offset + (value && value.size ? value.size : 0);
          req.setHeader('Upload-Length', _this9._size);
        }

        if (value === null) {
          return _this9._sendRequest(req);
        }

        _this9._emitProgress(_this9._offset, _this9._size);

        return _this9._sendRequest(req, value);
      });
    }
    /**
     * _handleUploadResponse is used by requests that haven been sent using _addChunkToRequest
     * and already have received a response.
     *
     * @api private
     */

  }, {
    key: "_handleUploadResponse",
    value: function _handleUploadResponse(req, res) {
      var offset = parseInt(res.getHeader('Upload-Offset'), 10);

      if (isNaN(offset)) {
        this._emitHttpError(req, res, 'tus: invalid or missing offset value');

        return;
      }

      this._emitProgress(offset, this._size);

      this._emitChunkComplete(offset - this._offset, offset, this._size);

      this._offset = offset;

      if (offset == this._size) {
        // Yay, finally done :)
        this._emitSuccess(res.getBody());

        this._source.close();

        return;
      }

      this._performUpload();
    }
    /**
     * Create a new HTTP request object with the given method and URL.
     *
     * @api private
     */

  }, {
    key: "_openRequest",
    value: function _openRequest(method, url) {
      var req = openRequest(method, url, this.options);
      this._req = req;
      return req;
    }
    /**
     * Remove the entry in the URL storage, if it has been saved before.
     *
     * @api private
     */

  }, {
    key: "_removeFromUrlStorage",
    value: function _removeFromUrlStorage() {
      var _this10 = this;

      if (!this._urlStorageKey) return;

      this._urlStorage.removeUpload(this._urlStorageKey)["catch"](function (err) {
        _this10._emitError(err);
      });

      this._urlStorageKey = null;
    }
    /**
     * Add the upload URL to the URL storage, if possible.
     *
     * @api private
     */

  }, {
    key: "_saveUploadInUrlStorage",
    value: function _saveUploadInUrlStorage() {
      var _this11 = this; // Only if a fingerprint was calculated for the input (i.e. not a stream), we can store the upload URL.


      if (!this.options.storeFingerprintForResuming || !this._fingerprint) {
        return;
      }

      var storedUpload = {
        size: this._size,
        metadata: this.options.metadata,
        creationTime: new Date().toString()
      };

      if (this._parallelUploads) {
        // Save multiple URLs if the parallelUploads option is used ...
        storedUpload.parallelUploadUrls = this._parallelUploadUrls;
      } else {
        // ... otherwise we just save the one available URL.
        storedUpload.uploadUrl = this.url;
      }

      this._urlStorage.addUpload(this._fingerprint, storedUpload).then(function (urlStorageKey) {
        return _this11._urlStorageKey = urlStorageKey;
      })["catch"](function (err) {
        _this11._emitError(err);
      });
    }
    /**
     * Send a request with the provided body.
     *
     * @api private
     */

  }, {
    key: "_sendRequest",
    value: function _sendRequest(req) {
      var body = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return sendRequest(req, body, this.options);
    }
  }], [{
    key: "terminate",
    value: function terminate(url, options) {
      // Count the number of arguments to see if a callback is being provided as the last
      // argument in the old style required by tus-js-client 1.x, then throw an error if it is.
      // `arguments` is a JavaScript built-in variable that contains all of the function's arguments.
      if (arguments.length > 1 && typeof arguments[arguments.length - 1] === 'function') {
        throw new Error('tus: the terminate function does not accept a callback since v2 anymore; please use the returned Promise instead');
      } // Note that in order for the trick above to work, a default value cannot be set for `options`,
      // so the check below replaces the old default `{}`.


      if (options === undefined) {
        options = {};
      }

      var req = openRequest('DELETE', url, options);
      return sendRequest(req, null, options).then(function (res) {
        // A 204 response indicates a successfull request
        if (res.getStatus() === 204) {
          return;
        }

        throw new _error["default"]('tus: unexpected response while terminating upload', null, req, res);
      })["catch"](function (err) {
        if (!(err instanceof _error["default"])) {
          err = new _error["default"]('tus: failed to terminate upload', err, req, null);
        }

        if (!shouldRetry(err, 0, options)) {
          throw err;
        } // Instead of keeping track of the retry attempts, we remove the first element from the delays
        // array. If the array is empty, all retry attempts are used up and we will bubble up the error.
        // We recursively call the terminate function will removing elements from the retryDelays array.


        var delay = options.retryDelays[0];
        var remainingDelays = options.retryDelays.slice(1);

        var newOptions = _objectSpread(_objectSpread({}, options), {}, {
          retryDelays: remainingDelays
        });

        return new Promise(function (resolve) {
          return setTimeout(resolve, delay);
        }).then(function () {
          return BaseUpload.terminate(url, newOptions);
        });
      });
    }
  }]);

  return BaseUpload;
}();

function encodeMetadata(metadata) {
  var encoded = [];

  for (var key in metadata) {
    encoded.push("".concat(key, " ").concat(_jsBase.Base64.encode(metadata[key])));
  }

  return encoded.join(',');
}
/**
 * Checks whether a given status is in the range of the expected category.
 * For example, only a status between 200 and 299 will satisfy the category 200.
 *
 * @api private
 */


function inStatusCategory(status, category) {
  return status >= category && status < category + 100;
}
/**
 * Create a new HTTP request with the specified method and URL.
 * The necessary headers that are included in every request
 * will be added, including the request ID.
 *
 * @api private
 */


function openRequest(method, url, options) {
  var req = options.httpStack.createRequest(method, url);
  req.setHeader('Tus-Resumable', '1.0.0');
  var headers = options.headers || {};

  for (var name in headers) {
    req.setHeader(name, headers[name]);
  }

  if (options.addRequestId) {
    var requestId = (0, _uuid["default"])();
    req.setHeader('X-Request-ID', requestId);
  }

  return req;
}
/**
 * Send a request with the provided body while invoking the onBeforeRequest
 * and onAfterResponse callbacks.
 *
 * @api private
 */


function sendRequest(req, body, options) {
  var onBeforeRequestPromise = typeof options.onBeforeRequest === 'function' ? Promise.resolve(options.onBeforeRequest(req)) : Promise.resolve();
  return onBeforeRequestPromise.then(function () {
    return req.send(body).then(function (res) {
      var onAfterResponsePromise = typeof options.onAfterResponse === 'function' ? Promise.resolve(options.onAfterResponse(req, res)) : Promise.resolve();
      return onAfterResponsePromise.then(function () {
        return res;
      });
    });
  });
}
/**
 * Checks whether the browser running this code has internet access.
 * This function will always return true in the node.js environment
 *
 * @api private
 */


function isOnline() {
  var online = true;

  if (typeof window !== 'undefined' && 'navigator' in window && window.navigator.onLine === false) {
    online = false;
  }

  return online;
}
/**
 * Checks whether or not it is ok to retry a request.
 * @param {Error} err the error returned from the last request
 * @param {number} retryAttempt the number of times the request has already been retried
 * @param {object} options tus Upload options
 *
 * @api private
 */


function shouldRetry(err, retryAttempt, options) {
  // We only attempt a retry if
  // - retryDelays option is set
  // - we didn't exceed the maxium number of retries, yet, and
  // - this error was caused by a request or it's response and
  // - the error is server error (i.e. not a status 4xx except a 409 or 423) or
  // a onShouldRetry is specified and returns true
  // - the browser does not indicate that we are offline
  if (options.retryDelays == null || retryAttempt >= options.retryDelays.length || err.originalRequest == null) {
    return false;
  }

  if (options && typeof options.onShouldRetry === 'function') {
    return options.onShouldRetry(err, retryAttempt, options);
  }

  var status = err.originalResponse ? err.originalResponse.getStatus() : 0;
  return (!inStatusCategory(status, 400) || status === 409 || status === 423) && isOnline();
}
/**
 * Resolve a relative link given the origin as source. For example,
 * if a HTTP request to http://example.com/files/ returns a Location
 * header with the value /upload/abc, the resolved URL will be:
 * http://example.com/upload/abc
 */


function resolveUrl(origin, link) {
  return new _urlParse["default"](link, origin).toString();
}
/**
 * Calculate the start and end positions for the parts if an upload
 * is split into multiple parallel requests.
 *
 * @param {number} totalSize The byte size of the upload, which will be split.
 * @param {number} partCount The number in how many parts the upload will be split.
 * @param {string[]} previousUrls The upload URLs for previous parts.
 * @return {object[]}
 * @api private
 */


function splitSizeIntoParts(totalSize, partCount, previousUrls) {
  var partSize = Math.floor(totalSize / partCount);
  var parts = [];

  for (var i = 0; i < partCount; i++) {
    parts.push({
      start: partSize * i,
      end: partSize * (i + 1)
    });
  }

  parts[partCount - 1].end = totalSize; // Attach URLs from previous uploads, if available.

  if (previousUrls) {
    parts.forEach(function (part, index) {
      part.uploadUrl = previousUrls[index] || null;
    });
  }

  return parts;
}

BaseUpload.defaultOptions = defaultOptions;
var _default = BaseUpload;
exports["default"] = _default;

},{"./error":10,"./logger":11,"./uuid":14,"js-base64":48,"url-parse":53}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = uuid;
/**
 * Generate a UUID v4 based on random numbers. We intentioanlly use the less
 * secure Math.random function here since the more secure crypto.getRandomNumbers
 * is not available on all platforms.
 * This is not a problem for us since we use the UUID only for generating a
 * request ID, so we can correlate server logs to client errors.
 *
 * This function is taken from following site:
 * https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
 *
 * @return {string} The generate UUID
 */

function uuid() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
        v = c == 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
}

},{}],15:[function(require,module,exports){
module.exports = require('./lib/axios');
},{"./lib/axios":17}],16:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var settle = require('./../core/settle');
var cookies = require('./../helpers/cookies');
var buildURL = require('./../helpers/buildURL');
var buildFullPath = require('../core/buildFullPath');
var parseHeaders = require('./../helpers/parseHeaders');
var isURLSameOrigin = require('./../helpers/isURLSameOrigin');
var createError = require('../core/createError');

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};

},{"../core/buildFullPath":23,"../core/createError":24,"./../core/settle":28,"./../helpers/buildURL":32,"./../helpers/cookies":34,"./../helpers/isURLSameOrigin":37,"./../helpers/parseHeaders":39,"./../utils":41}],17:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var bind = require('./helpers/bind');
var Axios = require('./core/Axios');
var mergeConfig = require('./core/mergeConfig');
var defaults = require('./defaults');

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = require('./cancel/Cancel');
axios.CancelToken = require('./cancel/CancelToken');
axios.isCancel = require('./cancel/isCancel');

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = require('./helpers/spread');

// Expose isAxiosError
axios.isAxiosError = require('./helpers/isAxiosError');

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;

},{"./cancel/Cancel":18,"./cancel/CancelToken":19,"./cancel/isCancel":20,"./core/Axios":21,"./core/mergeConfig":27,"./defaults":30,"./helpers/bind":31,"./helpers/isAxiosError":36,"./helpers/spread":40,"./utils":41}],18:[function(require,module,exports){
'use strict';

/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;

},{}],19:[function(require,module,exports){
'use strict';

var Cancel = require('./Cancel');

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

},{"./Cancel":18}],20:[function(require,module,exports){
'use strict';

module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

},{}],21:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var buildURL = require('../helpers/buildURL');
var InterceptorManager = require('./InterceptorManager');
var dispatchRequest = require('./dispatchRequest');
var mergeConfig = require('./mergeConfig');

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;

},{"../helpers/buildURL":32,"./../utils":41,"./InterceptorManager":22,"./dispatchRequest":25,"./mergeConfig":27}],22:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

},{"./../utils":41}],23:[function(require,module,exports){
'use strict';

var isAbsoluteURL = require('../helpers/isAbsoluteURL');
var combineURLs = require('../helpers/combineURLs');

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};

},{"../helpers/combineURLs":33,"../helpers/isAbsoluteURL":35}],24:[function(require,module,exports){
'use strict';

var enhanceError = require('./enhanceError');

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

},{"./enhanceError":26}],25:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var transformData = require('./transformData');
var isCancel = require('../cancel/isCancel');
var defaults = require('../defaults');

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};

},{"../cancel/isCancel":20,"../defaults":30,"./../utils":41,"./transformData":29}],26:[function(require,module,exports){
'use strict';

/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};

},{}],27:[function(require,module,exports){
'use strict';

var utils = require('../utils');

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = [
    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
  ];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys)
    .concat(directMergeKeys);

  var otherKeys = Object
    .keys(config1)
    .concat(Object.keys(config2))
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, mergeDeepProperties);

  return config;
};

},{"../utils":41}],28:[function(require,module,exports){
'use strict';

var createError = require('./createError');

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};

},{"./createError":24}],29:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};

},{"./../utils":41}],30:[function(require,module,exports){
(function (process){(function (){
'use strict';

var utils = require('./utils');
var normalizeHeaderName = require('./helpers/normalizeHeaderName');

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = require('./adapters/xhr');
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = require('./adapters/http');
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

}).call(this)}).call(this,require('_process'))

},{"./adapters/http":16,"./adapters/xhr":16,"./helpers/normalizeHeaderName":38,"./utils":41,"_process":49}],31:[function(require,module,exports){
'use strict';

module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

},{}],32:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

},{"./../utils":41}],33:[function(require,module,exports){
'use strict';

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};

},{}],34:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);

},{"./../utils":41}],35:[function(require,module,exports){
'use strict';

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

},{}],36:[function(require,module,exports){
'use strict';

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};

},{}],37:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);

},{"./../utils":41}],38:[function(require,module,exports){
'use strict';

var utils = require('../utils');

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

},{"../utils":41}],39:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};

},{"./../utils":41}],40:[function(require,module,exports){
'use strict';

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

},{}],41:[function(require,module,exports){
'use strict';

var bind = require('./helpers/bind');

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};

},{"./helpers/bind":31}],42:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],43:[function(require,module,exports){
(function (global,Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
 *     on objects.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

function typedArraySupport () {
  function Bar () {}
  try {
    var arr = new Uint8Array(1)
    arr.foo = function () { return 42 }
    arr.constructor = Bar
    return arr.foo() === 42 && // typed array instances can be augmented
        arr.constructor === Bar && // constructor can be set
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    this.length = 0
    this.parent = undefined
  }

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined') {
    if (object.buffer instanceof ArrayBuffer) {
      return fromTypedArray(that, object)
    }
    if (object instanceof ArrayBuffer) {
      return fromArrayBuffer(that, object)
    }
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    array.byteLength
    that = Buffer._augment(new Uint8Array(array))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromTypedArray(that, new Uint8Array(array))
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
} else {
  // pre-set for values that may exist in the future
  Buffer.prototype.length = undefined
  Buffer.prototype.parent = undefined
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = '' + string

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` is deprecated
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` is deprecated
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"base64-js":42,"buffer":43,"ieee754":46,"isarray":47}],44:[function(require,module,exports){
// This file can be required in Browserify and Node.js for automatic polyfill
// To use it:  require('es6-promise/auto');
'use strict';
module.exports = require('./').polyfill();

},{"./":45}],45:[function(require,module,exports){
(function (process,global){(function (){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.8+1e68dce6
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.ES6Promise = factory());
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  var type = typeof x;
  return x !== null && (type === 'object' || type === 'function');
}

function isFunction(x) {
  return typeof x === 'function';
}



var _isArray = void 0;
if (Array.isArray) {
  _isArray = Array.isArray;
} else {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
}

var isArray = _isArray;

var len = 0;
var vertxNext = void 0;
var customSchedulerFn = void 0;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }

  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var vertx = Function('return this')().require('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = void 0;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && typeof require === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;


  if (_state) {
    var callback = arguments[_state - 1];
    asap(function () {
      return invokeCallback(_state, child, callback, parent._result);
    });
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve$1(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(2);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
  try {
    then$$1.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then$$1) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then$$1, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return resolve(promise, value);
    }, function (reason) {
      return reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$1) {
  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$1 === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$1)) {
      handleForeignThenable(promise, maybeThenable, then$$1);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function resolve(promise, value) {
  if (promise === value) {
    reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    var then$$1 = void 0;
    try {
      then$$1 = value.then;
    } catch (error) {
      reject(promise, error);
      return;
    }
    handleMaybeThenable(promise, value, then$$1);
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;


  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = void 0,
      callback = void 0,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = void 0,
      error = void 0,
      succeeded = true;

  if (hasCallback) {
    try {
      value = callback(detail);
    } catch (e) {
      succeeded = false;
      error = e;
    }

    if (promise === value) {
      reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
    resolve(promise, value);
  } else if (succeeded === false) {
    reject(promise, error);
  } else if (settled === FULFILLED) {
    fulfill(promise, value);
  } else if (settled === REJECTED) {
    reject(promise, value);
  }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      resolve(promise, value);
    }, function rejectPromise(reason) {
      reject(promise, reason);
    });
  } catch (e) {
    reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
}

var Enumerator = function () {
  function Enumerator(Constructor, input) {
    this._instanceConstructor = Constructor;
    this.promise = new Constructor(noop);

    if (!this.promise[PROMISE_ID]) {
      makePromise(this.promise);
    }

    if (isArray(input)) {
      this.length = input.length;
      this._remaining = input.length;

      this._result = new Array(this.length);

      if (this.length === 0) {
        fulfill(this.promise, this._result);
      } else {
        this.length = this.length || 0;
        this._enumerate(input);
        if (this._remaining === 0) {
          fulfill(this.promise, this._result);
        }
      }
    } else {
      reject(this.promise, validationError());
    }
  }

  Enumerator.prototype._enumerate = function _enumerate(input) {
    for (var i = 0; this._state === PENDING && i < input.length; i++) {
      this._eachEntry(input[i], i);
    }
  };

  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
    var c = this._instanceConstructor;
    var resolve$$1 = c.resolve;


    if (resolve$$1 === resolve$1) {
      var _then = void 0;
      var error = void 0;
      var didError = false;
      try {
        _then = entry.then;
      } catch (e) {
        didError = true;
        error = e;
      }

      if (_then === then && entry._state !== PENDING) {
        this._settledAt(entry._state, i, entry._result);
      } else if (typeof _then !== 'function') {
        this._remaining--;
        this._result[i] = entry;
      } else if (c === Promise$1) {
        var promise = new c(noop);
        if (didError) {
          reject(promise, error);
        } else {
          handleMaybeThenable(promise, entry, _then);
        }
        this._willSettleAt(promise, i);
      } else {
        this._willSettleAt(new c(function (resolve$$1) {
          return resolve$$1(entry);
        }), i);
      }
    } else {
      this._willSettleAt(resolve$$1(entry), i);
    }
  };

  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
    var promise = this.promise;


    if (promise._state === PENDING) {
      this._remaining--;

      if (state === REJECTED) {
        reject(promise, value);
      } else {
        this._result[i] = value;
      }
    }

    if (this._remaining === 0) {
      fulfill(promise, this._result);
    }
  };

  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
    var enumerator = this;

    subscribe(promise, undefined, function (value) {
      return enumerator._settledAt(FULFILLED, i, value);
    }, function (reason) {
      return enumerator._settledAt(REJECTED, i, reason);
    });
  };

  return Enumerator;
}();

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject$1(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {Function} resolver
  Useful for tooling.
  @constructor
*/

var Promise$1 = function () {
  function Promise(resolver) {
    this[PROMISE_ID] = nextId();
    this._result = this._state = undefined;
    this._subscribers = [];

    if (noop !== resolver) {
      typeof resolver !== 'function' && needsResolver();
      this instanceof Promise ? initializePromise(this, resolver) : needsNew();
    }
  }

  /**
  The primary way of interacting with a promise is through its `then` method,
  which registers callbacks to receive either a promise's eventual value or the
  reason why the promise cannot be fulfilled.
   ```js
  findUser().then(function(user){
    // user is available
  }, function(reason){
    // user is unavailable, and you are given the reason why
  });
  ```
   Chaining
  --------
   The return value of `then` is itself a promise.  This second, 'downstream'
  promise is resolved with the return value of the first promise's fulfillment
  or rejection handler, or rejected if the handler throws an exception.
   ```js
  findUser().then(function (user) {
    return user.name;
  }, function (reason) {
    return 'default name';
  }).then(function (userName) {
    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
    // will be `'default name'`
  });
   findUser().then(function (user) {
    throw new Error('Found user, but still unhappy');
  }, function (reason) {
    throw new Error('`findUser` rejected and we're unhappy');
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
  });
  ```
  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
   ```js
  findUser().then(function (user) {
    throw new PedagogicalException('Upstream error');
  }).then(function (value) {
    // never reached
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // The `PedgagocialException` is propagated all the way down to here
  });
  ```
   Assimilation
  ------------
   Sometimes the value you want to propagate to a downstream promise can only be
  retrieved asynchronously. This can be achieved by returning a promise in the
  fulfillment or rejection handler. The downstream promise will then be pending
  until the returned promise is settled. This is called *assimilation*.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // The user's comments are now available
  });
  ```
   If the assimliated promise rejects, then the downstream promise will also reject.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // If `findCommentsByAuthor` fulfills, we'll have the value here
  }, function (reason) {
    // If `findCommentsByAuthor` rejects, we'll have the reason here
  });
  ```
   Simple Example
  --------------
   Synchronous Example
   ```javascript
  let result;
   try {
    result = findResult();
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
  findResult(function(result, err){
    if (err) {
      // failure
    } else {
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findResult().then(function(result){
    // success
  }, function(reason){
    // failure
  });
  ```
   Advanced Example
  --------------
   Synchronous Example
   ```javascript
  let author, books;
   try {
    author = findAuthor();
    books  = findBooksByAuthor(author);
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
   function foundBooks(books) {
   }
   function failure(reason) {
   }
   findAuthor(function(author, err){
    if (err) {
      failure(err);
      // failure
    } else {
      try {
        findBoooksByAuthor(author, function(books, err) {
          if (err) {
            failure(err);
          } else {
            try {
              foundBooks(books);
            } catch(reason) {
              failure(reason);
            }
          }
        });
      } catch(error) {
        failure(err);
      }
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findAuthor().
    then(findBooksByAuthor).
    then(function(books){
      // found books
  }).catch(function(reason){
    // something went wrong
  });
  ```
   @method then
  @param {Function} onFulfilled
  @param {Function} onRejected
  Useful for tooling.
  @return {Promise}
  */

  /**
  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
  as the catch block of a try/catch statement.
  ```js
  function findAuthor(){
  throw new Error('couldn't find that author');
  }
  // synchronous
  try {
  findAuthor();
  } catch(reason) {
  // something went wrong
  }
  // async with promises
  findAuthor().catch(function(reason){
  // something went wrong
  });
  ```
  @method catch
  @param {Function} onRejection
  Useful for tooling.
  @return {Promise}
  */


  Promise.prototype.catch = function _catch(onRejection) {
    return this.then(null, onRejection);
  };

  /**
    `finally` will be invoked regardless of the promise's fate just as native
    try/catch/finally behaves
  
    Synchronous example:
  
    ```js
    findAuthor() {
      if (Math.random() > 0.5) {
        throw new Error();
      }
      return new Author();
    }
  
    try {
      return findAuthor(); // succeed or fail
    } catch(error) {
      return findOtherAuther();
    } finally {
      // always runs
      // doesn't affect the return value
    }
    ```
  
    Asynchronous example:
  
    ```js
    findAuthor().catch(function(reason){
      return findOtherAuther();
    }).finally(function(){
      // author was either found, or not
    });
    ```
  
    @method finally
    @param {Function} callback
    @return {Promise}
  */


  Promise.prototype.finally = function _finally(callback) {
    var promise = this;
    var constructor = promise.constructor;

    if (isFunction(callback)) {
      return promise.then(function (value) {
        return constructor.resolve(callback()).then(function () {
          return value;
        });
      }, function (reason) {
        return constructor.resolve(callback()).then(function () {
          throw reason;
        });
      });
    }

    return promise.then(callback, callback);
  };

  return Promise;
}();

Promise$1.prototype.then = then;
Promise$1.all = all;
Promise$1.race = race;
Promise$1.resolve = resolve$1;
Promise$1.reject = reject$1;
Promise$1._setScheduler = setScheduler;
Promise$1._setAsap = setAsap;
Promise$1._asap = asap;

/*global self*/
function polyfill() {
  var local = void 0;

  if (typeof global !== 'undefined') {
    local = global;
  } else if (typeof self !== 'undefined') {
    local = self;
  } else {
    try {
      local = Function('return this')();
    } catch (e) {
      throw new Error('polyfill failed because global object is unavailable in this environment');
    }
  }

  var P = local.Promise;

  if (P) {
    var promiseToString = null;
    try {
      promiseToString = Object.prototype.toString.call(P.resolve());
    } catch (e) {
      // silently ignored
    }

    if (promiseToString === '[object Promise]' && !P.cast) {
      return;
    }
  }

  local.Promise = Promise$1;
}

// Strange compat..
Promise$1.polyfill = polyfill;
Promise$1.Promise = Promise$1;

return Promise$1;

})));





}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":49}],46:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],47:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],48:[function(require,module,exports){
(function (global){(function (){
/*
 *  base64.js
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 */
;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined'
        ? module.exports = factory(global)
        : typeof define === 'function' && define.amd
        ? define(factory) : factory(global)
}((
    typeof self !== 'undefined' ? self
        : typeof window !== 'undefined' ? window
        : typeof global !== 'undefined' ? global
: this
), function(global) {
    'use strict';
    // existing version for noConflict()
    global = global || {};
    var _Base64 = global.Base64;
    var version = "2.6.4";
    // constants
    var b64chars
        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    var b64tab = function(bin) {
        var t = {};
        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
        return t;
    }(b64chars);
    var fromCharCode = String.fromCharCode;
    // encoder stuff
    var cb_utob = function(c) {
        if (c.length < 2) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c
                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))
                                + fromCharCode(0x80 | (cc & 0x3f)))
                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))
                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                    + fromCharCode(0x80 | ( cc         & 0x3f)));
        } else {
            var cc = 0x10000
                + (c.charCodeAt(0) - 0xD800) * 0x400
                + (c.charCodeAt(1) - 0xDC00);
            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))
                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))
                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                    + fromCharCode(0x80 | ( cc         & 0x3f)));
        }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    var utob = function(u) {
        return u.replace(re_utob, cb_utob);
    };
    var cb_encode = function(ccc) {
        var padlen = [0, 2, 1][ccc.length % 3],
        ord = ccc.charCodeAt(0) << 16
            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),
        chars = [
            b64chars.charAt( ord >>> 18),
            b64chars.charAt((ord >>> 12) & 63),
            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
        ];
        return chars.join('');
    };
    var btoa = global.btoa && typeof global.btoa == 'function'
        ? function(b){ return global.btoa(b) } : function(b) {
        if (b.match(/[^\x00-\xFF]/)) throw new RangeError(
            'The string contains invalid characters.'
        );
        return b.replace(/[\s\S]{1,3}/g, cb_encode);
    };
    var _encode = function(u) {
        return btoa(utob(String(u)));
    };
    var mkUriSafe = function (b64) {
        return b64.replace(/[+\/]/g, function(m0) {
            return m0 == '+' ? '-' : '_';
        }).replace(/=/g, '');
    };
    var encode = function(u, urisafe) {
        return urisafe ? mkUriSafe(_encode(u)) : _encode(u);
    };
    var encodeURI = function(u) { return encode(u, true) };
    var fromUint8Array;
    if (global.Uint8Array) fromUint8Array = function(a, urisafe) {
        // return btoa(fromCharCode.apply(null, a));
        var b64 = '';
        for (var i = 0, l = a.length; i < l; i += 3) {
            var a0 = a[i], a1 = a[i+1], a2 = a[i+2];
            var ord = a0 << 16 | a1 << 8 | a2;
            b64 +=    b64chars.charAt( ord >>> 18)
                +     b64chars.charAt((ord >>> 12) & 63)
                + ( typeof a1 != 'undefined'
                    ? b64chars.charAt((ord >>>  6) & 63) : '=')
                + ( typeof a2 != 'undefined'
                    ? b64chars.charAt( ord         & 63) : '=');
        }
        return urisafe ? mkUriSafe(b64) : b64;
    };
    // decoder stuff
    var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
    var cb_btou = function(cccc) {
        switch(cccc.length) {
        case 4:
            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                |    ((0x3f & cccc.charCodeAt(1)) << 12)
                |    ((0x3f & cccc.charCodeAt(2)) <<  6)
                |     (0x3f & cccc.charCodeAt(3)),
            offset = cp - 0x10000;
            return (fromCharCode((offset  >>> 10) + 0xD800)
                    + fromCharCode((offset & 0x3FF) + 0xDC00));
        case 3:
            return fromCharCode(
                ((0x0f & cccc.charCodeAt(0)) << 12)
                    | ((0x3f & cccc.charCodeAt(1)) << 6)
                    |  (0x3f & cccc.charCodeAt(2))
            );
        default:
            return  fromCharCode(
                ((0x1f & cccc.charCodeAt(0)) << 6)
                    |  (0x3f & cccc.charCodeAt(1))
            );
        }
    };
    var btou = function(b) {
        return b.replace(re_btou, cb_btou);
    };
    var cb_decode = function(cccc) {
        var len = cccc.length,
        padlen = len % 4,
        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)
            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)
            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)
            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),
        chars = [
            fromCharCode( n >>> 16),
            fromCharCode((n >>>  8) & 0xff),
            fromCharCode( n         & 0xff)
        ];
        chars.length -= [0, 0, 2, 1][padlen];
        return chars.join('');
    };
    var _atob = global.atob && typeof global.atob == 'function'
        ? function(a){ return global.atob(a) } : function(a){
        return a.replace(/\S{1,4}/g, cb_decode);
    };
    var atob = function(a) {
        return _atob(String(a).replace(/[^A-Za-z0-9\+\/]/g, ''));
    };
    var _decode = function(a) { return btou(_atob(a)) };
    var _fromURI = function(a) {
        return String(a).replace(/[-_]/g, function(m0) {
            return m0 == '-' ? '+' : '/'
        }).replace(/[^A-Za-z0-9\+\/]/g, '');
    };
    var decode = function(a){
        return _decode(_fromURI(a));
    };
    var toUint8Array;
    if (global.Uint8Array) toUint8Array = function(a) {
        return Uint8Array.from(atob(_fromURI(a)), function(c) {
            return c.charCodeAt(0);
        });
    };
    var noConflict = function() {
        var Base64 = global.Base64;
        global.Base64 = _Base64;
        return Base64;
    };
    // export Base64
    global.Base64 = {
        VERSION: version,
        atob: atob,
        btoa: btoa,
        fromBase64: decode,
        toBase64: encode,
        utob: utob,
        encode: encode,
        encodeURI: encodeURI,
        btou: btou,
        decode: decode,
        noConflict: noConflict,
        fromUint8Array: fromUint8Array,
        toUint8Array: toUint8Array
    };
    // if ES5 is available, make Base64.extendString() available
    if (typeof Object.defineProperty === 'function') {
        var noEnum = function(v){
            return {value:v,enumerable:false,writable:true,configurable:true};
        };
        global.Base64.extendString = function () {
            Object.defineProperty(
                String.prototype, 'fromBase64', noEnum(function () {
                    return decode(this)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64', noEnum(function (urisafe) {
                    return encode(this, urisafe)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64URI', noEnum(function () {
                    return encode(this, true)
                }));
        };
    }
    //
    // export Base64 to the namespace
    //
    if (global['Meteor']) { // Meteor.js
        Base64 = global.Base64;
    }
    // module.exports and AMD are mutually exclusive.
    // module.exports has precedence.
    if (typeof module !== 'undefined' && module.exports) {
        module.exports.Base64 = global.Base64;
    }
    else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], function(){ return global.Base64 });
    }
    // that's it!
    return {Base64: global.Base64}
}));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],49:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],50:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

/**
 * Attempts to encode a given input.
 *
 * @param {String} input The string that needs to be encoded.
 * @returns {String|Null} The encoded string.
 * @api private
 */
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?#&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      key = encode(key);
      value = encode(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],51:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  typeof module === "object" ? module.exports : {}
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}

},{}],52:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],53:[function(require,module,exports){
(function (global){(function (){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i
  , windowsDriveLetter = /^[a-zA-Z]:/
  , whitespace = '[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]'
  , left = new RegExp('^'+ whitespace +'+');

/**
 * Trim a given string.
 *
 * @param {String} str String to trim.
 * @public
 */
function trimLeft(str) {
  return (str ? str : '').toString().replace(left, '');
}

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address, url) {     // Sanitize what is left of the address
    return isSpecial(url.protocol) ? address.replace(/\\/g, '/') : address;
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof global !== 'undefined') globalVar = global;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * Check whether a protocol scheme is special.
 *
 * @param {String} The protocol scheme of the URL
 * @return {Boolean} `true` if the protocol scheme is special, else `false`
 * @private
 */
function isSpecial(scheme) {
  return (
    scheme === 'file:' ||
    scheme === 'ftp:' ||
    scheme === 'http:' ||
    scheme === 'https:' ||
    scheme === 'ws:' ||
    scheme === 'wss:'
  );
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @param {Object} location
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address, location) {
  address = trimLeft(address);
  location = location || {};

  var match = protocolre.exec(address);
  var protocol = match[1] ? match[1].toLowerCase() : '';
  var forwardSlashes = !!match[2];
  var otherSlashes = !!match[3];
  var slashesCount = 0;
  var rest;

  if (forwardSlashes) {
    if (otherSlashes) {
      rest = match[2] + match[3] + match[4];
      slashesCount = match[2].length + match[3].length;
    } else {
      rest = match[2] + match[4];
      slashesCount = match[2].length;
    }
  } else {
    if (otherSlashes) {
      rest = match[3] + match[4];
      slashesCount = match[3].length;
    } else {
      rest = match[4]
    }
  }

  if (protocol === 'file:') {
    if (slashesCount >= 2) {
      rest = rest.slice(2);
    }
  } else if (isSpecial(protocol)) {
    rest = match[4];
  } else if (protocol) {
    if (forwardSlashes) {
      rest = rest.slice(2);
    }
  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
    rest = match[4];
  }

  return {
    protocol: protocol,
    slashes: forwardSlashes || isSpecial(protocol),
    slashesCount: slashesCount,
    rest: rest
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  if (relative === '') return base;

  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  address = trimLeft(address);

  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '', location);
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (
    extracted.protocol === 'file:' && (
      extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) ||
    (!extracted.slashes &&
      (extracted.protocol ||
        extracted.slashesCount < 2 ||
        !isSpecial(url.protocol)))
  ) {
    instructions[3] = [/(.*)/, 'pathname'];
  }

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address, url);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // Default to a / for pathname if none exists. This normalizes the URL
  // to always have a /
  //
  if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {
    url.pathname = '/' + url.pathname;
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes || isSpecial(url.protocol) ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;

module.exports = Url;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"querystringify":50,"requires-port":52}],54:[function(require,module,exports){
"use strict";

require("regenerator-runtime/runtime");

require("es6-promise/auto");

// The regenerator runtime is needed since the test use functions
// with the async/await keywords. See
// https://babeljs.io/docs/en/babel-plugin-transform-regenerator
// Polyfill `Promise` for Internet Explorer.
// This is a fun piece of code. Let me tell you the story behind it:
// Internet Explorer 10 and 11 have a bug where the event handlers
// for XMLHttpRequests will be invoked with a significant delay after
// the actual request has been finished. So, even if the HTTP request
// only took 1s to complete, IE will wait another 20s before it decides
// to tell your application that the request has been finished. This
// was not a big problem in daily use since this issue did only occur
// when the user did not interact with the webpage, e.g. move the mouse.
// However, when testing in automated browssers, no user interaction was
// occurring.
// Eventually, someone figured out that this was related to a Promise
// polyfill that is used by the axios HTTP client. This solution is
// to use a timeout, as follows, which is enough to cause the network
// delays to vanish.
// Whoever found that patch, I hope they will go to heaven.
// See https://github.com/axios/axios/issues/1862
function t() {
  window.setTimeout(t, 10);
}

t();
beforeEach(function () {
  // Clear localStorage before every test to prevent stored URLs to
  // interfere with our setup.
  localStorage.clear();
});

require('./helpers/puppeteer/reporter.js');

require('./test-common.js');

require('./test-browser-specific.js');

require('./test-parallel-uploads.js');

require('./test-terminate.js');

require('./test-end-to-end.js');

},{"./helpers/puppeteer/reporter.js":56,"./test-browser-specific.js":58,"./test-common.js":59,"./test-end-to-end.js":60,"./test-parallel-uploads.js":61,"./test-terminate.js":62,"es6-promise/auto":44,"regenerator-runtime/runtime":51}],55:[function(require,module,exports){
"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

module.exports = /*#__PURE__*/function () {
  var _assertUrlStorage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(urlStorage) {
    var result, key1, key2, key3;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return urlStorage.findAllUploads();

          case 2:
            result = _context.sent;
            expect(result).toEqual([]); // Add a few uploads into the storage

            _context.next = 6;
            return urlStorage.addUpload('fingerprintA', {
              id: 1
            });

          case 6:
            key1 = _context.sent;
            _context.next = 9;
            return urlStorage.addUpload('fingerprintA', {
              id: 2
            });

          case 9:
            key2 = _context.sent;
            _context.next = 12;
            return urlStorage.addUpload('fingerprintB', {
              id: 3
            });

          case 12:
            key3 = _context.sent;
            expect(/^tus::fingerprintA::/.test(key1)).toBe(true);
            expect(/^tus::fingerprintA::/.test(key2)).toBe(true);
            expect(/^tus::fingerprintB::/.test(key3)).toBe(true); // Query the just stored uploads individually

            _context.next = 18;
            return urlStorage.findUploadsByFingerprint('fingerprintA');

          case 18:
            result = _context.sent;
            sort(result);
            expect(result).toEqual([{
              id: 1,
              urlStorageKey: key1
            }, {
              id: 2,
              urlStorageKey: key2
            }]);
            _context.next = 23;
            return urlStorage.findUploadsByFingerprint('fingerprintB');

          case 23:
            result = _context.sent;
            sort(result);
            expect(result).toEqual([{
              id: 3,
              urlStorageKey: key3
            }]); // Check that we can retrieve all stored uploads

            _context.next = 28;
            return urlStorage.findAllUploads();

          case 28:
            result = _context.sent;
            sort(result);
            expect(result).toEqual([{
              id: 1,
              urlStorageKey: key1
            }, {
              id: 2,
              urlStorageKey: key2
            }, {
              id: 3,
              urlStorageKey: key3
            }]); // Check that it can remove an upload and will not return it back

            _context.next = 33;
            return urlStorage.removeUpload(key2);

          case 33:
            _context.next = 35;
            return urlStorage.removeUpload(key3);

          case 35:
            _context.next = 37;
            return urlStorage.findUploadsByFingerprint('fingerprintA');

          case 37:
            result = _context.sent;
            expect(result).toEqual([{
              id: 1,
              urlStorageKey: key1
            }]);
            _context.next = 41;
            return urlStorage.findUploadsByFingerprint('fingerprintB');

          case 41:
            result = _context.sent;
            expect(result).toEqual([]);

          case 43:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  function assertUrlStorage(_x) {
    return _assertUrlStorage.apply(this, arguments);
  }

  return assertUrlStorage;
}(); // Sort the results from the URL storage since the order in not deterministic.


function sort(result) {
  result.sort(function (a, b) {
    return a.id - b.id;
  });
}

},{}],56:[function(require,module,exports){
"use strict";

/* eslint no-console: 0 */

/* eslint no-unused-vars: 0 */
var testsCompleted = false;
var testsPassed = true; // This reporter is used by bin/puppeteer-jasmine.js to obtain the test results.
// See https://jasmine.github.io/api/edge/Reporter.html for more details on the
// function signatures.

var reporter = {
  jasmineStarted: function jasmineStarted(suiteInfo) {},
  suiteStarted: function suiteStarted(result) {},
  specStarted: function specStarted(result) {},
  specDone: function specDone(result) {
    // Print the test result to the console.
    var passed = result.status === 'passed';
    var prefix = passed ? '✓' : '✘';
    console.log(prefix, result.fullName);
    testsCompleted = true;
    testsPassed = testsPassed && passed;

    for (var i = 0; i < result.failedExpectations.length; i++) {
      console.log("Failure: ".concat(result.failedExpectations[i].message));
      console.log(result.failedExpectations[i].stack);
      console.log('');
    }
  },
  suiteDone: function suiteDone(result) {},
  jasmineDone: function jasmineDone(result) {
    var success = testsCompleted && testsPassed;

    if (success) {
      console.log('Tests passed!');
    } else {
      console.log('Tests failed!');
    } // The __jasmineCallback function is exposed by the bin/puppeteer-jasmine.js
    // script. See it for more details.


    if (typeof window.__jasmineCallback === 'function') {
      window.__jasmineCallback(success);
    }
  }
};
window.jasmine.getEnv().addReporter(reporter);

},{}],57:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var isBrowser = typeof window !== 'undefined';
var isNode = !isBrowser;
/**
 * Obtain a platform specific buffer object, which can be
 * handled by tus-js-client.
 */

function getBlob(str) {
  if (isNode) {
    return Buffer.from(str);
  }

  return new Blob(str.split(''));
}
/**
 * Create a promise and obtain the resolve/reject functions
 * outside of the Promise callback.
 */


function flatPromise() {
  var resolveFn;
  var rejectFn;
  var p = new Promise(function (resolve, reject) {
    resolveFn = resolve;
    rejectFn = reject;
  });
  return [p, resolveFn, rejectFn];
}
/**
 * Create a spy-able function which resolves a Promise
 * once it is called.
 */


function waitableFunction() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'func';

  var _flatPromise = flatPromise(),
      _flatPromise2 = _slicedToArray(_flatPromise, 2),
      promise = _flatPromise2[0],
      resolve = _flatPromise2[1];

  var fn = jasmine.createSpy(name, resolve).and.callThrough();
  fn.toBeCalled = promise;
  return fn;
}
/**
 * Create a Promise that resolves after the specified duration.
 */


function wait(delay) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, delay, 'timed out');
  });
}
/**
 * TestHttpStack implements the HTTP stack interface for tus-js-client
 * and can be used to assert outgoing requests and respond with mock data.
 */


var TestHttpStack = /*#__PURE__*/function () {
  function TestHttpStack() {
    _classCallCheck(this, TestHttpStack);

    this._pendingRequests = [];
    this._pendingWaits = [];
  }

  _createClass(TestHttpStack, [{
    key: "createRequest",
    value: function createRequest(method, url) {
      var _this = this;

      return new TestRequest(method, url, function (req) {
        if (_this._pendingWaits.length >= 1) {
          var handler = _this._pendingWaits.shift();

          handler(req);
          return;
        }

        _this._pendingRequests.push(req);
      });
    }
  }, {
    key: "nextRequest",
    value: function nextRequest() {
      var _this2 = this;

      if (this._pendingRequests.length >= 1) {
        return Promise.resolve(this._pendingRequests.shift());
      }

      return new Promise(function (resolve) {
        _this2._pendingWaits.push(resolve);
      });
    }
  }]);

  return TestHttpStack;
}();

var TestRequest = /*#__PURE__*/function () {
  function TestRequest(method, url, onRequestSend) {
    _classCallCheck(this, TestRequest);

    this.method = method;
    this.url = url;
    this.requestHeaders = {};
    this.body = null;
    this._onRequestSend = onRequestSend;

    this._onProgress = function () {};

    var _flatPromise3 = flatPromise();

    var _flatPromise4 = _slicedToArray(_flatPromise3, 3);

    this._requestPromise = _flatPromise4[0];
    this._resolveRequest = _flatPromise4[1];
    this._rejectRequest = _flatPromise4[2];
  }

  _createClass(TestRequest, [{
    key: "getMethod",
    value: function getMethod() {
      return this.method;
    }
  }, {
    key: "getURL",
    value: function getURL() {
      return this.url;
    }
  }, {
    key: "setHeader",
    value: function setHeader(header, value) {
      this.requestHeaders[header] = value;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this.requestHeaders[header] || null;
    }
  }, {
    key: "setProgressHandler",
    value: function setProgressHandler(progressHandler) {
      this._onProgress = progressHandler;
    }
  }, {
    key: "send",
    value: function send() {
      var body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      this.body = body;

      if (body) {
        this._onProgress(0);

        this._onProgress(body.length || body.size || 0);
      }

      this._onRequestSend(this);

      return this._requestPromise;
    }
  }, {
    key: "abort",
    value: function abort() {
      this._rejectRequest(new Error('request aborted'));
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      throw new Error('not implemented');
    }
  }, {
    key: "respondWith",
    value: function respondWith(resData) {
      resData.responseHeaders = resData.responseHeaders || {};
      var res = new TestResponse(resData);

      this._resolveRequest(res);
    }
  }, {
    key: "responseError",
    value: function responseError(err) {
      this._rejectRequest(err);
    }
  }]);

  return TestRequest;
}();

var TestResponse = /*#__PURE__*/function () {
  function TestResponse(res) {
    _classCallCheck(this, TestResponse);

    this._response = res;
  }

  _createClass(TestResponse, [{
    key: "getStatus",
    value: function getStatus() {
      return this._response.status;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this._response.responseHeaders[header];
    }
  }, {
    key: "getBody",
    value: function getBody() {
      return this._response.responseText;
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      throw new Error('not implemented');
    }
  }]);

  return TestResponse;
}();

module.exports = {
  TestHttpStack: TestHttpStack,
  waitableFunction: waitableFunction,
  wait: wait,
  getBlob: getBlob
};

}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":43}],58:[function(require,module,exports){
"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

/* global Blob  */
var assertUrlStorage = require('./helpers/assertUrlStorage');

var _require = require('./helpers/utils'),
    TestHttpStack = _require.TestHttpStack,
    waitableFunction = _require.waitableFunction,
    wait = _require.wait;

var tus = require('../..');

describe('tus', function () {
  beforeEach(function () {
    localStorage.clear();
  });
  describe('#Upload', function () {
    it('should resume an upload from a stored url', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      var testStack, file, options, upload, previousUploads, req;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              localStorage.setItem('tus::fingerprinted::1337', JSON.stringify({
                uploadUrl: 'http://tus.io/uploads/resuming'
              }));
              testStack = new TestHttpStack();
              file = new Blob('hello world'.split(''));
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                onProgress: function onProgress() {},
                fingerprint: function fingerprint() {}
              };
              spyOn(options, 'fingerprint').and.resolveTo('fingerprinted');
              spyOn(options, 'onProgress');
              upload = new tus.Upload(file, options);
              _context.next = 9;
              return upload.findPreviousUploads();

            case 9:
              previousUploads = _context.sent;
              expect(previousUploads).toEqual([{
                uploadUrl: 'http://tus.io/uploads/resuming',
                urlStorageKey: 'tus::fingerprinted::1337'
              }]);
              upload.resumeFromPreviousUpload(previousUploads[0]);
              upload.start();
              expect(options.fingerprint).toHaveBeenCalledWith(file, upload.options);
              _context.next = 16;
              return testStack.nextRequest();

            case 16:
              req = _context.sent;
              expect(req.url).toBe('http://tus.io/uploads/resuming');
              expect(req.method).toBe('HEAD');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 11,
                  'Upload-Offset': 3
                }
              });
              _context.next = 23;
              return testStack.nextRequest();

            case 23:
              req = _context.sent;
              expect(req.url).toBe('http://tus.io/uploads/resuming');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(3);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(11 - 3);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });
              expect(upload.url).toBe('http://tus.io/uploads/resuming');
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);

            case 33:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    describe('storing of upload urls', function () {
      var testStack = new TestHttpStack();
      var options = {
        httpStack: testStack,
        endpoint: 'http://tus.io/uploads',
        fingerprint: function fingerprint() {}
      };

      var startUpload = /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
          var file, upload, req;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  file = new Blob('hello world'.split(''));
                  spyOn(options, 'fingerprint').and.resolveTo('fingerprinted');
                  options.onSuccess = waitableFunction('onSuccess');
                  upload = new tus.Upload(file, options);
                  upload.start();
                  expect(options.fingerprint).toHaveBeenCalled();
                  _context2.next = 8;
                  return testStack.nextRequest();

                case 8:
                  req = _context2.sent;
                  expect(req.url).toBe('http://tus.io/uploads');
                  expect(req.method).toBe('POST');
                  req.respondWith({
                    status: 201,
                    responseHeaders: {
                      Location: '/uploads/blargh'
                    }
                  }); // Wait a short delay to allow the Promises to settle

                  _context2.next = 14;
                  return wait(10);

                case 14:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        return function startUpload() {
          return _ref2.apply(this, arguments);
        };
      }();

      var finishUpload = /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
          var req;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return testStack.nextRequest();

                case 2:
                  req = _context3.sent;
                  expect(req.url).toBe('http://tus.io/uploads/blargh');
                  expect(req.method).toBe('PATCH');
                  req.respondWith({
                    status: 204,
                    responseHeaders: {
                      'Upload-Offset': 11
                    }
                  });
                  _context3.next = 8;
                  return options.onSuccess.toBeCalled;

                case 8:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));

        return function finishUpload() {
          return _ref3.apply(this, arguments);
        };
      }();

      it('should store and retain with default options', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var key, storedUpload;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                options.removeFingerprintOnSuccess = false;
                _context4.next = 3;
                return startUpload();

              case 3:
                key = localStorage.key(0);
                expect(key.indexOf('tus::fingerprinted::')).toBe(0);
                storedUpload = JSON.parse(localStorage.getItem(key));
                expect(storedUpload.uploadUrl).toBe('http://tus.io/uploads/blargh');
                expect(storedUpload.size).toBe(11);
                _context4.next = 10;
                return finishUpload();

              case 10:
                expect(localStorage.getItem(key)).toBe(JSON.stringify(storedUpload));

              case 11:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      })));
      it('should store and remove with option removeFingerprintOnSuccess set', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var key, storedUpload;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                options.removeFingerprintOnSuccess = true;
                _context5.next = 3;
                return startUpload();

              case 3:
                key = localStorage.key(0);
                expect(key.indexOf('tus::fingerprinted::')).toBe(0);
                storedUpload = JSON.parse(localStorage.getItem(key));
                expect(storedUpload.uploadUrl).toBe('http://tus.io/uploads/blargh');
                expect(storedUpload.size).toBe(11);
                _context5.next = 10;
                return finishUpload();

              case 10:
                expect(localStorage.getItem(key)).toBe(null);

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      })));
    });
    it('should delete upload urls on a 4XX', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              testStack = new TestHttpStack();
              file = new Blob('hello world'.split(''));
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                fingerprint: function fingerprint() {}
              };
              spyOn(options, 'fingerprint').and.resolveTo('fingerprinted');
              upload = new tus.Upload(file, options);
              upload.resumeFromPreviousUpload({
                uploadUrl: 'http://tus.io/uploads/resuming',
                urlStorageKey: 'tus::fingerprinted::1337'
              });
              upload.start();
              _context6.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context6.sent;
              expect(req.url).toBe('http://tus.io/uploads/resuming');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 400
              });
              _context6.next = 15;
              return wait(10);

            case 15:
              expect(localStorage.getItem('tus::fingerprinted::1337')).toBe(null);

            case 16:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    })));
    describe('uploading data from a Reader', function () {
      function makeReader(content) {
        var readSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : content.length;
        var reader = {
          value: content.split(''),
          read: function read() {
            var value,
                done = false;

            if (this.value.length > 0) {
              value = this.value.slice(0, readSize);
              this.value = this.value.slice(readSize);
            } else {
              done = true;
            }

            return Promise.resolve({
              value: value,
              done: done
            });
          },
          cancel: waitableFunction('cancel')
        };
        return reader;
      }

      function assertReaderUpload(_x) {
        return _assertReaderUpload.apply(this, arguments);
      }

      function _assertReaderUpload() {
        _assertReaderUpload = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(_ref7) {
          var readSize, chunkSize, reader, testStack, options, upload, req;
          return regeneratorRuntime.wrap(function _callee14$(_context14) {
            while (1) {
              switch (_context14.prev = _context14.next) {
                case 0:
                  readSize = _ref7.readSize, chunkSize = _ref7.chunkSize;
                  reader = makeReader('hello world', readSize);
                  testStack = new TestHttpStack();
                  options = {
                    httpStack: testStack,
                    endpoint: 'http://tus.io/uploads',
                    chunkSize: chunkSize,
                    onProgress: waitableFunction('onProgress'),
                    onSuccess: waitableFunction('onSuccess'),
                    fingerprint: function fingerprint() {},
                    uploadLengthDeferred: true
                  };
                  spyOn(options, 'fingerprint').and.resolveTo('fingerprinted');
                  upload = new tus.Upload(reader, options);
                  upload.start();
                  expect(options.fingerprint).toHaveBeenCalledWith(reader, upload.options);
                  _context14.next = 10;
                  return testStack.nextRequest();

                case 10:
                  req = _context14.sent;
                  expect(req.url).toBe('http://tus.io/uploads');
                  expect(req.method).toBe('POST');
                  expect(req.requestHeaders['Upload-Length']).toBe(undefined);
                  expect(req.requestHeaders['Upload-Defer-Length']).toBe(1);
                  req.respondWith({
                    status: 201,
                    responseHeaders: {
                      Location: 'http://tus.io/uploads/blargh'
                    }
                  });
                  _context14.next = 18;
                  return testStack.nextRequest();

                case 18:
                  req = _context14.sent;
                  expect(req.url).toBe('http://tus.io/uploads/blargh');
                  expect(req.method).toBe('PATCH');
                  expect(req.requestHeaders['Upload-Offset']).toBe(0);
                  expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
                  expect(req.body.length).toBe(11);
                  req.respondWith({
                    status: 204,
                    responseHeaders: {
                      'Upload-Offset': 11
                    }
                  });
                  _context14.next = 27;
                  return options.onProgress.toBeCalled;

                case 27:
                  expect(options.onProgress).toHaveBeenCalledWith(11, null);
                  _context14.next = 30;
                  return testStack.nextRequest();

                case 30:
                  req = _context14.sent;
                  expect(req.url).toBe('http://tus.io/uploads/blargh');
                  expect(req.method).toBe('PATCH');
                  expect(req.requestHeaders['Upload-Offset']).toBe(11);
                  expect(req.requestHeaders['Upload-Length']).toBe(11);
                  expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
                  expect(req.body).toBe(null);
                  req.respondWith({
                    status: 204,
                    responseHeaders: {
                      'Upload-Offset': 11
                    }
                  });
                  _context14.next = 40;
                  return options.onSuccess.toBeCalled;

                case 40:
                  expect(upload.url).toBe('http://tus.io/uploads/blargh');
                  expect(options.onProgress).toHaveBeenCalledWith(11, 11);

                case 42:
                case "end":
                  return _context14.stop();
              }
            }
          }, _callee14);
        }));
        return _assertReaderUpload.apply(this, arguments);
      }

      it('should upload data', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return assertReaderUpload({
                  chunkSize: 100,
                  readSize: 100
                });

              case 2:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      })));
      it('should read multiple times from the reader', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return assertReaderUpload({
                  chunkSize: 100,
                  readSize: 6
                });

              case 2:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      })));
      it('should use multiple PATCH requests', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        var reader, testStack, options, upload, req;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                reader = makeReader('hello world', 1);
                testStack = new TestHttpStack();
                options = {
                  httpStack: testStack,
                  endpoint: 'http://tus.io/uploads',
                  chunkSize: 6,
                  onProgress: waitableFunction('onProgress'),
                  onSuccess: waitableFunction('onSuccess'),
                  fingerprint: function fingerprint() {},
                  uploadLengthDeferred: true
                };
                spyOn(options, 'fingerprint').and.resolveTo('fingerprinted');
                upload = new tus.Upload(reader, options);
                upload.start();
                expect(options.fingerprint).toHaveBeenCalledWith(reader, upload.options);
                _context9.next = 9;
                return testStack.nextRequest();

              case 9:
                req = _context9.sent;
                expect(req.url).toBe('http://tus.io/uploads');
                expect(req.method).toBe('POST');
                expect(req.requestHeaders['Upload-Length']).toBe(undefined);
                expect(req.requestHeaders['Upload-Defer-Length']).toBe(1);
                req.respondWith({
                  status: 201,
                  responseHeaders: {
                    Location: 'http://tus.io/uploads/blargh'
                  }
                });
                _context9.next = 17;
                return testStack.nextRequest();

              case 17:
                req = _context9.sent;
                expect(req.url).toBe('http://tus.io/uploads/blargh');
                expect(req.method).toBe('PATCH');
                expect(req.requestHeaders['Upload-Offset']).toBe(0);
                expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
                expect(req.body.length).toBe(6);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 6
                  }
                });
                _context9.next = 26;
                return options.onProgress.toBeCalled;

              case 26:
                expect(options.onProgress).toHaveBeenCalledWith(6, null);
                _context9.next = 29;
                return testStack.nextRequest();

              case 29:
                req = _context9.sent;
                expect(req.url).toBe('http://tus.io/uploads/blargh');
                expect(req.method).toBe('PATCH');
                expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
                expect(req.requestHeaders['Upload-Offset']).toBe(6);
                expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
                expect(req.body.length).toBe(5);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 11
                  }
                });
                _context9.next = 39;
                return testStack.nextRequest();

              case 39:
                req = _context9.sent;
                expect(req.url).toBe('http://tus.io/uploads/blargh');
                expect(req.method).toBe('PATCH');
                expect(req.requestHeaders['Upload-Offset']).toBe(11);
                expect(req.requestHeaders['Upload-Length']).toBe(11);
                expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
                expect(req.body).toBe(null);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 11
                  }
                });
                _context9.next = 49;
                return options.onSuccess.toBeCalled;

              case 49:
                expect(upload.url).toBe('http://tus.io/uploads/blargh');
                expect(options.onProgress).toHaveBeenCalledWith(11, 11);

              case 51:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      })));
      it('should retry the POST request', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
        var reader, testStack, options, upload, req;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                reader = makeReader('hello world', 1);
                testStack = new TestHttpStack();
                options = {
                  httpStack: testStack,
                  endpoint: 'http://tus.io/files/',
                  chunkSize: 11,
                  retryDelays: [10, 10, 10],
                  onSuccess: waitableFunction('onSuccess'),
                  uploadLengthDeferred: true
                };
                upload = new tus.Upload(reader, options);
                upload.start();
                _context10.next = 7;
                return testStack.nextRequest();

              case 7:
                req = _context10.sent;
                expect(req.url).toBe('http://tus.io/files/');
                expect(req.method).toBe('POST');
                req.respondWith({
                  status: 500
                });
                _context10.next = 13;
                return testStack.nextRequest();

              case 13:
                req = _context10.sent;
                expect(req.url).toBe('http://tus.io/files/');
                expect(req.method).toBe('POST');
                req.respondWith({
                  status: 201,
                  responseHeaders: {
                    Location: '/files/foo'
                  }
                });
                _context10.next = 19;
                return testStack.nextRequest();

              case 19:
                req = _context10.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 11
                  }
                });
                _context10.next = 25;
                return testStack.nextRequest();

              case 25:
                req = _context10.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                expect(req.requestHeaders['Upload-Length']).toBe(11);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 11
                  }
                });
                _context10.next = 32;
                return options.onSuccess.toBeCalled;

              case 32:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10);
      })));
      it('should retry the first PATCH request', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
        var reader, testStack, options, upload, req;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                reader = makeReader('hello world', 1);
                testStack = new TestHttpStack();
                options = {
                  httpStack: testStack,
                  endpoint: 'http://tus.io/files/',
                  chunkSize: 11,
                  retryDelays: [10, 10, 10],
                  onSuccess: waitableFunction('onSuccess'),
                  uploadLengthDeferred: true
                };
                upload = new tus.Upload(reader, options);
                upload.start();
                _context11.next = 7;
                return testStack.nextRequest();

              case 7:
                req = _context11.sent;
                expect(req.url).toBe('http://tus.io/files/');
                expect(req.method).toBe('POST');
                req.respondWith({
                  status: 201,
                  responseHeaders: {
                    Location: '/files/foo'
                  }
                });
                _context11.next = 13;
                return testStack.nextRequest();

              case 13:
                req = _context11.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                req.respondWith({
                  status: 500
                });
                _context11.next = 19;
                return testStack.nextRequest();

              case 19:
                req = _context11.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('HEAD');
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 0
                  }
                });
                _context11.next = 25;
                return testStack.nextRequest();

              case 25:
                req = _context11.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 11
                  }
                });
                _context11.next = 31;
                return testStack.nextRequest();

              case 31:
                req = _context11.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                expect(req.requestHeaders['Upload-Length']).toBe(11);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 11
                  }
                });
                _context11.next = 38;
                return options.onSuccess.toBeCalled;

              case 38:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11);
      })));
      it('should retry following PATCH requests', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
        var reader, testStack, options, upload, req;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                reader = makeReader('hello world there!');
                testStack = new TestHttpStack();
                options = {
                  httpStack: testStack,
                  endpoint: 'http://tus.io/files/',
                  chunkSize: 6,
                  retryDelays: [10, 10, 10],
                  onSuccess: function onSuccess() {},
                  uploadLengthDeferred: true
                };
                upload = new tus.Upload(reader, options);
                upload.start();
                _context12.next = 7;
                return testStack.nextRequest();

              case 7:
                req = _context12.sent;
                expect(req.url).toBe('http://tus.io/files/');
                expect(req.method).toBe('POST');
                req.respondWith({
                  status: 201,
                  responseHeaders: {
                    Location: '/files/foo'
                  }
                });
                _context12.next = 13;
                return testStack.nextRequest();

              case 13:
                req = _context12.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 6
                  }
                });
                _context12.next = 19;
                return testStack.nextRequest();

              case 19:
                req = _context12.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                req.respondWith({
                  status: 500
                });
                _context12.next = 25;
                return testStack.nextRequest();

              case 25:
                req = _context12.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('HEAD');
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 6
                  }
                });
                _context12.next = 31;
                return testStack.nextRequest();

              case 31:
                req = _context12.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 12
                  }
                });
                _context12.next = 37;
                return testStack.nextRequest();

              case 37:
                req = _context12.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 18
                  }
                });
                _context12.next = 43;
                return testStack.nextRequest();

              case 43:
                req = _context12.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                expect(req.requestHeaders['Upload-Length']).toBe(18);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 18
                  }
                });
                _context12.next = 50;
                return options.onSuccess.toBeCalled;

              case 50:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12);
      })));
      it('should cancel the reader when aborted', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
        var reader, options, upload;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                reader = makeReader('hello there world');
                options = {
                  httpStack: new TestHttpStack(),
                  endpoint: 'http://tus.io/files/',
                  chunkSize: 6,
                  retryDelays: [10, 10, 10],
                  onSuccess: function onSuccess() {},
                  uploadLengthDeferred: true
                };
                upload = new tus.Upload(reader, options);
                upload.start(); // We wait until the first request arrives, so that the first promises have resolved.

                _context13.next = 6;
                return options.httpStack.nextRequest();

              case 6:
                upload.abort();
                _context13.next = 9;
                return reader.cancel.toBeCalled;

              case 9:
                expect(reader.cancel).toHaveBeenCalled();

              case 10:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13);
      })));
    });
    describe('resolving of URIs', function () {
      // Disable these tests for IE 10 and 11 because it's not possible to overwrite
      // the navigator.product property.
      var isIE = navigator.userAgent.indexOf('Trident/') > 0;

      if (isIE) {
        console.log('Skipping tests for React Native in Internet Explorer'); // eslint-disable-line no-console

        return;
      }

      var originalProduct = navigator.product;
      beforeEach(function () {
        jasmine.Ajax.install(); // Simulate React Native environment to enable URIs as input objects.

        Object.defineProperty(navigator, 'product', {
          value: 'ReactNative',
          configurable: true
        });
      });
      afterEach(function () {
        jasmine.Ajax.uninstall();
        Object.defineProperty(navigator, 'product', {
          value: originalProduct,
          configurable: true
        });
      });
      it('should upload a file from an URI', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {
        var file, testStack, options, upload, req;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                file = {
                  uri: 'file:///my/file.dat'
                };
                testStack = new TestHttpStack();
                options = {
                  httpStack: testStack,
                  endpoint: 'http://tus.io/uploads',
                  onSuccess: waitableFunction('onSuccess')
                };
                upload = new tus.Upload(file, options);
                upload.start(); // Wait a short interval to make sure that the XHR has been sent.

                _context15.next = 7;
                return wait(0);

              case 7:
                req = jasmine.Ajax.requests.mostRecent();
                expect(req.url).toBe('file:///my/file.dat');
                expect(req.method).toBe('GET');
                expect(req.responseType).toBe('blob');
                req.respondWith({
                  status: 200,
                  responseHeaders: {
                    'Upload-Length': 11,
                    'Upload-Offset': 3
                  },
                  response: new Blob('hello world'.split(''))
                });
                _context15.next = 14;
                return testStack.nextRequest();

              case 14:
                req = _context15.sent;
                expect(req.url).toBe('http://tus.io/uploads');
                expect(req.method).toBe('POST');
                expect(req.requestHeaders['Upload-Length']).toBe(11);
                req.respondWith({
                  status: 201,
                  responseHeaders: {
                    Location: '/uploads/blargh'
                  }
                });
                _context15.next = 21;
                return testStack.nextRequest();

              case 21:
                req = _context15.sent;
                expect(req.url).toBe('http://tus.io/uploads/blargh');
                expect(req.method).toBe('PATCH');
                expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
                expect(req.requestHeaders['Upload-Offset']).toBe(0);
                expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
                expect(req.body.size).toBe(11);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 11
                  }
                });
                _context15.next = 31;
                return options.onSuccess.toBeCalled;

              case 31:
                expect(upload.url).toBe('http://tus.io/uploads/blargh');

              case 32:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15);
      })));
      it("should emit an error if it can't resolve the URI", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16() {
        var file, options, upload, req;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                file = {
                  uri: 'file:///my/file.dat'
                };
                options = {
                  endpoint: 'http://tus.io/uploads',
                  onError: waitableFunction('onError')
                };
                upload = new tus.Upload(file, options);
                upload.start(); // Wait a short interval to make sure that the XHR has been sent.

                _context16.next = 6;
                return wait(0);

              case 6:
                req = jasmine.Ajax.requests.mostRecent();
                expect(req.url).toBe('file:///my/file.dat');
                expect(req.method).toBe('GET');
                expect(req.responseType).toBe('blob');
                req.responseError();
                _context16.next = 13;
                return options.onError.toBeCalled;

              case 13:
                expect(options.onError).toHaveBeenCalledWith(new Error('tus: cannot fetch `file.uri` as Blob, make sure the uri is correct and accessible. [object Object]'));

              case 14:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16);
      })));
    });
  });
  describe('#LocalStorageUrlStorage', function () {
    it('should allow storing and retrieving uploads', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17() {
      return regeneratorRuntime.wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              _context17.next = 2;
              return assertUrlStorage(tus.defaultOptions.urlStorage);

            case 2:
            case "end":
              return _context17.stop();
          }
        }
      }, _callee17);
    })));
  });
});

},{"../..":4,"./helpers/assertUrlStorage":55,"./helpers/utils":57}],59:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _require = require('./helpers/utils'),
    TestHttpStack = _require.TestHttpStack,
    waitableFunction = _require.waitableFunction,
    wait = _require.wait,
    getBlob = _require.getBlob;

var tus = require('../..'); // Uncomment to enable debug log from tus-js-client
// tus.enableDebugLog();


describe('tus', function () {
  describe('#isSupported', function () {
    it('should be true', function () {
      expect(tus.isSupported).toBe(true);
    });
  });
  describe('#Upload', function () {
    it('should throw if no error handler is available', function () {
      var upload = new tus.Upload(null);
      expect(upload.start.bind(upload)).toThrowError('tus: no file or stream to upload provided');
    });
    it('should throw if no endpoint and upload URL is provided', function () {
      var file = getBlob('hello world');
      var upload = new tus.Upload(file);
      expect(upload.start.bind(upload)).toThrowError('tus: neither an endpoint or an upload URL is provided');
    });
    it('should upload a file', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'https://tus.io/uploads',
                headers: {
                  Custom: 'blargh'
                },
                metadata: {
                  foo: 'hello',
                  bar: 'world',
                  nonlatin: 'słońce',
                  number: 100
                },
                withCredentials: true,
                onProgress: function onProgress() {},
                onSuccess: waitableFunction()
              };
              spyOn(options, 'onProgress');
              upload = new tus.Upload(file, options);
              upload.start();
              _context.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(11); // if (isBrowser) expect(req.withCredentials).toBe(true);

              expect(req.requestHeaders['Upload-Metadata']).toBe('foo aGVsbG8=,bar d29ybGQ=,nonlatin c8WCb8WEY2U=,number MTAw');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/blargh'
                }
              });
              _context.next = 18;
              return testStack.nextRequest();

            case 18:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads/blargh');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(11); // if (isBrowser) expect(req.withCredentials).toBe(true);

              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });
              _context.next = 29;
              return options.onSuccess.toBeCalled;

            case 29:
              expect(upload.url).toBe('https://tus.io/uploads/blargh');
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);

            case 31:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    it('should create an upload if resuming fails', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                uploadUrl: 'http://tus.io/uploads/resuming'
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context2.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context2.sent;
              expect(req.url).toBe('http://tus.io/uploads/resuming');
              expect(req.method).toBe('HEAD');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              req.respondWith({
                status: 404
              });
              _context2.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context2.sent;
              expect(req.url).toBe('http://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(11); // The upload URL should be cleared when tus-js.client tries to create a new upload.

              expect(upload.url).toBe(null);

            case 20:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })));
    it('should create an upload using the creation-with-data extension', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                uploadDataDuringCreation: true,
                onProgress: function onProgress() {},
                onChunkComplete: function onChunkComplete() {},
                onSuccess: waitableFunction('onSuccess')
              };
              spyOn(options, 'onProgress');
              spyOn(options, 'onChunkComplete');
              upload = new tus.Upload(file, options);
              upload.start();
              _context3.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context3.sent;
              expect(req.url).toBe('http://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(11);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(11);
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'http://tus.io/uploads/blargh',
                  'Upload-Offset': 11
                }
              });
              _context3.next = 19;
              return options.onSuccess.toBeCalled;

            case 19:
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(options.onChunkComplete).toHaveBeenCalledWith(11, 11, 11);
              expect(options.onSuccess).toHaveBeenCalled();
              expect(upload.url).toBe('http://tus.io/uploads/blargh');

            case 23:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    })));
    it('should create an upload with partial data and continue', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                uploadDataDuringCreation: true,
                chunkSize: 6,
                onProgress: function onProgress() {},
                onChunkComplete: function onChunkComplete() {},
                onSuccess: waitableFunction('onSuccess')
              };
              spyOn(options, 'onProgress');
              spyOn(options, 'onChunkComplete');
              upload = new tus.Upload(file, options);
              upload.start();
              _context4.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context4.sent;
              expect(req.url).toBe('http://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(11);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(6);
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'http://tus.io/uploads/blargh',
                  'Upload-Offset': 6
                }
              });
              _context4.next = 19;
              return testStack.nextRequest();

            case 19:
              req = _context4.sent;
              // Once the second request has been sent, the progress handler must have been invoked.
              expect(options.onProgress).toHaveBeenCalledWith(6, 11);
              expect(options.onChunkComplete).toHaveBeenCalledWith(6, 6, 11);
              expect(options.onSuccess).not.toHaveBeenCalled();
              expect(upload.url).toBe('http://tus.io/uploads/blargh');
              expect(req.url).toBe('http://tus.io/uploads/blargh');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(6);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(5);
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'http://tus.io/uploads/blargh',
                  'Upload-Offset': 11
                }
              });
              _context4.next = 33;
              return options.onSuccess.toBeCalled;

            case 33:
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(options.onChunkComplete).toHaveBeenCalledWith(5, 11, 11);
              expect(options.onSuccess).toHaveBeenCalled();

            case 36:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    })));
    it("should add the request's body and ID to errors", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
      var testStack, file, options, upload, req, reqId, err;
      return regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                addRequestId: true,
                retryDelays: null,
                onError: waitableFunction('onError')
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context5.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context5.sent;
              expect(req.url).toBe('http://tus.io/uploads');
              expect(req.method).toBe('POST');
              reqId = req.requestHeaders['X-Request-ID'];
              expect(_typeof(reqId)).toBe('string');
              expect(reqId.length).toBe(36);
              req.respondWith({
                status: 500,
                responseText: 'server_error'
              });
              _context5.next = 16;
              return options.onError.toBeCalled;

            case 16:
              err = _context5.sent;
              expect(err.message).toBe("tus: unexpected response while creating upload, originated from request (method: POST, url: http://tus.io/uploads, response code: 500, response text: server_error, request id: ".concat(reqId, ")"));
              expect(err.originalRequest).toBeDefined();
              expect(err.originalResponse).toBeDefined();

            case 20:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    })));
    it('should invoke the request and response callbacks', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                uploadUrl: 'http://tus.io/uploads/foo',
                onBeforeRequest: function onBeforeRequest(req) {
                  expect(req.getURL()).toBe('http://tus.io/uploads/foo');
                  expect(req.getMethod()).toBe('HEAD');
                },
                onAfterResponse: function onAfterResponse(req, res) {
                  expect(req.getURL()).toBe('http://tus.io/uploads/foo');
                  expect(req.getMethod()).toBe('HEAD');
                  expect(res.getStatus()).toBe(204);
                  expect(res.getHeader('Upload-Offset')).toBe(11);
                },
                onSuccess: waitableFunction('onSuccess')
              };
              spyOn(options, 'onBeforeRequest');
              spyOn(options, 'onAfterResponse');
              upload = new tus.Upload(file, options);
              upload.start();
              _context6.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context6.sent;
              expect(req.url).toBe('http://tus.io/uploads/foo');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11,
                  'Upload-Length': 11
                }
              });
              _context6.next = 15;
              return options.onSuccess.toBeCalled;

            case 15:
              expect(options.onBeforeRequest).toHaveBeenCalled();
              expect(options.onAfterResponse).toHaveBeenCalled();

            case 17:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    })));
    it('should throw an error if resuming fails and no endpoint is provided', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
      var testStack, file, options, upload, req, err;
      return regeneratorRuntime.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                uploadUrl: 'http://tus.io/uploads/resuming',
                onError: waitableFunction('onError')
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context7.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context7.sent;
              expect(req.url).toBe('http://tus.io/uploads/resuming');
              expect(req.method).toBe('HEAD');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              req.respondWith({
                status: 404
              });
              _context7.next = 14;
              return options.onError.toBeCalled;

            case 14:
              err = _context7.sent;
              expect(err.message).toBe('tus: unable to resume upload (new upload cannot be created without an endpoint), originated from request (method: HEAD, url: http://tus.io/uploads/resuming, response code: 404, response text: , request id: n/a)');

            case 16:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    })));
    it('should resolve relative URLs', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io:1080/files/'
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context8.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context8.sent;
              expect(req.url).toBe('http://tus.io:1080/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: '//localhost/uploads/foo'
                }
              });
              _context8.next = 13;
              return testStack.nextRequest();

            case 13:
              req = _context8.sent;
              expect(req.url).toBe('http://localhost/uploads/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });
              expect(upload.url).toBe('http://localhost/uploads/foo');

            case 18:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8);
    })));
    it('should upload a file in chunks', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                chunkSize: 7,
                onSuccess: waitableFunction('onSuccess'),
                onProgress: function onProgress() {},
                onChunkComplete: function onChunkComplete() {}
              };
              spyOn(options, 'onProgress');
              spyOn(options, 'onChunkComplete');
              upload = new tus.Upload(file, options);
              upload.start();
              _context9.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context9.sent;
              expect(req.url).toBe('http://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(11);
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: '/uploads/blargh'
                }
              });
              _context9.next = 17;
              return testStack.nextRequest();

            case 17:
              req = _context9.sent;
              expect(req.url).toBe('http://tus.io/uploads/blargh');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(7);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 7
                }
              });
              _context9.next = 27;
              return testStack.nextRequest();

            case 27:
              req = _context9.sent;
              expect(req.url).toBe('http://tus.io/uploads/blargh');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(7);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(4);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });
              _context9.next = 37;
              return options.onSuccess.toBeCalled;

            case 37:
              expect(upload.url).toBe('http://tus.io/uploads/blargh');
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(options.onChunkComplete).toHaveBeenCalledWith(7, 7, 11);
              expect(options.onChunkComplete).toHaveBeenCalledWith(4, 11, 11);

            case 41:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9);
    })));
    it('should add the original request to errors', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
      var testStack, file, options, upload, req, err;
      return regeneratorRuntime.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                retryDelays: null,
                onError: waitableFunction('onError')
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context10.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context10.sent;
              expect(req.url).toBe('http://tus.io/uploads');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 500,
                responseHeaders: {
                  Custom: 'blargh'
                }
              });
              _context10.next = 13;
              return options.onError.toBeCalled;

            case 13:
              err = _context10.sent;
              expect(upload.url).toBe(null);
              expect(err.message).toBe('tus: unexpected response while creating upload, originated from request (method: POST, url: http://tus.io/uploads, response code: 500, response text: , request id: n/a)');
              expect(err.originalRequest).toBeDefined();
              expect(err.originalResponse).toBeDefined();
              expect(err.originalResponse.getHeader('Custom')).toBe('blargh');

            case 19:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10);
    })));
    it('should only create an upload for empty files', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                onSuccess: waitableFunction('onSuccess')
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context11.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context11.sent;
              expect(req.url).toBe('http://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(0);
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'http://tus.io/uploads/empty'
                }
              });
              _context11.next = 15;
              return options.onSuccess.toBeCalled;

            case 15:
              expect(options.onSuccess).toHaveBeenCalled();

            case 16:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11);
    })));
    it('should not resume a finished upload', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                onProgress: function onProgress() {},
                onSuccess: waitableFunction('onSuccess'),
                uploadUrl: 'http://tus.io/uploads/resuming'
              };
              spyOn(options, 'onProgress');
              upload = new tus.Upload(file, options);
              upload.start();
              _context12.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context12.sent;
              expect(req.url).toBe('http://tus.io/uploads/resuming');
              expect(req.method).toBe('HEAD');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': '11',
                  'Upload-Offset': '11'
                }
              });
              _context12.next = 15;
              return options.onSuccess.toBeCalled;

            case 15:
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(options.onSuccess).toHaveBeenCalled();

            case 17:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12);
    })));
    it('should resume an upload from a specified url', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                uploadUrl: 'http://tus.io/files/upload',
                onProgress: function onProgress() {},
                onSuccess: waitableFunction('onSuccess'),
                fingerprint: function fingerprint() {}
              };
              spyOn(options, 'fingerprint').and.resolveTo('fingerprinted');
              spyOn(options, 'onProgress');
              upload = new tus.Upload(file, options);
              upload.start();
              expect(options.fingerprint).toHaveBeenCalled();
              _context13.next = 10;
              return testStack.nextRequest();

            case 10:
              req = _context13.sent;
              expect(req.url).toBe('http://tus.io/files/upload');
              expect(req.method).toBe('HEAD');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 11,
                  'Upload-Offset': 3
                }
              });
              _context13.next = 17;
              return testStack.nextRequest();

            case 17:
              req = _context13.sent;
              expect(req.url).toBe('http://tus.io/files/upload');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(3);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(11 - 3);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });
              _context13.next = 27;
              return options.onSuccess.toBeCalled;

            case 27:
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(upload.url).toBe('http://tus.io/files/upload');

            case 29:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee13);
    })));
    it('should resume a previously started upload', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                onSuccess: waitableFunction('onSuccess'),
                onError: function onError() {}
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context14.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context14.sent;
              expect(req.url).toBe('http://tus.io/uploads');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'http://tus.io/uploads/blargh'
                }
              });
              _context14.next = 13;
              return testStack.nextRequest();

            case 13:
              req = _context14.sent;
              expect(req.url).toBe('http://tus.io/uploads/blargh');
              expect(req.method).toBe('PATCH');
              upload.abort();
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              upload.start();
              _context14.next = 21;
              return testStack.nextRequest();

            case 21:
              req = _context14.sent;
              expect(req.url).toBe('http://tus.io/uploads/blargh');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5,
                  'Upload-Length': 11
                }
              });
              _context14.next = 27;
              return testStack.nextRequest();

            case 27:
              req = _context14.sent;
              expect(req.url).toBe('http://tus.io/uploads/blargh');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });
              _context14.next = 33;
              return options.onSuccess.toBeCalled;

            case 33:
              expect(options.onSuccess).toHaveBeenCalled();

            case 34:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14);
    })));
    it('should override the PATCH method', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                uploadUrl: 'http://tus.io/files/upload',
                overridePatchMethod: true
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context15.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context15.sent;
              expect(req.url).toBe('http://tus.io/files/upload');
              expect(req.method).toBe('HEAD');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 11,
                  'Upload-Offset': 3
                }
              });
              _context15.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context15.sent;
              expect(req.url).toBe('http://tus.io/files/upload');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(3);
              expect(req.requestHeaders['X-HTTP-Method-Override']).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });

            case 21:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee15);
    })));
    it('should emit an error if an upload is locked', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                uploadUrl: 'http://tus.io/files/upload',
                onError: waitableFunction('onError'),
                retryDelays: null
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context16.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context16.sent;
              expect(req.url).toBe('http://tus.io/files/upload');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 423 // Locked

              });
              _context16.next = 13;
              return options.onError.toBeCalled;

            case 13:
              expect(options.onError).toHaveBeenCalledWith(new Error('tus: upload is currently locked; retry later, originated from request (method: HEAD, url: http://tus.io/files/upload, response code: 423, response text: , request id: n/a)'));

            case 14:
            case "end":
              return _context16.stop();
          }
        }
      }, _callee16);
    })));
    it('should emit an error if no Location header is presented', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                onError: waitableFunction('onError'),
                retryDelays: null
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context17.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context17.sent;
              expect(req.url).toBe('http://tus.io/uploads');
              expect(req.method).toBe('POST'); // The Location header is omitted on purpose here

              req.respondWith({
                status: 201
              });
              _context17.next = 13;
              return options.onError.toBeCalled;

            case 13:
              expect(options.onError).toHaveBeenCalledWith(new Error('tus: invalid or missing Location header, originated from request (method: POST, url: http://tus.io/uploads, response code: 201, response text: , request id: n/a)'));

            case 14:
            case "end":
              return _context17.stop();
          }
        }
      }, _callee17);
    })));
    it('should throw if retryDelays is not an array', function () {
      var file = getBlob('hello world');
      var upload = new tus.Upload(file, {
        endpoint: 'http://endpoint/',
        retryDelays: 44
      });
      expect(upload.start.bind(upload)).toThrowError('tus: the `retryDelays` option must either be an array or null');
    }); // This tests ensures that tus-js-client correctly retries if the
    // response has the code 500 Internal Error, 423 Locked or 409 Conflict.

    it('should retry the upload', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee18$(_context18) {
        while (1) {
          switch (_context18.prev = _context18.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                retryDelays: [10, 10, 10],
                onSuccess: waitableFunction('onSuccess')
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context18.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context18.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 500
              });
              _context18.next = 13;
              return testStack.nextRequest();

            case 13:
              req = _context18.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: '/files/foo'
                }
              });
              _context18.next = 19;
              return testStack.nextRequest();

            case 19:
              req = _context18.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 423
              });
              _context18.next = 25;
              return testStack.nextRequest();

            case 25:
              req = _context18.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  'Upload-Offset': 0,
                  'Upload-Length': 11
                }
              });
              _context18.next = 31;
              return testStack.nextRequest();

            case 31:
              req = _context18.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 409
              });
              _context18.next = 37;
              return testStack.nextRequest();

            case 37:
              req = _context18.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  'Upload-Offset': 0,
                  'Upload-Length': 11
                }
              });
              _context18.next = 43;
              return testStack.nextRequest();

            case 43:
              req = _context18.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });
              _context18.next = 49;
              return options.onSuccess.toBeCalled;

            case 49:
              expect(options.onSuccess).toHaveBeenCalled();

            case 50:
            case "end":
              return _context18.stop();
          }
        }
      }, _callee18);
    }))); // This tests ensures that tus-js-client correctly retries if the
    // return value of onShouldRetry is true.

    it('should retry the upload when onShouldRetry specified and returns true', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19() {
      var testStack, file, options, upload, req, error;
      return regeneratorRuntime.wrap(function _callee19$(_context19) {
        while (1) {
          switch (_context19.prev = _context19.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                retryDelays: [10, 10, 10],
                onSuccess: waitableFunction('onSuccess'),
                onShouldRetry: function onShouldRetry() {
                  return true;
                }
              };
              spyOn(options, 'onShouldRetry').and.callThrough();
              spyOn(tus.Upload.prototype, '_emitError').and.callThrough();
              upload = new tus.Upload(file, options);
              upload.start();
              _context19.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context19.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 500
              });
              _context19.next = 15;
              return testStack.nextRequest();

            case 15:
              req = _context19.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: '/files/foo'
                }
              });
              _context19.next = 21;
              return testStack.nextRequest();

            case 21:
              req = _context19.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 423
              });
              _context19.next = 27;
              return testStack.nextRequest();

            case 27:
              req = _context19.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  'Upload-Offset': 0,
                  'Upload-Length': 11
                }
              });
              _context19.next = 33;
              return testStack.nextRequest();

            case 33:
              req = _context19.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 409
              });
              _context19.next = 39;
              return testStack.nextRequest();

            case 39:
              req = _context19.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  'Upload-Offset': 0,
                  'Upload-Length': 11
                }
              });
              _context19.next = 45;
              return testStack.nextRequest();

            case 45:
              req = _context19.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });
              _context19.next = 51;
              return options.onSuccess.toBeCalled;

            case 51:
              expect(options.onSuccess).toHaveBeenCalled();
              error = upload._emitError.calls.argsFor(0)[0];
              expect(options.onShouldRetry).toHaveBeenCalled();
              expect(options.onShouldRetry.calls.argsFor(0)).toEqual([error, 0, upload.options]);
              error = upload._emitError.calls.argsFor(1)[0];
              expect(options.onShouldRetry.calls.argsFor(1)).toEqual([error, 1, upload.options]);

            case 57:
            case "end":
              return _context19.stop();
          }
        }
      }, _callee19);
    }))); // This tests ensures that tus-js-client correctly aborts if the
    // return value of onShouldRetry is false.

    it('should not retry the upload when callback specified and returns false', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee20$(_context20) {
        while (1) {
          switch (_context20.prev = _context20.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                retryDelays: [10, 10, 10],
                onSuccess: waitableFunction('onSuccess'),
                onError: waitableFunction('onError'),
                onShouldRetry: function onShouldRetry() {
                  return false;
                }
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context20.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context20.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST'); // The error callback should not be invoked for the first error response.

              expect(options.onError).not.toHaveBeenCalled();
              req.respondWith({
                status: 500
              });
              _context20.next = 14;
              return options.onError.toBeCalled;

            case 14:
              expect(options.onSuccess).not.toHaveBeenCalled();
              expect(options.onError).toHaveBeenCalledTimes(1);

            case 16:
            case "end":
              return _context20.stop();
          }
        }
      }, _callee20);
    })));
    it('should not retry if the error has not been caused by a request', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21() {
      var file, options, upload, error;
      return regeneratorRuntime.wrap(function _callee21$(_context21) {
        while (1) {
          switch (_context21.prev = _context21.next) {
            case 0:
              file = getBlob('hello world');
              options = {
                httpStack: new TestHttpStack(),
                endpoint: 'http://tus.io/files/',
                retryDelays: [10, 10, 10],
                onSuccess: function onSuccess() {},
                onError: function onError() {}
              };
              spyOn(options, 'onSuccess');
              spyOn(options, 'onError');
              upload = new tus.Upload(file, options);
              spyOn(upload, '_createUpload');
              upload.start();
              _context21.next = 9;
              return wait(200);

            case 9:
              error = new Error('custom error');

              upload._emitError(error);

              expect(upload._createUpload).toHaveBeenCalledTimes(1);
              expect(options.onError).toHaveBeenCalledWith(error);
              expect(options.onSuccess).not.toHaveBeenCalled();

            case 14:
            case "end":
              return _context21.stop();
          }
        }
      }, _callee21);
    })));
    it('should stop retrying after all delays have been used', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee22$(_context22) {
        while (1) {
          switch (_context22.prev = _context22.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                retryDelays: [10],
                onSuccess: function onSuccess() {},
                onError: waitableFunction('onError')
              };
              spyOn(options, 'onSuccess');
              upload = new tus.Upload(file, options);
              upload.start();
              _context22.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context22.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 500
              });
              _context22.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context22.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST'); // The error callback should not be invoked for the first error response.

              expect(options.onError).not.toHaveBeenCalled();
              req.respondWith({
                status: 500
              });
              _context22.next = 21;
              return options.onError.toBeCalled;

            case 21:
              expect(options.onSuccess).not.toHaveBeenCalled();
              expect(options.onError).toHaveBeenCalledTimes(1);

            case 23:
            case "end":
              return _context22.stop();
          }
        }
      }, _callee22);
    })));
    it('should stop retrying when the abort function is called', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23() {
      var testStack, file, options, upload, req, result;
      return regeneratorRuntime.wrap(function _callee23$(_context23) {
        while (1) {
          switch (_context23.prev = _context23.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                retryDelays: [10],
                onError: function onError() {}
              };
              spyOn(options, 'onError');
              upload = new tus.Upload(file, options);
              upload.start();
              _context23.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context23.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              spyOn(upload, 'start').and.callThrough();
              upload.abort();
              req.respondWith({
                status: 500
              });
              _context23.next = 16;
              return Promise.race([testStack.nextRequest(), wait(100)]);

            case 16:
              result = _context23.sent;
              expect(result).toBe('timed out');

            case 18:
            case "end":
              return _context23.stop();
          }
        }
      }, _callee23);
    })));
    it('should stop upload when the abort function is called during a callback', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24() {
      var testStack, file, options, upload, req, result;
      return regeneratorRuntime.wrap(function _callee24$(_context24) {
        while (1) {
          switch (_context24.prev = _context24.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                chunkSize: 5,
                onChunkComplete: function onChunkComplete() {
                  upload.abort();
                }
              };
              spyOn(options, 'onChunkComplete').and.callThrough();
              upload = new tus.Upload(file, options);
              upload.start();
              _context24.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context24.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: '/files/foo'
                }
              });
              _context24.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context24.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              _context24.next = 20;
              return Promise.race([testStack.nextRequest(), wait(200)]);

            case 20:
              result = _context24.sent;
              expect(options.onChunkComplete).toHaveBeenCalled();
              expect(result).toBe('timed out');

            case 23:
            case "end":
              return _context24.stop();
          }
        }
      }, _callee24);
    })));
    it('should stop upload when the abort function is called during the POST request', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25() {
      var testStack, file, options, upload, req, result;
      return regeneratorRuntime.wrap(function _callee25$(_context25) {
        while (1) {
          switch (_context25.prev = _context25.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                onError: function onError() {}
              };
              spyOn(options, 'onError').and.callThrough();
              upload = new tus.Upload(file, options);
              upload.start();
              _context25.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context25.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              upload.abort();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: '/files/foo'
                }
              });
              _context25.next = 15;
              return Promise.race([testStack.nextRequest(), wait(200)]);

            case 15:
              result = _context25.sent;
              expect(options.onError).not.toHaveBeenCalled();
              expect(result).toBe('timed out');

            case 18:
            case "end":
              return _context25.stop();
          }
        }
      }, _callee25);
    })));
    it('should reset the attempt counter if an upload proceeds', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee26$(_context26) {
        while (1) {
          switch (_context26.prev = _context26.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                retryDelays: [10],
                onError: function onError() {},
                onSuccess: waitableFunction('onSuccess')
              };
              spyOn(options, 'onError');
              upload = new tus.Upload(file, options);
              upload.start();
              _context26.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context26.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: '/files/foo'
                }
              });
              _context26.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context26.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 500
              });
              _context26.next = 20;
              return testStack.nextRequest();

            case 20:
              req = _context26.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 0,
                  'Upload-Length': 11
                }
              });
              _context26.next = 26;
              return testStack.nextRequest();

            case 26:
              req = _context26.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              _context26.next = 32;
              return testStack.nextRequest();

            case 32:
              req = _context26.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 500
              });
              _context26.next = 38;
              return testStack.nextRequest();

            case 38:
              req = _context26.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5,
                  'Upload-Length': 11
                }
              });
              _context26.next = 44;
              return testStack.nextRequest();

            case 44:
              req = _context26.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });
              _context26.next = 50;
              return options.onSuccess.toBeCalled;

            case 50:
              expect(options.onError).not.toHaveBeenCalled();
              expect(options.onSuccess).toHaveBeenCalled();

            case 52:
            case "end":
              return _context26.stop();
          }
        }
      }, _callee26);
    })));
  });
});

},{"../..":4,"./helpers/utils":57}],60:[function(require,module,exports){
"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var axios = require('axios');

var _require = require('./helpers/utils'),
    getBlob = _require.getBlob;

var tus = require('../..'); // Test timeout for end-to-end tests when uploading to real server.


var END_TO_END_TIMEOUT = 20 * 1000;
describe('tus', function () {
  describe('end-to-end', function () {
    it('should upload to a real tus server', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", new Promise(function (resolve, reject) {
                var file = getBlob('hello world');
                var options = {
                  endpoint: 'https://tusd.tusdemo.net/files/',
                  metadata: {
                    nonlatin: 'słońce',
                    number: 100,
                    filename: 'hello.txt',
                    filetype: 'text/plain'
                  },
                  onSuccess: function onSuccess() {
                    expect(upload.url).toMatch(/^https:\/\/tusd\.tusdemo\.net\/files\//);
                    console.log('Upload URL:', upload.url); // eslint-disable-line no-console

                    // eslint-disable-line no-console
                    resolve(upload);
                  },
                  onError: function onError(err) {
                    reject(err);
                  }
                };
                var upload = new tus.Upload(file, options);
                upload.start();
              }).then(validateUploadContent).then(function (upload) {
                return upload.abort(true).then(function () {
                  return upload;
                });
              }).then(validateUploadDeletion));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })), END_TO_END_TIMEOUT);
    it('should upload to a real tus server with creation-with-upload', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", new Promise(function (resolve, reject) {
                var file = getBlob('hello world');
                var options = {
                  endpoint: 'https://tusd.tusdemo.net/files/',
                  metadata: {
                    nonlatin: 'słońce',
                    number: 100,
                    filename: 'hello.txt',
                    filetype: 'text/plain'
                  },
                  onSuccess: function onSuccess() {
                    expect(upload.url).toMatch(/^https:\/\/tusd\.tusdemo\.net\/files\//);
                    console.log('Upload URL:', upload.url); // eslint-disable-line no-console

                    // eslint-disable-line no-console
                    resolve(upload);
                  },
                  onError: function onError(err) {
                    reject(err);
                  }
                };
                var upload = new tus.Upload(file, options);
                upload.start();
              }).then(validateUploadContent));

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })), END_TO_END_TIMEOUT);
  });
});

function validateUploadContent(upload) {
  return axios.get(upload.url).then(function (res) {
    expect(res.status).toBe(200);
    expect(res.data).toBe('hello world');
    return validateUploadMetadata(upload);
  });
}

function validateUploadMetadata(upload) {
  return axios.head(upload.url, {
    headers: {
      'Tus-Resumable': '1.0.0'
    }
  }).then(function (res) {
    expect(res.status).toBe(200);
    expect(res.data).toBe('');
    expect(res.headers['tus-resumable']).toBe('1.0.0');
    expect(res.headers['upload-offset']).toBe('11');
    expect(res.headers['upload-length']).toBe('11'); // The values in the Upload-Metadata header may not be in the same
    // order as we submitted them (the specification does not require
    // that). Therefore, we split the values and verify that each one
    // is present.

    var metadataStr = res.headers['upload-metadata'];
    expect(metadataStr).toBeTruthy();
    var metadata = metadataStr.split(',');
    expect(metadata).toContain('filename aGVsbG8udHh0');
    expect(metadata).toContain('filetype dGV4dC9wbGFpbg==');
    expect(metadata).toContain('nonlatin c8WCb8WEY2U=');
    expect(metadata).toContain('number MTAw');
    expect(metadata.length).toBe(4);
    return upload;
  });
}

function validateUploadDeletion(upload) {
  var validateStatus = function validateStatus(status) {
    return status === 404;
  };

  return axios.get(upload.url, {
    validateStatus: validateStatus
  }).then(function (res) {
    expect(res.status).toBe(404);
    return upload;
  });
}

},{"../..":4,"./helpers/utils":57,"axios":15}],61:[function(require,module,exports){
"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _require = require('./helpers/utils'),
    TestHttpStack = _require.TestHttpStack,
    waitableFunction = _require.waitableFunction,
    wait = _require.wait,
    getBlob = _require.getBlob;

var tus = require('../..');

describe('tus', function () {
  describe('parallel uploading', function () {
    it('should throw if incompatible options are used', function () {
      var file = getBlob('hello world');
      var upload = new tus.Upload(file, {
        endpoint: 'https://tus.io/uploads',
        parallelUploads: 2,
        uploadUrl: 'foo'
      });
      expect(upload.start.bind(upload)).toThrowError('tus: cannot use the uploadUrl option when parallelUploads is enabled');
    });
    it('should split a file into multiple parts and create an upload for each', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      var testStack, testUrlStorage, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              testStack = new TestHttpStack();
              testUrlStorage = {
                addUpload: function addUpload(fingerprint, upload) {
                  expect(fingerprint).toBe('fingerprinted');
                  expect(upload.uploadUrl).toBeUndefined();
                  expect(upload.size).toBe(11);
                  expect(upload.parallelUploadUrls).toEqual(['https://tus.io/uploads/upload1', 'https://tus.io/uploads/upload2']);
                  return Promise.resolve('tus::fingerprinted::1337');
                },
                removeUpload: function removeUpload(urlStorageKey) {
                  expect(urlStorageKey).toBe('tus::fingerprinted::1337');
                  return Promise.resolve();
                }
              };
              spyOn(testUrlStorage, 'removeUpload').and.callThrough();
              spyOn(testUrlStorage, 'addUpload').and.callThrough();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                urlStorage: testUrlStorage,
                storeFingerprintForResuming: true,
                removeFingerprintOnSuccess: true,
                parallelUploads: 2,
                retryDelays: [10],
                endpoint: 'https://tus.io/uploads',
                headers: {
                  Custom: 'blargh'
                },
                metadata: {
                  foo: 'hello'
                },
                onProgress: function onProgress() {},
                onSuccess: waitableFunction(),
                fingerprint: function fingerprint() {
                  return Promise.resolve('fingerprinted');
                }
              };
              spyOn(options, 'onProgress');
              upload = new tus.Upload(file, options);
              upload.start();
              _context.next = 11;
              return testStack.nextRequest();

            case 11:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(5);
              expect(req.requestHeaders['Upload-Concat']).toBe('partial');
              expect(req.requestHeaders['Upload-Metadata']).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload1'
                }
              });
              _context.next = 22;
              return testStack.nextRequest();

            case 22:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(6);
              expect(req.requestHeaders['Upload-Concat']).toBe('partial');
              expect(req.requestHeaders['Upload-Metadata']).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload2'
                }
              });
              _context.next = 33;
              return testStack.nextRequest();

            case 33:
              req = _context.sent;
              // Assert that the URLs have been stored.
              expect(testUrlStorage.addUpload).toHaveBeenCalled();
              expect(req.url).toBe('https://tus.io/uploads/upload1');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(5);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              _context.next = 45;
              return testStack.nextRequest();

            case 45:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(6); // Return an error to ensure that the individual partial upload is properly retried.

              req.respondWith({
                status: 500
              });
              _context.next = 56;
              return testStack.nextRequest();

            case 56:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 11,
                  'Upload-Offset': 0
                }
              });
              _context.next = 62;
              return testStack.nextRequest();

            case 62:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(6);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 6
                }
              });
              _context.next = 73;
              return testStack.nextRequest();

            case 73:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBeUndefined();
              expect(req.requestHeaders['Upload-Concat']).toBe('final;https://tus.io/uploads/upload1 https://tus.io/uploads/upload2');
              expect(req.requestHeaders['Upload-Metadata']).toBe('foo aGVsbG8=');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload3'
                }
              });
              _context.next = 84;
              return options.onSuccess.toBeCalled;

            case 84:
              expect(upload.url).toBe('https://tus.io/uploads/upload3');
              expect(options.onProgress).toHaveBeenCalledWith(5, 11);
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(testUrlStorage.removeUpload).toHaveBeenCalled();

            case 88:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    it('should emit error from a partial upload', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
      var testStack, file, options, upload, req, err;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                parallelUploads: 2,
                retryDelays: null,
                endpoint: 'https://tus.io/uploads',
                onError: waitableFunction('onError')
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context2.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context2.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(5);
              req.respondWith({
                status: 500
              });
              _context2.next = 15;
              return options.onError.toBeCalled;

            case 15:
              err = _context2.sent;
              expect(err.message).toBe('tus: unexpected response while creating upload, originated from request (method: POST, url: https://tus.io/uploads, response code: 500, response text: , request id: n/a)');
              expect(err.originalRequest).toBe(req);

            case 18:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })));
    it('should resume the partial uploads', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                // The client should resume the parallel uploads, even if it is not
                // configured for new uploads.
                parallelUploads: 1,
                endpoint: 'https://tus.io/uploads',
                onProgress: function onProgress() {},
                onSuccess: waitableFunction()
              };
              spyOn(options, 'onProgress');
              upload = new tus.Upload(file, options);
              upload.resumeFromPreviousUpload({
                urlStorageKey: 'tus::fingerprint::1337',
                parallelUploadUrls: ['https://tus.io/uploads/upload1', 'https://tus.io/uploads/upload2']
              });
              upload.start();
              _context3.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context3.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload1');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 5,
                  'Upload-Offset': 2
                }
              });
              _context3.next = 15;
              return testStack.nextRequest();

            case 15:
              req = _context3.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 6,
                  'Upload-Offset': 0
                }
              });
              _context3.next = 21;
              return testStack.nextRequest();

            case 21:
              req = _context3.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload1');
              expect(req.method).toBe('PATCH');
              expect(req.body.size).toBe(3);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              _context3.next = 28;
              return testStack.nextRequest();

            case 28:
              req = _context3.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('PATCH');
              expect(req.body.size).toBe(6);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 6
                }
              });
              _context3.next = 35;
              return testStack.nextRequest();

            case 35:
              req = _context3.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Upload-Concat']).toBe('final;https://tus.io/uploads/upload1 https://tus.io/uploads/upload2');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload3'
                }
              });
              _context3.next = 42;
              return options.onSuccess.toBeCalled;

            case 42:
              expect(upload.url).toBe('https://tus.io/uploads/upload3');
              expect(options.onProgress).toHaveBeenCalledWith(5, 11);
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);

            case 45:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    })));
    it('should abort all partial uploads and resume from them', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
      var testStack, file, options, upload, req, req1, req2, reqPromise, result;
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                parallelUploads: 2,
                endpoint: 'https://tus.io/uploads',
                onProgress: function onProgress() {},
                onSuccess: waitableFunction(),
                fingerprint: function fingerprint() {
                  return Promise.resolve('fingerprinted');
                }
              };
              spyOn(options, 'onProgress');
              upload = new tus.Upload(file, options);
              upload.start();
              _context4.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context4.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(5);
              expect(req.requestHeaders['Upload-Concat']).toBe('partial');
              expect(req.requestHeaders['Upload-Metadata']).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload1'
                }
              });
              _context4.next = 18;
              return testStack.nextRequest();

            case 18:
              req = _context4.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(6);
              expect(req.requestHeaders['Upload-Concat']).toBe('partial');
              expect(req.requestHeaders['Upload-Metadata']).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload2'
                }
              });
              _context4.next = 28;
              return testStack.nextRequest();

            case 28:
              req1 = _context4.sent;
              expect(req1.url).toBe('https://tus.io/uploads/upload1');
              expect(req1.method).toBe('PATCH');
              expect(req1.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req1.requestHeaders['Upload-Offset']).toBe(0);
              expect(req1.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req1.body.size).toBe(5);
              _context4.next = 37;
              return testStack.nextRequest();

            case 37:
              req2 = _context4.sent;
              expect(req2.url).toBe('https://tus.io/uploads/upload2');
              expect(req2.method).toBe('PATCH');
              expect(req2.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req2.requestHeaders['Upload-Offset']).toBe(0);
              expect(req2.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req2.body.size).toBe(6);
              upload.abort();
              req1.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              req2.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 6
                }
              }); // No further requests should be sent.

              reqPromise = testStack.nextRequest();
              _context4.next = 50;
              return Promise.race([reqPromise, wait(100)]);

            case 50:
              result = _context4.sent;
              expect(result).toBe('timed out'); // Restart the upload

              upload.start(); // Reuse the promise from before as it is not cancelled.

              _context4.next = 55;
              return reqPromise;

            case 55:
              req = _context4.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload1');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 5,
                  'Upload-Offset': 5
                }
              });
              _context4.next = 61;
              return testStack.nextRequest();

            case 61:
              req = _context4.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 6,
                  'Upload-Offset': 6
                }
              });
              _context4.next = 67;
              return testStack.nextRequest();

            case 67:
              req = _context4.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBeUndefined();
              expect(req.requestHeaders['Upload-Concat']).toBe('final;https://tus.io/uploads/upload1 https://tus.io/uploads/upload2');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload3'
                }
              });
              _context4.next = 76;
              return options.onSuccess.toBeCalled;

            case 76:
              expect(upload.url).toBe('https://tus.io/uploads/upload3');
              expect(options.onProgress).toHaveBeenCalledWith(5, 11);
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);

            case 79:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    })));
  });
});

},{"../..":4,"./helpers/utils":57}],62:[function(require,module,exports){
"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

/* global expectAsync */
var _require = require('./helpers/utils'),
    TestHttpStack = _require.TestHttpStack,
    getBlob = _require.getBlob;

var tus = require('../..');

describe('tus', function () {
  describe('terminate upload', function () {
    it('should terminate upload when abort is called with true', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      var abortPromise, testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                chunkSize: 5,
                onChunkComplete: function onChunkComplete() {
                  abortPromise = upload.abort(true);
                }
              };
              spyOn(options, 'onChunkComplete').and.callThrough();
              upload = new tus.Upload(file, options);
              upload.start();
              _context.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: '/files/foo'
                }
              });
              _context.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              _context.next = 20;
              return testStack.nextRequest();

            case 20:
              req = _context.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('DELETE');
              req.respondWith({
                status: 204
              });
              expect(options.onChunkComplete).toHaveBeenCalled();
              _context.next = 27;
              return abortPromise;

            case 27:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    it('should retry terminate when an error is returned on first try', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
      var abortPromise, testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                chunkSize: 5,
                retryDelays: [10, 10, 10],
                onChunkComplete: function onChunkComplete() {
                  abortPromise = upload.abort(true);
                }
              };
              spyOn(options, 'onChunkComplete').and.callThrough();
              upload = new tus.Upload(file, options);
              upload.start();
              _context2.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context2.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: '/files/foo'
                }
              });
              _context2.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context2.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              _context2.next = 20;
              return testStack.nextRequest();

            case 20:
              req = _context2.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('DELETE');
              req.respondWith({
                status: 423
              });
              _context2.next = 26;
              return testStack.nextRequest();

            case 26:
              req = _context2.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('DELETE');
              req.respondWith({
                status: 204
              });
              _context2.next = 32;
              return abortPromise;

            case 32:
              expect(options.onChunkComplete).toHaveBeenCalled();

            case 33:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })));
    it('should stop retrying when all delays are used up', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
      var testStack, options, terminatePromise, req;
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              testStack = new TestHttpStack();
              options = {
                httpStack: testStack,
                retryDelays: [10, 10]
              };
              terminatePromise = tus.Upload.terminate('http://tus.io/files/foo', options);
              _context3.next = 5;
              return testStack.nextRequest();

            case 5:
              req = _context3.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('DELETE');
              req.respondWith({
                status: 500
              });
              _context3.next = 11;
              return testStack.nextRequest();

            case 11:
              req = _context3.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('DELETE');
              req.respondWith({
                status: 500
              });
              _context3.next = 17;
              return testStack.nextRequest();

            case 17:
              req = _context3.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('DELETE');
              req.respondWith({
                status: 500
              });
              _context3.next = 23;
              return expectAsync(terminatePromise).toBeRejectedWithError(/tus: unexpected response while terminating upload/);

            case 23:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    })));
    it('should invoke the request and response Promises', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
      var testStack, options, terminatePromise, req;
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              testStack = new TestHttpStack();
              options = {
                httpStack: testStack,
                onBeforeRequest: function onBeforeRequest(req) {
                  return new Promise(function (resolve) {
                    expect(req.getURL()).toBe('http://tus.io/uploads/foo');
                    expect(req.getMethod()).toBe('DELETE');
                    resolve();
                  });
                },
                onAfterResponse: function onAfterResponse(req, res) {
                  return new Promise(function (resolve) {
                    expect(req.getURL()).toBe('http://tus.io/uploads/foo');
                    expect(req.getMethod()).toBe('DELETE');
                    expect(res.getStatus()).toBe(204);
                    resolve();
                  });
                }
              };
              spyOn(options, 'onBeforeRequest');
              spyOn(options, 'onAfterResponse');
              terminatePromise = tus.Upload.terminate('http://tus.io/uploads/foo', options);
              _context4.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context4.sent;
              expect(req.url).toBe('http://tus.io/uploads/foo');
              expect(req.method).toBe('DELETE');
              req.respondWith({
                status: 204
              });
              _context4.next = 13;
              return expectAsync(terminatePromise).toBeResolved();

            case 13:
              expect(options.onBeforeRequest).toHaveBeenCalled();
              expect(options.onAfterResponse).toHaveBeenCalled();

            case 15:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    })));
  });
});

},{"../..":4,"./helpers/utils":57}]},{},[54])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWIuZXM1L2Jyb3dzZXIvZmlsZVJlYWRlci5qcyIsImxpYi5lczUvYnJvd3Nlci9maW5nZXJwcmludC5qcyIsImxpYi5lczUvYnJvd3Nlci9odHRwU3RhY2suanMiLCJsaWIuZXM1L2Jyb3dzZXIvaW5kZXguanMiLCJsaWIuZXM1L2Jyb3dzZXIvaXNDb3Jkb3ZhLmpzIiwibGliLmVzNS9icm93c2VyL2lzUmVhY3ROYXRpdmUuanMiLCJsaWIuZXM1L2Jyb3dzZXIvcmVhZEFzQnl0ZUFycmF5LmpzIiwibGliLmVzNS9icm93c2VyL3VyaVRvQmxvYi5qcyIsImxpYi5lczUvYnJvd3Nlci91cmxTdG9yYWdlLmpzIiwibGliLmVzNS9lcnJvci5qcyIsImxpYi5lczUvbG9nZ2VyLmpzIiwibGliLmVzNS9ub29wVXJsU3RvcmFnZS5qcyIsImxpYi5lczUvdXBsb2FkLmpzIiwibGliLmVzNS91dWlkLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvYnVpbGRGdWxsUGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZW5oYW5jZUVycm9yLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL21lcmdlQ29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0F4aW9zRXJyb3IuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCJub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VzNi1wcm9taXNlL2F1dG8uanMiLCJub2RlX21vZHVsZXMvZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanMtYmFzZTY0L2Jhc2U2NC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmdpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwibm9kZV9tb2R1bGVzL3JlcXVpcmVzLXBvcnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdXJsLXBhcnNlL2luZGV4LmpzIiwidGVzdC9zcGVjL2Jyb3dzZXItaW5kZXguanMiLCJ0ZXN0L3NwZWMvaGVscGVycy9hc3NlcnRVcmxTdG9yYWdlLmpzIiwidGVzdC9zcGVjL2hlbHBlcnMvcHVwcGV0ZWVyL3JlcG9ydGVyLmpzIiwidGVzdC9zcGVjL2hlbHBlcnMvdXRpbHMuanMiLCJ0ZXN0L3NwZWMvdGVzdC1icm93c2VyLXNwZWNpZmljLmpzIiwidGVzdC9zcGVjL3Rlc3QtY29tbW9uLmpzIiwidGVzdC9zcGVjL3Rlc3QtZW5kLXRvLWVuZC5qcyIsInRlc3Qvc3BlYy90ZXN0LXBhcmFsbGVsLXVwbG9hZHMuanMiLCJ0ZXN0L3NwZWMvdGVzdC10ZXJtaW5hdGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTs7QUFFQSxNQUFNLENBQUMsY0FBUCxDQUFzQixPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUMzQyxFQUFBLEtBQUssRUFBRTtBQURvQyxDQUE3QztBQUdBLE9BQU8sV0FBUCxHQUFrQixLQUFLLENBQXZCOztBQUVBLElBQUksY0FBYyxHQUFHLHNCQUFzQixDQUFDLE9BQU8sQ0FBQyxpQkFBRCxDQUFSLENBQTNDOztBQUVBLElBQUksVUFBVSxHQUFHLHNCQUFzQixDQUFDLE9BQU8sQ0FBQyxhQUFELENBQVIsQ0FBdkM7O0FBRUEsSUFBSSxVQUFVLEdBQUcsc0JBQXNCLENBQUMsT0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVnREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QXhCO0FBRUEsY0FBQSxHQUFHLENBQUMsV0FBSixDQUFnQjtBQUNkLGdCQUFBLE1BQU0sRUFBRTtBQURNLGVBQWhCO0FBN0JvRDtBQUFBLHFCQWlDOUMsV0FBVyxDQUFDLGdCQUFELENBQVgsQ0FBOEIsWUFBOUIsRUFqQzhDOztBQUFBO0FBa0NwRCxjQUFBLE1BQU0sQ0FBQyxPQUFPLENBQUMsZUFBVCxDQUFOLENBQWdDLGdCQUFoQztBQUNBLGNBQUEsTUFBTSxDQUFDLE9BQU8sQ0FBQyxlQUFULENBQU4sQ0FBZ0MsZ0JBQWhDOztBQW5Db0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FBcEQsR0FBRjtBQXFDRCxHQTNMTyxDQUFSO0FBNExELENBN0xPLENBQVIiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9pc1JlYWN0TmF0aXZlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pc1JlYWN0TmF0aXZlXCIpKTtcblxudmFyIF91cmlUb0Jsb2IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3VyaVRvQmxvYlwiKSk7XG5cbnZhciBfaXNDb3Jkb3ZhID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pc0NvcmRvdmFcIikpO1xuXG52YXIgX3JlYWRBc0J5dGVBcnJheSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmVhZEFzQnl0ZUFycmF5XCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG52YXIgRmlsZVNvdXJjZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIE1ha2UgdGhpcy5zaXplIGEgbWV0aG9kXG4gIGZ1bmN0aW9uIEZpbGVTb3VyY2UoZmlsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGaWxlU291cmNlKTtcblxuICAgIHRoaXMuX2ZpbGUgPSBmaWxlO1xuICAgIHRoaXMuc2l6ZSA9IGZpbGUuc2l6ZTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhGaWxlU291cmNlLCBbe1xuICAgIGtleTogXCJzbGljZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgICAvLyBJbiBBcGFjaGUgQ29yZG92YSBhcHBsaWNhdGlvbnMsIGEgRmlsZSBtdXN0IGJlIHJlc29sdmVkIHVzaW5nXG4gICAgICAvLyBGaWxlUmVhZGVyIGluc3RhbmNlcywgc2VlXG4gICAgICAvLyBodHRwczovL2NvcmRvdmEuYXBhY2hlLm9yZy9kb2NzL2VuLzgueC9yZWZlcmVuY2UvY29yZG92YS1wbHVnaW4tZmlsZS9pbmRleC5odG1sI3JlYWQtYS1maWxlXG4gICAgICBpZiAoKDAsIF9pc0NvcmRvdmEuZGVmYXVsdCkoKSkge1xuICAgICAgICByZXR1cm4gKDAsIF9yZWFkQXNCeXRlQXJyYXkuZGVmYXVsdCkodGhpcy5fZmlsZS5zbGljZShzdGFydCwgZW5kKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2ZpbGUuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHsvLyBOb3RoaW5nIHRvIGRvIGhlcmUgc2luY2Ugd2UgZG9uJ3QgbmVlZCB0byByZWxlYXNlIGFueSByZXNvdXJjZXMuXG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZpbGVTb3VyY2U7XG59KCk7XG5cbnZhciBTdHJlYW1Tb3VyY2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHJlYW1Tb3VyY2UocmVhZGVyLCBjaHVua1NpemUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RyZWFtU291cmNlKTtcblxuICAgIHRoaXMuX2NodW5rU2l6ZSA9IGNodW5rU2l6ZTtcbiAgICB0aGlzLl9idWZmZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fYnVmZmVyT2Zmc2V0ID0gMDtcbiAgICB0aGlzLl9yZWFkZXIgPSByZWFkZXI7XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN0cmVhbVNvdXJjZSwgW3tcbiAgICBrZXk6IFwic2xpY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKHN0YXJ0IDwgdGhpcy5fYnVmZmVyT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJSZXF1ZXN0ZWQgZGF0YSBpcyBiZWZvcmUgdGhlIHJlYWRlcidzIGN1cnJlbnQgb2Zmc2V0XCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRVbnRpbEVub3VnaERhdGFPckRvbmUoc3RhcnQsIGVuZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZWFkVW50aWxFbm91Z2hEYXRhT3JEb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWFkVW50aWxFbm91Z2hEYXRhT3JEb25lKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBoYXNFbm91Z2hEYXRhID0gZW5kIDw9IHRoaXMuX2J1ZmZlck9mZnNldCArIGxlbih0aGlzLl9idWZmZXIpO1xuXG4gICAgICBpZiAodGhpcy5fZG9uZSB8fCBoYXNFbm91Z2hEYXRhKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2dldERhdGFGcm9tQnVmZmVyKHN0YXJ0LCBlbmQpO1xuXG4gICAgICAgIHZhciBkb25lID0gdmFsdWUgPT0gbnVsbCA/IHRoaXMuX2RvbmUgOiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIGRvbmU6IGRvbmVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gX3JlZi52YWx1ZSxcbiAgICAgICAgICAgIGRvbmUgPSBfcmVmLmRvbmU7XG5cbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBfdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoX3RoaXMuX2J1ZmZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgX3RoaXMuX2J1ZmZlciA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLl9idWZmZXIgPSBjb25jYXQoX3RoaXMuX2J1ZmZlciwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF90aGlzLl9yZWFkVW50aWxFbm91Z2hEYXRhT3JEb25lKHN0YXJ0LCBlbmQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXREYXRhRnJvbUJ1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGF0YUZyb21CdWZmZXIoc3RhcnQsIGVuZCkge1xuICAgICAgLy8gUmVtb3ZlIGRhdGEgZnJvbSBidWZmZXIgYmVmb3JlIGBzdGFydGAuXG4gICAgICAvLyBEYXRhIG1pZ2h0IGJlIHJlcmVhZCBmcm9tIHRoZSBidWZmZXIgaWYgYW4gdXBsb2FkIGZhaWxzLCBzbyB3ZSBjYW4gb25seVxuICAgICAgLy8gc2FmZWx5IGRlbGV0ZSBkYXRhIHdoZW4gaXQgY29tZXMgKmJlZm9yZSogd2hhdCBpcyBjdXJyZW50bHkgYmVpbmcgcmVhZC5cbiAgICAgIGlmIChzdGFydCA+IHRoaXMuX2J1ZmZlck9mZnNldCkge1xuICAgICAgICB0aGlzLl9idWZmZXIgPSB0aGlzLl9idWZmZXIuc2xpY2Uoc3RhcnQgLSB0aGlzLl9idWZmZXJPZmZzZXQpO1xuICAgICAgICB0aGlzLl9idWZmZXJPZmZzZXQgPSBzdGFydDtcbiAgICAgIH0gLy8gSWYgdGhlIGJ1ZmZlciBpcyBlbXB0eSBhZnRlciByZW1vdmluZyBvbGQgZGF0YSwgYWxsIGRhdGEgaGFzIGJlZW4gcmVhZC5cblxuXG4gICAgICB2YXIgaGFzQWxsRGF0YUJlZW5SZWFkID0gbGVuKHRoaXMuX2J1ZmZlcikgPT09IDA7XG5cbiAgICAgIGlmICh0aGlzLl9kb25lICYmIGhhc0FsbERhdGFCZWVuUmVhZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gLy8gV2UgYWxyZWFkeSByZW1vdmVkIGRhdGEgYmVmb3JlIGBzdGFydGAsIHNvIHdlIGp1c3QgcmV0dXJuIHRoZSBmaXJzdFxuICAgICAgLy8gY2h1bmsgZnJvbSB0aGUgYnVmZmVyLlxuXG5cbiAgICAgIHJldHVybiB0aGlzLl9idWZmZXIuc2xpY2UoMCwgZW5kIC0gc3RhcnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIGlmICh0aGlzLl9yZWFkZXIuY2FuY2VsKSB7XG4gICAgICAgIHRoaXMuX3JlYWRlci5jYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3RyZWFtU291cmNlO1xufSgpO1xuXG5mdW5jdGlvbiBsZW4oYmxvYk9yQXJyYXkpIHtcbiAgaWYgKGJsb2JPckFycmF5ID09PSB1bmRlZmluZWQpIHJldHVybiAwO1xuICBpZiAoYmxvYk9yQXJyYXkuc2l6ZSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gYmxvYk9yQXJyYXkuc2l6ZTtcbiAgcmV0dXJuIGJsb2JPckFycmF5Lmxlbmd0aDtcbn1cbi8qXG4gIFR5cGVkIGFycmF5cyBhbmQgYmxvYnMgZG9uJ3QgaGF2ZSBhIGNvbmNhdCBtZXRob2QuXG4gIFRoaXMgZnVuY3Rpb24gaGVscHMgU3RyZWFtU291cmNlIGFjY3VtdWxhdGUgZGF0YSB0byByZWFjaCBjaHVua1NpemUuXG4qL1xuXG5cbmZ1bmN0aW9uIGNvbmNhdChhLCBiKSB7XG4gIGlmIChhLmNvbmNhdCkge1xuICAgIC8vIElzIGBhYCBhbiBBcnJheT9cbiAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gIH1cblxuICBpZiAoYSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICByZXR1cm4gbmV3IEJsb2IoW2EsIGJdLCB7XG4gICAgICB0eXBlOiBhLnR5cGVcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChhLnNldCkge1xuICAgIC8vIElzIGBhYCBhIHR5cGVkIGFycmF5P1xuICAgIHZhciBjID0gbmV3IGEuY29uc3RydWN0b3IoYS5sZW5ndGggKyBiLmxlbmd0aCk7XG4gICAgYy5zZXQoYSk7XG4gICAgYy5zZXQoYiwgYS5sZW5ndGgpO1xuICAgIHJldHVybiBjO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGRhdGEgdHlwZScpO1xufVxuXG52YXIgRmlsZVJlYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZpbGVSZWFkZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZpbGVSZWFkZXIsIFt7XG4gICAga2V5OiBcIm9wZW5GaWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW5GaWxlKGlucHV0LCBjaHVua1NpemUpIHtcbiAgICAgIC8vIEluIFJlYWN0IE5hdGl2ZSwgd2hlbiB1c2VyIHNlbGVjdHMgYSBmaWxlLCBpbnN0ZWFkIG9mIGEgRmlsZSBvciBCbG9iLFxuICAgICAgLy8geW91IHVzdWFsbHkgZ2V0IGEgZmlsZSBvYmplY3Qge30gd2l0aCBhIHVyaSBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zXG4gICAgICAvLyBhIGxvY2FsIHBhdGggdG8gdGhlIGZpbGUuIFdlIHVzZSBYTUxIdHRwUmVxdWVzdCB0byBmZXRjaFxuICAgICAgLy8gdGhlIGZpbGUgYmxvYiwgYmVmb3JlIHVwbG9hZGluZyB3aXRoIHR1cy5cbiAgICAgIGlmICgoMCwgX2lzUmVhY3ROYXRpdmUuZGVmYXVsdCkoKSAmJiBpbnB1dCAmJiB0eXBlb2YgaW5wdXQudXJpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gKDAsIF91cmlUb0Jsb2IuZGVmYXVsdCkoaW5wdXQudXJpKS50aGVuKGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBGaWxlU291cmNlKGJsb2IpO1xuICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0dXM6IGNhbm5vdCBmZXRjaCBgZmlsZS51cmlgIGFzIEJsb2IsIG1ha2Ugc3VyZSB0aGUgdXJpIGlzIGNvcnJlY3QgYW5kIGFjY2Vzc2libGUuIFwiLmNvbmNhdChlcnIpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIFNpbmNlIHdlIGVtdWxhdGUgdGhlIEJsb2IgdHlwZSBpbiBvdXIgdGVzdHMgKG5vdCBhbGwgdGFyZ2V0IGJyb3dzZXJzXG4gICAgICAvLyBzdXBwb3J0IGl0KSwgd2UgY2Fubm90IHVzZSBgaW5zdGFuY2VvZmAgZm9yIHRlc3Rpbmcgd2hldGhlciB0aGUgaW5wdXQgdmFsdWVcbiAgICAgIC8vIGNhbiBiZSBoYW5kbGVkLiBJbnN0ZWFkLCB3ZSBzaW1wbHkgY2hlY2sgaXMgdGhlIHNsaWNlKCkgZnVuY3Rpb24gYW5kIHRoZVxuICAgICAgLy8gc2l6ZSBwcm9wZXJ0eSBhcmUgYXZhaWxhYmxlLlxuXG5cbiAgICAgIGlmICh0eXBlb2YgaW5wdXQuc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGlucHV0LnNpemUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEZpbGVTb3VyY2UoaW5wdXQpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnB1dC5yZWFkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNodW5rU2l6ZSA9ICtjaHVua1NpemU7XG5cbiAgICAgICAgaWYgKCFpc0Zpbml0ZShjaHVua1NpemUpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignY2Fubm90IGNyZWF0ZSBzb3VyY2UgZm9yIHN0cmVhbSB3aXRob3V0IGEgZmluaXRlIHZhbHVlIGZvciB0aGUgYGNodW5rU2l6ZWAgb3B0aW9uJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgU3RyZWFtU291cmNlKGlucHV0LCBjaHVua1NpemUpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignc291cmNlIG9iamVjdCBtYXkgb25seSBiZSBhbiBpbnN0YW5jZSBvZiBGaWxlLCBCbG9iLCBvciBSZWFkZXIgaW4gdGhpcyBlbnZpcm9ubWVudCcpKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRmlsZVJlYWRlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRmlsZVJlYWRlcjsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZpbmdlcnByaW50O1xuXG52YXIgX2lzUmVhY3ROYXRpdmUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lzUmVhY3ROYXRpdmVcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBUT0RPOiBEaWZmZXJlbmNpYXRlIGJldHdlZW4gaW5wdXQgdHlwZXNcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGZpbmdlcnByaW50IGZvciBhIGZpbGUgd2hpY2ggd2lsbCBiZSB1c2VkIHRoZSBzdG9yZSB0aGUgZW5kcG9pbnRcbiAqXG4gKiBAcGFyYW0ge0ZpbGV9IGZpbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBmaW5nZXJwcmludChmaWxlLCBvcHRpb25zKSB7XG4gIGlmICgoMCwgX2lzUmVhY3ROYXRpdmUuZGVmYXVsdCkoKSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVhY3ROYXRpdmVGaW5nZXJwcmludChmaWxlLCBvcHRpb25zKSk7XG4gIH1cblxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFsndHVzLWJyJywgZmlsZS5uYW1lLCBmaWxlLnR5cGUsIGZpbGUuc2l6ZSwgZmlsZS5sYXN0TW9kaWZpZWQsIG9wdGlvbnMuZW5kcG9pbnRdLmpvaW4oJy0nKSk7XG59XG5cbmZ1bmN0aW9uIHJlYWN0TmF0aXZlRmluZ2VycHJpbnQoZmlsZSwgb3B0aW9ucykge1xuICB2YXIgZXhpZkhhc2ggPSBmaWxlLmV4aWYgPyBoYXNoQ29kZShKU09OLnN0cmluZ2lmeShmaWxlLmV4aWYpKSA6ICdub2V4aWYnO1xuICByZXR1cm4gWyd0dXMtcm4nLCBmaWxlLm5hbWUgfHwgJ25vbmFtZScsIGZpbGUuc2l6ZSB8fCAnbm9zaXplJywgZXhpZkhhc2gsIG9wdGlvbnMuZW5kcG9pbnRdLmpvaW4oJy8nKTtcbn1cblxuZnVuY3Rpb24gaGFzaENvZGUoc3RyKSB7XG4gIC8vIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg4MzE5MzcvMTUxNjY2XG4gIHZhciBoYXNoID0gMDtcblxuICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBoYXNoO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2NoYXIgPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBfY2hhcjtcbiAgICBoYXNoICY9IGhhc2g7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG5cbiAgcmV0dXJuIGhhc2g7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbi8qIGdsb2JhbCB3aW5kb3cgKi9cblxuXG52YXIgWEhSSHR0cFN0YWNrID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWEhSSHR0cFN0YWNrKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBYSFJIdHRwU3RhY2spO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFhIUkh0dHBTdGFjaywgW3tcbiAgICBrZXk6IFwiY3JlYXRlUmVxdWVzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVSZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gICAgICByZXR1cm4gbmV3IFJlcXVlc3QobWV0aG9kLCB1cmwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXROYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5hbWUoKSB7XG4gICAgICByZXR1cm4gJ1hIUkh0dHBTdGFjayc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFhIUkh0dHBTdGFjaztcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gWEhSSHR0cFN0YWNrO1xuXG52YXIgUmVxdWVzdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlcXVlc3QobWV0aG9kLCB1cmwpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVxdWVzdCk7XG5cbiAgICB0aGlzLl94aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIHRoaXMuX3hoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcblxuICAgIHRoaXMuX21ldGhvZCA9IG1ldGhvZDtcbiAgICB0aGlzLl91cmwgPSB1cmw7XG4gICAgdGhpcy5faGVhZGVycyA9IHt9O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFJlcXVlc3QsIFt7XG4gICAga2V5OiBcImdldE1ldGhvZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNZXRob2QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWV0aG9kO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRVUkxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VVJMKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3VybDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0SGVhZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEhlYWRlcihoZWFkZXIsIHZhbHVlKSB7XG4gICAgICB0aGlzLl94aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIHZhbHVlKTtcblxuICAgICAgdGhpcy5faGVhZGVyc1toZWFkZXJdID0gdmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEhlYWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIZWFkZXIoaGVhZGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5faGVhZGVyc1toZWFkZXJdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRQcm9ncmVzc0hhbmRsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UHJvZ3Jlc3NIYW5kbGVyKHByb2dyZXNzSGFuZGxlcikge1xuICAgICAgLy8gVGVzdCBzdXBwb3J0IGZvciBwcm9ncmVzcyBldmVudHMgYmVmb3JlIGF0dGFjaGluZyBhbiBldmVudCBsaXN0ZW5lclxuICAgICAgaWYgKCEoJ3VwbG9hZCcgaW4gdGhpcy5feGhyKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3hoci51cGxvYWQub25wcm9ncmVzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghZS5sZW5ndGhDb21wdXRhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvZ3Jlc3NIYW5kbGVyKGUubG9hZGVkKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBib2R5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgX3RoaXMuX3hoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVzb2x2ZShuZXcgUmVzcG9uc2UoX3RoaXMuX3hocikpO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLl94aHIub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5feGhyLnNlbmQoYm9keSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWJvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICB0aGlzLl94aHIuYWJvcnQoKTtcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRVbmRlcmx5aW5nT2JqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVuZGVybHlpbmdPYmplY3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5feGhyO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZXF1ZXN0O1xufSgpO1xuXG52YXIgUmVzcG9uc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZXNwb25zZSh4aHIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzcG9uc2UpO1xuXG4gICAgdGhpcy5feGhyID0geGhyO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFJlc3BvbnNlLCBbe1xuICAgIGtleTogXCJnZXRTdGF0dXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RhdHVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3hoci5zdGF0dXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEhlYWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIZWFkZXIoaGVhZGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5feGhyLmdldFJlc3BvbnNlSGVhZGVyKGhlYWRlcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJvZHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm9keSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl94aHIucmVzcG9uc2VUZXh0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRVbmRlcmx5aW5nT2JqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVuZGVybHlpbmdPYmplY3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5feGhyO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZXNwb25zZTtcbn0oKTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuYWJsZURlYnVnTG9nXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9sb2dnZXIuZW5hYmxlRGVidWdMb2c7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2FuU3RvcmVVUkxzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91cmxTdG9yYWdlLmNhblN0b3JlVVJMcztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJIdHRwU3RhY2tcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2h0dHBTdGFjay5kZWZhdWx0O1xuICB9XG59KTtcbmV4cG9ydHMuaXNTdXBwb3J0ZWQgPSBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5VcGxvYWQgPSB2b2lkIDA7XG5cbnZhciBfdXBsb2FkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdXBsb2FkXCIpKTtcblxudmFyIF9ub29wVXJsU3RvcmFnZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL25vb3BVcmxTdG9yYWdlXCIpKTtcblxudmFyIF9sb2dnZXIgPSByZXF1aXJlKFwiLi4vbG9nZ2VyXCIpO1xuXG52YXIgX3VybFN0b3JhZ2UgPSByZXF1aXJlKFwiLi91cmxTdG9yYWdlXCIpO1xuXG52YXIgX2h0dHBTdGFjayA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaHR0cFN0YWNrXCIpKTtcblxudmFyIF9maWxlUmVhZGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9maWxlUmVhZGVyXCIpKTtcblxudmFyIF9maW5nZXJwcmludCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZmluZ2VycHJpbnRcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcblxuICAgIGlmIChlbnVtZXJhYmxlT25seSkge1xuICAgICAgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG4vKiBnbG9iYWwgd2luZG93ICovXG5cblxudmFyIGRlZmF1bHRPcHRpb25zID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfdXBsb2FkLmRlZmF1bHQuZGVmYXVsdE9wdGlvbnMpLCB7fSwge1xuICBodHRwU3RhY2s6IG5ldyBfaHR0cFN0YWNrLmRlZmF1bHQoKSxcbiAgZmlsZVJlYWRlcjogbmV3IF9maWxlUmVhZGVyLmRlZmF1bHQoKSxcbiAgdXJsU3RvcmFnZTogX3VybFN0b3JhZ2UuY2FuU3RvcmVVUkxzID8gbmV3IF91cmxTdG9yYWdlLldlYlN0b3JhZ2VVcmxTdG9yYWdlKCkgOiBuZXcgX25vb3BVcmxTdG9yYWdlLmRlZmF1bHQoKSxcbiAgZmluZ2VycHJpbnQ6IF9maW5nZXJwcmludC5kZWZhdWx0XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuXG52YXIgVXBsb2FkID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVVwbG9hZCkge1xuICBfaW5oZXJpdHMoVXBsb2FkLCBfQmFzZVVwbG9hZCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihVcGxvYWQpO1xuXG4gIGZ1bmN0aW9uIFVwbG9hZCgpIHtcbiAgICB2YXIgZmlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVXBsb2FkKTtcblxuICAgIG9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGZpbGUsIG9wdGlvbnMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFVwbG9hZCwgbnVsbCwgW3tcbiAgICBrZXk6IFwidGVybWluYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRlcm1pbmF0ZSh1cmwsIG9wdGlvbnMsIGNiKSB7XG4gICAgICBvcHRpb25zID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0T3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIF91cGxvYWQuZGVmYXVsdC50ZXJtaW5hdGUodXJsLCBvcHRpb25zLCBjYik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFVwbG9hZDtcbn0oX3VwbG9hZC5kZWZhdWx0KTtcblxuZXhwb3J0cy5VcGxvYWQgPSBVcGxvYWQ7XG52YXIgX3dpbmRvdyA9IHdpbmRvdyxcbiAgICBYTUxIdHRwUmVxdWVzdCA9IF93aW5kb3cuWE1MSHR0cFJlcXVlc3QsXG4gICAgQmxvYiA9IF93aW5kb3cuQmxvYjtcbnZhciBpc1N1cHBvcnRlZCA9IFhNTEh0dHBSZXF1ZXN0ICYmIEJsb2IgJiYgdHlwZW9mIEJsb2IucHJvdG90eXBlLnNsaWNlID09PSAnZnVuY3Rpb24nO1xuZXhwb3J0cy5pc1N1cHBvcnRlZCA9IGlzU3VwcG9ydGVkOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgaXNDb3Jkb3ZhID0gZnVuY3Rpb24gaXNDb3Jkb3ZhKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiAodHlwZW9mIHdpbmRvdy5QaG9uZUdhcCAhPSAndW5kZWZpbmVkJyB8fCB0eXBlb2Ygd2luZG93LkNvcmRvdmEgIT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHdpbmRvdy5jb3Jkb3ZhICE9ICd1bmRlZmluZWQnKTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IGlzQ29yZG92YTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgaXNSZWFjdE5hdGl2ZSA9IGZ1bmN0aW9uIGlzUmVhY3ROYXRpdmUoKSB7XG4gIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdzdHJpbmcnICYmIG5hdmlnYXRvci5wcm9kdWN0LnRvTG93ZXJDYXNlKCkgPT09ICdyZWFjdG5hdGl2ZSc7XG59O1xuXG52YXIgX2RlZmF1bHQgPSBpc1JlYWN0TmF0aXZlO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSByZWFkQXNCeXRlQXJyYXk7XG5cbi8qKlxuICogcmVhZEFzQnl0ZUFycmF5IGNvbnZlcnRzIGEgRmlsZSBvYmplY3QgdG8gYSBVaW50OEFycmF5LlxuICogVGhpcyBmdW5jdGlvbiBpcyBvbmx5IHVzZWQgb24gdGhlIEFwYWNoZSBDb3Jkb3ZhIHBsYXRmb3JtLlxuICogU2VlIGh0dHBzOi8vY29yZG92YS5hcGFjaGUub3JnL2RvY3MvZW4vbGF0ZXN0L3JlZmVyZW5jZS9jb3Jkb3ZhLXBsdWdpbi1maWxlL2luZGV4Lmh0bWwjcmVhZC1hLWZpbGVcbiAqL1xuZnVuY3Rpb24gcmVhZEFzQnl0ZUFycmF5KGNodW5rKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlID0gbmV3IFVpbnQ4QXJyYXkocmVhZGVyLnJlc3VsdCk7XG4gICAgICByZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9O1xuXG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGNodW5rKTtcbiAgfSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB1cmlUb0Jsb2I7XG5cbi8qKlxuICogdXJpVG9CbG9iIHJlc29sdmVzIGEgVVJJIHRvIGEgQmxvYiBvYmplY3QuIFRoaXMgaXMgdXNlZCBmb3JcbiAqIFJlYWN0IE5hdGl2ZSB0byByZXRyaWV2ZSBhIGZpbGUgKGlkZW50aWZpZWQgYnkgYSBmaWxlOi8vXG4gKiBVUkkpIGFzIGEgYmxvYi5cbiAqL1xuZnVuY3Rpb24gdXJpVG9CbG9iKHVyaSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuXG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBibG9iID0geGhyLnJlc3BvbnNlO1xuICAgICAgcmVzb2x2ZShibG9iKTtcbiAgICB9O1xuXG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9O1xuXG4gICAgeGhyLm9wZW4oJ0dFVCcsIHVyaSk7XG4gICAgeGhyLnNlbmQoKTtcbiAgfSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLldlYlN0b3JhZ2VVcmxTdG9yYWdlID0gZXhwb3J0cy5jYW5TdG9yZVVSTHMgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbi8qIGdsb2JhbCB3aW5kb3csIGxvY2FsU3RvcmFnZSAqL1xuXG5cbnZhciBoYXNTdG9yYWdlID0gZmFsc2U7XG5cbnRyeSB7XG4gIGhhc1N0b3JhZ2UgPSAnbG9jYWxTdG9yYWdlJyBpbiB3aW5kb3c7IC8vIEF0dGVtcHQgdG8gc3RvcmUgYW5kIHJlYWQgZW50cmllcyBmcm9tIHRoZSBsb2NhbCBzdG9yYWdlIHRvIGRldGVjdCBQcml2YXRlXG4gIC8vIE1vZGUgb24gU2FmYXJpIG9uIGlPUyAoc2VlICM0OSlcblxuICB2YXIga2V5ID0gJ3R1c1N1cHBvcnQnO1xuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSkpO1xufSBjYXRjaCAoZSkge1xuICAvLyBJZiB3ZSB0cnkgdG8gYWNjZXNzIGxvY2FsU3RvcmFnZSBpbnNpZGUgYSBzYW5kYm94ZWQgaWZyYW1lLCBhIFNlY3VyaXR5RXJyb3JcbiAgLy8gaXMgdGhyb3duLiBXaGVuIGluIHByaXZhdGUgbW9kZSBvbiBpT1MgU2FmYXJpLCBhIFF1b3RhRXhjZWVkZWRFcnJvciBpc1xuICAvLyB0aHJvd24gKHNlZSAjNDkpXG4gIGlmIChlLmNvZGUgPT09IGUuU0VDVVJJVFlfRVJSIHx8IGUuY29kZSA9PT0gZS5RVU9UQV9FWENFRURFRF9FUlIpIHtcbiAgICBoYXNTdG9yYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuXG52YXIgY2FuU3RvcmVVUkxzID0gaGFzU3RvcmFnZTtcbmV4cG9ydHMuY2FuU3RvcmVVUkxzID0gY2FuU3RvcmVVUkxzO1xuXG52YXIgV2ViU3RvcmFnZVVybFN0b3JhZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBXZWJTdG9yYWdlVXJsU3RvcmFnZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2ViU3RvcmFnZVVybFN0b3JhZ2UpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFdlYlN0b3JhZ2VVcmxTdG9yYWdlLCBbe1xuICAgIGtleTogXCJmaW5kQWxsVXBsb2Fkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kQWxsVXBsb2FkcygpIHtcbiAgICAgIHZhciByZXN1bHRzID0gdGhpcy5fZmluZEVudHJpZXMoJ3R1czo6Jyk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmRVcGxvYWRzQnlGaW5nZXJwcmludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kVXBsb2Fkc0J5RmluZ2VycHJpbnQoZmluZ2VycHJpbnQpIHtcbiAgICAgIHZhciByZXN1bHRzID0gdGhpcy5fZmluZEVudHJpZXMoXCJ0dXM6OlwiLmNvbmNhdChmaW5nZXJwcmludCwgXCI6OlwiKSk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVVcGxvYWQodXJsU3RvcmFnZUtleSkge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odXJsU3RvcmFnZUtleSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRVcGxvYWQoZmluZ2VycHJpbnQsIHVwbG9hZCkge1xuICAgICAgdmFyIGlkID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMWUxMik7XG4gICAgICB2YXIga2V5ID0gXCJ0dXM6OlwiLmNvbmNhdChmaW5nZXJwcmludCwgXCI6OlwiKS5jb25jYXQoaWQpO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeSh1cGxvYWQpKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoa2V5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmRFbnRyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kRW50cmllcyhwcmVmaXgpIHtcbiAgICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jYWxTdG9yYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBfa2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKTtcblxuICAgICAgICBpZiAoX2tleS5pbmRleE9mKHByZWZpeCkgIT09IDApIGNvbnRpbnVlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHVwbG9hZCA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oX2tleSkpO1xuICAgICAgICAgIHVwbG9hZC51cmxTdG9yYWdlS2V5ID0gX2tleTtcbiAgICAgICAgICByZXN1bHRzLnB1c2godXBsb2FkKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgey8vIFRoZSBKU09OIHBhcnNlIGVycm9yIGlzIGludGVudGlvbmFsbHkgaWdub3JlZCBoZXJlLCBzbyBhIG1hbGZvcm1lZFxuICAgICAgICAgIC8vIGVudHJ5IGluIHRoZSBzdG9yYWdlIGNhbm5vdCBwcmV2ZW50IGFuIHVwbG9hZC5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gV2ViU3RvcmFnZVVybFN0b3JhZ2U7XG59KCk7XG5cbmV4cG9ydHMuV2ViU3RvcmFnZVVybFN0b3JhZ2UgPSBXZWJTdG9yYWdlVXJsU3RvcmFnZTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gIHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7XG5cbiAgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuXG4gICAgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpO1xuXG4gICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXcmFwcGVyKCkge1xuICAgICAgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbiAgICBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogV3JhcHBlcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTtcbiAgfTtcblxuICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xuICB9IGVsc2Uge1xuICAgIF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7XG4gIHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbnZhciBEZXRhaWxlZEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKERldGFpbGVkRXJyb3IsIF9FcnJvcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihEZXRhaWxlZEVycm9yKTtcblxuICBmdW5jdGlvbiBEZXRhaWxlZEVycm9yKG1lc3NhZ2UpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgY2F1c2luZ0VyciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICB2YXIgcmVxID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgIHZhciByZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGV0YWlsZWRFcnJvcik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgIF90aGlzLm9yaWdpbmFsUmVxdWVzdCA9IHJlcTtcbiAgICBfdGhpcy5vcmlnaW5hbFJlc3BvbnNlID0gcmVzO1xuICAgIF90aGlzLmNhdXNpbmdFcnJvciA9IGNhdXNpbmdFcnI7XG5cbiAgICBpZiAoY2F1c2luZ0VyciAhPSBudWxsKSB7XG4gICAgICBtZXNzYWdlICs9IFwiLCBjYXVzZWQgYnkgXCIuY29uY2F0KGNhdXNpbmdFcnIudG9TdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgaWYgKHJlcSAhPSBudWxsKSB7XG4gICAgICB2YXIgcmVxdWVzdElkID0gcmVxLmdldEhlYWRlcignWC1SZXF1ZXN0LUlEJykgfHwgJ24vYSc7XG4gICAgICB2YXIgbWV0aG9kID0gcmVxLmdldE1ldGhvZCgpO1xuICAgICAgdmFyIHVybCA9IHJlcS5nZXRVUkwoKTtcbiAgICAgIHZhciBzdGF0dXMgPSByZXMgPyByZXMuZ2V0U3RhdHVzKCkgOiAnbi9hJztcbiAgICAgIHZhciBib2R5ID0gcmVzID8gcmVzLmdldEJvZHkoKSB8fCAnJyA6ICduL2EnO1xuICAgICAgbWVzc2FnZSArPSBcIiwgb3JpZ2luYXRlZCBmcm9tIHJlcXVlc3QgKG1ldGhvZDogXCIuY29uY2F0KG1ldGhvZCwgXCIsIHVybDogXCIpLmNvbmNhdCh1cmwsIFwiLCByZXNwb25zZSBjb2RlOiBcIikuY29uY2F0KHN0YXR1cywgXCIsIHJlc3BvbnNlIHRleHQ6IFwiKS5jb25jYXQoYm9keSwgXCIsIHJlcXVlc3QgaWQ6IFwiKS5jb25jYXQocmVxdWVzdElkLCBcIilcIik7XG4gICAgfVxuXG4gICAgX3RoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIERldGFpbGVkRXJyb3I7XG59KCAvKiNfX1BVUkVfXyovX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuXG52YXIgX2RlZmF1bHQgPSBEZXRhaWxlZEVycm9yO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmVuYWJsZURlYnVnTG9nID0gZW5hYmxlRGVidWdMb2c7XG5leHBvcnRzLmxvZyA9IGxvZztcblxuLyogZXNsaW50IG5vLWNvbnNvbGU6IFwib2ZmXCIgKi9cbnZhciBpc0VuYWJsZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gZW5hYmxlRGVidWdMb2coKSB7XG4gIGlzRW5hYmxlZCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGxvZyhtc2cpIHtcbiAgaWYgKCFpc0VuYWJsZWQpIHJldHVybjtcbiAgY29uc29sZS5sb2cobXNnKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBcIm9mZlwiICovXG5cblxudmFyIE5vb3BVcmxTdG9yYWdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTm9vcFVybFN0b3JhZ2UoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vb3BVcmxTdG9yYWdlKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhOb29wVXJsU3RvcmFnZSwgW3tcbiAgICBrZXk6IFwibGlzdEFsbFVwbG9hZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdEFsbFVwbG9hZHMoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZFVwbG9hZHNCeUZpbmdlcnByaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRVcGxvYWRzQnlGaW5nZXJwcmludChmaW5nZXJwcmludCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVVcGxvYWQodXJsU3RvcmFnZUtleSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkVXBsb2FkKGZpbmdlcnByaW50LCB1cGxvYWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE5vb3BVcmxTdG9yYWdlO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBOb29wVXJsU3RvcmFnZTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9qc0Jhc2UgPSByZXF1aXJlKFwianMtYmFzZTY0XCIpO1xuXG52YXIgX3VybFBhcnNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwidXJsLXBhcnNlXCIpKTtcblxudmFyIF9lcnJvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZXJyb3JcIikpO1xuXG52YXIgX2xvZ2dlciA9IHJlcXVpcmUoXCIuL2xvZ2dlclwiKTtcblxudmFyIF91dWlkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dWlkXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuXG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSB7XG4gICAgICBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuLyogZ2xvYmFsIHdpbmRvdyAqL1xuXG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgZW5kcG9pbnQ6IG51bGwsXG4gIHVwbG9hZFVybDogbnVsbCxcbiAgbWV0YWRhdGE6IHt9LFxuICBmaW5nZXJwcmludDogbnVsbCxcbiAgdXBsb2FkU2l6ZTogbnVsbCxcbiAgb25Qcm9ncmVzczogbnVsbCxcbiAgb25DaHVua0NvbXBsZXRlOiBudWxsLFxuICBvblN1Y2Nlc3M6IG51bGwsXG4gIG9uRXJyb3I6IG51bGwsXG4gIF9vblVwbG9hZFVybEF2YWlsYWJsZTogbnVsbCxcbiAgb3ZlcnJpZGVQYXRjaE1ldGhvZDogZmFsc2UsXG4gIGhlYWRlcnM6IHt9LFxuICBhZGRSZXF1ZXN0SWQ6IGZhbHNlLFxuICBvbkJlZm9yZVJlcXVlc3Q6IG51bGwsXG4gIG9uQWZ0ZXJSZXNwb25zZTogbnVsbCxcbiAgb25TaG91bGRSZXRyeTogbnVsbCxcbiAgY2h1bmtTaXplOiBJbmZpbml0eSxcbiAgcmV0cnlEZWxheXM6IFswLCAxMDAwLCAzMDAwLCA1MDAwXSxcbiAgcGFyYWxsZWxVcGxvYWRzOiAxLFxuICBzdG9yZUZpbmdlcnByaW50Rm9yUmVzdW1pbmc6IHRydWUsXG4gIHJlbW92ZUZpbmdlcnByaW50T25TdWNjZXNzOiBmYWxzZSxcbiAgdXBsb2FkTGVuZ3RoRGVmZXJyZWQ6IGZhbHNlLFxuICB1cGxvYWREYXRhRHVyaW5nQ3JlYXRpb246IGZhbHNlLFxuICB1cmxTdG9yYWdlOiBudWxsLFxuICBmaWxlUmVhZGVyOiBudWxsLFxuICBodHRwU3RhY2s6IG51bGxcbn07XG5cbnZhciBCYXNlVXBsb2FkID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFzZVVwbG9hZChmaWxlLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VVcGxvYWQpOyAvLyBXYXJuIGFib3V0IHJlbW92ZWQgb3B0aW9ucyBmcm9tIHByZXZpb3VzIHZlcnNpb25zXG5cblxuICAgIGlmICgncmVzdW1lJyBpbiBvcHRpb25zKSB7XG4gICAgICBjb25zb2xlLmxvZygndHVzOiBUaGUgYHJlc3VtZWAgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWQgaW4gdHVzLWpzLWNsaWVudCB2Mi4gUGxlYXNlIHVzZSB0aGUgVVJMIHN0b3JhZ2UgQVBJIGluc3RlYWQuJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIH0gLy8gVGhlIGRlZmF1bHQgb3B0aW9ucyB3aWxsIGFscmVhZHkgYmUgYWRkZWQgZnJvbSB0aGUgd3JhcHBlciBjbGFzc2VzLlxuXG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zOyAvLyBUaGUgc3RvcmFnZSBtb2R1bGUgdXNlZCB0byBzdG9yZSBVUkxzXG5cbiAgICB0aGlzLl91cmxTdG9yYWdlID0gdGhpcy5vcHRpb25zLnVybFN0b3JhZ2U7IC8vIFRoZSB1bmRlcmx5aW5nIEZpbGUvQmxvYiBvYmplY3RcblxuICAgIHRoaXMuZmlsZSA9IGZpbGU7IC8vIFRoZSBVUkwgYWdhaW5zdCB3aGljaCB0aGUgZmlsZSB3aWxsIGJlIHVwbG9hZGVkXG5cbiAgICB0aGlzLnVybCA9IG51bGw7IC8vIFRoZSB1bmRlcmx5aW5nIHJlcXVlc3Qgb2JqZWN0IGZvciB0aGUgY3VycmVudCBQQVRDSCByZXF1ZXN0XG5cbiAgICB0aGlzLl9yZXEgPSBudWxsOyAvLyBUaGUgZmluZ2VycGlucnQgZm9yIHRoZSBjdXJyZW50IGZpbGUgKHNldCBhZnRlciBzdGFydCgpKVxuXG4gICAgdGhpcy5fZmluZ2VycHJpbnQgPSBudWxsOyAvLyBUaGUga2V5IHRoYXQgdGhlIFVSTCBzdG9yYWdlIHJldHVybmVkIHdoZW4gc2F2aW5nIGFuIFVSTCB3aXRoIGEgZmluZ2VycHJpbnQsXG5cbiAgICB0aGlzLl91cmxTdG9yYWdlS2V5ID0gbnVsbDsgLy8gVGhlIG9mZnNldCB1c2VkIGluIHRoZSBjdXJyZW50IFBBVENIIHJlcXVlc3RcblxuICAgIHRoaXMuX29mZnNldCA9IG51bGw7IC8vIFRydWUgaWYgdGhlIGN1cnJlbnQgUEFUQ0ggcmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkXG5cbiAgICB0aGlzLl9hYm9ydGVkID0gZmFsc2U7IC8vIFRoZSBmaWxlJ3Mgc2l6ZSBpbiBieXRlc1xuXG4gICAgdGhpcy5fc2l6ZSA9IG51bGw7IC8vIFRoZSBTb3VyY2Ugb2JqZWN0IHdoaWNoIHdpbGwgd3JhcCBhcm91bmQgdGhlIGdpdmVuIGZpbGUgYW5kIHByb3ZpZGVzIHVzXG4gICAgLy8gd2l0aCBhIHVuaWZpZWQgaW50ZXJmYWNlIGZvciBnZXR0aW5nIGl0cyBzaXplIGFuZCBzbGljZSBjaHVua3MgZnJvbSBpdHNcbiAgICAvLyBjb250ZW50IGFsbG93aW5nIHVzIHRvIGVhc2lseSBoYW5kbGUgRmlsZXMsIEJsb2JzLCBCdWZmZXJzIGFuZCBTdHJlYW1zLlxuXG4gICAgdGhpcy5fc291cmNlID0gbnVsbDsgLy8gVGhlIGN1cnJlbnQgY291bnQgb2YgYXR0ZW1wdHMgd2hpY2ggaGF2ZSBiZWVuIG1hZGUuIFplcm8gaW5kaWNhdGVzIG5vbmUuXG5cbiAgICB0aGlzLl9yZXRyeUF0dGVtcHQgPSAwOyAvLyBUaGUgdGltZW91dCdzIElEIHdoaWNoIGlzIHVzZWQgdG8gZGVsYXkgdGhlIG5leHQgcmV0cnlcblxuICAgIHRoaXMuX3JldHJ5VGltZW91dCA9IG51bGw7IC8vIFRoZSBvZmZzZXQgb2YgdGhlIHJlbW90ZSB1cGxvYWQgYmVmb3JlIHRoZSBsYXRlc3QgYXR0ZW1wdCB3YXMgc3RhcnRlZC5cblxuICAgIHRoaXMuX29mZnNldEJlZm9yZVJldHJ5ID0gMDsgLy8gQW4gYXJyYXkgb2YgQmFzZVVwbG9hZCBpbnN0YW5jZXMgd2hpY2ggYXJlIHVzZWQgZm9yIHVwbG9hZGluZyB0aGUgZGlmZmVyZW50XG4gICAgLy8gcGFydHMsIGlmIHRoZSBwYXJhbGxlbFVwbG9hZHMgb3B0aW9uIGlzIHVzZWQuXG5cbiAgICB0aGlzLl9wYXJhbGxlbFVwbG9hZHMgPSBudWxsOyAvLyBBbiBhcnJheSBvZiB1cGxvYWQgVVJMcyB3aGljaCBhcmUgdXNlZCBmb3IgdXBsb2FkaW5nIHRoZSBkaWZmZXJlbnRcbiAgICAvLyBwYXJ0cywgaWYgdGhlIHBhcmFsbGVsVXBsb2FkcyBvcHRpb24gaXMgdXNlZC5cblxuICAgIHRoaXMuX3BhcmFsbGVsVXBsb2FkVXJscyA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFVzZSB0aGUgVGVybWluYXRpb24gZXh0ZW5zaW9uIHRvIGRlbGV0ZSBhbiB1cGxvYWQgZnJvbSB0aGUgc2VydmVyIGJ5IHNlbmRpbmcgYSBERUxFVEVcbiAgICogcmVxdWVzdCB0byB0aGUgc3BlY2lmaWVkIHVwbG9hZCBVUkwuIFRoaXMgaXMgb25seSBwb3NzaWJsZSBpZiB0aGUgc2VydmVyIHN1cHBvcnRzIHRoZVxuICAgKiBUZXJtaW5hdGlvbiBleHRlbnNpb24uIElmIHRoZSBgb3B0aW9ucy5yZXRyeURlbGF5c2AgcHJvcGVydHkgaXMgc2V0LCB0aGUgbWV0aG9kIHdpbGxcbiAgICogYWxzbyByZXRyeSBpZiBhbiBlcnJvciBvY3VycnMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIHVwbG9hZCdzIFVSTCB3aGljaCB3aWxsIGJlIHRlcm1pbmF0ZWQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIE9wdGlvbmFsIG9wdGlvbnMgZm9yIGluZmx1ZW5jaW5nIEhUVFAgcmVxdWVzdHMuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRoZSBQcm9taXNlIHdpbGwgYmUgcmVzb2x2ZWQvcmVqZWN0ZWQgd2hlbiB0aGUgcmVxdWVzdHMgZmluaXNoLlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhCYXNlVXBsb2FkLCBbe1xuICAgIGtleTogXCJmaW5kUHJldmlvdXNVcGxvYWRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRQcmV2aW91c1VwbG9hZHMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZpbmdlcnByaW50KHRoaXMuZmlsZSwgdGhpcy5vcHRpb25zKS50aGVuKGZ1bmN0aW9uIChmaW5nZXJwcmludCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuX3VybFN0b3JhZ2UuZmluZFVwbG9hZHNCeUZpbmdlcnByaW50KGZpbmdlcnByaW50KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXN1bWVGcm9tUHJldmlvdXNVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzdW1lRnJvbVByZXZpb3VzVXBsb2FkKHByZXZpb3VzVXBsb2FkKSB7XG4gICAgICB0aGlzLnVybCA9IHByZXZpb3VzVXBsb2FkLnVwbG9hZFVybCB8fCBudWxsO1xuICAgICAgdGhpcy5fcGFyYWxsZWxVcGxvYWRVcmxzID0gcHJldmlvdXNVcGxvYWQucGFyYWxsZWxVcGxvYWRVcmxzIHx8IG51bGw7XG4gICAgICB0aGlzLl91cmxTdG9yYWdlS2V5ID0gcHJldmlvdXNVcGxvYWQudXJsU3RvcmFnZUtleTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGZpbGUgPSB0aGlzLmZpbGU7XG5cbiAgICAgIGlmICghZmlsZSkge1xuICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCd0dXM6IG5vIGZpbGUgb3Igc3RyZWFtIHRvIHVwbG9hZCBwcm92aWRlZCcpKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmVuZHBvaW50ICYmICF0aGlzLm9wdGlvbnMudXBsb2FkVXJsKSB7XG4gICAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ3R1czogbmVpdGhlciBhbiBlbmRwb2ludCBvciBhbiB1cGxvYWQgVVJMIGlzIHByb3ZpZGVkJykpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJldHJ5RGVsYXlzID0gdGhpcy5vcHRpb25zLnJldHJ5RGVsYXlzO1xuXG4gICAgICBpZiAocmV0cnlEZWxheXMgIT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmV0cnlEZWxheXMpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ3R1czogdGhlIGByZXRyeURlbGF5c2Agb3B0aW9uIG11c3QgZWl0aGVyIGJlIGFuIGFycmF5IG9yIG51bGwnKSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBhcmFsbGVsVXBsb2FkcyA+IDEpIHtcbiAgICAgICAgLy8gVGVzdCB3aGljaCBvcHRpb25zIGFyZSBpbmNvbXBhdGlibGUgd2l0aCBwYXJhbGxlbCB1cGxvYWRzLlxuICAgICAgICBbJ3VwbG9hZFVybCcsICd1cGxvYWRTaXplJywgJ3VwbG9hZExlbmd0aERlZmVycmVkJ10uZm9yRWFjaChmdW5jdGlvbiAob3B0aW9uTmFtZSkge1xuICAgICAgICAgIGlmIChfdGhpczIub3B0aW9uc1tvcHRpb25OYW1lXSkge1xuICAgICAgICAgICAgX3RoaXMyLl9lbWl0RXJyb3IobmV3IEVycm9yKFwidHVzOiBjYW5ub3QgdXNlIHRoZSBcIi5jb25jYXQob3B0aW9uTmFtZSwgXCIgb3B0aW9uIHdoZW4gcGFyYWxsZWxVcGxvYWRzIGlzIGVuYWJsZWRcIikpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm9wdGlvbnMuZmluZ2VycHJpbnQoZmlsZSwgdGhpcy5vcHRpb25zKS50aGVuKGZ1bmN0aW9uIChmaW5nZXJwcmludCkge1xuICAgICAgICBpZiAoZmluZ2VycHJpbnQgPT0gbnVsbCkge1xuICAgICAgICAgICgwLCBfbG9nZ2VyLmxvZykoJ05vIGZpbmdlcnByaW50IHdhcyBjYWxjdWxhdGVkIG1lYW5pbmcgdGhhdCB0aGUgdXBsb2FkIGNhbm5vdCBiZSBzdG9yZWQgaW4gdGhlIFVSTCBzdG9yYWdlLicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICgwLCBfbG9nZ2VyLmxvZykoXCJDYWxjdWxhdGVkIGZpbmdlcnByaW50OiBcIi5jb25jYXQoZmluZ2VycHJpbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMi5fZmluZ2VycHJpbnQgPSBmaW5nZXJwcmludDtcblxuICAgICAgICBpZiAoX3RoaXMyLl9zb3VyY2UpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLl9zb3VyY2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3RoaXMyLm9wdGlvbnMuZmlsZVJlYWRlci5vcGVuRmlsZShmaWxlLCBfdGhpczIub3B0aW9ucy5jaHVua1NpemUpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIF90aGlzMi5fc291cmNlID0gc291cmNlOyAvLyBJZiB0aGUgdXBsb2FkIHdhcyBjb25maWd1cmVkIHRvIHVzZSBtdWx0aXBsZSByZXF1ZXN0cyBvciBpZiB3ZSByZXN1bWUgZnJvbVxuICAgICAgICAvLyBhbiB1cGxvYWQgd2hpY2ggdXNlZCBtdWx0aXBsZSByZXF1ZXN0cywgd2Ugc3RhcnQgYSBwYXJhbGxlbCB1cGxvYWQuXG5cbiAgICAgICAgaWYgKF90aGlzMi5vcHRpb25zLnBhcmFsbGVsVXBsb2FkcyA+IDEgfHwgX3RoaXMyLl9wYXJhbGxlbFVwbG9hZFVybHMgIT0gbnVsbCkge1xuICAgICAgICAgIF90aGlzMi5fc3RhcnRQYXJhbGxlbFVwbG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzMi5fc3RhcnRTaW5nbGVVcGxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIF90aGlzMi5fZW1pdEVycm9yKGVycik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhdGUgdGhlIHVwbG9hZGluZyBwcm9jZWR1cmUgZm9yIGEgcGFyYWxsZWxpemVkIHVwbG9hZCwgd2hlcmUgb25lIGZpbGUgaXMgc3BsaXQgaW50b1xuICAgICAqIG11bHRpcGxlIHJlcXVlc3Qgd2hpY2ggYXJlIHJ1biBpbiBwYXJhbGxlbC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3N0YXJ0UGFyYWxsZWxVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N0YXJ0UGFyYWxsZWxVcGxvYWQoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHRvdGFsU2l6ZSA9IHRoaXMuX3NpemUgPSB0aGlzLl9zb3VyY2Uuc2l6ZTtcbiAgICAgIHZhciB0b3RhbFByb2dyZXNzID0gMDtcbiAgICAgIHRoaXMuX3BhcmFsbGVsVXBsb2FkcyA9IFtdO1xuICAgICAgdmFyIHBhcnRDb3VudCA9IHRoaXMuX3BhcmFsbGVsVXBsb2FkVXJscyAhPSBudWxsID8gdGhpcy5fcGFyYWxsZWxVcGxvYWRVcmxzLmxlbmd0aCA6IHRoaXMub3B0aW9ucy5wYXJhbGxlbFVwbG9hZHM7IC8vIFRoZSBpbnB1dCBmaWxlIHdpbGwgYmUgc3BsaXQgaW50byBtdWx0aXBsZSBzbGljZXMgd2hpY2ggYXJlIHVwbG9hZGVkIGluIHNlcGFyYXRlXG4gICAgICAvLyByZXF1ZXN0cy4gSGVyZSB3ZSBnZW5lcmF0ZSB0aGUgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbiBmb3IgdGhlIHNsaWNlcy5cblxuICAgICAgdmFyIHBhcnRzID0gc3BsaXRTaXplSW50b1BhcnRzKHRoaXMuX3NvdXJjZS5zaXplLCBwYXJ0Q291bnQsIHRoaXMuX3BhcmFsbGVsVXBsb2FkVXJscyk7IC8vIENyZWF0ZSBhbiBlbXB0eSBsaXN0IGZvciBzdG9yaW5nIHRoZSB1cGxvYWQgVVJMc1xuXG4gICAgICB0aGlzLl9wYXJhbGxlbFVwbG9hZFVybHMgPSBuZXcgQXJyYXkocGFydHMubGVuZ3RoKTsgLy8gR2VuZXJhdGUgYSBwcm9taXNlIGZvciBlYWNoIHNsaWNlIHRoYXQgd2lsbCBiZSByZXNvbHZlIGlmIHRoZSByZXNwZWN0aXZlXG4gICAgICAvLyB1cGxvYWQgaXMgY29tcGxldGVkLlxuXG4gICAgICB2YXIgdXBsb2FkcyA9IHBhcnRzLm1hcChmdW5jdGlvbiAocGFydCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGxhc3RQYXJ0UHJvZ3Jlc3MgPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXMzLl9zb3VyY2Uuc2xpY2UocGFydC5zdGFydCwgcGFydC5lbmQpLnRoZW4oZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAvLyBNZXJnZSB3aXRoIHRoZSB1c2VyIHN1cHBsaWVkIG9wdGlvbnMgYnV0IG92ZXJ3cml0ZSBzb21lIHZhbHVlcy5cbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfdGhpczMub3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgICAgIC8vIElmIGF2YWlsYWJsZSwgdGhlIHBhcnRpYWwgdXBsb2FkIHNob3VsZCBiZSByZXN1bWVkIGZyb20gYSBwcmV2aW91cyBVUkwuXG4gICAgICAgICAgICAgIHVwbG9hZFVybDogcGFydC51cGxvYWRVcmwgfHwgbnVsbCxcbiAgICAgICAgICAgICAgLy8gV2UgdGFrZSBtYW51YWxseSBjYXJlIG9mIHJlc3VtaW5nIGZvciBwYXJ0aWFsIHVwbG9hZHMsIHNvIHRoZXkgc2hvdWxkXG4gICAgICAgICAgICAgIC8vIG5vdCBiZSBzdG9yZWQgaW4gdGhlIFVSTCBzdG9yYWdlLlxuICAgICAgICAgICAgICBzdG9yZUZpbmdlcnByaW50Rm9yUmVzdW1pbmc6IGZhbHNlLFxuICAgICAgICAgICAgICByZW1vdmVGaW5nZXJwcmludE9uU3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBwYXJhbGxlbFVwbG9hZHMgb3B0aW9uIHRvIG5vdCBjYXVzZSByZWN1cnNpb24uXG4gICAgICAgICAgICAgIHBhcmFsbGVsVXBsb2FkczogMSxcbiAgICAgICAgICAgICAgbWV0YWRhdGE6IHt9LFxuICAgICAgICAgICAgICAvLyBBZGQgdGhlIGhlYWRlciB0byBpbmRpY2F0ZSB0aGUgdGhpcyBpcyBhIHBhcnRpYWwgdXBsb2FkLlxuICAgICAgICAgICAgICBoZWFkZXJzOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIF90aGlzMy5vcHRpb25zLmhlYWRlcnMpLCB7fSwge1xuICAgICAgICAgICAgICAgICdVcGxvYWQtQ29uY2F0JzogJ3BhcnRpYWwnXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAvLyBSZWplY3Qgb3IgcmVzb2x2ZSB0aGUgcHJvbWlzZSBpZiB0aGUgdXBsb2FkIGVycm9ycyBvciBjb21wbGV0ZXMuXG4gICAgICAgICAgICAgIG9uU3VjY2VzczogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgb25FcnJvcjogcmVqZWN0LFxuICAgICAgICAgICAgICAvLyBCYXNlZCBpbiB0aGUgcHJvZ3Jlc3MgZm9yIHRoaXMgcGFydGlhbCB1cGxvYWQsIGNhbGN1bGF0ZSB0aGUgcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgLy8gZm9yIHRoZSBlbnRpcmUgZmluYWwgdXBsb2FkLlxuICAgICAgICAgICAgICBvblByb2dyZXNzOiBmdW5jdGlvbiBvblByb2dyZXNzKG5ld1BhcnRQcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIHRvdGFsUHJvZ3Jlc3MgPSB0b3RhbFByb2dyZXNzIC0gbGFzdFBhcnRQcm9ncmVzcyArIG5ld1BhcnRQcm9ncmVzcztcbiAgICAgICAgICAgICAgICBsYXN0UGFydFByb2dyZXNzID0gbmV3UGFydFByb2dyZXNzO1xuXG4gICAgICAgICAgICAgICAgX3RoaXMzLl9lbWl0UHJvZ3Jlc3ModG90YWxQcm9ncmVzcywgdG90YWxTaXplKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgLy8gV2FpdCB1bnRpbCBldmVyeSBwYXJ0aWFsIHVwbG9hZCBoYXMgYW4gdXBsb2FkIFVSTCwgc28gd2UgY2FuIGFkZFxuICAgICAgICAgICAgICAvLyB0aGVtIHRvIHRoZSBVUkwgc3RvcmFnZS5cbiAgICAgICAgICAgICAgX29uVXBsb2FkVXJsQXZhaWxhYmxlOiBmdW5jdGlvbiBfb25VcGxvYWRVcmxBdmFpbGFibGUoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMzLl9wYXJhbGxlbFVwbG9hZFVybHNbaW5kZXhdID0gdXBsb2FkLnVybDsgLy8gVGVzdCBpZiBhbGwgdXBsb2FkcyBoYXZlIHJlY2VpdmVkIGFuIFVSTFxuXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzMy5fcGFyYWxsZWxVcGxvYWRVcmxzLmZpbHRlcihmdW5jdGlvbiAodSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICEhdTtcbiAgICAgICAgICAgICAgICB9KS5sZW5ndGggPT09IHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMzLl9zYXZlVXBsb2FkSW5VcmxTdG9yYWdlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHVwbG9hZCA9IG5ldyBCYXNlVXBsb2FkKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHVwbG9hZC5zdGFydCgpOyAvLyBTdG9yZSB0aGUgdXBsb2FkIGluIGFuIGFycmF5LCBzbyB3ZSBjYW4gbGF0ZXIgYWJvcnQgdGhlbSBpZiBuZWNlc3NhcnkuXG5cbiAgICAgICAgICAgIF90aGlzMy5fcGFyYWxsZWxVcGxvYWRzLnB1c2godXBsb2FkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHZhciByZXE7IC8vIFdhaXQgdW50aWwgYWxsIHBhcnRpYWwgdXBsb2FkcyBhcmUgZmluaXNoZWQgYW5kIHdlIGNhbiBzZW5kIHRoZSBQT1NUIHJlcXVlc3QgZm9yXG4gICAgICAvLyBjcmVhdGluZyB0aGUgZmluYWwgdXBsb2FkLlxuXG4gICAgICBQcm9taXNlLmFsbCh1cGxvYWRzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVxID0gX3RoaXMzLl9vcGVuUmVxdWVzdCgnUE9TVCcsIF90aGlzMy5vcHRpb25zLmVuZHBvaW50KTtcbiAgICAgICAgcmVxLnNldEhlYWRlcignVXBsb2FkLUNvbmNhdCcsIFwiZmluYWw7XCIuY29uY2F0KF90aGlzMy5fcGFyYWxsZWxVcGxvYWRVcmxzLmpvaW4oJyAnKSkpOyAvLyBBZGQgbWV0YWRhdGEgaWYgdmFsdWVzIGhhdmUgYmVlbiBhZGRlZFxuXG4gICAgICAgIHZhciBtZXRhZGF0YSA9IGVuY29kZU1ldGFkYXRhKF90aGlzMy5vcHRpb25zLm1ldGFkYXRhKTtcblxuICAgICAgICBpZiAobWV0YWRhdGEgIT09ICcnKSB7XG4gICAgICAgICAgcmVxLnNldEhlYWRlcignVXBsb2FkLU1ldGFkYXRhJywgbWV0YWRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF90aGlzMy5fc2VuZFJlcXVlc3QocmVxLCBudWxsKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICBpZiAoIWluU3RhdHVzQ2F0ZWdvcnkocmVzLmdldFN0YXR1cygpLCAyMDApKSB7XG4gICAgICAgICAgX3RoaXMzLl9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCAndHVzOiB1bmV4cGVjdGVkIHJlc3BvbnNlIHdoaWxlIGNyZWF0aW5nIHVwbG9hZCcpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2F0aW9uID0gcmVzLmdldEhlYWRlcignTG9jYXRpb24nKTtcblxuICAgICAgICBpZiAobG9jYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgIF90aGlzMy5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgJ3R1czogaW52YWxpZCBvciBtaXNzaW5nIExvY2F0aW9uIGhlYWRlcicpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMzLnVybCA9IHJlc29sdmVVcmwoX3RoaXMzLm9wdGlvbnMuZW5kcG9pbnQsIGxvY2F0aW9uKTtcbiAgICAgICAgKDAsIF9sb2dnZXIubG9nKShcIkNyZWF0ZWQgdXBsb2FkIGF0IFwiLmNvbmNhdChfdGhpczMudXJsKSk7XG5cbiAgICAgICAgX3RoaXMzLl9lbWl0U3VjY2VzcygpO1xuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIF90aGlzMy5fZW1pdEVycm9yKGVycik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhdGUgdGhlIHVwbG9hZGluZyBwcm9jZWR1cmUgZm9yIGEgbm9uLXBhcmFsbGVsIHVwbG9hZC4gSGVyZSB0aGUgZW50aXJlIGZpbGUgaXNcbiAgICAgKiB1cGxvYWRlZCBpbiBhIHNlcXVlbnRpYWwgbWF0dGVyLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc3RhcnRTaW5nbGVVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N0YXJ0U2luZ2xlVXBsb2FkKCkge1xuICAgICAgLy8gRmlyc3QsIHdlIGxvb2sgYXQgdGhlIHVwbG9hZExlbmd0aERlZmVycmVkIG9wdGlvbi5cbiAgICAgIC8vIE5leHQsIHdlIGNoZWNrIGlmIHRoZSBjYWxsZXIgaGFzIHN1cHBsaWVkIGEgbWFudWFsIHVwbG9hZCBzaXplLlxuICAgICAgLy8gRmluYWxseSwgd2UgdHJ5IHRvIHVzZSB0aGUgY2FsY3VsYXRlZCBzaXplIGZyb20gdGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZExlbmd0aERlZmVycmVkKSB7XG4gICAgICAgIHRoaXMuX3NpemUgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3NpemUgPSArdGhpcy5vcHRpb25zLnVwbG9hZFNpemU7XG5cbiAgICAgICAgaWYgKGlzTmFOKHRoaXMuX3NpemUpKSB7XG4gICAgICAgICAgdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcigndHVzOiBjYW5ub3QgY29udmVydCBgdXBsb2FkU2l6ZWAgb3B0aW9uIGludG8gYSBudW1iZXInKSk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NpemUgPSB0aGlzLl9zb3VyY2Uuc2l6ZTtcblxuICAgICAgICBpZiAodGhpcy5fc2l6ZSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcInR1czogY2Fubm90IGF1dG9tYXRpY2FsbHkgZGVyaXZlIHVwbG9hZCdzIHNpemUgZnJvbSBpbnB1dCBhbmQgbXVzdCBiZSBzcGVjaWZpZWQgbWFudWFsbHkgdXNpbmcgdGhlIGB1cGxvYWRTaXplYCBvcHRpb25cIikpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IC8vIFJlc2V0IHRoZSBhYm9ydGVkIGZsYWcgd2hlbiB0aGUgdXBsb2FkIGlzIHN0YXJ0ZWQgb3IgZWxzZSB0aGVcbiAgICAgIC8vIF9wZXJmb3JtVXBsb2FkIHdpbGwgc3RvcCBiZWZvcmUgc2VuZGluZyBhIHJlcXVlc3QgaWYgdGhlIHVwbG9hZCBoYXMgYmVlblxuICAgICAgLy8gYWJvcnRlZCBwcmV2aW91c2x5LlxuXG5cbiAgICAgIHRoaXMuX2Fib3J0ZWQgPSBmYWxzZTsgLy8gVGhlIHVwbG9hZCBoYWQgYmVlbiBzdGFydGVkIHByZXZpb3VzbHkgYW5kIHdlIHNob3VsZCByZXVzZSB0aGlzIFVSTC5cblxuICAgICAgaWYgKHRoaXMudXJsICE9IG51bGwpIHtcbiAgICAgICAgKDAsIF9sb2dnZXIubG9nKShcIlJlc3VtaW5nIHVwbG9hZCBmcm9tIHByZXZpb3VzIFVSTDogXCIuY29uY2F0KHRoaXMudXJsKSk7XG5cbiAgICAgICAgdGhpcy5fcmVzdW1lVXBsb2FkKCk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBBIFVSTCBoYXMgbWFudWFsbHkgYmVlbiBzcGVjaWZpZWQsIHNvIHdlIHRyeSB0byByZXN1bWVcblxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZFVybCAhPSBudWxsKSB7XG4gICAgICAgICgwLCBfbG9nZ2VyLmxvZykoXCJSZXN1bWluZyB1cGxvYWQgZnJvbSBwcm92aWRlZCBVUkw6IFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMudXJsKSk7XG4gICAgICAgIHRoaXMudXJsID0gdGhpcy5vcHRpb25zLnVwbG9hZFVybDtcblxuICAgICAgICB0aGlzLl9yZXN1bWVVcGxvYWQoKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIEFuIHVwbG9hZCBoYXMgbm90IHN0YXJ0ZWQgZm9yIHRoZSBmaWxlIHlldCwgc28gd2Ugc3RhcnQgYSBuZXcgb25lXG5cblxuICAgICAgKDAsIF9sb2dnZXIubG9nKSgnQ3JlYXRpbmcgYSBuZXcgdXBsb2FkJyk7XG5cbiAgICAgIHRoaXMuX2NyZWF0ZVVwbG9hZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBYm9ydCBhbnkgcnVubmluZyByZXF1ZXN0IGFuZCBzdG9wIHRoZSBjdXJyZW50IHVwbG9hZC4gQWZ0ZXIgYWJvcnQgaXMgY2FsbGVkLCBubyBldmVudFxuICAgICAqIGhhbmRsZXIgd2lsbCBiZSBpbnZva2VkIGFueW1vcmUuIFlvdSBjYW4gdXNlIHRoZSBgc3RhcnRgIG1ldGhvZCB0byByZXN1bWUgdGhlIHVwbG9hZFxuICAgICAqIGFnYWluLlxuICAgICAqIElmIGBzaG91bGRUZXJtaW5hdGVgIGlzIHRydWUsIHRoZSBgdGVybWluYXRlYCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB0byByZW1vdmUgdGhlXG4gICAgICogY3VycmVudCB1cGxvYWQgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRUZXJtaW5hdGUgVHJ1ZSBpZiB0aGUgdXBsb2FkIHNob3VsZCBiZSBkZWxldGVkIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB3aWxsIGJlIHJlc29sdmVkL3JlamVjdGVkIHdoZW4gdGhlIHJlcXVlc3RzIGZpbmlzaC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFib3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFib3J0KHNob3VsZFRlcm1pbmF0ZSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7IC8vIENvdW50IHRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHNlZSBpZiBhIGNhbGxiYWNrIGlzIGJlaW5nIHByb3ZpZGVkIGluIHRoZSBvbGQgc3R5bGUgcmVxdWlyZWQgYnkgdHVzLWpzLWNsaWVudCAxLngsIHRoZW4gdGhyb3cgYW4gZXJyb3IgaWYgaXQgaXMuXG4gICAgICAvLyBgYXJndW1lbnRzYCBpcyBhIEphdmFTY3JpcHQgYnVpbHQtaW4gdmFyaWFibGUgdGhhdCBjb250YWlucyBhbGwgb2YgdGhlIGZ1bmN0aW9uJ3MgYXJndW1lbnRzLlxuXG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHVzOiB0aGUgYWJvcnQgZnVuY3Rpb24gZG9lcyBub3QgYWNjZXB0IGEgY2FsbGJhY2sgc2luY2UgdjIgYW55bW9yZTsgcGxlYXNlIHVzZSB0aGUgcmV0dXJuZWQgUHJvbWlzZSBpbnN0ZWFkJyk7XG4gICAgICB9IC8vIFN0b3AgYW55IHBhcmFsbGVsIHBhcnRpYWwgdXBsb2FkcywgdGhhdCBoYXZlIGJlZW4gc3RhcnRlZCBpbiBfc3RhcnRQYXJhbGxlbFVwbG9hZHMuXG5cblxuICAgICAgaWYgKHRoaXMuX3BhcmFsbGVsVXBsb2FkcyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3BhcmFsbGVsVXBsb2Fkcy5mb3JFYWNoKGZ1bmN0aW9uICh1cGxvYWQpIHtcbiAgICAgICAgICB1cGxvYWQuYWJvcnQoc2hvdWxkVGVybWluYXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIFN0b3AgYW55IGN1cnJlbnQgcnVubmluZyByZXF1ZXN0LlxuXG5cbiAgICAgIGlmICh0aGlzLl9yZXEgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcmVxLmFib3J0KCk7XG5cbiAgICAgICAgdGhpcy5fc291cmNlLmNsb3NlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Fib3J0ZWQgPSB0cnVlOyAvLyBTdG9wIGFueSB0aW1lb3V0IHVzZWQgZm9yIGluaXRpYXRpbmcgYSByZXRyeS5cblxuICAgICAgaWYgKHRoaXMuX3JldHJ5VGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZXRyeVRpbWVvdXQpO1xuICAgICAgICB0aGlzLl9yZXRyeVRpbWVvdXQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNob3VsZFRlcm1pbmF0ZSB8fCB0aGlzLnVybCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEJhc2VVcGxvYWQudGVybWluYXRlKHRoaXMudXJsLCB0aGlzLm9wdGlvbnMpIC8vIFJlbW92ZSBlbnRyeSBmcm9tIHRoZSBVUkwgc3RvcmFnZSBzaW5jZSB0aGUgdXBsb2FkIFVSTCBpcyBubyBsb25nZXIgdmFsaWQuXG4gICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczQuX3JlbW92ZUZyb21VcmxTdG9yYWdlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2VtaXRIdHRwRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsIG1lc3NhZ2UsIGNhdXNpbmdFcnIpIHtcbiAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgX2Vycm9yLmRlZmF1bHQobWVzc2FnZSwgY2F1c2luZ0VyciwgcmVxLCByZXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2VtaXRFcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdEVycm9yKGVycikge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7IC8vIERvIG5vdCBlbWl0IGVycm9ycywgZS5nLiBmcm9tIGFib3J0ZWQgSFRUUCByZXF1ZXN0cywgaWYgdGhlIHVwbG9hZCBoYXMgYmVlbiBzdG9wcGVkLlxuXG5cbiAgICAgIGlmICh0aGlzLl9hYm9ydGVkKSByZXR1cm47IC8vIENoZWNrIGlmIHdlIHNob3VsZCByZXRyeSwgd2hlbiBlbmFibGVkLCBiZWZvcmUgc2VuZGluZyB0aGUgZXJyb3IgdG8gdGhlIHVzZXIuXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmV0cnlEZWxheXMgIT0gbnVsbCkge1xuICAgICAgICAvLyBXZSB3aWxsIHJlc2V0IHRoZSBhdHRlbXB0IGNvdW50ZXIgaWZcbiAgICAgICAgLy8gLSB3ZSB3ZXJlIGFscmVhZHkgYWJsZSB0byBjb25uZWN0IHRvIHRoZSBzZXJ2ZXIgKG9mZnNldCAhPSBudWxsKSBhbmRcbiAgICAgICAgLy8gLSB3ZSB3ZXJlIGFibGUgdG8gdXBsb2FkIGEgc21hbGwgY2h1bmsgb2YgZGF0YSB0byB0aGUgc2VydmVyXG4gICAgICAgIHZhciBzaG91bGRSZXNldERlbGF5cyA9IHRoaXMuX29mZnNldCAhPSBudWxsICYmIHRoaXMuX29mZnNldCA+IHRoaXMuX29mZnNldEJlZm9yZVJldHJ5O1xuXG4gICAgICAgIGlmIChzaG91bGRSZXNldERlbGF5cykge1xuICAgICAgICAgIHRoaXMuX3JldHJ5QXR0ZW1wdCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdWxkUmV0cnkoZXJyLCB0aGlzLl9yZXRyeUF0dGVtcHQsIHRoaXMub3B0aW9ucykpIHtcbiAgICAgICAgICB2YXIgZGVsYXkgPSB0aGlzLm9wdGlvbnMucmV0cnlEZWxheXNbdGhpcy5fcmV0cnlBdHRlbXB0KytdO1xuICAgICAgICAgIHRoaXMuX29mZnNldEJlZm9yZVJldHJ5ID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgICAgIHRoaXMuX3JldHJ5VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXM1LnN0YXJ0KCk7XG4gICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vbkVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkVycm9yKGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1Ymxpc2hlcyBub3RpZmljYXRpb24gaWYgdGhlIHVwbG9hZCBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgY29tcGxldGVkLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZW1pdFN1Y2Nlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VtaXRTdWNjZXNzKGRhdGEpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVtb3ZlRmluZ2VycHJpbnRPblN1Y2Nlc3MpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHN0b3JlZCBmaW5nZXJwcmludCBhbmQgY29ycmVzcG9uZGluZyBlbmRwb2ludC4gVGhpcyBjYXVzZXNcbiAgICAgICAgLy8gbmV3IHVwbG9hZHMgb2YgdGhlIHNhbWUgZmlsZSB0byBiZSB0cmVhdGVkIGFzIGEgZGlmZmVyZW50IGZpbGUuXG4gICAgICAgIHRoaXMuX3JlbW92ZUZyb21VcmxTdG9yYWdlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9uU3VjY2VzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25TdWNjZXNzKGRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaXNoZXMgbm90aWZpY2F0aW9uIHdoZW4gZGF0YSBoYXMgYmVlbiBzZW50IHRvIHRoZSBzZXJ2ZXIuIFRoaXNcbiAgICAgKiBkYXRhIG1heSBub3QgaGF2ZSBiZWVuIGFjY2VwdGVkIGJ5IHRoZSBzZXJ2ZXIgeWV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVzU2VudCAgTnVtYmVyIG9mIGJ5dGVzIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYnl0ZXNUb3RhbCBUb3RhbCBudW1iZXIgb2YgYnl0ZXMgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyLlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2VtaXRQcm9ncmVzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdFByb2dyZXNzKGJ5dGVzU2VudCwgYnl0ZXNUb3RhbCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMub25Qcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25Qcm9ncmVzcyhieXRlc1NlbnQsIGJ5dGVzVG90YWwpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaXNoZXMgbm90aWZpY2F0aW9uIHdoZW4gYSBjaHVuayBvZiBkYXRhIGhhcyBiZWVuIHNlbnQgdG8gdGhlIHNlcnZlclxuICAgICAqIGFuZCBhY2NlcHRlZCBieSB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjaHVua1NpemUgIFNpemUgb2YgdGhlIGNodW5rIHRoYXQgd2FzIGFjY2VwdGVkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVzQWNjZXB0ZWQgVG90YWwgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgaGF2ZSBiZWVuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VwdGVkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVzVG90YWwgVG90YWwgbnVtYmVyIG9mIGJ5dGVzIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9lbWl0Q2h1bmtDb21wbGV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdENodW5rQ29tcGxldGUoY2h1bmtTaXplLCBieXRlc0FjY2VwdGVkLCBieXRlc1RvdGFsKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vbkNodW5rQ29tcGxldGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9uQ2h1bmtDb21wbGV0ZShjaHVua1NpemUsIGJ5dGVzQWNjZXB0ZWQsIGJ5dGVzVG90YWwpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgdXBsb2FkIHVzaW5nIHRoZSBjcmVhdGlvbiBleHRlbnNpb24gYnkgc2VuZGluZyBhIFBPU1RcbiAgICAgKiByZXF1ZXN0IHRvIHRoZSBlbmRwb2ludC4gQWZ0ZXIgc3VjY2Vzc2Z1bCBjcmVhdGlvbiB0aGUgZmlsZSB3aWxsIGJlXG4gICAgICogdXBsb2FkZWRcbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlVXBsb2FkKCkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmVuZHBvaW50KSB7XG4gICAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ3R1czogdW5hYmxlIHRvIGNyZWF0ZSB1cGxvYWQgYmVjYXVzZSBubyBlbmRwb2ludCBpcyBwcm92aWRlZCcpKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZXEgPSB0aGlzLl9vcGVuUmVxdWVzdCgnUE9TVCcsIHRoaXMub3B0aW9ucy5lbmRwb2ludCk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkTGVuZ3RoRGVmZXJyZWQpIHtcbiAgICAgICAgcmVxLnNldEhlYWRlcignVXBsb2FkLURlZmVyLUxlbmd0aCcsIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxLnNldEhlYWRlcignVXBsb2FkLUxlbmd0aCcsIHRoaXMuX3NpemUpO1xuICAgICAgfSAvLyBBZGQgbWV0YWRhdGEgaWYgdmFsdWVzIGhhdmUgYmVlbiBhZGRlZFxuXG5cbiAgICAgIHZhciBtZXRhZGF0YSA9IGVuY29kZU1ldGFkYXRhKHRoaXMub3B0aW9ucy5tZXRhZGF0YSk7XG5cbiAgICAgIGlmIChtZXRhZGF0YSAhPT0gJycpIHtcbiAgICAgICAgcmVxLnNldEhlYWRlcignVXBsb2FkLU1ldGFkYXRhJywgbWV0YWRhdGEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvbWlzZTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGxvYWREYXRhRHVyaW5nQ3JlYXRpb24gJiYgIXRoaXMub3B0aW9ucy51cGxvYWRMZW5ndGhEZWZlcnJlZCkge1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSAwO1xuICAgICAgICBwcm9taXNlID0gdGhpcy5fYWRkQ2h1bmtUb1JlcXVlc3QocmVxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2UgPSB0aGlzLl9zZW5kUmVxdWVzdChyZXEsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICBpZiAoIWluU3RhdHVzQ2F0ZWdvcnkocmVzLmdldFN0YXR1cygpLCAyMDApKSB7XG4gICAgICAgICAgX3RoaXM2Ll9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCAndHVzOiB1bmV4cGVjdGVkIHJlc3BvbnNlIHdoaWxlIGNyZWF0aW5nIHVwbG9hZCcpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2F0aW9uID0gcmVzLmdldEhlYWRlcignTG9jYXRpb24nKTtcblxuICAgICAgICBpZiAobG9jYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgIF90aGlzNi5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgJ3R1czogaW52YWxpZCBvciBtaXNzaW5nIExvY2F0aW9uIGhlYWRlcicpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90aGlzNi5vcHRpb25zLm1hcFVybCkge1xuICAgICAgICAgIF90aGlzNi51cmwgPSBfdGhpczYub3B0aW9ucy5tYXBVcmwocmVzb2x2ZVVybChfdGhpczYub3B0aW9ucy5lbmRwb2ludCwgbG9jYXRpb24pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczYudXJsID0gcmVzb2x2ZVVybChfdGhpczYub3B0aW9ucy5lbmRwb2ludCwgbG9jYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgKDAsIF9sb2dnZXIubG9nKShcIkNyZWF0ZWQgdXBsb2FkIGF0IFwiLmNvbmNhdChfdGhpczYudXJsKSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBfdGhpczYub3B0aW9ucy5fb25VcGxvYWRVcmxBdmFpbGFibGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBfdGhpczYub3B0aW9ucy5fb25VcGxvYWRVcmxBdmFpbGFibGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdGhpczYuX3NpemUgPT09IDApIHtcbiAgICAgICAgICAvLyBOb3RoaW5nIHRvIHVwbG9hZCBhbmQgZmlsZSB3YXMgc3VjY2Vzc2Z1bGx5IGNyZWF0ZWRcbiAgICAgICAgICBfdGhpczYuX2VtaXRTdWNjZXNzKHJlcy5nZXRCb2R5KCkpO1xuXG4gICAgICAgICAgX3RoaXM2Ll9zb3VyY2UuY2xvc2UoKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzNi5fc2F2ZVVwbG9hZEluVXJsU3RvcmFnZSgpO1xuXG4gICAgICAgIGlmIChfdGhpczYub3B0aW9ucy51cGxvYWREYXRhRHVyaW5nQ3JlYXRpb24pIHtcbiAgICAgICAgICBfdGhpczYuX2hhbmRsZVVwbG9hZFJlc3BvbnNlKHJlcSwgcmVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczYuX29mZnNldCA9IDA7XG5cbiAgICAgICAgICBfdGhpczYuX3BlcmZvcm1VcGxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIF90aGlzNi5fZW1pdEh0dHBFcnJvcihyZXEsIG51bGwsICd0dXM6IGZhaWxlZCB0byBjcmVhdGUgdXBsb2FkJywgZXJyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKlxuICAgICAqIFRyeSB0byByZXN1bWUgYW4gZXhpc3RpbmcgdXBsb2FkLiBGaXJzdCBhIEhFQUQgcmVxdWVzdCB3aWxsIGJlIHNlbnRcbiAgICAgKiB0byByZXRyaWV2ZSB0aGUgb2Zmc2V0LiBJZiB0aGUgcmVxdWVzdCBmYWlscyBhIG5ldyB1cGxvYWQgd2lsbCBiZVxuICAgICAqIGNyZWF0ZWQuIEluIHRoZSBjYXNlIG9mIGEgc3VjY2Vzc2Z1bCByZXNwb25zZSB0aGUgZmlsZSB3aWxsIGJlIHVwbG9hZGVkLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVzdW1lVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXN1bWVVcGxvYWQoKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgdmFyIHJlcSA9IHRoaXMuX29wZW5SZXF1ZXN0KCdIRUFEJywgdGhpcy51cmwpO1xuXG4gICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3NlbmRSZXF1ZXN0KHJlcSwgbnVsbCk7XG5cbiAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIHZhciBzdGF0dXMgPSByZXMuZ2V0U3RhdHVzKCk7XG5cbiAgICAgICAgaWYgKCFpblN0YXR1c0NhdGVnb3J5KHN0YXR1cywgMjAwKSkge1xuICAgICAgICAgIGlmIChpblN0YXR1c0NhdGVnb3J5KHN0YXR1cywgNDAwKSkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHN0b3JlZCBmaW5nZXJwcmludCBhbmQgY29ycmVzcG9uZGluZyBlbmRwb2ludCxcbiAgICAgICAgICAgIC8vIG9uIGNsaWVudCBlcnJvcnMgc2luY2UgdGhlIGZpbGUgY2FuIG5vdCBiZSBmb3VuZFxuICAgICAgICAgICAgX3RoaXM3Ll9yZW1vdmVGcm9tVXJsU3RvcmFnZSgpO1xuICAgICAgICAgIH0gLy8gSWYgdGhlIHVwbG9hZCBpcyBsb2NrZWQgKGluZGljYXRlZCBieSB0aGUgNDIzIExvY2tlZCBzdGF0dXMgY29kZSksIHdlXG4gICAgICAgICAgLy8gZW1pdCBhbiBlcnJvciBpbnN0ZWFkIG9mIGRpcmVjdGx5IHN0YXJ0aW5nIGEgbmV3IHVwbG9hZC4gVGhpcyB3YXkgdGhlXG4gICAgICAgICAgLy8gcmV0cnkgbG9naWMgY2FuIGNhdGNoIHRoZSBlcnJvciBhbmQgd2lsbCByZXRyeSB0aGUgdXBsb2FkLiBBbiB1cGxvYWRcbiAgICAgICAgICAvLyBpcyB1c3VhbGx5IGxvY2tlZCBmb3IgYSBzaG9ydCBwZXJpb2Qgb2YgdGltZSBhbmQgd2lsbCBiZSBhdmFpbGFibGVcbiAgICAgICAgICAvLyBhZnRlcndhcmRzLlxuXG5cbiAgICAgICAgICBpZiAoc3RhdHVzID09PSA0MjMpIHtcbiAgICAgICAgICAgIF90aGlzNy5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgJ3R1czogdXBsb2FkIGlzIGN1cnJlbnRseSBsb2NrZWQ7IHJldHJ5IGxhdGVyJyk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIV90aGlzNy5vcHRpb25zLmVuZHBvaW50KSB7XG4gICAgICAgICAgICAvLyBEb24ndCBhdHRlbXB0IHRvIGNyZWF0ZSBhIG5ldyB1cGxvYWQgaWYgbm8gZW5kcG9pbnQgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICBfdGhpczcuX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsICd0dXM6IHVuYWJsZSB0byByZXN1bWUgdXBsb2FkIChuZXcgdXBsb2FkIGNhbm5vdCBiZSBjcmVhdGVkIHdpdGhvdXQgYW4gZW5kcG9pbnQpJyk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IC8vIFRyeSB0byBjcmVhdGUgYSBuZXcgdXBsb2FkXG5cblxuICAgICAgICAgIF90aGlzNy51cmwgPSBudWxsO1xuXG4gICAgICAgICAgX3RoaXM3Ll9jcmVhdGVVcGxvYWQoKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvZmZzZXQgPSBwYXJzZUludChyZXMuZ2V0SGVhZGVyKCdVcGxvYWQtT2Zmc2V0JyksIDEwKTtcblxuICAgICAgICBpZiAoaXNOYU4ob2Zmc2V0KSkge1xuICAgICAgICAgIF90aGlzNy5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgJ3R1czogaW52YWxpZCBvciBtaXNzaW5nIG9mZnNldCB2YWx1ZScpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHBhcnNlSW50KHJlcy5nZXRIZWFkZXIoJ1VwbG9hZC1MZW5ndGgnKSwgMTApO1xuXG4gICAgICAgIGlmIChpc05hTihsZW5ndGgpICYmICFfdGhpczcub3B0aW9ucy51cGxvYWRMZW5ndGhEZWZlcnJlZCkge1xuICAgICAgICAgIF90aGlzNy5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgJ3R1czogaW52YWxpZCBvciBtaXNzaW5nIGxlbmd0aCB2YWx1ZScpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBfdGhpczcub3B0aW9ucy5fb25VcGxvYWRVcmxBdmFpbGFibGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBfdGhpczcub3B0aW9ucy5fb25VcGxvYWRVcmxBdmFpbGFibGUoKTtcbiAgICAgICAgfSAvLyBVcGxvYWQgaGFzIGFscmVhZHkgYmVlbiBjb21wbGV0ZWQgYW5kIHdlIGRvIG5vdCBuZWVkIHRvIHNlbmQgYWRkaXRpb25hbFxuICAgICAgICAvLyBkYXRhIHRvIHRoZSBzZXJ2ZXJcblxuXG4gICAgICAgIGlmIChvZmZzZXQgPT09IGxlbmd0aCkge1xuICAgICAgICAgIF90aGlzNy5fZW1pdFByb2dyZXNzKGxlbmd0aCwgbGVuZ3RoKTtcblxuICAgICAgICAgIF90aGlzNy5fZW1pdFN1Y2Nlc3MocmVzLmdldEJvZHkoKSk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczcuX29mZnNldCA9IG9mZnNldDtcblxuICAgICAgICBfdGhpczcuX3BlcmZvcm1VcGxvYWQoKTtcbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBfdGhpczcuX2VtaXRIdHRwRXJyb3IocmVxLCBudWxsLCAndHVzOiBmYWlsZWQgdG8gcmVzdW1lIHVwbG9hZCcsIGVycik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgdXBsb2FkaW5nIHRoZSBmaWxlIHVzaW5nIFBBVENIIHJlcXVlc3RzLiBUaGUgZmlsZSB3aWxsIGJlIGRpdmlkZWRcbiAgICAgKiBpbnRvIGNodW5rcyBhcyBzcGVjaWZpZWQgaW4gdGhlIGNodW5rU2l6ZSBvcHRpb24uIER1cmluZyB0aGUgdXBsb2FkXG4gICAgICogdGhlIG9uUHJvZ3Jlc3MgZXZlbnQgaGFuZGxlciBtYXkgYmUgaW52b2tlZCBtdWx0aXBsZSB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BlcmZvcm1VcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BlcmZvcm1VcGxvYWQoKSB7XG4gICAgICB2YXIgX3RoaXM4ID0gdGhpczsgLy8gSWYgdGhlIHVwbG9hZCBoYXMgYmVlbiBhYm9ydGVkLCB3ZSB3aWxsIG5vdCBzZW5kIHRoZSBuZXh0IFBBVENIIHJlcXVlc3QuXG4gICAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBpZiB0aGUgYWJvcnQgbWV0aG9kIHdhcyBjYWxsZWQgZHVyaW5nIGEgY2FsbGJhY2ssIHN1Y2hcbiAgICAgIC8vIGFzIG9uQ2h1bmtDb21wbGV0ZSBvciBvblByb2dyZXNzLlxuXG5cbiAgICAgIGlmICh0aGlzLl9hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlcTsgLy8gU29tZSBicm93c2VyIGFuZCBzZXJ2ZXJzIG1heSBub3Qgc3VwcG9ydCB0aGUgUEFUQ0ggbWV0aG9kLiBGb3IgdGhvc2VcbiAgICAgIC8vIGNhc2VzLCB5b3UgY2FuIHRlbGwgdHVzLWpzLWNsaWVudCB0byB1c2UgYSBQT1NUIHJlcXVlc3Qgd2l0aCB0aGVcbiAgICAgIC8vIFgtSFRUUC1NZXRob2QtT3ZlcnJpZGUgaGVhZGVyIGZvciBzaW11bGF0aW5nIGEgUEFUQ0ggcmVxdWVzdC5cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vdmVycmlkZVBhdGNoTWV0aG9kKSB7XG4gICAgICAgIHJlcSA9IHRoaXMuX29wZW5SZXF1ZXN0KCdQT1NUJywgdGhpcy51cmwpO1xuICAgICAgICByZXEuc2V0SGVhZGVyKCdYLUhUVFAtTWV0aG9kLU92ZXJyaWRlJywgJ1BBVENIJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXEgPSB0aGlzLl9vcGVuUmVxdWVzdCgnUEFUQ0gnLCB0aGlzLnVybCk7XG4gICAgICB9XG5cbiAgICAgIHJlcS5zZXRIZWFkZXIoJ1VwbG9hZC1PZmZzZXQnLCB0aGlzLl9vZmZzZXQpO1xuXG4gICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX2FkZENodW5rVG9SZXF1ZXN0KHJlcSk7XG5cbiAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIGlmICghaW5TdGF0dXNDYXRlZ29yeShyZXMuZ2V0U3RhdHVzKCksIDIwMCkpIHtcbiAgICAgICAgICBfdGhpczguX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsICd0dXM6IHVuZXhwZWN0ZWQgcmVzcG9uc2Ugd2hpbGUgdXBsb2FkaW5nIGNodW5rJyk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczguX2hhbmRsZVVwbG9hZFJlc3BvbnNlKHJlcSwgcmVzKTtcbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAvLyBEb24ndCBlbWl0IGFuIGVycm9yIGlmIHRoZSB1cGxvYWQgd2FzIGFib3J0ZWQgbWFudWFsbHlcbiAgICAgICAgaWYgKF90aGlzOC5fYWJvcnRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzOC5fZW1pdEh0dHBFcnJvcihyZXEsIG51bGwsIFwidHVzOiBmYWlsZWQgdG8gdXBsb2FkIGNodW5rIGF0IG9mZnNldCBcIi5jb25jYXQoX3RoaXM4Ll9vZmZzZXQpLCBlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIF9hZGRDaHVua3RvUmVxdWVzdCByZWFkcyBhIGNodW5rIGZyb20gdGhlIHNvdXJjZSBhbmQgc2VuZHMgaXQgdXNpbmcgdGhlXG4gICAgICogc3VwcGxpZWQgcmVxdWVzdCBvYmplY3QuIEl0IHdpbGwgbm90IGhhbmRsZSB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9hZGRDaHVua1RvUmVxdWVzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkQ2h1bmtUb1JlcXVlc3QocmVxKSB7XG4gICAgICB2YXIgX3RoaXM5ID0gdGhpcztcblxuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgdmFyIGVuZCA9IHRoaXMuX29mZnNldCArIHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gICAgICByZXEuc2V0UHJvZ3Jlc3NIYW5kbGVyKGZ1bmN0aW9uIChieXRlc1NlbnQpIHtcbiAgICAgICAgX3RoaXM5Ll9lbWl0UHJvZ3Jlc3Moc3RhcnQgKyBieXRlc1NlbnQsIF90aGlzOS5fc2l6ZSk7XG4gICAgICB9KTtcbiAgICAgIHJlcS5zZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJyk7IC8vIFRoZSBzcGVjaWZpZWQgY2h1bmtTaXplIG1heSBiZSBJbmZpbml0eSBvciB0aGUgY2FsY2x1YXRlZCBlbmQgcG9zaXRpb25cbiAgICAgIC8vIG1heSBleGNlZWQgdGhlIGZpbGUncyBzaXplLiBJbiBib3RoIGNhc2VzLCB3ZSBsaW1pdCB0aGUgZW5kIHBvc2l0aW9uIHRvXG4gICAgICAvLyB0aGUgaW5wdXQncyB0b3RhbCBzaXplIGZvciBzaW1wbGVyIGNhbGN1bGF0aW9ucyBhbmQgY29ycmVjdG5lc3MuXG5cbiAgICAgIGlmICgoZW5kID09PSBJbmZpbml0eSB8fCBlbmQgPiB0aGlzLl9zaXplKSAmJiAhdGhpcy5vcHRpb25zLnVwbG9hZExlbmd0aERlZmVycmVkKSB7XG4gICAgICAgIGVuZCA9IHRoaXMuX3NpemU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9zb3VyY2Uuc2xpY2Uoc3RhcnQsIGVuZCkudGhlbihmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gX3JlZjIudmFsdWUsXG4gICAgICAgICAgICBkb25lID0gX3JlZjIuZG9uZTsgLy8gSWYgdGhlIHVwbG9hZCBsZW5ndGggaXMgZGVmZXJyZWQsIHRoZSB1cGxvYWQgc2l6ZSB3YXMgbm90IHNwZWNpZmllZCBkdXJpbmdcbiAgICAgICAgLy8gdXBsb2FkIGNyZWF0aW9uLiBTbywgaWYgdGhlIGZpbGUgcmVhZGVyIGlzIGRvbmUgcmVhZGluZywgd2Uga25vdyB0aGUgdG90YWxcbiAgICAgICAgLy8gdXBsb2FkIHNpemUgYW5kIGNhbiB0ZWxsIHRoZSB0dXMgc2VydmVyLlxuXG4gICAgICAgIGlmIChfdGhpczkub3B0aW9ucy51cGxvYWRMZW5ndGhEZWZlcnJlZCAmJiBkb25lKSB7XG4gICAgICAgICAgX3RoaXM5Ll9zaXplID0gX3RoaXM5Ll9vZmZzZXQgKyAodmFsdWUgJiYgdmFsdWUuc2l6ZSA/IHZhbHVlLnNpemUgOiAwKTtcbiAgICAgICAgICByZXEuc2V0SGVhZGVyKCdVcGxvYWQtTGVuZ3RoJywgX3RoaXM5Ll9zaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczkuX3NlbmRSZXF1ZXN0KHJlcSk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczkuX2VtaXRQcm9ncmVzcyhfdGhpczkuX29mZnNldCwgX3RoaXM5Ll9zaXplKTtcblxuICAgICAgICByZXR1cm4gX3RoaXM5Ll9zZW5kUmVxdWVzdChyZXEsIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBfaGFuZGxlVXBsb2FkUmVzcG9uc2UgaXMgdXNlZCBieSByZXF1ZXN0cyB0aGF0IGhhdmVuIGJlZW4gc2VudCB1c2luZyBfYWRkQ2h1bmtUb1JlcXVlc3RcbiAgICAgKiBhbmQgYWxyZWFkeSBoYXZlIHJlY2VpdmVkIGEgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVVcGxvYWRSZXNwb25zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlVXBsb2FkUmVzcG9uc2UocmVxLCByZXMpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBwYXJzZUludChyZXMuZ2V0SGVhZGVyKCdVcGxvYWQtT2Zmc2V0JyksIDEwKTtcblxuICAgICAgaWYgKGlzTmFOKG9mZnNldCkpIHtcbiAgICAgICAgdGhpcy5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgJ3R1czogaW52YWxpZCBvciBtaXNzaW5nIG9mZnNldCB2YWx1ZScpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZW1pdFByb2dyZXNzKG9mZnNldCwgdGhpcy5fc2l6ZSk7XG5cbiAgICAgIHRoaXMuX2VtaXRDaHVua0NvbXBsZXRlKG9mZnNldCAtIHRoaXMuX29mZnNldCwgb2Zmc2V0LCB0aGlzLl9zaXplKTtcblxuICAgICAgdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0O1xuXG4gICAgICBpZiAob2Zmc2V0ID09IHRoaXMuX3NpemUpIHtcbiAgICAgICAgLy8gWWF5LCBmaW5hbGx5IGRvbmUgOilcbiAgICAgICAgdGhpcy5fZW1pdFN1Y2Nlc3MocmVzLmdldEJvZHkoKSk7XG5cbiAgICAgICAgdGhpcy5fc291cmNlLmNsb3NlKCk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wZXJmb3JtVXBsb2FkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBIVFRQIHJlcXVlc3Qgb2JqZWN0IHdpdGggdGhlIGdpdmVuIG1ldGhvZCBhbmQgVVJMLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfb3BlblJlcXVlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29wZW5SZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gICAgICB2YXIgcmVxID0gb3BlblJlcXVlc3QobWV0aG9kLCB1cmwsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLl9yZXEgPSByZXE7XG4gICAgICByZXR1cm4gcmVxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGVudHJ5IGluIHRoZSBVUkwgc3RvcmFnZSwgaWYgaXQgaGFzIGJlZW4gc2F2ZWQgYmVmb3JlLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVtb3ZlRnJvbVVybFN0b3JhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUZyb21VcmxTdG9yYWdlKCkge1xuICAgICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMuX3VybFN0b3JhZ2VLZXkpIHJldHVybjtcblxuICAgICAgdGhpcy5fdXJsU3RvcmFnZS5yZW1vdmVVcGxvYWQodGhpcy5fdXJsU3RvcmFnZUtleSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIF90aGlzMTAuX2VtaXRFcnJvcihlcnIpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3VybFN0b3JhZ2VLZXkgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIHVwbG9hZCBVUkwgdG8gdGhlIFVSTCBzdG9yYWdlLCBpZiBwb3NzaWJsZS5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NhdmVVcGxvYWRJblVybFN0b3JhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NhdmVVcGxvYWRJblVybFN0b3JhZ2UoKSB7XG4gICAgICB2YXIgX3RoaXMxMSA9IHRoaXM7IC8vIE9ubHkgaWYgYSBmaW5nZXJwcmludCB3YXMgY2FsY3VsYXRlZCBmb3IgdGhlIGlucHV0IChpLmUuIG5vdCBhIHN0cmVhbSksIHdlIGNhbiBzdG9yZSB0aGUgdXBsb2FkIFVSTC5cblxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zdG9yZUZpbmdlcnByaW50Rm9yUmVzdW1pbmcgfHwgIXRoaXMuX2ZpbmdlcnByaW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0b3JlZFVwbG9hZCA9IHtcbiAgICAgICAgc2l6ZTogdGhpcy5fc2l6ZSxcbiAgICAgICAgbWV0YWRhdGE6IHRoaXMub3B0aW9ucy5tZXRhZGF0YSxcbiAgICAgICAgY3JlYXRpb25UaW1lOiBuZXcgRGF0ZSgpLnRvU3RyaW5nKClcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLl9wYXJhbGxlbFVwbG9hZHMpIHtcbiAgICAgICAgLy8gU2F2ZSBtdWx0aXBsZSBVUkxzIGlmIHRoZSBwYXJhbGxlbFVwbG9hZHMgb3B0aW9uIGlzIHVzZWQgLi4uXG4gICAgICAgIHN0b3JlZFVwbG9hZC5wYXJhbGxlbFVwbG9hZFVybHMgPSB0aGlzLl9wYXJhbGxlbFVwbG9hZFVybHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAuLi4gb3RoZXJ3aXNlIHdlIGp1c3Qgc2F2ZSB0aGUgb25lIGF2YWlsYWJsZSBVUkwuXG4gICAgICAgIHN0b3JlZFVwbG9hZC51cGxvYWRVcmwgPSB0aGlzLnVybDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdXJsU3RvcmFnZS5hZGRVcGxvYWQodGhpcy5fZmluZ2VycHJpbnQsIHN0b3JlZFVwbG9hZCkudGhlbihmdW5jdGlvbiAodXJsU3RvcmFnZUtleSkge1xuICAgICAgICByZXR1cm4gX3RoaXMxMS5fdXJsU3RvcmFnZUtleSA9IHVybFN0b3JhZ2VLZXk7XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgX3RoaXMxMS5fZW1pdEVycm9yKGVycik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIHJlcXVlc3Qgd2l0aCB0aGUgcHJvdmlkZWQgYm9keS5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NlbmRSZXF1ZXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZW5kUmVxdWVzdChyZXEpIHtcbiAgICAgIHZhciBib2R5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgICAgcmV0dXJuIHNlbmRSZXF1ZXN0KHJlcSwgYm9keSwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJ0ZXJtaW5hdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGVybWluYXRlKHVybCwgb3B0aW9ucykge1xuICAgICAgLy8gQ291bnQgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gc2VlIGlmIGEgY2FsbGJhY2sgaXMgYmVpbmcgcHJvdmlkZWQgYXMgdGhlIGxhc3RcbiAgICAgIC8vIGFyZ3VtZW50IGluIHRoZSBvbGQgc3R5bGUgcmVxdWlyZWQgYnkgdHVzLWpzLWNsaWVudCAxLngsIHRoZW4gdGhyb3cgYW4gZXJyb3IgaWYgaXQgaXMuXG4gICAgICAvLyBgYXJndW1lbnRzYCBpcyBhIEphdmFTY3JpcHQgYnVpbHQtaW4gdmFyaWFibGUgdGhhdCBjb250YWlucyBhbGwgb2YgdGhlIGZ1bmN0aW9uJ3MgYXJndW1lbnRzLlxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHVzOiB0aGUgdGVybWluYXRlIGZ1bmN0aW9uIGRvZXMgbm90IGFjY2VwdCBhIGNhbGxiYWNrIHNpbmNlIHYyIGFueW1vcmU7IHBsZWFzZSB1c2UgdGhlIHJldHVybmVkIFByb21pc2UgaW5zdGVhZCcpO1xuICAgICAgfSAvLyBOb3RlIHRoYXQgaW4gb3JkZXIgZm9yIHRoZSB0cmljayBhYm92ZSB0byB3b3JrLCBhIGRlZmF1bHQgdmFsdWUgY2Fubm90IGJlIHNldCBmb3IgYG9wdGlvbnNgLFxuICAgICAgLy8gc28gdGhlIGNoZWNrIGJlbG93IHJlcGxhY2VzIHRoZSBvbGQgZGVmYXVsdCBge31gLlxuXG5cbiAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVxID0gb3BlblJlcXVlc3QoJ0RFTEVURScsIHVybCwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gc2VuZFJlcXVlc3QocmVxLCBudWxsLCBvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgLy8gQSAyMDQgcmVzcG9uc2UgaW5kaWNhdGVzIGEgc3VjY2Vzc2Z1bGwgcmVxdWVzdFxuICAgICAgICBpZiAocmVzLmdldFN0YXR1cygpID09PSAyMDQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgX2Vycm9yLmRlZmF1bHQoJ3R1czogdW5leHBlY3RlZCByZXNwb25zZSB3aGlsZSB0ZXJtaW5hdGluZyB1cGxvYWQnLCBudWxsLCByZXEsIHJlcyk7XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgX2Vycm9yLmRlZmF1bHQpKSB7XG4gICAgICAgICAgZXJyID0gbmV3IF9lcnJvci5kZWZhdWx0KCd0dXM6IGZhaWxlZCB0byB0ZXJtaW5hdGUgdXBsb2FkJywgZXJyLCByZXEsIG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzaG91bGRSZXRyeShlcnIsIDAsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IC8vIEluc3RlYWQgb2Yga2VlcGluZyB0cmFjayBvZiB0aGUgcmV0cnkgYXR0ZW1wdHMsIHdlIHJlbW92ZSB0aGUgZmlyc3QgZWxlbWVudCBmcm9tIHRoZSBkZWxheXNcbiAgICAgICAgLy8gYXJyYXkuIElmIHRoZSBhcnJheSBpcyBlbXB0eSwgYWxsIHJldHJ5IGF0dGVtcHRzIGFyZSB1c2VkIHVwIGFuZCB3ZSB3aWxsIGJ1YmJsZSB1cCB0aGUgZXJyb3IuXG4gICAgICAgIC8vIFdlIHJlY3Vyc2l2ZWx5IGNhbGwgdGhlIHRlcm1pbmF0ZSBmdW5jdGlvbiB3aWxsIHJlbW92aW5nIGVsZW1lbnRzIGZyb20gdGhlIHJldHJ5RGVsYXlzIGFycmF5LlxuXG5cbiAgICAgICAgdmFyIGRlbGF5ID0gb3B0aW9ucy5yZXRyeURlbGF5c1swXTtcbiAgICAgICAgdmFyIHJlbWFpbmluZ0RlbGF5cyA9IG9wdGlvbnMucmV0cnlEZWxheXMuc2xpY2UoMSk7XG5cbiAgICAgICAgdmFyIG5ld09wdGlvbnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgIHJldHJ5RGVsYXlzOiByZW1haW5pbmdEZWxheXNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gQmFzZVVwbG9hZC50ZXJtaW5hdGUodXJsLCBuZXdPcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmFzZVVwbG9hZDtcbn0oKTtcblxuZnVuY3Rpb24gZW5jb2RlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgdmFyIGVuY29kZWQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gbWV0YWRhdGEpIHtcbiAgICBlbmNvZGVkLnB1c2goXCJcIi5jb25jYXQoa2V5LCBcIiBcIikuY29uY2F0KF9qc0Jhc2UuQmFzZTY0LmVuY29kZShtZXRhZGF0YVtrZXldKSkpO1xuICB9XG5cbiAgcmV0dXJuIGVuY29kZWQuam9pbignLCcpO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIGdpdmVuIHN0YXR1cyBpcyBpbiB0aGUgcmFuZ2Ugb2YgdGhlIGV4cGVjdGVkIGNhdGVnb3J5LlxuICogRm9yIGV4YW1wbGUsIG9ubHkgYSBzdGF0dXMgYmV0d2VlbiAyMDAgYW5kIDI5OSB3aWxsIHNhdGlzZnkgdGhlIGNhdGVnb3J5IDIwMC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGluU3RhdHVzQ2F0ZWdvcnkoc3RhdHVzLCBjYXRlZ29yeSkge1xuICByZXR1cm4gc3RhdHVzID49IGNhdGVnb3J5ICYmIHN0YXR1cyA8IGNhdGVnb3J5ICsgMTAwO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgSFRUUCByZXF1ZXN0IHdpdGggdGhlIHNwZWNpZmllZCBtZXRob2QgYW5kIFVSTC5cbiAqIFRoZSBuZWNlc3NhcnkgaGVhZGVycyB0aGF0IGFyZSBpbmNsdWRlZCBpbiBldmVyeSByZXF1ZXN0XG4gKiB3aWxsIGJlIGFkZGVkLCBpbmNsdWRpbmcgdGhlIHJlcXVlc3QgSUQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBvcGVuUmVxdWVzdChtZXRob2QsIHVybCwgb3B0aW9ucykge1xuICB2YXIgcmVxID0gb3B0aW9ucy5odHRwU3RhY2suY3JlYXRlUmVxdWVzdChtZXRob2QsIHVybCk7XG4gIHJlcS5zZXRIZWFkZXIoJ1R1cy1SZXN1bWFibGUnLCAnMS4wLjAnKTtcbiAgdmFyIGhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge307XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBoZWFkZXJzKSB7XG4gICAgcmVxLnNldEhlYWRlcihuYW1lLCBoZWFkZXJzW25hbWVdKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmFkZFJlcXVlc3RJZCkge1xuICAgIHZhciByZXF1ZXN0SWQgPSAoMCwgX3V1aWQuZGVmYXVsdCkoKTtcbiAgICByZXEuc2V0SGVhZGVyKCdYLVJlcXVlc3QtSUQnLCByZXF1ZXN0SWQpO1xuICB9XG5cbiAgcmV0dXJuIHJlcTtcbn1cbi8qKlxuICogU2VuZCBhIHJlcXVlc3Qgd2l0aCB0aGUgcHJvdmlkZWQgYm9keSB3aGlsZSBpbnZva2luZyB0aGUgb25CZWZvcmVSZXF1ZXN0XG4gKiBhbmQgb25BZnRlclJlc3BvbnNlIGNhbGxiYWNrcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHNlbmRSZXF1ZXN0KHJlcSwgYm9keSwgb3B0aW9ucykge1xuICB2YXIgb25CZWZvcmVSZXF1ZXN0UHJvbWlzZSA9IHR5cGVvZiBvcHRpb25zLm9uQmVmb3JlUmVxdWVzdCA9PT0gJ2Z1bmN0aW9uJyA/IFByb21pc2UucmVzb2x2ZShvcHRpb25zLm9uQmVmb3JlUmVxdWVzdChyZXEpKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICByZXR1cm4gb25CZWZvcmVSZXF1ZXN0UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVxLnNlbmQoYm9keSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICB2YXIgb25BZnRlclJlc3BvbnNlUHJvbWlzZSA9IHR5cGVvZiBvcHRpb25zLm9uQWZ0ZXJSZXNwb25zZSA9PT0gJ2Z1bmN0aW9uJyA/IFByb21pc2UucmVzb2x2ZShvcHRpb25zLm9uQWZ0ZXJSZXNwb25zZShyZXEsIHJlcykpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICByZXR1cm4gb25BZnRlclJlc3BvbnNlUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGJyb3dzZXIgcnVubmluZyB0aGlzIGNvZGUgaGFzIGludGVybmV0IGFjY2Vzcy5cbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBhbHdheXMgcmV0dXJuIHRydWUgaW4gdGhlIG5vZGUuanMgZW52aXJvbm1lbnRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzT25saW5lKCkge1xuICB2YXIgb25saW5lID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ25hdmlnYXRvcicgaW4gd2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3Iub25MaW5lID09PSBmYWxzZSkge1xuICAgIG9ubGluZSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG9ubGluZTtcbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IGl0IGlzIG9rIHRvIHJldHJ5IGEgcmVxdWVzdC5cbiAqIEBwYXJhbSB7RXJyb3J9IGVyciB0aGUgZXJyb3IgcmV0dXJuZWQgZnJvbSB0aGUgbGFzdCByZXF1ZXN0XG4gKiBAcGFyYW0ge251bWJlcn0gcmV0cnlBdHRlbXB0IHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIHJlcXVlc3QgaGFzIGFscmVhZHkgYmVlbiByZXRyaWVkXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyB0dXMgVXBsb2FkIG9wdGlvbnNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHNob3VsZFJldHJ5KGVyciwgcmV0cnlBdHRlbXB0LCBvcHRpb25zKSB7XG4gIC8vIFdlIG9ubHkgYXR0ZW1wdCBhIHJldHJ5IGlmXG4gIC8vIC0gcmV0cnlEZWxheXMgb3B0aW9uIGlzIHNldFxuICAvLyAtIHdlIGRpZG4ndCBleGNlZWQgdGhlIG1heGl1bSBudW1iZXIgb2YgcmV0cmllcywgeWV0LCBhbmRcbiAgLy8gLSB0aGlzIGVycm9yIHdhcyBjYXVzZWQgYnkgYSByZXF1ZXN0IG9yIGl0J3MgcmVzcG9uc2UgYW5kXG4gIC8vIC0gdGhlIGVycm9yIGlzIHNlcnZlciBlcnJvciAoaS5lLiBub3QgYSBzdGF0dXMgNHh4IGV4Y2VwdCBhIDQwOSBvciA0MjMpIG9yXG4gIC8vIGEgb25TaG91bGRSZXRyeSBpcyBzcGVjaWZpZWQgYW5kIHJldHVybnMgdHJ1ZVxuICAvLyAtIHRoZSBicm93c2VyIGRvZXMgbm90IGluZGljYXRlIHRoYXQgd2UgYXJlIG9mZmxpbmVcbiAgaWYgKG9wdGlvbnMucmV0cnlEZWxheXMgPT0gbnVsbCB8fCByZXRyeUF0dGVtcHQgPj0gb3B0aW9ucy5yZXRyeURlbGF5cy5sZW5ndGggfHwgZXJyLm9yaWdpbmFsUmVxdWVzdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMub25TaG91bGRSZXRyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBvcHRpb25zLm9uU2hvdWxkUmV0cnkoZXJyLCByZXRyeUF0dGVtcHQsIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIHN0YXR1cyA9IGVyci5vcmlnaW5hbFJlc3BvbnNlID8gZXJyLm9yaWdpbmFsUmVzcG9uc2UuZ2V0U3RhdHVzKCkgOiAwO1xuICByZXR1cm4gKCFpblN0YXR1c0NhdGVnb3J5KHN0YXR1cywgNDAwKSB8fCBzdGF0dXMgPT09IDQwOSB8fCBzdGF0dXMgPT09IDQyMykgJiYgaXNPbmxpbmUoKTtcbn1cbi8qKlxuICogUmVzb2x2ZSBhIHJlbGF0aXZlIGxpbmsgZ2l2ZW4gdGhlIG9yaWdpbiBhcyBzb3VyY2UuIEZvciBleGFtcGxlLFxuICogaWYgYSBIVFRQIHJlcXVlc3QgdG8gaHR0cDovL2V4YW1wbGUuY29tL2ZpbGVzLyByZXR1cm5zIGEgTG9jYXRpb25cbiAqIGhlYWRlciB3aXRoIHRoZSB2YWx1ZSAvdXBsb2FkL2FiYywgdGhlIHJlc29sdmVkIFVSTCB3aWxsIGJlOlxuICogaHR0cDovL2V4YW1wbGUuY29tL3VwbG9hZC9hYmNcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlc29sdmVVcmwob3JpZ2luLCBsaW5rKSB7XG4gIHJldHVybiBuZXcgX3VybFBhcnNlLmRlZmF1bHQobGluaywgb3JpZ2luKS50b1N0cmluZygpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb25zIGZvciB0aGUgcGFydHMgaWYgYW4gdXBsb2FkXG4gKiBpcyBzcGxpdCBpbnRvIG11bHRpcGxlIHBhcmFsbGVsIHJlcXVlc3RzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3RhbFNpemUgVGhlIGJ5dGUgc2l6ZSBvZiB0aGUgdXBsb2FkLCB3aGljaCB3aWxsIGJlIHNwbGl0LlxuICogQHBhcmFtIHtudW1iZXJ9IHBhcnRDb3VudCBUaGUgbnVtYmVyIGluIGhvdyBtYW55IHBhcnRzIHRoZSB1cGxvYWQgd2lsbCBiZSBzcGxpdC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IHByZXZpb3VzVXJscyBUaGUgdXBsb2FkIFVSTHMgZm9yIHByZXZpb3VzIHBhcnRzLlxuICogQHJldHVybiB7b2JqZWN0W119XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHNwbGl0U2l6ZUludG9QYXJ0cyh0b3RhbFNpemUsIHBhcnRDb3VudCwgcHJldmlvdXNVcmxzKSB7XG4gIHZhciBwYXJ0U2l6ZSA9IE1hdGguZmxvb3IodG90YWxTaXplIC8gcGFydENvdW50KTtcbiAgdmFyIHBhcnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0Q291bnQ7IGkrKykge1xuICAgIHBhcnRzLnB1c2goe1xuICAgICAgc3RhcnQ6IHBhcnRTaXplICogaSxcbiAgICAgIGVuZDogcGFydFNpemUgKiAoaSArIDEpXG4gICAgfSk7XG4gIH1cblxuICBwYXJ0c1twYXJ0Q291bnQgLSAxXS5lbmQgPSB0b3RhbFNpemU7IC8vIEF0dGFjaCBVUkxzIGZyb20gcHJldmlvdXMgdXBsb2FkcywgaWYgYXZhaWxhYmxlLlxuXG4gIGlmIChwcmV2aW91c1VybHMpIHtcbiAgICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0LCBpbmRleCkge1xuICAgICAgcGFydC51cGxvYWRVcmwgPSBwcmV2aW91c1VybHNbaW5kZXhdIHx8IG51bGw7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbkJhc2VVcGxvYWQuZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbnZhciBfZGVmYXVsdCA9IEJhc2VVcGxvYWQ7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHV1aWQ7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBVVUlEIHY0IGJhc2VkIG9uIHJhbmRvbSBudW1iZXJzLiBXZSBpbnRlbnRpb2FubGx5IHVzZSB0aGUgbGVzc1xuICogc2VjdXJlIE1hdGgucmFuZG9tIGZ1bmN0aW9uIGhlcmUgc2luY2UgdGhlIG1vcmUgc2VjdXJlIGNyeXB0by5nZXRSYW5kb21OdW1iZXJzXG4gKiBpcyBub3QgYXZhaWxhYmxlIG9uIGFsbCBwbGF0Zm9ybXMuXG4gKiBUaGlzIGlzIG5vdCBhIHByb2JsZW0gZm9yIHVzIHNpbmNlIHdlIHVzZSB0aGUgVVVJRCBvbmx5IGZvciBnZW5lcmF0aW5nIGFcbiAqIHJlcXVlc3QgSUQsIHNvIHdlIGNhbiBjb3JyZWxhdGUgc2VydmVyIGxvZ3MgdG8gY2xpZW50IGVycm9ycy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHRha2VuIGZyb20gZm9sbG93aW5nIHNpdGU6XG4gKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDUwMzQvY3JlYXRlLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0XG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgZ2VuZXJhdGUgVVVJRFxuICovXG5mdW5jdGlvbiB1dWlkKCkge1xuICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCxcbiAgICAgICAgdiA9IGMgPT0gJ3gnID8gciA6IHIgJiAweDMgfCAweDg7XG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICB9KTtcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2F4aW9zJyk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgc2V0dGxlID0gcmVxdWlyZSgnLi8uLi9jb3JlL3NldHRsZScpO1xudmFyIGNvb2tpZXMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29va2llcycpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgYnVpbGRGdWxsUGF0aCA9IHJlcXVpcmUoJy4uL2NvcmUvYnVpbGRGdWxsUGF0aCcpO1xudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9wYXJzZUhlYWRlcnMnKTtcbnZhciBpc1VSTFNhbWVPcmlnaW4gPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luJyk7XG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL2NyZWF0ZUVycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geGhyQWRhcHRlcihjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGRpc3BhdGNoWGhyUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxdWVzdERhdGEgPSBjb25maWcuZGF0YTtcbiAgICB2YXIgcmVxdWVzdEhlYWRlcnMgPSBjb25maWcuaGVhZGVycztcblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSkge1xuICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gICAgaWYgKGNvbmZpZy5hdXRoKSB7XG4gICAgICB2YXIgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcbiAgICAgIHZhciBwYXNzd29yZCA9IGNvbmZpZy5hdXRoLnBhc3N3b3JkID8gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGNvbmZpZy5hdXRoLnBhc3N3b3JkKSkgOiAnJztcbiAgICAgIHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIGJ0b2EodXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZCk7XG4gICAgfVxuXG4gICAgdmFyIGZ1bGxQYXRoID0gYnVpbGRGdWxsUGF0aChjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG4gICAgcmVxdWVzdC5vcGVuKGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSwgYnVpbGRVUkwoZnVsbFBhdGgsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKSwgdHJ1ZSk7XG5cbiAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCBpbiBNU1xuICAgIHJlcXVlc3QudGltZW91dCA9IGNvbmZpZy50aW1lb3V0O1xuXG4gICAgLy8gTGlzdGVuIGZvciByZWFkeSBzdGF0ZVxuICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCB8fCByZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgcmVxdWVzdCBlcnJvcmVkIG91dCBhbmQgd2UgZGlkbid0IGdldCBhIHJlc3BvbnNlLCB0aGlzIHdpbGwgYmVcbiAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXG4gICAgICAvLyBXaXRoIG9uZSBleGNlcHRpb246IHJlcXVlc3QgdGhhdCB1c2luZyBmaWxlOiBwcm90b2NvbCwgbW9zdCBicm93c2Vyc1xuICAgICAgLy8gd2lsbCByZXR1cm4gc3RhdHVzIGFzIDAgZXZlbiB0aG91Z2ggaXQncyBhIHN1Y2Nlc3NmdWwgcmVxdWVzdFxuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICEocmVxdWVzdC5yZXNwb25zZVVSTCAmJiByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUHJlcGFyZSB0aGUgcmVzcG9uc2VcbiAgICAgIHZhciByZXNwb25zZUhlYWRlcnMgPSAnZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJyBpbiByZXF1ZXN0ID8gcGFyc2VIZWFkZXJzKHJlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpIDogbnVsbDtcbiAgICAgIHZhciByZXNwb25zZURhdGEgPSAhY29uZmlnLnJlc3BvbnNlVHlwZSB8fCBjb25maWcucmVzcG9uc2VUeXBlID09PSAndGV4dCcgPyByZXF1ZXN0LnJlc3BvbnNlVGV4dCA6IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0XG4gICAgICB9O1xuXG4gICAgICBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgYnJvd3NlciByZXF1ZXN0IGNhbmNlbGxhdGlvbiAoYXMgb3Bwb3NlZCB0byBhIG1hbnVhbCBjYW5jZWxsYXRpb24pXG4gICAgcmVxdWVzdC5vbmFib3J0ID0gZnVuY3Rpb24gaGFuZGxlQWJvcnQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ1JlcXVlc3QgYWJvcnRlZCcsIGNvbmZpZywgJ0VDT05OQUJPUlRFRCcsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcbiAgICAgIC8vIFJlYWwgZXJyb3JzIGFyZSBoaWRkZW4gZnJvbSB1cyBieSB0aGUgYnJvd3NlclxuICAgICAgLy8gb25lcnJvciBzaG91bGQgb25seSBmaXJlIGlmIGl0J3MgYSBuZXR3b3JrIGVycm9yXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBjb25maWcsIG51bGwsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSB0aW1lb3V0XG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge1xuICAgICAgdmFyIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSAndGltZW91dCBvZiAnICsgY29uZmlnLnRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnO1xuICAgICAgaWYgKGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBjb25maWcudGltZW91dEVycm9yTWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcih0aW1lb3V0RXJyb3JNZXNzYWdlLCBjb25maWcsICdFQ09OTkFCT1JURUQnLFxuICAgICAgICByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAvLyBUaGlzIGlzIG9ubHkgZG9uZSBpZiBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuICAgIGlmICh1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpKSB7XG4gICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgIHZhciB4c3JmVmFsdWUgPSAoY29uZmlnLndpdGhDcmVkZW50aWFscyB8fCBpc1VSTFNhbWVPcmlnaW4oZnVsbFBhdGgpKSAmJiBjb25maWcueHNyZkNvb2tpZU5hbWUgP1xuICAgICAgICBjb29raWVzLnJlYWQoY29uZmlnLnhzcmZDb29raWVOYW1lKSA6XG4gICAgICAgIHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHhzcmZWYWx1ZSkge1xuICAgICAgICByZXF1ZXN0SGVhZGVyc1tjb25maWcueHNyZkhlYWRlck5hbWVdID0geHNyZlZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBoZWFkZXJzIHRvIHRoZSByZXF1ZXN0XG4gICAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiByZXF1ZXN0KSB7XG4gICAgICB1dGlscy5mb3JFYWNoKHJlcXVlc3RIZWFkZXJzLCBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKHZhbCwga2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdERhdGEgPT09ICd1bmRlZmluZWQnICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJykge1xuICAgICAgICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICAgICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UgYWRkIGhlYWRlciB0byB0aGUgcmVxdWVzdFxuICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9ICEhY29uZmlnLndpdGhDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRXhwZWN0ZWQgRE9NRXhjZXB0aW9uIHRocm93biBieSBicm93c2VycyBub3QgY29tcGF0aWJsZSBYTUxIdHRwUmVxdWVzdCBMZXZlbCAyLlxuICAgICAgICAvLyBCdXQsIHRoaXMgY2FuIGJlIHN1cHByZXNzZWQgZm9yICdqc29uJyB0eXBlIGFzIGl0IGNhbiBiZSBwYXJzZWQgYnkgZGVmYXVsdCAndHJhbnNmb3JtUmVzcG9uc2UnIGZ1bmN0aW9uLlxuICAgICAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25Eb3dubG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi5wcm9taXNlLnRoZW4oZnVuY3Rpb24gb25DYW5jZWxlZChjYW5jZWwpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZWplY3QoY2FuY2VsKTtcbiAgICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghcmVxdWVzdERhdGEpIHtcbiAgICAgIHJlcXVlc3REYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgcmVxdWVzdC5zZW5kKHJlcXVlc3REYXRhKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG52YXIgQXhpb3MgPSByZXF1aXJlKCcuL2NvcmUvQXhpb3MnKTtcbnZhciBtZXJnZUNvbmZpZyA9IHJlcXVpcmUoJy4vY29yZS9tZXJnZUNvbmZpZycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICB2YXIgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKTtcbiAgdmFyIGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQpO1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG52YXIgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0cyk7XG5cbi8vIEV4cG9zZSBBeGlvcyBjbGFzcyB0byBhbGxvdyBjbGFzcyBpbmhlcml0YW5jZVxuYXhpb3MuQXhpb3MgPSBBeGlvcztcblxuLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuYXhpb3MuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGluc3RhbmNlQ29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVJbnN0YW5jZShtZXJnZUNvbmZpZyhheGlvcy5kZWZhdWx0cywgaW5zdGFuY2VDb25maWcpKTtcbn07XG5cbi8vIEV4cG9zZSBDYW5jZWwgJiBDYW5jZWxUb2tlblxuYXhpb3MuQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsJyk7XG5heGlvcy5DYW5jZWxUb2tlbiA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbFRva2VuJyk7XG5heGlvcy5pc0NhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL2lzQ2FuY2VsJyk7XG5cbi8vIEV4cG9zZSBhbGwvc3ByZWFkXG5heGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5heGlvcy5zcHJlYWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ByZWFkJyk7XG5cbi8vIEV4cG9zZSBpc0F4aW9zRXJyb3JcbmF4aW9zLmlzQXhpb3NFcnJvciA9IHJlcXVpcmUoJy4vaGVscGVycy9pc0F4aW9zRXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBheGlvcztcblxuLy8gQWxsb3cgdXNlIG9mIGRlZmF1bHQgaW1wb3J0IHN5bnRheCBpbiBUeXBlU2NyaXB0XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gYXhpb3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBgQ2FuY2VsYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIENhbmNlbChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbkNhbmNlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuICdDYW5jZWwnICsgKHRoaXMubWVzc2FnZSA/ICc6ICcgKyB0aGlzLm1lc3NhZ2UgOiAnJyk7XG59O1xuXG5DYW5jZWwucHJvdG90eXBlLl9fQ0FOQ0VMX18gPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENhbmNlbCA9IHJlcXVpcmUoJy4vQ2FuY2VsJyk7XG5cbi8qKlxuICogQSBgQ2FuY2VsVG9rZW5gIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIGFuIG9wZXJhdGlvbi5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIFRoZSBleGVjdXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsVG9rZW4oZXhlY3V0b3IpIHtcbiAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciByZXNvbHZlUHJvbWlzZTtcbiAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gcHJvbWlzZUV4ZWN1dG9yKHJlc29sdmUpIHtcbiAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gIH0pO1xuXG4gIHZhciB0b2tlbiA9IHRoaXM7XG4gIGV4ZWN1dG9yKGZ1bmN0aW9uIGNhbmNlbChtZXNzYWdlKSB7XG4gICAgaWYgKHRva2VuLnJlYXNvbikge1xuICAgICAgLy8gQ2FuY2VsbGF0aW9uIGhhcyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdG9rZW4ucmVhc29uID0gbmV3IENhbmNlbChtZXNzYWdlKTtcbiAgICByZXNvbHZlUHJvbWlzZSh0b2tlbi5yZWFzb24pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5DYW5jZWxUb2tlbi5wcm90b3R5cGUudGhyb3dJZlJlcXVlc3RlZCA9IGZ1bmN0aW9uIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gIGlmICh0aGlzLnJlYXNvbikge1xuICAgIHRocm93IHRoaXMucmVhc29uO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBuZXcgYENhbmNlbFRva2VuYCBhbmQgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCxcbiAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXG4gKi9cbkNhbmNlbFRva2VuLnNvdXJjZSA9IGZ1bmN0aW9uIHNvdXJjZSgpIHtcbiAgdmFyIGNhbmNlbDtcbiAgdmFyIHRva2VuID0gbmV3IENhbmNlbFRva2VuKGZ1bmN0aW9uIGV4ZWN1dG9yKGMpIHtcbiAgICBjYW5jZWwgPSBjO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbjogdG9rZW4sXG4gICAgY2FuY2VsOiBjYW5jZWxcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsVG9rZW47XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNDYW5jZWwodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9fQ0FOQ0VMX18pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIEludGVyY2VwdG9yTWFuYWdlciA9IHJlcXVpcmUoJy4vSW50ZXJjZXB0b3JNYW5hZ2VyJyk7XG52YXIgZGlzcGF0Y2hSZXF1ZXN0ID0gcmVxdWlyZSgnLi9kaXNwYXRjaFJlcXVlc3QnKTtcbnZhciBtZXJnZUNvbmZpZyA9IHJlcXVpcmUoJy4vbWVyZ2VDb25maWcnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gQXhpb3MoaW5zdGFuY2VDb25maWcpIHtcbiAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnO1xuICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICovXG5BeGlvcy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QoY29uZmlnKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIGNvbmZpZyA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcbiAgICBjb25maWcudXJsID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgfVxuXG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG5cbiAgLy8gU2V0IGNvbmZpZy5tZXRob2RcbiAgaWYgKGNvbmZpZy5tZXRob2QpIHtcbiAgICBjb25maWcubWV0aG9kID0gY29uZmlnLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKHRoaXMuZGVmYXVsdHMubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IHRoaXMuZGVmYXVsdHMubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnLm1ldGhvZCA9ICdnZXQnO1xuICB9XG5cbiAgLy8gSG9vayB1cCBpbnRlcmNlcHRvcnMgbWlkZGxld2FyZVxuICB2YXIgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LCB1bmRlZmluZWRdO1xuICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjb25maWcpO1xuXG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZm9yRWFjaChmdW5jdGlvbiB1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgIGNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24gcHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4ucHVzaChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgd2hpbGUgKGNoYWluLmxlbmd0aCkge1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW4uc2hpZnQoKSwgY2hhaW4uc2hpZnQoKSk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbkF4aW9zLnByb3RvdHlwZS5nZXRVcmkgPSBmdW5jdGlvbiBnZXRVcmkoY29uZmlnKSB7XG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG4gIHJldHVybiBidWlsZFVSTChjb25maWcudXJsLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplcikucmVwbGFjZSgvXlxcPy8sICcnKTtcbn07XG5cbi8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdvcHRpb25zJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IChjb25maWcgfHwge30pLmRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEludGVyY2VwdG9yTWFuYWdlcigpIHtcbiAgdGhpcy5oYW5kbGVycyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgIGZ1bGZpbGxlZDogZnVsZmlsbGVkLFxuICAgIHJlamVjdGVkOiByZWplY3RlZFxuICB9KTtcbiAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGludGVyY2VwdG9yIGZyb20gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmVqZWN0ID0gZnVuY3Rpb24gZWplY3QoaWQpIHtcbiAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gKlxuICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcbiAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgaWYgKGggIT09IG51bGwpIHtcbiAgICAgIGZuKGgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyY2VwdG9yTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzQWJzb2x1dGVVUkwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwnKTtcbnZhciBjb21iaW5lVVJMcyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvY29tYmluZVVSTHMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIGJhc2VVUkwgd2l0aCB0aGUgcmVxdWVzdGVkVVJMLFxuICogb25seSB3aGVuIHRoZSByZXF1ZXN0ZWRVUkwgaXMgbm90IGFscmVhZHkgYW4gYWJzb2x1dGUgVVJMLlxuICogSWYgdGhlIHJlcXVlc3RVUkwgaXMgYWJzb2x1dGUsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgcmVxdWVzdGVkVVJMIHVudG91Y2hlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0ZWRVUkwgQWJzb2x1dGUgb3IgcmVsYXRpdmUgVVJMIHRvIGNvbWJpbmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBmdWxsIHBhdGhcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZEZ1bGxQYXRoKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCkge1xuICBpZiAoYmFzZVVSTCAmJiAhaXNBYnNvbHV0ZVVSTChyZXF1ZXN0ZWRVUkwpKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCk7XG4gIH1cbiAgcmV0dXJuIHJlcXVlc3RlZFVSTDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlbmhhbmNlRXJyb3IgPSByZXF1aXJlKCcuL2VuaGFuY2VFcnJvcicpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSwgY29uZmlnLCBlcnJvciBjb2RlLCByZXF1ZXN0IGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVFcnJvcihtZXNzYWdlLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgdHJhbnNmb3JtRGF0YSA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtRGF0YScpO1xudmFyIGlzQ2FuY2VsID0gcmVxdWlyZSgnLi4vY2FuY2VsL2lzQ2FuY2VsJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKSB7XG4gIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICBjb25maWcuY2FuY2VsVG9rZW4udGhyb3dJZlJlcXVlc3RlZCgpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYWRhcHRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRpc3BhdGNoUmVxdWVzdChjb25maWcpIHtcbiAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gIC8vIEVuc3VyZSBoZWFkZXJzIGV4aXN0XG4gIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG5cbiAgLy8gVHJhbnNmb3JtIHJlcXVlc3QgZGF0YVxuICBjb25maWcuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgY29uZmlnLmRhdGEsXG4gICAgY29uZmlnLmhlYWRlcnMsXG4gICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3RcbiAgKTtcblxuICAvLyBGbGF0dGVuIGhlYWRlcnNcbiAgY29uZmlnLmhlYWRlcnMgPSB1dGlscy5tZXJnZShcbiAgICBjb25maWcuaGVhZGVycy5jb21tb24gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNbY29uZmlnLm1ldGhvZF0gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNcbiAgKTtcblxuICB1dGlscy5mb3JFYWNoKFxuICAgIFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJywgJ2NvbW1vbiddLFxuICAgIGZ1bmN0aW9uIGNsZWFuSGVhZGVyQ29uZmlnKG1ldGhvZCkge1xuICAgICAgZGVsZXRlIGNvbmZpZy5oZWFkZXJzW21ldGhvZF07XG4gICAgfVxuICApO1xuXG4gIHZhciBhZGFwdGVyID0gY29uZmlnLmFkYXB0ZXIgfHwgZGVmYXVsdHMuYWRhcHRlcjtcblxuICByZXR1cm4gYWRhcHRlcihjb25maWcpLnRoZW4oZnVuY3Rpb24gb25BZGFwdGVyUmVzb2x1dGlvbihyZXNwb25zZSkge1xuICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgcmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICByZXNwb25zZS5kYXRhLFxuICAgICAgcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcbiAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcbiAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnJlc3BvbnNlKSB7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVwZGF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZmlnLCBlcnJvciBjb2RlLCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgVGhlIGVycm9yIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIGVycm9yLmNvbmZpZyA9IGNvbmZpZztcbiAgaWYgKGNvZGUpIHtcbiAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgfVxuXG4gIGVycm9yLnJlcXVlc3QgPSByZXF1ZXN0O1xuICBlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICBlcnJvci5pc0F4aW9zRXJyb3IgPSB0cnVlO1xuXG4gIGVycm9yLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gU3RhbmRhcmRcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIC8vIE1pY3Jvc29mdFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICBudW1iZXI6IHRoaXMubnVtYmVyLFxuICAgICAgLy8gTW96aWxsYVxuICAgICAgZmlsZU5hbWU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXG4gICAgICBjb2x1bW5OdW1iZXI6IHRoaXMuY29sdW1uTnVtYmVyLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICAvLyBBeGlvc1xuICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgIGNvZGU6IHRoaXMuY29kZVxuICAgIH07XG4gIH07XG4gIHJldHVybiBlcnJvcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQ29uZmlnLXNwZWNpZmljIG1lcmdlLWZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgYSBuZXcgY29uZmlnLW9iamVjdFxuICogYnkgbWVyZ2luZyB0d28gY29uZmlndXJhdGlvbiBvYmplY3RzIHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcxXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMlxuICogQHJldHVybnMge09iamVjdH0gTmV3IG9iamVjdCByZXN1bHRpbmcgZnJvbSBtZXJnaW5nIGNvbmZpZzIgdG8gY29uZmlnMVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1lcmdlQ29uZmlnKGNvbmZpZzEsIGNvbmZpZzIpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGNvbmZpZzIgPSBjb25maWcyIHx8IHt9O1xuICB2YXIgY29uZmlnID0ge307XG5cbiAgdmFyIHZhbHVlRnJvbUNvbmZpZzJLZXlzID0gWyd1cmwnLCAnbWV0aG9kJywgJ2RhdGEnXTtcbiAgdmFyIG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzID0gWydoZWFkZXJzJywgJ2F1dGgnLCAncHJveHknLCAncGFyYW1zJ107XG4gIHZhciBkZWZhdWx0VG9Db25maWcyS2V5cyA9IFtcbiAgICAnYmFzZVVSTCcsICd0cmFuc2Zvcm1SZXF1ZXN0JywgJ3RyYW5zZm9ybVJlc3BvbnNlJywgJ3BhcmFtc1NlcmlhbGl6ZXInLFxuICAgICd0aW1lb3V0JywgJ3RpbWVvdXRNZXNzYWdlJywgJ3dpdGhDcmVkZW50aWFscycsICdhZGFwdGVyJywgJ3Jlc3BvbnNlVHlwZScsICd4c3JmQ29va2llTmFtZScsXG4gICAgJ3hzcmZIZWFkZXJOYW1lJywgJ29uVXBsb2FkUHJvZ3Jlc3MnLCAnb25Eb3dubG9hZFByb2dyZXNzJywgJ2RlY29tcHJlc3MnLFxuICAgICdtYXhDb250ZW50TGVuZ3RoJywgJ21heEJvZHlMZW5ndGgnLCAnbWF4UmVkaXJlY3RzJywgJ3RyYW5zcG9ydCcsICdodHRwQWdlbnQnLFxuICAgICdodHRwc0FnZW50JywgJ2NhbmNlbFRva2VuJywgJ3NvY2tldFBhdGgnLCAncmVzcG9uc2VFbmNvZGluZydcbiAgXTtcbiAgdmFyIGRpcmVjdE1lcmdlS2V5cyA9IFsndmFsaWRhdGVTdGF0dXMnXTtcblxuICBmdW5jdGlvbiBnZXRNZXJnZWRWYWx1ZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgdXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2UodGFyZ2V0LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2Uoe30sIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlRGVlcFByb3BlcnRpZXMocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfVxuXG4gIHV0aWxzLmZvckVhY2godmFsdWVGcm9tQ29uZmlnMktleXMsIGZ1bmN0aW9uIHZhbHVlRnJvbUNvbmZpZzIocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XG4gICAgfVxuICB9KTtcblxuICB1dGlscy5mb3JFYWNoKG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzLCBtZXJnZURlZXBQcm9wZXJ0aWVzKTtcblxuICB1dGlscy5mb3JFYWNoKGRlZmF1bHRUb0NvbmZpZzJLZXlzLCBmdW5jdGlvbiBkZWZhdWx0VG9Db25maWcyKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChkaXJlY3RNZXJnZUtleXMsIGZ1bmN0aW9uIG1lcmdlKHByb3ApIHtcbiAgICBpZiAocHJvcCBpbiBjb25maWcyKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKHByb3AgaW4gY29uZmlnMSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBheGlvc0tleXMgPSB2YWx1ZUZyb21Db25maWcyS2V5c1xuICAgIC5jb25jYXQobWVyZ2VEZWVwUHJvcGVydGllc0tleXMpXG4gICAgLmNvbmNhdChkZWZhdWx0VG9Db25maWcyS2V5cylcbiAgICAuY29uY2F0KGRpcmVjdE1lcmdlS2V5cyk7XG5cbiAgdmFyIG90aGVyS2V5cyA9IE9iamVjdFxuICAgIC5rZXlzKGNvbmZpZzEpXG4gICAgLmNvbmNhdChPYmplY3Qua2V5cyhjb25maWcyKSlcbiAgICAuZmlsdGVyKGZ1bmN0aW9uIGZpbHRlckF4aW9zS2V5cyhrZXkpIHtcbiAgICAgIHJldHVybiBheGlvc0tleXMuaW5kZXhPZihrZXkpID09PSAtMTtcbiAgICB9KTtcblxuICB1dGlscy5mb3JFYWNoKG90aGVyS2V5cywgbWVyZ2VEZWVwUHJvcGVydGllcyk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4vY3JlYXRlRXJyb3InKTtcblxuLyoqXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICB2YXIgdmFsaWRhdGVTdGF0dXMgPSByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXM7XG4gIGlmICghcmVzcG9uc2Uuc3RhdHVzIHx8ICF2YWxpZGF0ZVN0YXR1cyB8fCB2YWxpZGF0ZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVqZWN0KGNyZWF0ZUVycm9yKFxuICAgICAgJ1JlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlLmNvbmZpZyxcbiAgICAgIG51bGwsXG4gICAgICByZXNwb25zZS5yZXF1ZXN0LFxuICAgICAgcmVzcG9uc2VcbiAgICApKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdHJhbnNmb3JtZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGhlYWRlcnMgVGhlIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0IG9yIHJlc3BvbnNlXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShkYXRhLCBoZWFkZXJzLCBmbnMpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIHV0aWxzLmZvckVhY2goZm5zLCBmdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcbiAgICBkYXRhID0gZm4oZGF0YSwgaGVhZGVycyk7XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIG5vcm1hbGl6ZUhlYWRlck5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZScpO1xuXG52YXIgREVGQVVMVF9DT05URU5UX1RZUEUgPSB7XG4gICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuZnVuY3Rpb24gc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsIHZhbHVlKSB7XG4gIGlmICghdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVycykgJiYgdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVyc1snQ29udGVudC1UeXBlJ10pKSB7XG4gICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0QWRhcHRlcigpIHtcbiAgdmFyIGFkYXB0ZXI7XG4gIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gRm9yIGJyb3dzZXJzIHVzZSBYSFIgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL3hocicpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJykge1xuICAgIC8vIEZvciBub2RlIHVzZSBIVFRQIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy9odHRwJyk7XG4gIH1cbiAgcmV0dXJuIGFkYXB0ZXI7XG59XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgYWRhcHRlcjogZ2V0RGVmYXVsdEFkYXB0ZXIoKSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQWNjZXB0Jyk7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQ29udGVudC1UeXBlJyk7XG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNGaWxlKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0Jsb2IoZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0cmFuc2Zvcm1SZXNwb25zZTogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgLyogSWdub3JlICovIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIC8qKlxuICAgKiBBIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIGFib3J0IGEgcmVxdWVzdC4gSWYgc2V0IHRvIDAgKGRlZmF1bHQpIGFcbiAgICogdGltZW91dCBpcyBub3QgY3JlYXRlZC5cbiAgICovXG4gIHRpbWVvdXQ6IDAsXG5cbiAgeHNyZkNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcbiAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuXG4gIG1heENvbnRlbnRMZW5ndGg6IC0xLFxuICBtYXhCb2R5TGVuZ3RoOiAtMSxcblxuICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gdmFsaWRhdGVTdGF0dXMoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwO1xuICB9XG59O1xuXG5kZWZhdWx0cy5oZWFkZXJzID0ge1xuICBjb21tb246IHtcbiAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKidcbiAgfVxufTtcblxudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB1dGlscy5tZXJnZShERUZBVUxUX0NPTlRFTlRfVFlQRSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0cztcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpLlxuICAgIHJlcGxhY2UoLyU1Qi9naSwgJ1snKS5cbiAgICByZXBsYWNlKC8lNUQvZ2ksICddJyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB1cmxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZFVSTCh1cmwsIHBhcmFtcywgcGFyYW1zU2VyaWFsaXplcikge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIGlmIChwYXJhbXNTZXJpYWxpemVyKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtc1NlcmlhbGl6ZXIocGFyYW1zKTtcbiAgfSBlbHNlIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtcy50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuXG4gICAgdXRpbHMuZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWwsIGtleSkge1xuICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGlscy5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAga2V5ID0ga2V5ICsgJ1tdJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IFt2YWxdO1xuICAgICAgfVxuXG4gICAgICB1dGlscy5mb3JFYWNoKHZhbCwgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XG4gICAgICAgIGlmICh1dGlscy5pc0RhdGUodikpIHtcbiAgICAgICAgICB2ID0gdi50b0lTT1N0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgdiA9IEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodikpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFydHMuam9pbignJicpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICB2YXIgaGFzaG1hcmtJbmRleCA9IHVybC5pbmRleE9mKCcjJyk7XG4gICAgaWYgKGhhc2htYXJrSW5kZXggIT09IC0xKSB7XG4gICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgaGFzaG1hcmtJbmRleCk7XG4gICAgfVxuXG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICAgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlKSB7XG4gICAgICAgICAgdmFyIGNvb2tpZSA9IFtdO1xuICAgICAgICAgIGNvb2tpZS5wdXNoKG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcblxuICAgICAgICAgIGlmICh1dGlscy5pc051bWJlcihleHBpcmVzKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ2V4cGlyZXM9JyArIG5ldyBEYXRlKGV4cGlyZXMpLnRvR01UU3RyaW5nKCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhwYXRoKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ3BhdGg9JyArIHBhdGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhkb21haW4pKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnZG9tYWluPScgKyBkb21haW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWN1cmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdzZWN1cmUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG5hbWUpIHtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKF58O1xcXFxzKikoJyArIG5hbWUgKyAnKT0oW147XSopJykpO1xuICAgICAgICAgIHJldHVybiAobWF0Y2ggPyBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbM10pIDogbnVsbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuICAgICAgICAgIHRoaXMud3JpdGUobmFtZSwgJycsIERhdGUubm93KCkgLSA4NjQwMDAwMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52ICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAgIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoKSB7fSxcbiAgICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZCgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge31cbiAgICAgIH07XG4gICAgfSkoKVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXG4gIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICByZXR1cm4gL14oW2Etel1bYS16XFxkXFwrXFwtXFwuXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3NcbiAqXG4gKiBAcGFyYW0geyp9IHBheWxvYWQgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvcywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBeGlvc0Vycm9yKHBheWxvYWQpIHtcbiAgcmV0dXJuICh0eXBlb2YgcGF5bG9hZCA9PT0gJ29iamVjdCcpICYmIChwYXlsb2FkLmlzQXhpb3NFcnJvciA9PT0gdHJ1ZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgaGF2ZSBmdWxsIHN1cHBvcnQgb2YgdGhlIEFQSXMgbmVlZGVkIHRvIHRlc3RcbiAgLy8gd2hldGhlciB0aGUgcmVxdWVzdCBVUkwgaXMgb2YgdGhlIHNhbWUgb3JpZ2luIGFzIGN1cnJlbnQgbG9jYXRpb24uXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHZhciBtc2llID0gLyhtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgIHZhciB1cmxQYXJzaW5nTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgIHZhciBvcmlnaW5VUkw7XG5cbiAgICAgIC8qKlxuICAgICogUGFyc2UgYSBVUkwgdG8gZGlzY292ZXIgaXQncyBjb21wb25lbnRzXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIGJlIHBhcnNlZFxuICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAqL1xuICAgICAgZnVuY3Rpb24gcmVzb2x2ZVVSTCh1cmwpIHtcbiAgICAgICAgdmFyIGhyZWYgPSB1cmw7XG5cbiAgICAgICAgaWYgKG1zaWUpIHtcbiAgICAgICAgLy8gSUUgbmVlZHMgYXR0cmlidXRlIHNldCB0d2ljZSB0byBub3JtYWxpemUgcHJvcGVydGllc1xuICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuICAgICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xuICAgICAgICB9XG5cbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG5cbiAgICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhyZWY6IHVybFBhcnNpbmdOb2RlLmhyZWYsXG4gICAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgICBob3N0OiB1cmxQYXJzaW5nTm9kZS5ob3N0LFxuICAgICAgICAgIHNlYXJjaDogdXJsUGFyc2luZ05vZGUuc2VhcmNoID8gdXJsUGFyc2luZ05vZGUuc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgOiAnJyxcbiAgICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuICAgICAgICAgIGhvc3RuYW1lOiB1cmxQYXJzaW5nTm9kZS5ob3N0bmFtZSxcbiAgICAgICAgICBwb3J0OiB1cmxQYXJzaW5nTm9kZS5wb3J0LFxuICAgICAgICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID9cbiAgICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lIDpcbiAgICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG9yaWdpblVSTCA9IHJlc29sdmVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgICAvKipcbiAgICAqIERldGVybWluZSBpZiBhIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luIGFzIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RVUkwgVGhlIFVSTCB0byB0ZXN0XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgKi9cbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4ocmVxdWVzdFVSTCkge1xuICAgICAgICB2YXIgcGFyc2VkID0gKHV0aWxzLmlzU3RyaW5nKHJlcXVlc3RVUkwpKSA/IHJlc29sdmVVUkwocmVxdWVzdFVSTCkgOiByZXF1ZXN0VVJMO1xuICAgICAgICByZXR1cm4gKHBhcnNlZC5wcm90b2NvbCA9PT0gb3JpZ2luVVJMLnByb3RvY29sICYmXG4gICAgICAgICAgICBwYXJzZWQuaG9zdCA9PT0gb3JpZ2luVVJMLmhvc3QpO1xuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAgIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfSkoKVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsIG5vcm1hbGl6ZWROYW1lKSB7XG4gIHV0aWxzLmZvckVhY2goaGVhZGVycywgZnVuY3Rpb24gcHJvY2Vzc0hlYWRlcih2YWx1ZSwgbmFtZSkge1xuICAgIGlmIChuYW1lICE9PSBub3JtYWxpemVkTmFtZSAmJiBuYW1lLnRvVXBwZXJDYXNlKCkgPT09IG5vcm1hbGl6ZWROYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIGhlYWRlcnNbbm9ybWFsaXplZE5hbWVdID0gdmFsdWU7XG4gICAgICBkZWxldGUgaGVhZGVyc1tuYW1lXTtcbiAgICB9XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vLyBIZWFkZXJzIHdob3NlIGR1cGxpY2F0ZXMgYXJlIGlnbm9yZWQgYnkgbm9kZVxuLy8gYy5mLiBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAuaHRtbCNodHRwX21lc3NhZ2VfaGVhZGVyc1xudmFyIGlnbm9yZUR1cGxpY2F0ZU9mID0gW1xuICAnYWdlJywgJ2F1dGhvcml6YXRpb24nLCAnY29udGVudC1sZW5ndGgnLCAnY29udGVudC10eXBlJywgJ2V0YWcnLFxuICAnZXhwaXJlcycsICdmcm9tJywgJ2hvc3QnLCAnaWYtbW9kaWZpZWQtc2luY2UnLCAnaWYtdW5tb2RpZmllZC1zaW5jZScsXG4gICdsYXN0LW1vZGlmaWVkJywgJ2xvY2F0aW9uJywgJ21heC1mb3J3YXJkcycsICdwcm94eS1hdXRob3JpemF0aW9uJyxcbiAgJ3JlZmVyZXInLCAncmV0cnktYWZ0ZXInLCAndXNlci1hZ2VudCdcbl07XG5cbi8qKlxuICogUGFyc2UgaGVhZGVycyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIGBgYFxuICogRGF0ZTogV2VkLCAyNyBBdWcgMjAxNCAwODo1ODo0OSBHTVRcbiAqIENvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvblxuICogQ29ubmVjdGlvbjoga2VlcC1hbGl2ZVxuICogVHJhbnNmZXItRW5jb2Rpbmc6IGNodW5rZWRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXJzIEhlYWRlcnMgbmVlZGluZyB0byBiZSBwYXJzZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IEhlYWRlcnMgcGFyc2VkIGludG8gYW4gb2JqZWN0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VIZWFkZXJzKGhlYWRlcnMpIHtcbiAgdmFyIHBhcnNlZCA9IHt9O1xuICB2YXIga2V5O1xuICB2YXIgdmFsO1xuICB2YXIgaTtcblxuICBpZiAoIWhlYWRlcnMpIHsgcmV0dXJuIHBhcnNlZDsgfVxuXG4gIHV0aWxzLmZvckVhY2goaGVhZGVycy5zcGxpdCgnXFxuJyksIGZ1bmN0aW9uIHBhcnNlcihsaW5lKSB7XG4gICAgaSA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGtleSA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoMCwgaSkpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cihpICsgMSkpO1xuXG4gICAgaWYgKGtleSkge1xuICAgICAgaWYgKHBhcnNlZFtrZXldICYmIGlnbm9yZUR1cGxpY2F0ZU9mLmluZGV4T2Yoa2V5KSA+PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuICAgICAgICBwYXJzZWRba2V5XSA9IChwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldIDogW10pLmNvbmNhdChbdmFsXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRba2V5XSA9IHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gKyAnLCAnICsgdmFsIDogdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cbiAqXG4gKiBDb21tb24gdXNlIGNhc2Ugd291bGQgYmUgdG8gdXNlIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgLlxuICpcbiAqICBgYGBqc1xuICogIGZ1bmN0aW9uIGYoeCwgeSwgeikge31cbiAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcbiAqICBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICogIGBgYFxuICpcbiAqIFdpdGggYHNwcmVhZGAgdGhpcyBleGFtcGxlIGNhbiBiZSByZS13cml0dGVuLlxuICpcbiAqICBgYGBqc1xuICogIHNwcmVhZChmdW5jdGlvbih4LCB5LCB6KSB7fSkoWzEsIDIsIDNdKTtcbiAqICBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcblxuLypnbG9iYWwgdG9TdHJpbmc6dHJ1ZSovXG5cbi8vIHV0aWxzIGlzIGEgbGlicmFyeSBvZiBnZW5lcmljIGhlbHBlciBmdW5jdGlvbnMgbm9uLXNwZWNpZmljIHRvIGF4aW9zXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgdW5kZWZpbmVkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwpICYmIHZhbC5jb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsLmNvbnN0cnVjdG9yKVxuICAgICYmIHR5cGVvZiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKHZhbCk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGb3JtRGF0YVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEZvcm1EYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGb3JtRGF0YSh2YWwpIHtcbiAgcmV0dXJuICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnKSAmJiAodmFsIGluc3RhbmNlb2YgRm9ybURhdGEpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbCkge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpICYmIChBcnJheUJ1ZmZlci5pc1ZpZXcpKSB7XG4gICAgcmVzdWx0ID0gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gKHZhbCkgJiYgKHZhbC5idWZmZXIpICYmICh2YWwuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmluZywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBOdW1iZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE51bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWwpIHtcbiAgaWYgKHRvU3RyaW5nLmNhbGwodmFsKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbCk7XG4gIHJldHVybiBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRmlsZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRmlsZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQmxvYl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVVJMU2VhcmNoUGFyYW1zKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zO1xufVxuXG4vKipcbiAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJykucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICogbmF0aXZlc2NyaXB0XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ05hdGl2ZVNjcmlwdCcgb3IgJ05TJ1xuICovXG5mdW5jdGlvbiBpc1N0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIChuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTmF0aXZlU2NyaXB0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTlMnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuICogY29uc29sZS5sb2cocmVzdWx0LmZvbyk7IC8vIG91dHB1dHMgNDU2XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMSBPYmplY3QgdG8gbWVyZ2VcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmIChpc1BsYWluT2JqZWN0KHJlc3VsdFtrZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2Uoe30sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XG4gIGZvckVhY2goYiwgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYnl0ZSBvcmRlciBtYXJrZXIuIFRoaXMgY2F0Y2hlcyBFRiBCQiBCRiAodGhlIFVURi04IEJPTSlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCB3aXRoIEJPTVxuICogQHJldHVybiB7c3RyaW5nfSBjb250ZW50IHZhbHVlIHdpdGhvdXQgQk9NXG4gKi9cbmZ1bmN0aW9uIHN0cmlwQk9NKGNvbnRlbnQpIHtcbiAgaWYgKGNvbnRlbnQuY2hhckNvZGVBdCgwKSA9PT0gMHhGRUZGKSB7XG4gICAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyOiBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gIGlzRm9ybURhdGE6IGlzRm9ybURhdGEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNQbGFpbk9iamVjdDogaXNQbGFpbk9iamVjdCxcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNGaWxlOiBpc0ZpbGUsXG4gIGlzQmxvYjogaXNCbG9iLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbTogaXNTdHJlYW0sXG4gIGlzVVJMU2VhcmNoUGFyYW1zOiBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNTdGFuZGFyZEJyb3dzZXJFbnY6IGlzU3RhbmRhcmRCcm93c2VyRW52LFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBtZXJnZTogbWVyZ2UsXG4gIGV4dGVuZDogZXh0ZW5kLFxuICB0cmltOiB0cmltLFxuICBzdHJpcEJPTTogc3RyaXBCT01cbn07XG4iLCJ2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXHR2YXIgUExVU19VUkxfU0FGRSA9ICctJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSF9VUkxfU0FGRSA9ICdfJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMgfHxcblx0XHQgICAgY29kZSA9PT0gUExVU19VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MiAvLyAnKydcblx0XHRpZiAoY29kZSA9PT0gU0xBU0ggfHxcblx0XHQgICAgY29kZSA9PT0gU0xBU0hfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjMgLy8gJy8nXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIpXG5cdFx0XHRyZXR1cm4gLTEgLy9ubyBtYXRjaFxuXHRcdGlmIChjb2RlIDwgTlVNQkVSICsgMTApXG5cdFx0XHRyZXR1cm4gY29kZSAtIE5VTUJFUiArIDI2ICsgMjZcblx0XHRpZiAoY29kZSA8IFVQUEVSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIFVQUEVSXG5cdFx0aWYgKGNvZGUgPCBMT1dFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBMT1dFUiArIDI2XG5cdH1cblxuXHRmdW5jdGlvbiBiNjRUb0J5dGVBcnJheSAoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcblxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cdFx0cGxhY2VIb2xkZXJzID0gJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDIpID8gMiA6ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAxKSA/IDEgOiAwXG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBuZXcgQXJyKGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcblx0XHRsID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSA0IDogYjY0Lmxlbmd0aFxuXG5cdFx0dmFyIEwgPSAwXG5cblx0XHRmdW5jdGlvbiBwdXNoICh2KSB7XG5cdFx0XHRhcnJbTCsrXSA9IHZcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDE4KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDEyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpIDw8IDYpIHwgZGVjb2RlKGI2NC5jaGFyQXQoaSArIDMpKVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA+PiA0KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDEwKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDQpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPj4gMilcblx0XHRcdHB1c2goKHRtcCA+PiA4KSAmIDB4RkYpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyclxuXHR9XG5cblx0ZnVuY3Rpb24gdWludDhUb0Jhc2U2NCAodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aFxuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlIChudW0pIHtcblx0XHRcdHJldHVybiBsb29rdXAuY2hhckF0KG51bSlcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGVuY29kZShudW0gPj4gMTggJiAweDNGKSArIGVuY29kZShudW0gPj4gMTIgJiAweDNGKSArIGVuY29kZShudW0gPj4gNiAmIDB4M0YpICsgZW5jb2RlKG51bSAmIDB4M0YpXG5cdFx0fVxuXG5cdFx0Ly8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuXHRcdGZvciAoaSA9IDAsIGxlbmd0aCA9IHVpbnQ4Lmxlbmd0aCAtIGV4dHJhQnl0ZXM7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0dGVtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcClcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPT0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAxMClcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA+PiA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgMikgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0ZXhwb3J0cy50b0J5dGVBcnJheSA9IGI2NFRvQnl0ZUFycmF5XG5cdGV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjRcbn0odHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gKHRoaXMuYmFzZTY0anMgPSB7fSkgOiBleHBvcnRzKSlcbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbnZhciByb290UGFyZW50ID0ge31cblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBTYWZhcmkgNS03IGxhY2tzIHN1cHBvcnQgZm9yIGNoYW5naW5nIHRoZSBgT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvcmAgcHJvcGVydHlcbiAqICAgICBvbiBvYmplY3RzLlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgZnVuY3Rpb24gQmFyICgpIHt9XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLmZvbyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH1cbiAgICBhcnIuY29uc3RydWN0b3IgPSBCYXJcbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICBhcnIuY29uc3RydWN0b3IgPT09IEJhciAmJiAvLyBjb25zdHJ1Y3RvciBjYW4gYmUgc2V0XG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKGFyZykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIC8vIEF2b2lkIGdvaW5nIHRocm91Z2ggYW4gQXJndW1lbnRzQWRhcHRvclRyYW1wb2xpbmUgaW4gdGhlIGNvbW1vbiBjYXNlLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBhcmd1bWVudHNbMV0pXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnKVxuICB9XG5cbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXMubGVuZ3RoID0gMFxuICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZyb21OdW1iZXIodGhpcywgYXJnKVxuICB9XG5cbiAgLy8gU2xpZ2h0bHkgbGVzcyBjb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhpcywgYXJnLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6ICd1dGY4JylcbiAgfVxuXG4gIC8vIFVudXN1YWwuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoaXMsIGFyZylcbn1cblxuZnVuY3Rpb24gZnJvbU51bWJlciAodGhhdCwgbGVuZ3RoKSB7XG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGggPCAwID8gMCA6IGNoZWNrZWQobGVuZ3RoKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykgZW5jb2RpbmcgPSAndXRmOCdcblxuICAvLyBBc3N1bXB0aW9uOiBieXRlTGVuZ3RoKCkgcmV0dXJuIHZhbHVlIGlzIGFsd2F5cyA8IGtNYXhMZW5ndGguXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuXG4gIHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqZWN0KSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqZWN0KSkgcmV0dXJuIGZyb21CdWZmZXIodGhhdCwgb2JqZWN0KVxuXG4gIGlmIChpc0FycmF5KG9iamVjdCkpIHJldHVybiBmcm9tQXJyYXkodGhhdCwgb2JqZWN0KVxuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ211c3Qgc3RhcnQgd2l0aCBudW1iZXIsIGJ1ZmZlciwgYXJyYXkgb3Igc3RyaW5nJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKG9iamVjdC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGZyb21UeXBlZEFycmF5KHRoYXQsIG9iamVjdClcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIG9iamVjdClcbiAgICB9XG4gIH1cblxuICBpZiAob2JqZWN0Lmxlbmd0aCkgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqZWN0KVxuXG4gIHJldHVybiBmcm9tSnNvbk9iamVjdCh0aGF0LCBvYmplY3QpXG59XG5cbmZ1bmN0aW9uIGZyb21CdWZmZXIgKHRoYXQsIGJ1ZmZlcikge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChidWZmZXIubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgYnVmZmVyLmNvcHkodGhhdCwgMCwgMCwgbGVuZ3RoKVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXkgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vLyBEdXBsaWNhdGUgb2YgZnJvbUFycmF5KCkgdG8ga2VlcCBmcm9tQXJyYXkoKSBtb25vbW9ycGhpYy5cbmZ1bmN0aW9uIGZyb21UeXBlZEFycmF5ICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICAvLyBUcnVuY2F0aW5nIHRoZSBlbGVtZW50cyBpcyBwcm9iYWJseSBub3Qgd2hhdCBwZW9wbGUgZXhwZWN0IGZyb20gdHlwZWRcbiAgLy8gYXJyYXlzIHdpdGggQllURVNfUEVSX0VMRU1FTlQgPiAxIGJ1dCBpdCdzIGNvbXBhdGlibGUgd2l0aCB0aGUgYmVoYXZpb3JcbiAgLy8gb2YgdGhlIG9sZCBCdWZmZXIgY29uc3RydWN0b3IuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5KSB7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGFycmF5LmJ5dGVMZW5ndGhcbiAgICB0aGF0ID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGFycmF5KSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21UeXBlZEFycmF5KHRoYXQsIG5ldyBVaW50OEFycmF5KGFycmF5KSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLy8gRGVzZXJpYWxpemUgeyB0eXBlOiAnQnVmZmVyJywgZGF0YTogWzEsMiwzLC4uLl0gfSBpbnRvIGEgQnVmZmVyIG9iamVjdC5cbi8vIFJldHVybnMgYSB6ZXJvLWxlbmd0aCBidWZmZXIgZm9yIGlucHV0cyB0aGF0IGRvbid0IGNvbmZvcm0gdG8gdGhlIHNwZWMuXG5mdW5jdGlvbiBmcm9tSnNvbk9iamVjdCAodGhhdCwgb2JqZWN0KSB7XG4gIHZhciBhcnJheVxuICB2YXIgbGVuZ3RoID0gMFxuXG4gIGlmIChvYmplY3QudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmplY3QuZGF0YSkpIHtcbiAgICBhcnJheSA9IG9iamVjdC5kYXRhXG4gICAgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB9XG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG59IGVsc2Uge1xuICAvLyBwcmUtc2V0IGZvciB2YWx1ZXMgdGhhdCBtYXkgZXhpc3QgaW4gdGhlIGZ1dHVyZVxuICBCdWZmZXIucHJvdG90eXBlLmxlbmd0aCA9IHVuZGVmaW5lZFxuICBCdWZmZXIucHJvdG90eXBlLnBhcmVudCA9IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBhbGxvY2F0ZSAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgICB0aGF0Ll9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBmcm9tUG9vbCA9IGxlbmd0aCAhPT0gMCAmJiBsZW5ndGggPD0gQnVmZmVyLnBvb2xTaXplID4+PiAxXG4gIGlmIChmcm9tUG9vbCkgdGhhdC5wYXJlbnQgPSByb290UGFyZW50XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChzdWJqZWN0LCBlbmNvZGluZykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2xvd0J1ZmZlcikpIHJldHVybiBuZXcgU2xvd0J1ZmZlcihzdWJqZWN0LCBlbmNvZGluZylcblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZylcbiAgZGVsZXRlIGJ1Zi5wYXJlbnRcbiAgcmV0dXJuIGJ1ZlxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgdmFyIGkgPSAwXG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSBicmVha1xuXG4gICAgKytpXG4gIH1cblxuICBpZiAoaSAhPT0gbGVuKSB7XG4gICAgeCA9IGFbaV1cbiAgICB5ID0gYltpXVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdsaXN0IGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycy4nKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICBpdGVtLmNvcHkoYnVmLCBwb3MpXG4gICAgcG9zICs9IGl0ZW0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykgc3RyaW5nID0gJycgKyBzdHJpbmdcblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIC8vIERlcHJlY2F0ZWRcbiAgICAgIGNhc2UgJ3Jhdyc6XG4gICAgICBjYXNlICdyYXdzJzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICBzdGFydCA9IHN0YXJ0IHwgMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IEluZmluaXR5ID8gdGhpcy5sZW5ndGggOiBlbmQgfCAwXG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcbiAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKGVuZCA8PSBzdGFydCkgcmV0dXJuICcnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiAwXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICBieXRlT2Zmc2V0ID4+PSAwXG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHJldHVybiAtMVxuXG4gIC8vIE5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gTWF0aC5tYXgodGhpcy5sZW5ndGggKyBieXRlT2Zmc2V0LCAwKVxuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSByZXR1cm4gLTEgLy8gc3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcgYWx3YXlzIGZhaWxzXG4gICAgcmV0dXJuIFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgWyB2YWwgXSwgYnl0ZU9mZnNldClcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yICh2YXIgaSA9IDA7IGJ5dGVPZmZzZXQgKyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJyW2J5dGVPZmZzZXQgKyBpXSA9PT0gdmFsW2ZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4XSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbC5sZW5ndGgpIHJldHVybiBieXRlT2Zmc2V0ICsgZm91bmRJbmRleFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuLy8gYGdldGAgaXMgZGVwcmVjYXRlZFxuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgaXMgZGVwcmVjYXRlZFxuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKHYsIG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMud3JpdGVVSW50OCh2LCBvZmZzZXQpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHZhciBzd2FwID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIG9mZnNldCA9IGxlbmd0aCB8IDBcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IEJ1ZmZlci5fYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgaWYgKG5ld0J1Zi5sZW5ndGgpIG5ld0J1Zi5wYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gdmFsdWUgPCAwID8gMSA6IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSB2YWx1ZSA8IDAgPyAxIDogMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRTdGFydClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gdmFsdWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gdXRmOFRvQnl0ZXModmFsdWUudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gdG9BcnJheUJ1ZmZlciAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gX2F1Z21lbnQgKGFycikge1xuICBhcnIuY29uc3RydWN0b3IgPSBCdWZmZXJcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IHNldCBtZXRob2QgYmVmb3JlIG92ZXJ3cml0aW5nXG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgYXJyLmdldCA9IEJQLmdldFxuICBhcnIuc2V0ID0gQlAuc2V0XG5cbiAgYXJyLndyaXRlID0gQlAud3JpdGVcbiAgYXJyLnRvU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvSlNPTiA9IEJQLnRvSlNPTlxuICBhcnIuZXF1YWxzID0gQlAuZXF1YWxzXG4gIGFyci5jb21wYXJlID0gQlAuY29tcGFyZVxuICBhcnIuaW5kZXhPZiA9IEJQLmluZGV4T2ZcbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludExFID0gQlAucmVhZFVJbnRMRVxuICBhcnIucmVhZFVJbnRCRSA9IEJQLnJlYWRVSW50QkVcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxuICBhcnIucmVhZFVJbnQxNkxFID0gQlAucmVhZFVJbnQxNkxFXG4gIGFyci5yZWFkVUludDE2QkUgPSBCUC5yZWFkVUludDE2QkVcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxuICBhcnIucmVhZFVJbnQzMkJFID0gQlAucmVhZFVJbnQzMkJFXG4gIGFyci5yZWFkSW50TEUgPSBCUC5yZWFkSW50TEVcbiAgYXJyLnJlYWRJbnRCRSA9IEJQLnJlYWRJbnRCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnRMRSA9IEJQLndyaXRlVUludExFXG4gIGFyci53cml0ZVVJbnRCRSA9IEJQLndyaXRlVUludEJFXG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnRMRSA9IEJQLndyaXRlSW50TEVcbiAgYXJyLndyaXRlSW50QkUgPSBCUC53cml0ZUludEJFXG4gIGFyci53cml0ZUludDggPSBCUC53cml0ZUludDhcbiAgYXJyLndyaXRlSW50MTZMRSA9IEJQLndyaXRlSW50MTZMRVxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXG4gIGFyci53cml0ZUludDMyTEUgPSBCUC53cml0ZUludDMyTEVcbiAgYXJyLndyaXRlSW50MzJCRSA9IEJQLndyaXRlSW50MzJCRVxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXG4gIGFyci53cml0ZUZsb2F0QkUgPSBCUC53cml0ZUZsb2F0QkVcbiAgYXJyLndyaXRlRG91YmxlTEUgPSBCUC53cml0ZURvdWJsZUxFXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxuICBhcnIuZmlsbCA9IEJQLmZpbGxcbiAgYXJyLmluc3BlY3QgPSBCUC5pbnNwZWN0XG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxuXG4gIHJldHVybiBhcnJcbn1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG4iLCIvLyBUaGlzIGZpbGUgY2FuIGJlIHJlcXVpcmVkIGluIEJyb3dzZXJpZnkgYW5kIE5vZGUuanMgZm9yIGF1dG9tYXRpYyBwb2x5ZmlsbFxuLy8gVG8gdXNlIGl0OiAgcmVxdWlyZSgnZXM2LXByb21pc2UvYXV0bycpO1xuJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLycpLnBvbHlmaWxsKCk7XG4iLCIvKiFcbiAqIEBvdmVydmlldyBlczYtcHJvbWlzZSAtIGEgdGlueSBpbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlcy9BKy5cbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0IFllaHVkYSBLYXR6LCBUb20gRGFsZSwgU3RlZmFuIFBlbm5lciBhbmQgY29udHJpYnV0b3JzIChDb252ZXJzaW9uIHRvIEVTNiBBUEkgYnkgSmFrZSBBcmNoaWJhbGQpXG4gKiBAbGljZW5zZSAgIExpY2Vuc2VkIHVuZGVyIE1JVCBsaWNlbnNlXG4gKiAgICAgICAgICAgIFNlZSBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vc3RlZmFucGVubmVyL2VzNi1wcm9taXNlL21hc3Rlci9MSUNFTlNFXG4gKiBAdmVyc2lvbiAgIHY0LjIuOCsxZTY4ZGNlNlxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbC5FUzZQcm9taXNlID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBvYmplY3RPckZ1bmN0aW9uKHgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgeDtcbiAgcmV0dXJuIHggIT09IG51bGwgJiYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuXG5cblxudmFyIF9pc0FycmF5ID0gdm9pZCAwO1xuaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xufSBlbHNlIHtcbiAgX2lzQXJyYXkgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG59XG5cbnZhciBpc0FycmF5ID0gX2lzQXJyYXk7XG5cbnZhciBsZW4gPSAwO1xudmFyIHZlcnR4TmV4dCA9IHZvaWQgMDtcbnZhciBjdXN0b21TY2hlZHVsZXJGbiA9IHZvaWQgMDtcblxudmFyIGFzYXAgPSBmdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBhcmcpIHtcbiAgcXVldWVbbGVuXSA9IGNhbGxiYWNrO1xuICBxdWV1ZVtsZW4gKyAxXSA9IGFyZztcbiAgbGVuICs9IDI7XG4gIGlmIChsZW4gPT09IDIpIHtcbiAgICAvLyBJZiBsZW4gaXMgMiwgdGhhdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gc2NoZWR1bGUgYW4gYXN5bmMgZmx1c2guXG4gICAgLy8gSWYgYWRkaXRpb25hbCBjYWxsYmFja3MgYXJlIHF1ZXVlZCBiZWZvcmUgdGhlIHF1ZXVlIGlzIGZsdXNoZWQsIHRoZXlcbiAgICAvLyB3aWxsIGJlIHByb2Nlc3NlZCBieSB0aGlzIGZsdXNoIHRoYXQgd2UgYXJlIHNjaGVkdWxpbmcuXG4gICAgaWYgKGN1c3RvbVNjaGVkdWxlckZuKSB7XG4gICAgICBjdXN0b21TY2hlZHVsZXJGbihmbHVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVkdWxlRmx1c2goKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNjaGVkdWxlcihzY2hlZHVsZUZuKSB7XG4gIGN1c3RvbVNjaGVkdWxlckZuID0gc2NoZWR1bGVGbjtcbn1cblxuZnVuY3Rpb24gc2V0QXNhcChhc2FwRm4pIHtcbiAgYXNhcCA9IGFzYXBGbjtcbn1cblxudmFyIGJyb3dzZXJXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbnZhciBicm93c2VyR2xvYmFsID0gYnJvd3NlcldpbmRvdyB8fCB7fTtcbnZhciBCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9IGJyb3dzZXJHbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBicm93c2VyR2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgaXNOb2RlID0gdHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB7fS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG5cbi8vIHRlc3QgZm9yIHdlYiB3b3JrZXIgYnV0IG5vdCBpbiBJRTEwXG52YXIgaXNXb3JrZXIgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBpbXBvcnRTY3JpcHRzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBub2RlXG5mdW5jdGlvbiB1c2VOZXh0VGljaygpIHtcbiAgLy8gbm9kZSB2ZXJzaW9uIDAuMTAueCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2hlbiBuZXh0VGljayBpcyB1c2VkIHJlY3Vyc2l2ZWx5XG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3Vqb2pzL3doZW4vaXNzdWVzLzQxMCBmb3IgZGV0YWlsc1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgfTtcbn1cblxuLy8gdmVydHhcbmZ1bmN0aW9uIHVzZVZlcnR4VGltZXIoKSB7XG4gIGlmICh0eXBlb2YgdmVydHhOZXh0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2ZXJ0eE5leHQoZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xufVxuXG5mdW5jdGlvbiB1c2VNdXRhdGlvbk9ic2VydmVyKCkge1xuICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gIHZhciBvYnNlcnZlciA9IG5ldyBCcm93c2VyTXV0YXRpb25PYnNlcnZlcihmbHVzaCk7XG4gIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIG5vZGUuZGF0YSA9IGl0ZXJhdGlvbnMgPSArK2l0ZXJhdGlvbnMgJSAyO1xuICB9O1xufVxuXG4vLyB3ZWIgd29ya2VyXG5mdW5jdGlvbiB1c2VNZXNzYWdlQ2hhbm5lbCgpIHtcbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlU2V0VGltZW91dCgpIHtcbiAgLy8gU3RvcmUgc2V0VGltZW91dCByZWZlcmVuY2Ugc28gZXM2LXByb21pc2Ugd2lsbCBiZSB1bmFmZmVjdGVkIGJ5XG4gIC8vIG90aGVyIGNvZGUgbW9kaWZ5aW5nIHNldFRpbWVvdXQgKGxpa2Ugc2lub24udXNlRmFrZVRpbWVycygpKVxuICB2YXIgZ2xvYmFsU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdsb2JhbFNldFRpbWVvdXQoZmx1c2gsIDEpO1xuICB9O1xufVxuXG52YXIgcXVldWUgPSBuZXcgQXJyYXkoMTAwMCk7XG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuICAgIHZhciBhcmcgPSBxdWV1ZVtpICsgMV07XG5cbiAgICBjYWxsYmFjayhhcmcpO1xuXG4gICAgcXVldWVbaV0gPSB1bmRlZmluZWQ7XG4gICAgcXVldWVbaSArIDFdID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gYXR0ZW1wdFZlcnR4KCkge1xuICB0cnkge1xuICAgIHZhciB2ZXJ0eCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCkucmVxdWlyZSgndmVydHgnKTtcbiAgICB2ZXJ0eE5leHQgPSB2ZXJ0eC5ydW5Pbkxvb3AgfHwgdmVydHgucnVuT25Db250ZXh0O1xuICAgIHJldHVybiB1c2VWZXJ0eFRpbWVyKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xuICB9XG59XG5cbnZhciBzY2hlZHVsZUZsdXNoID0gdm9pZCAwO1xuLy8gRGVjaWRlIHdoYXQgYXN5bmMgbWV0aG9kIHRvIHVzZSB0byB0cmlnZ2VyaW5nIHByb2Nlc3Npbmcgb2YgcXVldWVkIGNhbGxiYWNrczpcbmlmIChpc05vZGUpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU5leHRUaWNrKCk7XG59IGVsc2UgaWYgKEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNdXRhdGlvbk9ic2VydmVyKCk7XG59IGVsc2UgaWYgKGlzV29ya2VyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNZXNzYWdlQ2hhbm5lbCgpO1xufSBlbHNlIGlmIChicm93c2VyV2luZG93ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IGF0dGVtcHRWZXJ0eCgpO1xufSBlbHNlIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgcGFyZW50ID0gdGhpcztcblxuICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wKTtcblxuICBpZiAoY2hpbGRbUFJPTUlTRV9JRF0gPT09IHVuZGVmaW5lZCkge1xuICAgIG1ha2VQcm9taXNlKGNoaWxkKTtcbiAgfVxuXG4gIHZhciBfc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG5cbiAgaWYgKF9zdGF0ZSkge1xuICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1tfc3RhdGUgLSAxXTtcbiAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpbnZva2VDYWxsYmFjayhfc3RhdGUsIGNoaWxkLCBjYWxsYmFjaywgcGFyZW50Ll9yZXN1bHQpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbik7XG4gIH1cblxuICByZXR1cm4gY2hpbGQ7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yZXNvbHZlYCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIHJlc29sdmVkIHdpdGggdGhlXG4gIHBhc3NlZCBgdmFsdWVgLiBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVzb2x2ZSgxKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoMSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZXNvbHZlXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZXNvbHZlZCB3aXRoXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgZnVsZmlsbGVkIHdpdGggdGhlIGdpdmVuXG4gIGB2YWx1ZWBcbiovXG5mdW5jdGlvbiByZXNvbHZlJDEob2JqZWN0KSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICByZXNvbHZlKHByb21pc2UsIG9iamVjdCk7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG52YXIgUFJPTUlTRV9JRCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBQRU5ESU5HID0gdm9pZCAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgPSAyO1xuXG5mdW5jdGlvbiBzZWxmRnVsZmlsbG1lbnQoKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKTtcbn1cblxuZnVuY3Rpb24gY2Fubm90UmV0dXJuT3duKCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpO1xufVxuXG5mdW5jdGlvbiB0cnlUaGVuKHRoZW4kJDEsIHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpIHtcbiAgdHJ5IHtcbiAgICB0aGVuJCQxLmNhbGwodmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUsIHRoZW4kJDEpIHtcbiAgYXNhcChmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgIHZhciBzZWFsZWQgPSBmYWxzZTtcbiAgICB2YXIgZXJyb3IgPSB0cnlUaGVuKHRoZW4kJDEsIHRoZW5hYmxlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmIChzZWFsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgIGlmICh0aGVuYWJsZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBpZiAoc2VhbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlYWxlZCA9IHRydWU7XG5cbiAgICAgIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0sICdTZXR0bGU6ICcgKyAocHJvbWlzZS5fbGFiZWwgfHwgJyB1bmtub3duIHByb21pc2UnKSk7XG5cbiAgICBpZiAoIXNlYWxlZCAmJiBlcnJvcikge1xuICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgfVxuICB9LCBwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUpIHtcbiAgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gRlVMRklMTEVEKSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgfSBlbHNlIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHN1YnNjcmliZSh0aGVuYWJsZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuJCQxKSB7XG4gIGlmIChtYXliZVRoZW5hYmxlLmNvbnN0cnVjdG9yID09PSBwcm9taXNlLmNvbnN0cnVjdG9yICYmIHRoZW4kJDEgPT09IHRoZW4gJiYgbWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3Rvci5yZXNvbHZlID09PSByZXNvbHZlJDEpIHtcbiAgICBoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodGhlbiQkMSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih0aGVuJCQxKSkge1xuICAgICAgaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBzZWxmRnVsZmlsbG1lbnQoKSk7XG4gIH0gZWxzZSBpZiAob2JqZWN0T3JGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgdGhlbiQkMSA9IHZvaWQgMDtcbiAgICB0cnkge1xuICAgICAgdGhlbiQkMSA9IHZhbHVlLnRoZW47XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUsIHRoZW4kJDEpO1xuICB9IGVsc2Uge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1Ymxpc2hSZWplY3Rpb24ocHJvbWlzZSkge1xuICBpZiAocHJvbWlzZS5fb25lcnJvcikge1xuICAgIHByb21pc2UuX29uZXJyb3IocHJvbWlzZS5fcmVzdWx0KTtcbiAgfVxuXG4gIHB1Ymxpc2gocHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpIHtcbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJvbWlzZS5fcmVzdWx0ID0gdmFsdWU7XG4gIHByb21pc2UuX3N0YXRlID0gRlVMRklMTEVEO1xuXG4gIGlmIChwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggIT09IDApIHtcbiAgICBhc2FwKHB1Ymxpc2gsIHByb21pc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlamVjdChwcm9taXNlLCByZWFzb24pIHtcbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHByb21pc2UuX3N0YXRlID0gUkVKRUNURUQ7XG4gIHByb21pc2UuX3Jlc3VsdCA9IHJlYXNvbjtcblxuICBhc2FwKHB1Ymxpc2hSZWplY3Rpb24sIHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgdmFyIF9zdWJzY3JpYmVycyA9IHBhcmVudC5fc3Vic2NyaWJlcnM7XG4gIHZhciBsZW5ndGggPSBfc3Vic2NyaWJlcnMubGVuZ3RoO1xuXG5cbiAgcGFyZW50Ll9vbmVycm9yID0gbnVsbDtcblxuICBfc3Vic2NyaWJlcnNbbGVuZ3RoXSA9IGNoaWxkO1xuICBfc3Vic2NyaWJlcnNbbGVuZ3RoICsgRlVMRklMTEVEXSA9IG9uRnVsZmlsbG1lbnQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBSRUpFQ1RFRF0gPSBvblJlamVjdGlvbjtcblxuICBpZiAobGVuZ3RoID09PSAwICYmIHBhcmVudC5fc3RhdGUpIHtcbiAgICBhc2FwKHB1Ymxpc2gsIHBhcmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaChwcm9taXNlKSB7XG4gIHZhciBzdWJzY3JpYmVycyA9IHByb21pc2UuX3N1YnNjcmliZXJzO1xuICB2YXIgc2V0dGxlZCA9IHByb21pc2UuX3N0YXRlO1xuXG4gIGlmIChzdWJzY3JpYmVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY2hpbGQgPSB2b2lkIDAsXG4gICAgICBjYWxsYmFjayA9IHZvaWQgMCxcbiAgICAgIGRldGFpbCA9IHByb21pc2UuX3Jlc3VsdDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgY2hpbGQgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICBjYWxsYmFjayA9IHN1YnNjcmliZXJzW2kgKyBzZXR0bGVkXTtcblxuICAgIGlmIChjaGlsZCkge1xuICAgICAgaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhkZXRhaWwpO1xuICAgIH1cbiAgfVxuXG4gIHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCA9IDA7XG59XG5cbmZ1bmN0aW9uIGludm9rZUNhbGxiYWNrKHNldHRsZWQsIHByb21pc2UsIGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgdmFyIGhhc0NhbGxiYWNrID0gaXNGdW5jdGlvbihjYWxsYmFjayksXG4gICAgICB2YWx1ZSA9IHZvaWQgMCxcbiAgICAgIGVycm9yID0gdm9pZCAwLFxuICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcblxuICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSBjYWxsYmFjayhkZXRhaWwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHN1Y2NlZWRlZCA9IGZhbHNlO1xuICAgICAgZXJyb3IgPSBlO1xuICAgIH1cblxuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgcmVqZWN0KHByb21pc2UsIGNhbm5vdFJldHVybk93bigpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBkZXRhaWw7XG4gIH1cblxuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICAvLyBub29wXG4gIH0gZWxzZSBpZiAoaGFzQ2FsbGJhY2sgJiYgc3VjY2VlZGVkKSB7XG4gICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoc3VjY2VlZGVkID09PSBmYWxzZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gRlVMRklMTEVEKSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gUkVKRUNURUQpIHtcbiAgICByZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVQcm9taXNlKHByb21pc2UsIHJlc29sdmVyKSB7XG4gIHRyeSB7XG4gICAgcmVzb2x2ZXIoZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsdWUpIHtcbiAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIHJlamVjdFByb21pc2UocmVhc29uKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBlKTtcbiAgfVxufVxuXG52YXIgaWQgPSAwO1xuZnVuY3Rpb24gbmV4dElkKCkge1xuICByZXR1cm4gaWQrKztcbn1cblxuZnVuY3Rpb24gbWFrZVByb21pc2UocHJvbWlzZSkge1xuICBwcm9taXNlW1BST01JU0VfSURdID0gaWQrKztcbiAgcHJvbWlzZS5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3Jlc3VsdCA9IHVuZGVmaW5lZDtcbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMgPSBbXTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICByZXR1cm4gbmV3IEVycm9yKCdBcnJheSBNZXRob2RzIG11c3QgYmUgcHJvdmlkZWQgYW4gQXJyYXknKTtcbn1cblxudmFyIEVudW1lcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVudW1lcmF0b3IoQ29uc3RydWN0b3IsIGlucHV0KSB7XG4gICAgdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcblxuICAgIGlmICghdGhpcy5wcm9taXNlW1BST01JU0VfSURdKSB7XG4gICAgICBtYWtlUHJvbWlzZSh0aGlzLnByb21pc2UpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICB0aGlzLl9yZW1haW5pbmcgPSBpbnB1dC5sZW5ndGg7XG5cbiAgICAgIHRoaXMuX3Jlc3VsdCA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG5cbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMDtcbiAgICAgICAgdGhpcy5fZW51bWVyYXRlKGlucHV0KTtcbiAgICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlamVjdCh0aGlzLnByb21pc2UsIHZhbGlkYXRpb25FcnJvcigpKTtcbiAgICB9XG4gIH1cblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24gX2VudW1lcmF0ZShpbnB1dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyB0aGlzLl9zdGF0ZSA9PT0gUEVORElORyAmJiBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2VhY2hFbnRyeShpbnB1dFtpXSwgaSk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9lYWNoRW50cnkgPSBmdW5jdGlvbiBfZWFjaEVudHJ5KGVudHJ5LCBpKSB7XG4gICAgdmFyIGMgPSB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yO1xuICAgIHZhciByZXNvbHZlJCQxID0gYy5yZXNvbHZlO1xuXG5cbiAgICBpZiAocmVzb2x2ZSQkMSA9PT0gcmVzb2x2ZSQxKSB7XG4gICAgICB2YXIgX3RoZW4gPSB2b2lkIDA7XG4gICAgICB2YXIgZXJyb3IgPSB2b2lkIDA7XG4gICAgICB2YXIgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIF90aGVuID0gZW50cnkudGhlbjtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICBlcnJvciA9IGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhlbiA9PT0gdGhlbiAmJiBlbnRyeS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICAgICAgdGhpcy5fc2V0dGxlZEF0KGVudHJ5Ll9zdGF0ZSwgaSwgZW50cnkuX3Jlc3VsdCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBfdGhlbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLl9yZW1haW5pbmctLTtcbiAgICAgICAgdGhpcy5fcmVzdWx0W2ldID0gZW50cnk7XG4gICAgICB9IGVsc2UgaWYgKGMgPT09IFByb21pc2UkMSkge1xuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBjKG5vb3ApO1xuICAgICAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgZW50cnksIF90aGVuKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93aWxsU2V0dGxlQXQocHJvbWlzZSwgaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl93aWxsU2V0dGxlQXQobmV3IGMoZnVuY3Rpb24gKHJlc29sdmUkJDEpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSQkMShlbnRyeSk7XG4gICAgICAgIH0pLCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KHJlc29sdmUkJDEoZW50cnkpLCBpKTtcbiAgICB9XG4gIH07XG5cbiAgRW51bWVyYXRvci5wcm90b3R5cGUuX3NldHRsZWRBdCA9IGZ1bmN0aW9uIF9zZXR0bGVkQXQoc3RhdGUsIGksIHZhbHVlKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzLnByb21pc2U7XG5cblxuICAgIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gUEVORElORykge1xuICAgICAgdGhpcy5fcmVtYWluaW5nLS07XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICAgICAgcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICB9XG4gIH07XG5cbiAgRW51bWVyYXRvci5wcm90b3R5cGUuX3dpbGxTZXR0bGVBdCA9IGZ1bmN0aW9uIF93aWxsU2V0dGxlQXQocHJvbWlzZSwgaSkge1xuICAgIHZhciBlbnVtZXJhdG9yID0gdGhpcztcblxuICAgIHN1YnNjcmliZShwcm9taXNlLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGVudW1lcmF0b3IuX3NldHRsZWRBdChGVUxGSUxMRUQsIGksIHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICByZXR1cm4gZW51bWVyYXRvci5fc2V0dGxlZEF0KFJFSkVDVEVELCBpLCByZWFzb24pO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBFbnVtZXJhdG9yO1xufSgpO1xuXG4vKipcbiAgYFByb21pc2UuYWxsYCBhY2NlcHRzIGFuIGFycmF5IG9mIHByb21pc2VzLCBhbmQgcmV0dXJucyBhIG5ldyBwcm9taXNlIHdoaWNoXG4gIGlzIGZ1bGZpbGxlZCB3aXRoIGFuIGFycmF5IG9mIGZ1bGZpbGxtZW50IHZhbHVlcyBmb3IgdGhlIHBhc3NlZCBwcm9taXNlcywgb3JcbiAgcmVqZWN0ZWQgd2l0aCB0aGUgcmVhc29uIG9mIHRoZSBmaXJzdCBwYXNzZWQgcHJvbWlzZSB0byBiZSByZWplY3RlZC4gSXQgY2FzdHMgYWxsXG4gIGVsZW1lbnRzIG9mIHRoZSBwYXNzZWQgaXRlcmFibGUgdG8gcHJvbWlzZXMgYXMgaXQgcnVucyB0aGlzIGFsZ29yaXRobS5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gcmVzb2x2ZSgxKTtcbiAgbGV0IHByb21pc2UyID0gcmVzb2x2ZSgyKTtcbiAgbGV0IHByb21pc2UzID0gcmVzb2x2ZSgzKTtcbiAgbGV0IHByb21pc2VzID0gWyBwcm9taXNlMSwgcHJvbWlzZTIsIHByb21pc2UzIF07XG5cbiAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oYXJyYXkpe1xuICAgIC8vIFRoZSBhcnJheSBoZXJlIHdvdWxkIGJlIFsgMSwgMiwgMyBdO1xuICB9KTtcbiAgYGBgXG5cbiAgSWYgYW55IG9mIHRoZSBgcHJvbWlzZXNgIGdpdmVuIHRvIGBhbGxgIGFyZSByZWplY3RlZCwgdGhlIGZpcnN0IHByb21pc2VcbiAgdGhhdCBpcyByZWplY3RlZCB3aWxsIGJlIGdpdmVuIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSByZXR1cm5lZCBwcm9taXNlcydzXG4gIHJlamVjdGlvbiBoYW5kbGVyLiBGb3IgZXhhbXBsZTpcblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gcmVzb2x2ZSgxKTtcbiAgbGV0IHByb21pc2UyID0gcmVqZWN0KG5ldyBFcnJvcihcIjJcIikpO1xuICBsZXQgcHJvbWlzZTMgPSByZWplY3QobmV3IEVycm9yKFwiM1wiKSk7XG4gIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAvLyBDb2RlIGhlcmUgbmV2ZXIgcnVucyBiZWNhdXNlIHRoZXJlIGFyZSByZWplY3RlZCBwcm9taXNlcyFcbiAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAvLyBlcnJvci5tZXNzYWdlID09PSBcIjJcIlxuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCBhbGxcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FycmF5fSBlbnRyaWVzIGFycmF5IG9mIHByb21pc2VzXG4gIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBvcHRpb25hbCBzdHJpbmcgZm9yIGxhYmVsaW5nIHRoZSBwcm9taXNlLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2hlbiBhbGwgYHByb21pc2VzYCBoYXZlIGJlZW5cbiAgZnVsZmlsbGVkLCBvciByZWplY3RlZCBpZiBhbnkgb2YgdGhlbSBiZWNvbWUgcmVqZWN0ZWQuXG4gIEBzdGF0aWNcbiovXG5mdW5jdGlvbiBhbGwoZW50cmllcykge1xuICByZXR1cm4gbmV3IEVudW1lcmF0b3IodGhpcywgZW50cmllcykucHJvbWlzZTtcbn1cblxuLyoqXG4gIGBQcm9taXNlLnJhY2VgIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaCBpcyBzZXR0bGVkIGluIHRoZSBzYW1lIHdheSBhcyB0aGVcbiAgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gc2V0dGxlLlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMScpO1xuICAgIH0sIDIwMCk7XG4gIH0pO1xuXG4gIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAyJyk7XG4gICAgfSwgMTAwKTtcbiAgfSk7XG5cbiAgUHJvbWlzZS5yYWNlKFtwcm9taXNlMSwgcHJvbWlzZTJdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgLy8gcmVzdWx0ID09PSAncHJvbWlzZSAyJyBiZWNhdXNlIGl0IHdhcyByZXNvbHZlZCBiZWZvcmUgcHJvbWlzZTFcbiAgICAvLyB3YXMgcmVzb2x2ZWQuXG4gIH0pO1xuICBgYGBcblxuICBgUHJvbWlzZS5yYWNlYCBpcyBkZXRlcm1pbmlzdGljIGluIHRoYXQgb25seSB0aGUgc3RhdGUgb2YgdGhlIGZpcnN0XG4gIHNldHRsZWQgcHJvbWlzZSBtYXR0ZXJzLiBGb3IgZXhhbXBsZSwgZXZlbiBpZiBvdGhlciBwcm9taXNlcyBnaXZlbiB0byB0aGVcbiAgYHByb21pc2VzYCBhcnJheSBhcmd1bWVudCBhcmUgcmVzb2x2ZWQsIGJ1dCB0aGUgZmlyc3Qgc2V0dGxlZCBwcm9taXNlIGhhc1xuICBiZWNvbWUgcmVqZWN0ZWQgYmVmb3JlIHRoZSBvdGhlciBwcm9taXNlcyBiZWNhbWUgZnVsZmlsbGVkLCB0aGUgcmV0dXJuZWRcbiAgcHJvbWlzZSB3aWxsIGJlY29tZSByZWplY3RlZDpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAxJyk7XG4gICAgfSwgMjAwKTtcbiAgfSk7XG5cbiAgbGV0IHByb21pc2UyID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZWplY3QobmV3IEVycm9yKCdwcm9taXNlIDInKSk7XG4gICAgfSwgMTAwKTtcbiAgfSk7XG5cbiAgUHJvbWlzZS5yYWNlKFtwcm9taXNlMSwgcHJvbWlzZTJdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnNcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBwcm9taXNlIDIgYmVjYW1lIHJlamVjdGVkIGJlZm9yZVxuICAgIC8vIHByb21pc2UgMSBiZWNhbWUgZnVsZmlsbGVkXG4gIH0pO1xuICBgYGBcblxuICBBbiBleGFtcGxlIHJlYWwtd29ybGQgdXNlIGNhc2UgaXMgaW1wbGVtZW50aW5nIHRpbWVvdXRzOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgUHJvbWlzZS5yYWNlKFthamF4KCdmb28uanNvbicpLCB0aW1lb3V0KDUwMDApXSlcbiAgYGBgXG5cbiAgQG1ldGhvZCByYWNlXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBcnJheX0gcHJvbWlzZXMgYXJyYXkgb2YgcHJvbWlzZXMgdG8gb2JzZXJ2ZVxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB3aGljaCBzZXR0bGVzIGluIHRoZSBzYW1lIHdheSBhcyB0aGUgZmlyc3QgcGFzc2VkXG4gIHByb21pc2UgdG8gc2V0dGxlLlxuKi9cbmZ1bmN0aW9uIHJhY2UoZW50cmllcykge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gIGlmICghaXNBcnJheShlbnRyaWVzKSkge1xuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gKF8sIHJlamVjdCkge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIHJhY2UuJykpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGVudHJpZXMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBDb25zdHJ1Y3Rvci5yZXNvbHZlKGVudHJpZXNbaV0pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAgYFByb21pc2UucmVqZWN0YCByZXR1cm5zIGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBwYXNzZWQgYHJlYXNvbmAuXG4gIEl0IGlzIHNob3J0aGFuZCBmb3IgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICByZWplY3QobmV3IEVycm9yKCdXSE9PUFMnKSk7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gQ29kZSBoZXJlIGRvZXNuJ3QgcnVuIGJlY2F1c2UgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQhXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdXSE9PUFMnXG4gIH0pO1xuICBgYGBcblxuICBJbnN0ZWFkIG9mIHdyaXRpbmcgdGhlIGFib3ZlLCB5b3VyIGNvZGUgbm93IHNpbXBseSBiZWNvbWVzIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gQ29kZSBoZXJlIGRvZXNuJ3QgcnVuIGJlY2F1c2UgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQhXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdXSE9PUFMnXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIHJlamVjdFxuICBAc3RhdGljXG4gIEBwYXJhbSB7QW55fSByZWFzb24gdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGguXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHJlamVjdGVkIHdpdGggdGhlIGdpdmVuIGByZWFzb25gLlxuKi9cbmZ1bmN0aW9uIHJlamVjdCQxKHJlYXNvbikge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcbiAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBuZWVkc1Jlc29sdmVyKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGEgcmVzb2x2ZXIgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBwcm9taXNlIGNvbnN0cnVjdG9yJyk7XG59XG5cbmZ1bmN0aW9uIG5lZWRzTmV3KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUHJvbWlzZSc6IFBsZWFzZSB1c2UgdGhlICduZXcnIG9wZXJhdG9yLCB0aGlzIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xufVxuXG4vKipcbiAgUHJvbWlzZSBvYmplY3RzIHJlcHJlc2VudCB0aGUgZXZlbnR1YWwgcmVzdWx0IG9mIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uIFRoZVxuICBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLCB3aGljaFxuICByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZSByZWFzb25cbiAgd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG5cbiAgVGVybWlub2xvZ3lcbiAgLS0tLS0tLS0tLS1cblxuICAtIGBwcm9taXNlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gd2l0aCBhIGB0aGVuYCBtZXRob2Qgd2hvc2UgYmVoYXZpb3IgY29uZm9ybXMgdG8gdGhpcyBzcGVjaWZpY2F0aW9uLlxuICAtIGB0aGVuYWJsZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyBhIGB0aGVuYCBtZXRob2QuXG4gIC0gYHZhbHVlYCBpcyBhbnkgbGVnYWwgSmF2YVNjcmlwdCB2YWx1ZSAoaW5jbHVkaW5nIHVuZGVmaW5lZCwgYSB0aGVuYWJsZSwgb3IgYSBwcm9taXNlKS5cbiAgLSBgZXhjZXB0aW9uYCBpcyBhIHZhbHVlIHRoYXQgaXMgdGhyb3duIHVzaW5nIHRoZSB0aHJvdyBzdGF0ZW1lbnQuXG4gIC0gYHJlYXNvbmAgaXMgYSB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aHkgYSBwcm9taXNlIHdhcyByZWplY3RlZC5cbiAgLSBgc2V0dGxlZGAgdGhlIGZpbmFsIHJlc3Rpbmcgc3RhdGUgb2YgYSBwcm9taXNlLCBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG5cbiAgQSBwcm9taXNlIGNhbiBiZSBpbiBvbmUgb2YgdGhyZWUgc3RhdGVzOiBwZW5kaW5nLCBmdWxmaWxsZWQsIG9yIHJlamVjdGVkLlxuXG4gIFByb21pc2VzIHRoYXQgYXJlIGZ1bGZpbGxlZCBoYXZlIGEgZnVsZmlsbG1lbnQgdmFsdWUgYW5kIGFyZSBpbiB0aGUgZnVsZmlsbGVkXG4gIHN0YXRlLiAgUHJvbWlzZXMgdGhhdCBhcmUgcmVqZWN0ZWQgaGF2ZSBhIHJlamVjdGlvbiByZWFzb24gYW5kIGFyZSBpbiB0aGVcbiAgcmVqZWN0ZWQgc3RhdGUuICBBIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5ldmVyIGEgdGhlbmFibGUuXG5cbiAgUHJvbWlzZXMgY2FuIGFsc28gYmUgc2FpZCB0byAqcmVzb2x2ZSogYSB2YWx1ZS4gIElmIHRoaXMgdmFsdWUgaXMgYWxzbyBhXG4gIHByb21pc2UsIHRoZW4gdGhlIG9yaWdpbmFsIHByb21pc2UncyBzZXR0bGVkIHN0YXRlIHdpbGwgbWF0Y2ggdGhlIHZhbHVlJ3NcbiAgc2V0dGxlZCBzdGF0ZS4gIFNvIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgcmVqZWN0cyB3aWxsXG4gIGl0c2VsZiByZWplY3QsIGFuZCBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpbGxcbiAgaXRzZWxmIGZ1bGZpbGwuXG5cblxuICBCYXNpYyBVc2FnZTpcbiAgLS0tLS0tLS0tLS0tXG5cbiAgYGBganNcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAvLyBvbiBzdWNjZXNzXG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG5cbiAgICAvLyBvbiBmYWlsdXJlXG4gICAgcmVqZWN0KHJlYXNvbik7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIC8vIG9uIHJlamVjdGlvblxuICB9KTtcbiAgYGBgXG5cbiAgQWR2YW5jZWQgVXNhZ2U6XG4gIC0tLS0tLS0tLS0tLS0tLVxuXG4gIFByb21pc2VzIHNoaW5lIHdoZW4gYWJzdHJhY3RpbmcgYXdheSBhc3luY2hyb25vdXMgaW50ZXJhY3Rpb25zIHN1Y2ggYXNcbiAgYFhNTEh0dHBSZXF1ZXN0YHMuXG5cbiAgYGBganNcbiAgZnVuY3Rpb24gZ2V0SlNPTih1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgIGxldCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gaGFuZGxlcjtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgIHhoci5zZW5kKCk7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuRE9ORSkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdnZXRKU09OOiBgJyArIHVybCArICdgIGZhaWxlZCB3aXRoIHN0YXR1czogWycgKyB0aGlzLnN0YXR1cyArICddJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldEpTT04oJy9wb3N0cy5qc29uJykudGhlbihmdW5jdGlvbihqc29uKSB7XG4gICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgLy8gb24gcmVqZWN0aW9uXG4gIH0pO1xuICBgYGBcblxuICBVbmxpa2UgY2FsbGJhY2tzLCBwcm9taXNlcyBhcmUgZ3JlYXQgY29tcG9zYWJsZSBwcmltaXRpdmVzLlxuXG4gIGBgYGpzXG4gIFByb21pc2UuYWxsKFtcbiAgICBnZXRKU09OKCcvcG9zdHMnKSxcbiAgICBnZXRKU09OKCcvY29tbWVudHMnKVxuICBdKS50aGVuKGZ1bmN0aW9uKHZhbHVlcyl7XG4gICAgdmFsdWVzWzBdIC8vID0+IHBvc3RzSlNPTlxuICAgIHZhbHVlc1sxXSAvLyA9PiBjb21tZW50c0pTT05cblxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH0pO1xuICBgYGBcblxuICBAY2xhc3MgUHJvbWlzZVxuICBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlclxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEBjb25zdHJ1Y3RvclxuKi9cblxudmFyIFByb21pc2UkMSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUHJvbWlzZShyZXNvbHZlcikge1xuICAgIHRoaXNbUFJPTUlTRV9JRF0gPSBuZXh0SWQoKTtcbiAgICB0aGlzLl9yZXN1bHQgPSB0aGlzLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdWJzY3JpYmVycyA9IFtdO1xuXG4gICAgaWYgKG5vb3AgIT09IHJlc29sdmVyKSB7XG4gICAgICB0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicgJiYgbmVlZHNSZXNvbHZlcigpO1xuICAgICAgdGhpcyBpbnN0YW5jZW9mIFByb21pc2UgPyBpbml0aWFsaXplUHJvbWlzZSh0aGlzLCByZXNvbHZlcikgOiBuZWVkc05ldygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICBUaGUgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCxcbiAgd2hpY2ggcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGVcbiAgcmVhc29uIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uKHVzZXIpe1xuICAgIC8vIHVzZXIgaXMgYXZhaWxhYmxlXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gdXNlciBpcyB1bmF2YWlsYWJsZSwgYW5kIHlvdSBhcmUgZ2l2ZW4gdGhlIHJlYXNvbiB3aHlcbiAgfSk7XG4gIGBgYFxuICAgQ2hhaW5pbmdcbiAgLS0tLS0tLS1cbiAgIFRoZSByZXR1cm4gdmFsdWUgb2YgYHRoZW5gIGlzIGl0c2VsZiBhIHByb21pc2UuICBUaGlzIHNlY29uZCwgJ2Rvd25zdHJlYW0nXG4gIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmaXJzdCBwcm9taXNlJ3MgZnVsZmlsbG1lbnRcbiAgb3IgcmVqZWN0aW9uIGhhbmRsZXIsIG9yIHJlamVjdGVkIGlmIHRoZSBoYW5kbGVyIHRocm93cyBhbiBleGNlcHRpb24uXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICByZXR1cm4gdXNlci5uYW1lO1xuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgcmV0dXJuICdkZWZhdWx0IG5hbWUnO1xuICB9KS50aGVuKGZ1bmN0aW9uICh1c2VyTmFtZSkge1xuICAgIC8vIElmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgdXNlck5hbWVgIHdpbGwgYmUgdGhlIHVzZXIncyBuYW1lLCBvdGhlcndpc2UgaXRcbiAgICAvLyB3aWxsIGJlIGAnZGVmYXVsdCBuYW1lJ2BcbiAgfSk7XG4gICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jyk7XG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknKTtcbiAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBuZXZlciByZWFjaGVkXG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAvLyBpZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHJlYXNvbmAgd2lsbCBiZSAnRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknLlxuICAgIC8vIElmIGBmaW5kVXNlcmAgcmVqZWN0ZWQsIGByZWFzb25gIHdpbGwgYmUgJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknLlxuICB9KTtcbiAgYGBgXG4gIElmIHRoZSBkb3duc3RyZWFtIHByb21pc2UgZG9lcyBub3Qgc3BlY2lmeSBhIHJlamVjdGlvbiBoYW5kbGVyLCByZWplY3Rpb24gcmVhc29ucyB3aWxsIGJlIHByb3BhZ2F0ZWQgZnVydGhlciBkb3duc3RyZWFtLlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgdGhyb3cgbmV3IFBlZGFnb2dpY2FsRXhjZXB0aW9uKCdVcHN0cmVhbSBlcnJvcicpO1xuICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBuZXZlciByZWFjaGVkXG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAvLyBUaGUgYFBlZGdhZ29jaWFsRXhjZXB0aW9uYCBpcyBwcm9wYWdhdGVkIGFsbCB0aGUgd2F5IGRvd24gdG8gaGVyZVxuICB9KTtcbiAgYGBgXG4gICBBc3NpbWlsYXRpb25cbiAgLS0tLS0tLS0tLS0tXG4gICBTb21ldGltZXMgdGhlIHZhbHVlIHlvdSB3YW50IHRvIHByb3BhZ2F0ZSB0byBhIGRvd25zdHJlYW0gcHJvbWlzZSBjYW4gb25seSBiZVxuICByZXRyaWV2ZWQgYXN5bmNocm9ub3VzbHkuIFRoaXMgY2FuIGJlIGFjaGlldmVkIGJ5IHJldHVybmluZyBhIHByb21pc2UgaW4gdGhlXG4gIGZ1bGZpbGxtZW50IG9yIHJlamVjdGlvbiBoYW5kbGVyLiBUaGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgdGhlbiBiZSBwZW5kaW5nXG4gIHVudGlsIHRoZSByZXR1cm5lZCBwcm9taXNlIGlzIHNldHRsZWQuIFRoaXMgaXMgY2FsbGVkICphc3NpbWlsYXRpb24qLlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgIC8vIFRoZSB1c2VyJ3MgY29tbWVudHMgYXJlIG5vdyBhdmFpbGFibGVcbiAgfSk7XG4gIGBgYFxuICAgSWYgdGhlIGFzc2ltbGlhdGVkIHByb21pc2UgcmVqZWN0cywgdGhlbiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgYWxzbyByZWplY3QuXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCBmdWxmaWxscywgd2UnbGwgaGF2ZSB0aGUgdmFsdWUgaGVyZVxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCByZWplY3RzLCB3ZSdsbCBoYXZlIHRoZSByZWFzb24gaGVyZVxuICB9KTtcbiAgYGBgXG4gICBTaW1wbGUgRXhhbXBsZVxuICAtLS0tLS0tLS0tLS0tLVxuICAgU3luY2hyb25vdXMgRXhhbXBsZVxuICAgYGBgamF2YXNjcmlwdFxuICBsZXQgcmVzdWx0O1xuICAgdHJ5IHtcbiAgICByZXN1bHQgPSBmaW5kUmVzdWx0KCk7XG4gICAgLy8gc3VjY2Vzc1xuICB9IGNhdGNoKHJlYXNvbikge1xuICAgIC8vIGZhaWx1cmVcbiAgfVxuICBgYGBcbiAgIEVycmJhY2sgRXhhbXBsZVxuICAgYGBganNcbiAgZmluZFJlc3VsdChmdW5jdGlvbihyZXN1bHQsIGVycil7XG4gICAgaWYgKGVycikge1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfVxuICB9KTtcbiAgYGBgXG4gICBQcm9taXNlIEV4YW1wbGU7XG4gICBgYGBqYXZhc2NyaXB0XG4gIGZpbmRSZXN1bHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgLy8gc3VjY2Vzc1xuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIGZhaWx1cmVcbiAgfSk7XG4gIGBgYFxuICAgQWR2YW5jZWQgRXhhbXBsZVxuICAtLS0tLS0tLS0tLS0tLVxuICAgU3luY2hyb25vdXMgRXhhbXBsZVxuICAgYGBgamF2YXNjcmlwdFxuICBsZXQgYXV0aG9yLCBib29rcztcbiAgIHRyeSB7XG4gICAgYXV0aG9yID0gZmluZEF1dGhvcigpO1xuICAgIGJvb2tzICA9IGZpbmRCb29rc0J5QXV0aG9yKGF1dGhvcik7XG4gICAgLy8gc3VjY2Vzc1xuICB9IGNhdGNoKHJlYXNvbikge1xuICAgIC8vIGZhaWx1cmVcbiAgfVxuICBgYGBcbiAgIEVycmJhY2sgRXhhbXBsZVxuICAgYGBganNcbiAgIGZ1bmN0aW9uIGZvdW5kQm9va3MoYm9va3MpIHtcbiAgIH1cbiAgIGZ1bmN0aW9uIGZhaWx1cmUocmVhc29uKSB7XG4gICB9XG4gICBmaW5kQXV0aG9yKGZ1bmN0aW9uKGF1dGhvciwgZXJyKXtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBmYWlsdXJlKGVycik7XG4gICAgICAvLyBmYWlsdXJlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZpbmRCb29va3NCeUF1dGhvcihhdXRob3IsIGZ1bmN0aW9uKGJvb2tzLCBlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZvdW5kQm9va3MoYm9va3MpO1xuICAgICAgICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgICAgICAgZmFpbHVyZShyZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgIH1cbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICB9XG4gIH0pO1xuICBgYGBcbiAgIFByb21pc2UgRXhhbXBsZTtcbiAgIGBgYGphdmFzY3JpcHRcbiAgZmluZEF1dGhvcigpLlxuICAgIHRoZW4oZmluZEJvb2tzQnlBdXRob3IpLlxuICAgIHRoZW4oZnVuY3Rpb24oYm9va3Mpe1xuICAgICAgLy8gZm91bmQgYm9va3NcbiAgfSkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICB9KTtcbiAgYGBgXG4gICBAbWV0aG9kIHRoZW5cbiAgQHBhcmFtIHtGdW5jdGlvbn0gb25GdWxmaWxsZWRcbiAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3RlZFxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG5cbiAgLyoqXG4gIGBjYXRjaGAgaXMgc2ltcGx5IHN1Z2FyIGZvciBgdGhlbih1bmRlZmluZWQsIG9uUmVqZWN0aW9uKWAgd2hpY2ggbWFrZXMgaXQgdGhlIHNhbWVcbiAgYXMgdGhlIGNhdGNoIGJsb2NrIG9mIGEgdHJ5L2NhdGNoIHN0YXRlbWVudC5cbiAgYGBganNcbiAgZnVuY3Rpb24gZmluZEF1dGhvcigpe1xuICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkbid0IGZpbmQgdGhhdCBhdXRob3InKTtcbiAgfVxuICAvLyBzeW5jaHJvbm91c1xuICB0cnkge1xuICBmaW5kQXV0aG9yKCk7XG4gIH0gY2F0Y2gocmVhc29uKSB7XG4gIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gIH1cbiAgLy8gYXN5bmMgd2l0aCBwcm9taXNlc1xuICBmaW5kQXV0aG9yKCkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgfSk7XG4gIGBgYFxuICBAbWV0aG9kIGNhdGNoXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0aW9uXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cblxuXG4gIFByb21pc2UucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24gX2NhdGNoKG9uUmVqZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAgYGZpbmFsbHlgIHdpbGwgYmUgaW52b2tlZCByZWdhcmRsZXNzIG9mIHRoZSBwcm9taXNlJ3MgZmF0ZSBqdXN0IGFzIG5hdGl2ZVxuICAgIHRyeS9jYXRjaC9maW5hbGx5IGJlaGF2ZXNcbiAgXG4gICAgU3luY2hyb25vdXMgZXhhbXBsZTpcbiAgXG4gICAgYGBganNcbiAgICBmaW5kQXV0aG9yKCkge1xuICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEF1dGhvcigpO1xuICAgIH1cbiAgXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmaW5kQXV0aG9yKCk7IC8vIHN1Y2NlZWQgb3IgZmFpbFxuICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgIHJldHVybiBmaW5kT3RoZXJBdXRoZXIoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gYWx3YXlzIHJ1bnNcbiAgICAgIC8vIGRvZXNuJ3QgYWZmZWN0IHRoZSByZXR1cm4gdmFsdWVcbiAgICB9XG4gICAgYGBgXG4gIFxuICAgIEFzeW5jaHJvbm91cyBleGFtcGxlOlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRBdXRob3IoKS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgICAgcmV0dXJuIGZpbmRPdGhlckF1dGhlcigpO1xuICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKXtcbiAgICAgIC8vIGF1dGhvciB3YXMgZWl0aGVyIGZvdW5kLCBvciBub3RcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQG1ldGhvZCBmaW5hbGx5XG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuXG5cbiAgUHJvbWlzZS5wcm90b3R5cGUuZmluYWxseSA9IGZ1bmN0aW9uIF9maW5hbGx5KGNhbGxiYWNrKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHByb21pc2UuY29uc3RydWN0b3I7XG5cbiAgICBpZiAoaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5yZXNvbHZlKGNhbGxiYWNrKCkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5yZXNvbHZlKGNhbGxiYWNrKCkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRocm93IHJlYXNvbjtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKGNhbGxiYWNrLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgcmV0dXJuIFByb21pc2U7XG59KCk7XG5cblByb21pc2UkMS5wcm90b3R5cGUudGhlbiA9IHRoZW47XG5Qcm9taXNlJDEuYWxsID0gYWxsO1xuUHJvbWlzZSQxLnJhY2UgPSByYWNlO1xuUHJvbWlzZSQxLnJlc29sdmUgPSByZXNvbHZlJDE7XG5Qcm9taXNlJDEucmVqZWN0ID0gcmVqZWN0JDE7XG5Qcm9taXNlJDEuX3NldFNjaGVkdWxlciA9IHNldFNjaGVkdWxlcjtcblByb21pc2UkMS5fc2V0QXNhcCA9IHNldEFzYXA7XG5Qcm9taXNlJDEuX2FzYXAgPSBhc2FwO1xuXG4vKmdsb2JhbCBzZWxmKi9cbmZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICB2YXIgbG9jYWwgPSB2b2lkIDA7XG5cbiAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9jYWwgPSBnbG9iYWw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9jYWwgPSBzZWxmO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBsb2NhbCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2x5ZmlsbCBmYWlsZWQgYmVjYXVzZSBnbG9iYWwgb2JqZWN0IGlzIHVuYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgICB9XG4gIH1cblxuICB2YXIgUCA9IGxvY2FsLlByb21pc2U7XG5cbiAgaWYgKFApIHtcbiAgICB2YXIgcHJvbWlzZVRvU3RyaW5nID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgcHJvbWlzZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFAucmVzb2x2ZSgpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBzaWxlbnRseSBpZ25vcmVkXG4gICAgfVxuXG4gICAgaWYgKHByb21pc2VUb1N0cmluZyA9PT0gJ1tvYmplY3QgUHJvbWlzZV0nICYmICFQLmNhc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBsb2NhbC5Qcm9taXNlID0gUHJvbWlzZSQxO1xufVxuXG4vLyBTdHJhbmdlIGNvbXBhdC4uXG5Qcm9taXNlJDEucG9seWZpbGwgPSBwb2x5ZmlsbDtcblByb21pc2UkMS5Qcm9taXNlID0gUHJvbWlzZSQxO1xuXG5yZXR1cm4gUHJvbWlzZSQxO1xuXG59KSkpO1xuXG5cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXM2LXByb21pc2UubWFwXG4iLCIvKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvKlxuICogIGJhc2U2NC5qc1xuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQlNEIDMtQ2xhdXNlIExpY2Vuc2UuXG4gKiAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKlxuICogIFJlZmVyZW5jZXM6XG4gKiAgICBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NFxuICovXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoZ2xvYmFsKVxuICAgICAgICA6IHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZFxuICAgICAgICA/IGRlZmluZShmYWN0b3J5KSA6IGZhY3RvcnkoZ2xvYmFsKVxufSgoXG4gICAgdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZlxuICAgICAgICA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93XG4gICAgICAgIDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxcbjogdGhpc1xuKSwgZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIGV4aXN0aW5nIHZlcnNpb24gZm9yIG5vQ29uZmxpY3QoKVxuICAgIGdsb2JhbCA9IGdsb2JhbCB8fCB7fTtcbiAgICB2YXIgX0Jhc2U2NCA9IGdsb2JhbC5CYXNlNjQ7XG4gICAgdmFyIHZlcnNpb24gPSBcIjIuNi40XCI7XG4gICAgLy8gY29uc3RhbnRzXG4gICAgdmFyIGI2NGNoYXJzXG4gICAgICAgID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuICAgIHZhciBiNjR0YWIgPSBmdW5jdGlvbihiaW4pIHtcbiAgICAgICAgdmFyIHQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBiaW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB0W2Jpbi5jaGFyQXQoaSldID0gaTtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfShiNjRjaGFycyk7XG4gICAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gICAgLy8gZW5jb2RlciBzdHVmZlxuICAgIHZhciBjYl91dG9iID0gZnVuY3Rpb24oYykge1xuICAgICAgICBpZiAoYy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICB2YXIgY2MgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICByZXR1cm4gY2MgPCAweDgwID8gY1xuICAgICAgICAgICAgICAgIDogY2MgPCAweDgwMCA/IChmcm9tQ2hhckNvZGUoMHhjMCB8IChjYyA+Pj4gNikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgZnJvbUNoYXJDb2RlKDB4ODAgfCAoY2MgJiAweDNmKSkpXG4gICAgICAgICAgICAgICAgOiAoZnJvbUNoYXJDb2RlKDB4ZTAgfCAoKGNjID4+PiAxMikgJiAweDBmKSlcbiAgICAgICAgICAgICAgICAgICAgKyBmcm9tQ2hhckNvZGUoMHg4MCB8ICgoY2MgPj4+ICA2KSAmIDB4M2YpKVxuICAgICAgICAgICAgICAgICAgICArIGZyb21DaGFyQ29kZSgweDgwIHwgKCBjYyAgICAgICAgICYgMHgzZikpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjYyA9IDB4MTAwMDBcbiAgICAgICAgICAgICAgICArIChjLmNoYXJDb2RlQXQoMCkgLSAweEQ4MDApICogMHg0MDBcbiAgICAgICAgICAgICAgICArIChjLmNoYXJDb2RlQXQoMSkgLSAweERDMDApO1xuICAgICAgICAgICAgcmV0dXJuIChmcm9tQ2hhckNvZGUoMHhmMCB8ICgoY2MgPj4+IDE4KSAmIDB4MDcpKVxuICAgICAgICAgICAgICAgICAgICArIGZyb21DaGFyQ29kZSgweDgwIHwgKChjYyA+Pj4gMTIpICYgMHgzZikpXG4gICAgICAgICAgICAgICAgICAgICsgZnJvbUNoYXJDb2RlKDB4ODAgfCAoKGNjID4+PiAgNikgJiAweDNmKSlcbiAgICAgICAgICAgICAgICAgICAgKyBmcm9tQ2hhckNvZGUoMHg4MCB8ICggY2MgICAgICAgICAmIDB4M2YpKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZV91dG9iID0gL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRkZdfFteXFx4MDAtXFx4N0ZdL2c7XG4gICAgdmFyIHV0b2IgPSBmdW5jdGlvbih1KSB7XG4gICAgICAgIHJldHVybiB1LnJlcGxhY2UocmVfdXRvYiwgY2JfdXRvYik7XG4gICAgfTtcbiAgICB2YXIgY2JfZW5jb2RlID0gZnVuY3Rpb24oY2NjKSB7XG4gICAgICAgIHZhciBwYWRsZW4gPSBbMCwgMiwgMV1bY2NjLmxlbmd0aCAlIDNdLFxuICAgICAgICBvcmQgPSBjY2MuY2hhckNvZGVBdCgwKSA8PCAxNlxuICAgICAgICAgICAgfCAoKGNjYy5sZW5ndGggPiAxID8gY2NjLmNoYXJDb2RlQXQoMSkgOiAwKSA8PCA4KVxuICAgICAgICAgICAgfCAoKGNjYy5sZW5ndGggPiAyID8gY2NjLmNoYXJDb2RlQXQoMikgOiAwKSksXG4gICAgICAgIGNoYXJzID0gW1xuICAgICAgICAgICAgYjY0Y2hhcnMuY2hhckF0KCBvcmQgPj4+IDE4KSxcbiAgICAgICAgICAgIGI2NGNoYXJzLmNoYXJBdCgob3JkID4+PiAxMikgJiA2MyksXG4gICAgICAgICAgICBwYWRsZW4gPj0gMiA/ICc9JyA6IGI2NGNoYXJzLmNoYXJBdCgob3JkID4+PiA2KSAmIDYzKSxcbiAgICAgICAgICAgIHBhZGxlbiA+PSAxID8gJz0nIDogYjY0Y2hhcnMuY2hhckF0KG9yZCAmIDYzKVxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XG4gICAgfTtcbiAgICB2YXIgYnRvYSA9IGdsb2JhbC5idG9hICYmIHR5cGVvZiBnbG9iYWwuYnRvYSA9PSAnZnVuY3Rpb24nXG4gICAgICAgID8gZnVuY3Rpb24oYil7IHJldHVybiBnbG9iYWwuYnRvYShiKSB9IDogZnVuY3Rpb24oYikge1xuICAgICAgICBpZiAoYi5tYXRjaCgvW15cXHgwMC1cXHhGRl0vKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICAgICAgICAnVGhlIHN0cmluZyBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMuJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gYi5yZXBsYWNlKC9bXFxzXFxTXXsxLDN9L2csIGNiX2VuY29kZSk7XG4gICAgfTtcbiAgICB2YXIgX2VuY29kZSA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgcmV0dXJuIGJ0b2EodXRvYihTdHJpbmcodSkpKTtcbiAgICB9O1xuICAgIHZhciBta1VyaVNhZmUgPSBmdW5jdGlvbiAoYjY0KSB7XG4gICAgICAgIHJldHVybiBiNjQucmVwbGFjZSgvWytcXC9dL2csIGZ1bmN0aW9uKG0wKSB7XG4gICAgICAgICAgICByZXR1cm4gbTAgPT0gJysnID8gJy0nIDogJ18nO1xuICAgICAgICB9KS5yZXBsYWNlKC89L2csICcnKTtcbiAgICB9O1xuICAgIHZhciBlbmNvZGUgPSBmdW5jdGlvbih1LCB1cmlzYWZlKSB7XG4gICAgICAgIHJldHVybiB1cmlzYWZlID8gbWtVcmlTYWZlKF9lbmNvZGUodSkpIDogX2VuY29kZSh1KTtcbiAgICB9O1xuICAgIHZhciBlbmNvZGVVUkkgPSBmdW5jdGlvbih1KSB7IHJldHVybiBlbmNvZGUodSwgdHJ1ZSkgfTtcbiAgICB2YXIgZnJvbVVpbnQ4QXJyYXk7XG4gICAgaWYgKGdsb2JhbC5VaW50OEFycmF5KSBmcm9tVWludDhBcnJheSA9IGZ1bmN0aW9uKGEsIHVyaXNhZmUpIHtcbiAgICAgICAgLy8gcmV0dXJuIGJ0b2EoZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGEpKTtcbiAgICAgICAgdmFyIGI2NCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSArPSAzKSB7XG4gICAgICAgICAgICB2YXIgYTAgPSBhW2ldLCBhMSA9IGFbaSsxXSwgYTIgPSBhW2krMl07XG4gICAgICAgICAgICB2YXIgb3JkID0gYTAgPDwgMTYgfCBhMSA8PCA4IHwgYTI7XG4gICAgICAgICAgICBiNjQgKz0gICAgYjY0Y2hhcnMuY2hhckF0KCBvcmQgPj4+IDE4KVxuICAgICAgICAgICAgICAgICsgICAgIGI2NGNoYXJzLmNoYXJBdCgob3JkID4+PiAxMikgJiA2MylcbiAgICAgICAgICAgICAgICArICggdHlwZW9mIGExICE9ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgID8gYjY0Y2hhcnMuY2hhckF0KChvcmQgPj4+ICA2KSAmIDYzKSA6ICc9JylcbiAgICAgICAgICAgICAgICArICggdHlwZW9mIGEyICE9ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgID8gYjY0Y2hhcnMuY2hhckF0KCBvcmQgICAgICAgICAmIDYzKSA6ICc9Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVyaXNhZmUgPyBta1VyaVNhZmUoYjY0KSA6IGI2NDtcbiAgICB9O1xuICAgIC8vIGRlY29kZXIgc3R1ZmZcbiAgICB2YXIgcmVfYnRvdSA9IC9bXFx4QzAtXFx4REZdW1xceDgwLVxceEJGXXxbXFx4RTAtXFx4RUZdW1xceDgwLVxceEJGXXsyfXxbXFx4RjAtXFx4RjddW1xceDgwLVxceEJGXXszfS9nO1xuICAgIHZhciBjYl9idG91ID0gZnVuY3Rpb24oY2NjYykge1xuICAgICAgICBzd2l0Y2goY2NjYy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdmFyIGNwID0gKCgweDA3ICYgY2NjYy5jaGFyQ29kZUF0KDApKSA8PCAxOClcbiAgICAgICAgICAgICAgICB8ICAgICgoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgxKSkgPDwgMTIpXG4gICAgICAgICAgICAgICAgfCAgICAoKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMikpIDw8ICA2KVxuICAgICAgICAgICAgICAgIHwgICAgICgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDMpKSxcbiAgICAgICAgICAgIG9mZnNldCA9IGNwIC0gMHgxMDAwMDtcbiAgICAgICAgICAgIHJldHVybiAoZnJvbUNoYXJDb2RlKChvZmZzZXQgID4+PiAxMCkgKyAweEQ4MDApXG4gICAgICAgICAgICAgICAgICAgICsgZnJvbUNoYXJDb2RlKChvZmZzZXQgJiAweDNGRikgKyAweERDMDApKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIGZyb21DaGFyQ29kZShcbiAgICAgICAgICAgICAgICAoKDB4MGYgJiBjY2NjLmNoYXJDb2RlQXQoMCkpIDw8IDEyKVxuICAgICAgICAgICAgICAgICAgICB8ICgoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgxKSkgPDwgNilcbiAgICAgICAgICAgICAgICAgICAgfCAgKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMikpXG4gICAgICAgICAgICApO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICBmcm9tQ2hhckNvZGUoXG4gICAgICAgICAgICAgICAgKCgweDFmICYgY2NjYy5jaGFyQ29kZUF0KDApKSA8PCA2KVxuICAgICAgICAgICAgICAgICAgICB8ICAoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgxKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBidG91ID0gZnVuY3Rpb24oYikge1xuICAgICAgICByZXR1cm4gYi5yZXBsYWNlKHJlX2J0b3UsIGNiX2J0b3UpO1xuICAgIH07XG4gICAgdmFyIGNiX2RlY29kZSA9IGZ1bmN0aW9uKGNjY2MpIHtcbiAgICAgICAgdmFyIGxlbiA9IGNjY2MubGVuZ3RoLFxuICAgICAgICBwYWRsZW4gPSBsZW4gJSA0LFxuICAgICAgICBuID0gKGxlbiA+IDAgPyBiNjR0YWJbY2NjYy5jaGFyQXQoMCldIDw8IDE4IDogMClcbiAgICAgICAgICAgIHwgKGxlbiA+IDEgPyBiNjR0YWJbY2NjYy5jaGFyQXQoMSldIDw8IDEyIDogMClcbiAgICAgICAgICAgIHwgKGxlbiA+IDIgPyBiNjR0YWJbY2NjYy5jaGFyQXQoMildIDw8ICA2IDogMClcbiAgICAgICAgICAgIHwgKGxlbiA+IDMgPyBiNjR0YWJbY2NjYy5jaGFyQXQoMyldICAgICAgIDogMCksXG4gICAgICAgIGNoYXJzID0gW1xuICAgICAgICAgICAgZnJvbUNoYXJDb2RlKCBuID4+PiAxNiksXG4gICAgICAgICAgICBmcm9tQ2hhckNvZGUoKG4gPj4+ICA4KSAmIDB4ZmYpLFxuICAgICAgICAgICAgZnJvbUNoYXJDb2RlKCBuICAgICAgICAgJiAweGZmKVxuICAgICAgICBdO1xuICAgICAgICBjaGFycy5sZW5ndGggLT0gWzAsIDAsIDIsIDFdW3BhZGxlbl07XG4gICAgICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbiAgICB9O1xuICAgIHZhciBfYXRvYiA9IGdsb2JhbC5hdG9iICYmIHR5cGVvZiBnbG9iYWwuYXRvYiA9PSAnZnVuY3Rpb24nXG4gICAgICAgID8gZnVuY3Rpb24oYSl7IHJldHVybiBnbG9iYWwuYXRvYihhKSB9IDogZnVuY3Rpb24oYSl7XG4gICAgICAgIHJldHVybiBhLnJlcGxhY2UoL1xcU3sxLDR9L2csIGNiX2RlY29kZSk7XG4gICAgfTtcbiAgICB2YXIgYXRvYiA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgcmV0dXJuIF9hdG9iKFN0cmluZyhhKS5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL10vZywgJycpKTtcbiAgICB9O1xuICAgIHZhciBfZGVjb2RlID0gZnVuY3Rpb24oYSkgeyByZXR1cm4gYnRvdShfYXRvYihhKSkgfTtcbiAgICB2YXIgX2Zyb21VUkkgPSBmdW5jdGlvbihhKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoYSkucmVwbGFjZSgvWy1fXS9nLCBmdW5jdGlvbihtMCkge1xuICAgICAgICAgICAgcmV0dXJuIG0wID09ICctJyA/ICcrJyA6ICcvJ1xuICAgICAgICB9KS5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL10vZywgJycpO1xuICAgIH07XG4gICAgdmFyIGRlY29kZSA9IGZ1bmN0aW9uKGEpe1xuICAgICAgICByZXR1cm4gX2RlY29kZShfZnJvbVVSSShhKSk7XG4gICAgfTtcbiAgICB2YXIgdG9VaW50OEFycmF5O1xuICAgIGlmIChnbG9iYWwuVWludDhBcnJheSkgdG9VaW50OEFycmF5ID0gZnVuY3Rpb24oYSkge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGF0b2IoX2Zyb21VUkkoYSkpLCBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICByZXR1cm4gYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHZhciBub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBCYXNlNjQgPSBnbG9iYWwuQmFzZTY0O1xuICAgICAgICBnbG9iYWwuQmFzZTY0ID0gX0Jhc2U2NDtcbiAgICAgICAgcmV0dXJuIEJhc2U2NDtcbiAgICB9O1xuICAgIC8vIGV4cG9ydCBCYXNlNjRcbiAgICBnbG9iYWwuQmFzZTY0ID0ge1xuICAgICAgICBWRVJTSU9OOiB2ZXJzaW9uLFxuICAgICAgICBhdG9iOiBhdG9iLFxuICAgICAgICBidG9hOiBidG9hLFxuICAgICAgICBmcm9tQmFzZTY0OiBkZWNvZGUsXG4gICAgICAgIHRvQmFzZTY0OiBlbmNvZGUsXG4gICAgICAgIHV0b2I6IHV0b2IsXG4gICAgICAgIGVuY29kZTogZW5jb2RlLFxuICAgICAgICBlbmNvZGVVUkk6IGVuY29kZVVSSSxcbiAgICAgICAgYnRvdTogYnRvdSxcbiAgICAgICAgZGVjb2RlOiBkZWNvZGUsXG4gICAgICAgIG5vQ29uZmxpY3Q6IG5vQ29uZmxpY3QsXG4gICAgICAgIGZyb21VaW50OEFycmF5OiBmcm9tVWludDhBcnJheSxcbiAgICAgICAgdG9VaW50OEFycmF5OiB0b1VpbnQ4QXJyYXlcbiAgICB9O1xuICAgIC8vIGlmIEVTNSBpcyBhdmFpbGFibGUsIG1ha2UgQmFzZTY0LmV4dGVuZFN0cmluZygpIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBub0VudW0gPSBmdW5jdGlvbih2KXtcbiAgICAgICAgICAgIHJldHVybiB7dmFsdWU6dixlbnVtZXJhYmxlOmZhbHNlLHdyaXRhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWV9O1xuICAgICAgICB9O1xuICAgICAgICBnbG9iYWwuQmFzZTY0LmV4dGVuZFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICBTdHJpbmcucHJvdG90eXBlLCAnZnJvbUJhc2U2NCcsIG5vRW51bShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGUodGhpcylcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgU3RyaW5nLnByb3RvdHlwZSwgJ3RvQmFzZTY0Jywgbm9FbnVtKGZ1bmN0aW9uICh1cmlzYWZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGUodGhpcywgdXJpc2FmZSlcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgU3RyaW5nLnByb3RvdHlwZSwgJ3RvQmFzZTY0VVJJJywgbm9FbnVtKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZSh0aGlzLCB0cnVlKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy9cbiAgICAvLyBleHBvcnQgQmFzZTY0IHRvIHRoZSBuYW1lc3BhY2VcbiAgICAvL1xuICAgIGlmIChnbG9iYWxbJ01ldGVvciddKSB7IC8vIE1ldGVvci5qc1xuICAgICAgICBCYXNlNjQgPSBnbG9iYWwuQmFzZTY0O1xuICAgIH1cbiAgICAvLyBtb2R1bGUuZXhwb3J0cyBhbmQgQU1EIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuXG4gICAgLy8gbW9kdWxlLmV4cG9ydHMgaGFzIHByZWNlZGVuY2UuXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzLkJhc2U2NCA9IGdsb2JhbC5CYXNlNjQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKXsgcmV0dXJuIGdsb2JhbC5CYXNlNjQgfSk7XG4gICAgfVxuICAgIC8vIHRoYXQncyBpdCFcbiAgICByZXR1cm4ge0Jhc2U2NDogZ2xvYmFsLkJhc2U2NH1cbn0pKTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgdW5kZWY7XG5cbi8qKlxuICogRGVjb2RlIGEgVVJJIGVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgVVJJIGVuY29kZWQgc3RyaW5nLlxuICogQHJldHVybnMge1N0cmluZ3xOdWxsfSBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChpbnB1dC5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGVuY29kZSBhIGdpdmVuIGlucHV0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIHRoYXQgbmVlZHMgdG8gYmUgZW5jb2RlZC5cbiAqIEByZXR1cm5zIHtTdHJpbmd8TnVsbH0gVGhlIGVuY29kZWQgc3RyaW5nLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuICB0cnkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoaW5wdXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBTaW1wbGUgcXVlcnkgc3RyaW5nIHBhcnNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZyB0aGF0IG5lZWRzIHRvIGJlIHBhcnNlZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZyhxdWVyeSkge1xuICB2YXIgcGFyc2VyID0gLyhbXj0/IyZdKyk9PyhbXiZdKikvZ1xuICAgICwgcmVzdWx0ID0ge31cbiAgICAsIHBhcnQ7XG5cbiAgd2hpbGUgKHBhcnQgPSBwYXJzZXIuZXhlYyhxdWVyeSkpIHtcbiAgICB2YXIga2V5ID0gZGVjb2RlKHBhcnRbMV0pXG4gICAgICAsIHZhbHVlID0gZGVjb2RlKHBhcnRbMl0pO1xuXG4gICAgLy9cbiAgICAvLyBQcmV2ZW50IG92ZXJyaWRpbmcgb2YgZXhpc3RpbmcgcHJvcGVydGllcy4gVGhpcyBlbnN1cmVzIHRoYXQgYnVpbGQtaW5cbiAgICAvLyBtZXRob2RzIGxpa2UgYHRvU3RyaW5nYCBvciBfX3Byb3RvX18gYXJlIG5vdCBvdmVycmlkZW4gYnkgbWFsaWNpb3VzXG4gICAgLy8gcXVlcnlzdHJpbmdzLlxuICAgIC8vXG4gICAgLy8gSW4gdGhlIGNhc2UgaWYgZmFpbGVkIGRlY29kaW5nLCB3ZSB3YW50IHRvIG9taXQgdGhlIGtleS92YWx1ZSBwYWlyc1xuICAgIC8vIGZyb20gdGhlIHJlc3VsdC5cbiAgICAvL1xuICAgIGlmIChrZXkgPT09IG51bGwgfHwgdmFsdWUgPT09IG51bGwgfHwga2V5IGluIHJlc3VsdCkgY29udGludWU7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgcXVlcnkgc3RyaW5nIHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdCB0aGF0IHNob3VsZCBiZSB0cmFuc2Zvcm1lZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXggT3B0aW9uYWwgcHJlZml4LlxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5naWZ5KG9iaiwgcHJlZml4KSB7XG4gIHByZWZpeCA9IHByZWZpeCB8fCAnJztcblxuICB2YXIgcGFpcnMgPSBbXVxuICAgICwgdmFsdWVcbiAgICAsIGtleTtcblxuICAvL1xuICAvLyBPcHRpb25hbGx5IHByZWZpeCB3aXRoIGEgJz8nIGlmIG5lZWRlZFxuICAvL1xuICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcmVmaXgpIHByZWZpeCA9ICc/JztcblxuICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICB2YWx1ZSA9IG9ialtrZXldO1xuXG4gICAgICAvL1xuICAgICAgLy8gRWRnZSBjYXNlcyB3aGVyZSB3ZSBhY3R1YWxseSB3YW50IHRvIGVuY29kZSB0aGUgdmFsdWUgdG8gYW4gZW1wdHlcbiAgICAgIC8vIHN0cmluZyBpbnN0ZWFkIG9mIHRoZSBzdHJpbmdpZmllZCB2YWx1ZS5cbiAgICAgIC8vXG4gICAgICBpZiAoIXZhbHVlICYmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWYgfHwgaXNOYU4odmFsdWUpKSkge1xuICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSBlbmNvZGUoa2V5KTtcbiAgICAgIHZhbHVlID0gZW5jb2RlKHZhbHVlKTtcblxuICAgICAgLy9cbiAgICAgIC8vIElmIHdlIGZhaWxlZCB0byBlbmNvZGUgdGhlIHN0cmluZ3MsIHdlIHNob3VsZCBiYWlsIG91dCBhcyB3ZSBkb24ndFxuICAgICAgLy8gd2FudCB0byBhZGQgaW52YWxpZCBzdHJpbmdzIHRvIHRoZSBxdWVyeS5cbiAgICAgIC8vXG4gICAgICBpZiAoa2V5ID09PSBudWxsIHx8IHZhbHVlID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgIHBhaXJzLnB1c2goa2V5ICsnPScrIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFpcnMubGVuZ3RoID8gcHJlZml4ICsgcGFpcnMuam9pbignJicpIDogJyc7XG59XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5leHBvcnRzLnN0cmluZ2lmeSA9IHF1ZXJ5c3RyaW5naWZ5O1xuZXhwb3J0cy5wYXJzZSA9IHF1ZXJ5c3RyaW5nO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuICB0cnkge1xuICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBkZWZpbmUoR3AsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb24pO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShcbiAgICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSxcbiAgICB0b1N0cmluZ1RhZ1N5bWJvbCxcbiAgICBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgKTtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYXN5bmNJdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG5cbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXG4gICAgICBQcm9taXNlSW1wbFxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9KTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgLy8gb3Igbm90LCByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGRlY2xhcmUgdGhlIHZhcmlhYmxlXG4gIC8vIHJlZ2VuZXJhdG9yUnVudGltZSBpbiB0aGUgb3V0ZXIgc2NvcGUsIHdoaWNoIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZVxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuICByZXR1cm4gZXhwb3J0cztcblxufShcbiAgLy8gSWYgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlLCB1c2UgbW9kdWxlLmV4cG9ydHNcbiAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuICAvLyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIHZhcmlhYmxlIGF0IHRoZSB0b3Agb2YgdGhpcyBmaWxlLlxuICB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiID8gbW9kdWxlLmV4cG9ydHMgOiB7fVxuKSk7XG5cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxuICAvLyBhc3NpZ25tZW50IHNob3VsZCBhbHdheXMgd29yayB1bmxlc3Mgc29tZXRoaW5nIGlzIG1pc2NvbmZpZ3VyZWQuIEp1c3RcbiAgLy8gaW4gY2FzZSBydW50aW1lLmpzIGFjY2lkZW50YWxseSBydW5zIGluIHN0cmljdCBtb2RlLCBpbiBtb2Rlcm4gZW5naW5lc1xuICAvLyB3ZSBjYW4gZXhwbGljaXRseSBhY2Nlc3MgZ2xvYmFsVGhpcy4gSW4gb2xkZXIgZW5naW5lcyB3ZSBjYW4gZXNjYXBlXG4gIC8vIHN0cmljdCBtb2RlIHVzaW5nIGEgZ2xvYmFsIEZ1bmN0aW9uIGNhbGwuIFRoaXMgY291bGQgY29uY2VpdmFibHkgZmFpbFxuICAvLyBpZiBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGZvcmJpZHMgdXNpbmcgRnVuY3Rpb24sIGJ1dCBpbiB0aGF0IGNhc2VcbiAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcbiAgLy8geW91J3ZlIG1pc2NvbmZpZ3VyZWQgeW91ciBidW5kbGVyIHRvIGZvcmNlIHN0cmljdCBtb2RlIGFuZCBhcHBsaWVkIGFcbiAgLy8gQ1NQIHRvIGZvcmJpZCBGdW5jdGlvbiwgYW5kIHlvdSdyZSBub3Qgd2lsbGluZyB0byBmaXggZWl0aGVyIG9mIHRob3NlXG4gIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBnbG9iYWxUaGlzLnJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG4gIH0gZWxzZSB7XG4gICAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlJ3JlIHJlcXVpcmVkIHRvIGFkZCBhIHBvcnQgbnVtYmVyLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkZWZhdWx0LXBvcnRcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gcG9ydCBQb3J0IG51bWJlciB3ZSBuZWVkIHRvIGNoZWNrXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgd2UgbmVlZCB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMge0Jvb2xlYW59IElzIGl0IGEgZGVmYXVsdCBwb3J0IGZvciB0aGUgZ2l2ZW4gcHJvdG9jb2xcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcXVpcmVkKHBvcnQsIHByb3RvY29sKSB7XG4gIHByb3RvY29sID0gcHJvdG9jb2wuc3BsaXQoJzonKVswXTtcbiAgcG9ydCA9ICtwb3J0O1xuXG4gIGlmICghcG9ydCkgcmV0dXJuIGZhbHNlO1xuXG4gIHN3aXRjaCAocHJvdG9jb2wpIHtcbiAgICBjYXNlICdodHRwJzpcbiAgICBjYXNlICd3cyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDgwO1xuXG4gICAgY2FzZSAnaHR0cHMnOlxuICAgIGNhc2UgJ3dzcyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDQ0MztcblxuICAgIGNhc2UgJ2Z0cCc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDIxO1xuXG4gICAgY2FzZSAnZ29waGVyJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gNzA7XG5cbiAgICBjYXNlICdmaWxlJzpcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcG9ydCAhPT0gMDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZXF1aXJlZCA9IHJlcXVpcmUoJ3JlcXVpcmVzLXBvcnQnKVxuICAsIHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmdpZnknKVxuICAsIHNsYXNoZXMgPSAvXltBLVphLXpdW0EtWmEtejAtOSstLl0qOlxcL1xcLy9cbiAgLCBwcm90b2NvbHJlID0gL14oW2Etel1bYS16MC05ListXSo6KT8oXFwvXFwvKT8oW1xcXFwvXSspPyhbXFxTXFxzXSopL2lcbiAgLCB3aW5kb3dzRHJpdmVMZXR0ZXIgPSAvXlthLXpBLVpdOi9cbiAgLCB3aGl0ZXNwYWNlID0gJ1tcXFxceDA5XFxcXHgwQVxcXFx4MEJcXFxceDBDXFxcXHgwRFxcXFx4MjBcXFxceEEwXFxcXHUxNjgwXFxcXHUxODBFXFxcXHUyMDAwXFxcXHUyMDAxXFxcXHUyMDAyXFxcXHUyMDAzXFxcXHUyMDA0XFxcXHUyMDA1XFxcXHUyMDA2XFxcXHUyMDA3XFxcXHUyMDA4XFxcXHUyMDA5XFxcXHUyMDBBXFxcXHUyMDJGXFxcXHUyMDVGXFxcXHUzMDAwXFxcXHUyMDI4XFxcXHUyMDI5XFxcXHVGRUZGXSdcbiAgLCBsZWZ0ID0gbmV3IFJlZ0V4cCgnXicrIHdoaXRlc3BhY2UgKycrJyk7XG5cbi8qKlxuICogVHJpbSBhIGdpdmVuIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byB0cmltLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0cmltTGVmdChzdHIpIHtcbiAgcmV0dXJuIChzdHIgPyBzdHIgOiAnJykudG9TdHJpbmcoKS5yZXBsYWNlKGxlZnQsICcnKTtcbn1cblxuLyoqXG4gKiBUaGVzZSBhcmUgdGhlIHBhcnNlIHJ1bGVzIGZvciB0aGUgVVJMIHBhcnNlciwgaXQgaW5mb3JtcyB0aGUgcGFyc2VyXG4gKiBhYm91dDpcbiAqXG4gKiAwLiBUaGUgY2hhciBpdCBOZWVkcyB0byBwYXJzZSwgaWYgaXQncyBhIHN0cmluZyBpdCBzaG91bGQgYmUgZG9uZSB1c2luZ1xuICogICAgaW5kZXhPZiwgUmVnRXhwIHVzaW5nIGV4ZWMgYW5kIE5hTiBtZWFucyBzZXQgYXMgY3VycmVudCB2YWx1ZS5cbiAqIDEuIFRoZSBwcm9wZXJ0eSB3ZSBzaG91bGQgc2V0IHdoZW4gcGFyc2luZyB0aGlzIHZhbHVlLlxuICogMi4gSW5kaWNhdGlvbiBpZiBpdCdzIGJhY2t3YXJkcyBvciBmb3J3YXJkIHBhcnNpbmcsIHdoZW4gc2V0IGFzIG51bWJlciBpdCdzXG4gKiAgICB0aGUgdmFsdWUgb2YgZXh0cmEgY2hhcnMgdGhhdCBzaG91bGQgYmUgc3BsaXQgb2ZmLlxuICogMy4gSW5oZXJpdCBmcm9tIGxvY2F0aW9uIGlmIG5vbiBleGlzdGluZyBpbiB0aGUgcGFyc2VyLlxuICogNC4gYHRvTG93ZXJDYXNlYCB0aGUgcmVzdWx0aW5nIHZhbHVlLlxuICovXG52YXIgcnVsZXMgPSBbXG4gIFsnIycsICdoYXNoJ10sICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJz8nLCAncXVlcnknXSwgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgZnVuY3Rpb24gc2FuaXRpemUoYWRkcmVzcywgdXJsKSB7ICAgICAvLyBTYW5pdGl6ZSB3aGF0IGlzIGxlZnQgb2YgdGhlIGFkZHJlc3NcbiAgICByZXR1cm4gaXNTcGVjaWFsKHVybC5wcm90b2NvbCkgPyBhZGRyZXNzLnJlcGxhY2UoL1xcXFwvZywgJy8nKSA6IGFkZHJlc3M7XG4gIH0sXG4gIFsnLycsICdwYXRobmFtZSddLCAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJ0AnLCAnYXV0aCcsIDFdLCAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgZnJvbnQuXG4gIFtOYU4sICdob3N0JywgdW5kZWZpbmVkLCAxLCAxXSwgICAgICAgLy8gU2V0IGxlZnQgb3ZlciB2YWx1ZS5cbiAgWy86KFxcZCspJC8sICdwb3J0JywgdW5kZWZpbmVkLCAxXSwgICAgLy8gUmVnRXhwIHRoZSBiYWNrLlxuICBbTmFOLCAnaG9zdG5hbWUnLCB1bmRlZmluZWQsIDEsIDFdICAgIC8vIFNldCBsZWZ0IG92ZXIuXG5dO1xuXG4vKipcbiAqIFRoZXNlIHByb3BlcnRpZXMgc2hvdWxkIG5vdCBiZSBjb3BpZWQgb3IgaW5oZXJpdGVkIGZyb20uIFRoaXMgaXMgb25seSBuZWVkZWRcbiAqIGZvciBhbGwgbm9uIGJsb2IgVVJMJ3MgYXMgYSBibG9iIFVSTCBkb2VzIG5vdCBpbmNsdWRlIGEgaGFzaCwgb25seSB0aGVcbiAqIG9yaWdpbi5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmFyIGlnbm9yZSA9IHsgaGFzaDogMSwgcXVlcnk6IDEgfTtcblxuLyoqXG4gKiBUaGUgbG9jYXRpb24gb2JqZWN0IGRpZmZlcnMgd2hlbiB5b3VyIGNvZGUgaXMgbG9hZGVkIHRocm91Z2ggYSBub3JtYWwgcGFnZSxcbiAqIFdvcmtlciBvciB0aHJvdWdoIGEgd29ya2VyIHVzaW5nIGEgYmxvYi4gQW5kIHdpdGggdGhlIGJsb2JibGUgYmVnaW5zIHRoZVxuICogdHJvdWJsZSBhcyB0aGUgbG9jYXRpb24gb2JqZWN0IHdpbGwgY29udGFpbiB0aGUgVVJMIG9mIHRoZSBibG9iLCBub3QgdGhlXG4gKiBsb2NhdGlvbiBvZiB0aGUgcGFnZSB3aGVyZSBvdXIgY29kZSBpcyBsb2FkZWQgaW4uIFRoZSBhY3R1YWwgb3JpZ2luIGlzXG4gKiBlbmNvZGVkIGluIHRoZSBgcGF0aG5hbWVgIHNvIHdlIGNhbiB0aGFua2Z1bGx5IGdlbmVyYXRlIGEgZ29vZCBcImRlZmF1bHRcIlxuICogbG9jYXRpb24gZnJvbSBpdCBzbyB3ZSBjYW4gZ2VuZXJhdGUgcHJvcGVyIHJlbGF0aXZlIFVSTCdzIGFnYWluLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbG9jIE9wdGlvbmFsIGRlZmF1bHQgbG9jYXRpb24gb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gbG9sY2F0aW9uIG9iamVjdC5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gbG9sY2F0aW9uKGxvYykge1xuICB2YXIgZ2xvYmFsVmFyO1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgZ2xvYmFsVmFyID0gd2luZG93O1xuICBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykgZ2xvYmFsVmFyID0gZ2xvYmFsO1xuICBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIGdsb2JhbFZhciA9IHNlbGY7XG4gIGVsc2UgZ2xvYmFsVmFyID0ge307XG5cbiAgdmFyIGxvY2F0aW9uID0gZ2xvYmFsVmFyLmxvY2F0aW9uIHx8IHt9O1xuICBsb2MgPSBsb2MgfHwgbG9jYXRpb247XG5cbiAgdmFyIGZpbmFsZGVzdGluYXRpb24gPSB7fVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NcbiAgICAsIGtleTtcblxuICBpZiAoJ2Jsb2I6JyA9PT0gbG9jLnByb3RvY29sKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVcmwodW5lc2NhcGUobG9jLnBhdGhuYW1lKSwge30pO1xuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVcmwobG9jLCB7fSk7XG4gICAgZm9yIChrZXkgaW4gaWdub3JlKSBkZWxldGUgZmluYWxkZXN0aW5hdGlvbltrZXldO1xuICB9IGVsc2UgaWYgKCdvYmplY3QnID09PSB0eXBlKSB7XG4gICAgZm9yIChrZXkgaW4gbG9jKSB7XG4gICAgICBpZiAoa2V5IGluIGlnbm9yZSkgY29udGludWU7XG4gICAgICBmaW5hbGRlc3RpbmF0aW9uW2tleV0gPSBsb2Nba2V5XTtcbiAgICB9XG5cbiAgICBpZiAoZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9IHNsYXNoZXMudGVzdChsb2MuaHJlZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbmFsZGVzdGluYXRpb247XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhIHByb3RvY29sIHNjaGVtZSBpcyBzcGVjaWFsLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBUaGUgcHJvdG9jb2wgc2NoZW1lIG9mIHRoZSBVUkxcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcHJvdG9jb2wgc2NoZW1lIGlzIHNwZWNpYWwsIGVsc2UgYGZhbHNlYFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNTcGVjaWFsKHNjaGVtZSkge1xuICByZXR1cm4gKFxuICAgIHNjaGVtZSA9PT0gJ2ZpbGU6JyB8fFxuICAgIHNjaGVtZSA9PT0gJ2Z0cDonIHx8XG4gICAgc2NoZW1lID09PSAnaHR0cDonIHx8XG4gICAgc2NoZW1lID09PSAnaHR0cHM6JyB8fFxuICAgIHNjaGVtZSA9PT0gJ3dzOicgfHxcbiAgICBzY2hlbWUgPT09ICd3c3M6J1xuICApO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIFByb3RvY29sRXh0cmFjdFxuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgbWF0Y2hlZCBpbiB0aGUgVVJMLCBpbiBsb3dlcmNhc2UuXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHNsYXNoZXMgYHRydWVgIGlmIHByb3RvY29sIGlzIGZvbGxvd2VkIGJ5IFwiLy9cIiwgZWxzZSBgZmFsc2VgLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IHJlc3QgUmVzdCBvZiB0aGUgVVJMIHRoYXQgaXMgbm90IHBhcnQgb2YgdGhlIHByb3RvY29sLlxuICovXG5cbi8qKlxuICogRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBmcm9tIGEgVVJMIHdpdGgvd2l0aG91dCBkb3VibGUgc2xhc2ggKFwiLy9cIikuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgVVJMIHdlIHdhbnQgdG8gZXh0cmFjdCBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IGxvY2F0aW9uXG4gKiBAcmV0dXJuIHtQcm90b2NvbEV4dHJhY3R9IEV4dHJhY3RlZCBpbmZvcm1hdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RQcm90b2NvbChhZGRyZXNzLCBsb2NhdGlvbikge1xuICBhZGRyZXNzID0gdHJpbUxlZnQoYWRkcmVzcyk7XG4gIGxvY2F0aW9uID0gbG9jYXRpb24gfHwge307XG5cbiAgdmFyIG1hdGNoID0gcHJvdG9jb2xyZS5leGVjKGFkZHJlc3MpO1xuICB2YXIgcHJvdG9jb2wgPSBtYXRjaFsxXSA/IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgOiAnJztcbiAgdmFyIGZvcndhcmRTbGFzaGVzID0gISFtYXRjaFsyXTtcbiAgdmFyIG90aGVyU2xhc2hlcyA9ICEhbWF0Y2hbM107XG4gIHZhciBzbGFzaGVzQ291bnQgPSAwO1xuICB2YXIgcmVzdDtcblxuICBpZiAoZm9yd2FyZFNsYXNoZXMpIHtcbiAgICBpZiAob3RoZXJTbGFzaGVzKSB7XG4gICAgICByZXN0ID0gbWF0Y2hbMl0gKyBtYXRjaFszXSArIG1hdGNoWzRdO1xuICAgICAgc2xhc2hlc0NvdW50ID0gbWF0Y2hbMl0ubGVuZ3RoICsgbWF0Y2hbM10ubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN0ID0gbWF0Y2hbMl0gKyBtYXRjaFs0XTtcbiAgICAgIHNsYXNoZXNDb3VudCA9IG1hdGNoWzJdLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKG90aGVyU2xhc2hlcykge1xuICAgICAgcmVzdCA9IG1hdGNoWzNdICsgbWF0Y2hbNF07XG4gICAgICBzbGFzaGVzQ291bnQgPSBtYXRjaFszXS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3QgPSBtYXRjaFs0XVxuICAgIH1cbiAgfVxuXG4gIGlmIChwcm90b2NvbCA9PT0gJ2ZpbGU6Jykge1xuICAgIGlmIChzbGFzaGVzQ291bnQgPj0gMikge1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoMik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzU3BlY2lhbChwcm90b2NvbCkpIHtcbiAgICByZXN0ID0gbWF0Y2hbNF07XG4gIH0gZWxzZSBpZiAocHJvdG9jb2wpIHtcbiAgICBpZiAoZm9yd2FyZFNsYXNoZXMpIHtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKDIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzbGFzaGVzQ291bnQgPj0gMiAmJiBpc1NwZWNpYWwobG9jYXRpb24ucHJvdG9jb2wpKSB7XG4gICAgcmVzdCA9IG1hdGNoWzRdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwcm90b2NvbDogcHJvdG9jb2wsXG4gICAgc2xhc2hlczogZm9yd2FyZFNsYXNoZXMgfHwgaXNTcGVjaWFsKHByb3RvY29sKSxcbiAgICBzbGFzaGVzQ291bnQ6IHNsYXNoZXNDb3VudCxcbiAgICByZXN0OiByZXN0XG4gIH07XG59XG5cbi8qKlxuICogUmVzb2x2ZSBhIHJlbGF0aXZlIFVSTCBwYXRobmFtZSBhZ2FpbnN0IGEgYmFzZSBVUkwgcGF0aG5hbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlbGF0aXZlIFBhdGhuYW1lIG9mIHRoZSByZWxhdGl2ZSBVUkwuXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZSBQYXRobmFtZSBvZiB0aGUgYmFzZSBVUkwuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFJlc29sdmVkIHBhdGhuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZShyZWxhdGl2ZSwgYmFzZSkge1xuICBpZiAocmVsYXRpdmUgPT09ICcnKSByZXR1cm4gYmFzZTtcblxuICB2YXIgcGF0aCA9IChiYXNlIHx8ICcvJykuc3BsaXQoJy8nKS5zbGljZSgwLCAtMSkuY29uY2F0KHJlbGF0aXZlLnNwbGl0KCcvJykpXG4gICAgLCBpID0gcGF0aC5sZW5ndGhcbiAgICAsIGxhc3QgPSBwYXRoW2kgLSAxXVxuICAgICwgdW5zaGlmdCA9IGZhbHNlXG4gICAgLCB1cCA9IDA7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChwYXRoW2ldID09PSAnLicpIHtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAocGF0aFtpXSA9PT0gJy4uJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIGlmIChpID09PSAwKSB1bnNoaWZ0ID0gdHJ1ZTtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICBpZiAodW5zaGlmdCkgcGF0aC51bnNoaWZ0KCcnKTtcbiAgaWYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSBwYXRoLnB1c2goJycpO1xuXG4gIHJldHVybiBwYXRoLmpvaW4oJy8nKTtcbn1cblxuLyoqXG4gKiBUaGUgYWN0dWFsIFVSTCBpbnN0YW5jZS4gSW5zdGVhZCBvZiByZXR1cm5pbmcgYW4gb2JqZWN0IHdlJ3ZlIG9wdGVkLWluIHRvXG4gKiBjcmVhdGUgYW4gYWN0dWFsIGNvbnN0cnVjdG9yIGFzIGl0J3MgbXVjaCBtb3JlIG1lbW9yeSBlZmZpY2llbnQgYW5kXG4gKiBmYXN0ZXIgYW5kIGl0IHBsZWFzZXMgbXkgT0NELlxuICpcbiAqIEl0IGlzIHdvcnRoIG5vdGluZyB0aGF0IHdlIHNob3VsZCBub3QgdXNlIGBVUkxgIGFzIGNsYXNzIG5hbWUgdG8gcHJldmVudFxuICogY2xhc2hlcyB3aXRoIHRoZSBnbG9iYWwgVVJMIGluc3RhbmNlIHRoYXQgZ290IGludHJvZHVjZWQgaW4gYnJvd3NlcnMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBwYXJzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gW2xvY2F0aW9uXSBMb2NhdGlvbiBkZWZhdWx0cyBmb3IgcmVsYXRpdmUgcGF0aHMuXG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IFtwYXJzZXJdIFBhcnNlciBmb3IgdGhlIHF1ZXJ5IHN0cmluZy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFVybChhZGRyZXNzLCBsb2NhdGlvbiwgcGFyc2VyKSB7XG4gIGFkZHJlc3MgPSB0cmltTGVmdChhZGRyZXNzKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVXJsKSkge1xuICAgIHJldHVybiBuZXcgVXJsKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpO1xuICB9XG5cbiAgdmFyIHJlbGF0aXZlLCBleHRyYWN0ZWQsIHBhcnNlLCBpbnN0cnVjdGlvbiwgaW5kZXgsIGtleVxuICAgICwgaW5zdHJ1Y3Rpb25zID0gcnVsZXMuc2xpY2UoKVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NhdGlvblxuICAgICwgdXJsID0gdGhpc1xuICAgICwgaSA9IDA7XG5cbiAgLy9cbiAgLy8gVGhlIGZvbGxvd2luZyBpZiBzdGF0ZW1lbnRzIGFsbG93cyB0aGlzIG1vZHVsZSB0d28gaGF2ZSBjb21wYXRpYmlsaXR5IHdpdGhcbiAgLy8gMiBkaWZmZXJlbnQgQVBJOlxuICAvL1xuICAvLyAxLiBOb2RlLmpzJ3MgYHVybC5wYXJzZWAgYXBpIHdoaWNoIGFjY2VwdHMgYSBVUkwsIGJvb2xlYW4gYXMgYXJndW1lbnRzXG4gIC8vICAgIHdoZXJlIHRoZSBib29sZWFuIGluZGljYXRlcyB0aGF0IHRoZSBxdWVyeSBzdHJpbmcgc2hvdWxkIGFsc28gYmUgcGFyc2VkLlxuICAvL1xuICAvLyAyLiBUaGUgYFVSTGAgaW50ZXJmYWNlIG9mIHRoZSBicm93c2VyIHdoaWNoIGFjY2VwdHMgYSBVUkwsIG9iamVjdCBhc1xuICAvLyAgICBhcmd1bWVudHMuIFRoZSBzdXBwbGllZCBvYmplY3Qgd2lsbCBiZSB1c2VkIGFzIGRlZmF1bHQgdmFsdWVzIC8gZmFsbC1iYWNrXG4gIC8vICAgIGZvciByZWxhdGl2ZSBwYXRocy5cbiAgLy9cbiAgaWYgKCdvYmplY3QnICE9PSB0eXBlICYmICdzdHJpbmcnICE9PSB0eXBlKSB7XG4gICAgcGFyc2VyID0gbG9jYXRpb247XG4gICAgbG9jYXRpb24gPSBudWxsO1xuICB9XG5cbiAgaWYgKHBhcnNlciAmJiAnZnVuY3Rpb24nICE9PSB0eXBlb2YgcGFyc2VyKSBwYXJzZXIgPSBxcy5wYXJzZTtcblxuICBsb2NhdGlvbiA9IGxvbGNhdGlvbihsb2NhdGlvbik7XG5cbiAgLy9cbiAgLy8gRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBiZWZvcmUgcnVubmluZyB0aGUgaW5zdHJ1Y3Rpb25zLlxuICAvL1xuICBleHRyYWN0ZWQgPSBleHRyYWN0UHJvdG9jb2woYWRkcmVzcyB8fCAnJywgbG9jYXRpb24pO1xuICByZWxhdGl2ZSA9ICFleHRyYWN0ZWQucHJvdG9jb2wgJiYgIWV4dHJhY3RlZC5zbGFzaGVzO1xuICB1cmwuc2xhc2hlcyA9IGV4dHJhY3RlZC5zbGFzaGVzIHx8IHJlbGF0aXZlICYmIGxvY2F0aW9uLnNsYXNoZXM7XG4gIHVybC5wcm90b2NvbCA9IGV4dHJhY3RlZC5wcm90b2NvbCB8fCBsb2NhdGlvbi5wcm90b2NvbCB8fCAnJztcbiAgYWRkcmVzcyA9IGV4dHJhY3RlZC5yZXN0O1xuXG4gIC8vXG4gIC8vIFdoZW4gdGhlIGF1dGhvcml0eSBjb21wb25lbnQgaXMgYWJzZW50IHRoZSBVUkwgc3RhcnRzIHdpdGggYSBwYXRoXG4gIC8vIGNvbXBvbmVudC5cbiAgLy9cbiAgaWYgKFxuICAgIGV4dHJhY3RlZC5wcm90b2NvbCA9PT0gJ2ZpbGU6JyAmJiAoXG4gICAgICBleHRyYWN0ZWQuc2xhc2hlc0NvdW50ICE9PSAyIHx8IHdpbmRvd3NEcml2ZUxldHRlci50ZXN0KGFkZHJlc3MpKSB8fFxuICAgICghZXh0cmFjdGVkLnNsYXNoZXMgJiZcbiAgICAgIChleHRyYWN0ZWQucHJvdG9jb2wgfHxcbiAgICAgICAgZXh0cmFjdGVkLnNsYXNoZXNDb3VudCA8IDIgfHxcbiAgICAgICAgIWlzU3BlY2lhbCh1cmwucHJvdG9jb2wpKSlcbiAgKSB7XG4gICAgaW5zdHJ1Y3Rpb25zWzNdID0gWy8oLiopLywgJ3BhdGhuYW1lJ107XG4gIH1cblxuICBmb3IgKDsgaSA8IGluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb25zW2ldO1xuXG4gICAgaWYgKHR5cGVvZiBpbnN0cnVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYWRkcmVzcyA9IGluc3RydWN0aW9uKGFkZHJlc3MsIHVybCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwYXJzZSA9IGluc3RydWN0aW9uWzBdO1xuICAgIGtleSA9IGluc3RydWN0aW9uWzFdO1xuXG4gICAgaWYgKHBhcnNlICE9PSBwYXJzZSkge1xuICAgICAgdXJsW2tleV0gPSBhZGRyZXNzO1xuICAgIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBwYXJzZSkge1xuICAgICAgaWYgKH4oaW5kZXggPSBhZGRyZXNzLmluZGV4T2YocGFyc2UpKSkge1xuICAgICAgICBpZiAoJ251bWJlcicgPT09IHR5cGVvZiBpbnN0cnVjdGlvblsyXSkge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoaW5kZXggKyBpbnN0cnVjdGlvblsyXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKChpbmRleCA9IHBhcnNlLmV4ZWMoYWRkcmVzcykpKSB7XG4gICAgICB1cmxba2V5XSA9IGluZGV4WzFdO1xuICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXguaW5kZXgpO1xuICAgIH1cblxuICAgIHVybFtrZXldID0gdXJsW2tleV0gfHwgKFxuICAgICAgcmVsYXRpdmUgJiYgaW5zdHJ1Y3Rpb25bM10gPyBsb2NhdGlvbltrZXldIHx8ICcnIDogJydcbiAgICApO1xuXG4gICAgLy9cbiAgICAvLyBIb3N0bmFtZSwgaG9zdCBhbmQgcHJvdG9jb2wgc2hvdWxkIGJlIGxvd2VyY2FzZWQgc28gdGhleSBjYW4gYmUgdXNlZCB0b1xuICAgIC8vIGNyZWF0ZSBhIHByb3BlciBgb3JpZ2luYC5cbiAgICAvL1xuICAgIGlmIChpbnN0cnVjdGlvbls0XSkgdXJsW2tleV0gPSB1cmxba2V5XS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgLy9cbiAgLy8gQWxzbyBwYXJzZSB0aGUgc3VwcGxpZWQgcXVlcnkgc3RyaW5nIGluIHRvIGFuIG9iamVjdC4gSWYgd2UncmUgc3VwcGxpZWRcbiAgLy8gd2l0aCBhIGN1c3RvbSBwYXJzZXIgYXMgZnVuY3Rpb24gdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBidWlsZC1pblxuICAvLyBwYXJzZXIuXG4gIC8vXG4gIGlmIChwYXJzZXIpIHVybC5xdWVyeSA9IHBhcnNlcih1cmwucXVlcnkpO1xuXG4gIC8vXG4gIC8vIElmIHRoZSBVUkwgaXMgcmVsYXRpdmUsIHJlc29sdmUgdGhlIHBhdGhuYW1lIGFnYWluc3QgdGhlIGJhc2UgVVJMLlxuICAvL1xuICBpZiAoXG4gICAgICByZWxhdGl2ZVxuICAgICYmIGxvY2F0aW9uLnNsYXNoZXNcbiAgICAmJiB1cmwucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLydcbiAgICAmJiAodXJsLnBhdGhuYW1lICE9PSAnJyB8fCBsb2NhdGlvbi5wYXRobmFtZSAhPT0gJycpXG4gICkge1xuICAgIHVybC5wYXRobmFtZSA9IHJlc29sdmUodXJsLnBhdGhuYW1lLCBsb2NhdGlvbi5wYXRobmFtZSk7XG4gIH1cblxuICAvL1xuICAvLyBEZWZhdWx0IHRvIGEgLyBmb3IgcGF0aG5hbWUgaWYgbm9uZSBleGlzdHMuIFRoaXMgbm9ybWFsaXplcyB0aGUgVVJMXG4gIC8vIHRvIGFsd2F5cyBoYXZlIGEgL1xuICAvL1xuICBpZiAodXJsLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nICYmIGlzU3BlY2lhbCh1cmwucHJvdG9jb2wpKSB7XG4gICAgdXJsLnBhdGhuYW1lID0gJy8nICsgdXJsLnBhdGhuYW1lO1xuICB9XG5cbiAgLy9cbiAgLy8gV2Ugc2hvdWxkIG5vdCBhZGQgcG9ydCBudW1iZXJzIGlmIHRoZXkgYXJlIGFscmVhZHkgdGhlIGRlZmF1bHQgcG9ydCBudW1iZXJcbiAgLy8gZm9yIGEgZ2l2ZW4gcHJvdG9jb2wuIEFzIHRoZSBob3N0IGFsc28gY29udGFpbnMgdGhlIHBvcnQgbnVtYmVyIHdlJ3JlIGdvaW5nXG4gIC8vIG92ZXJyaWRlIGl0IHdpdGggdGhlIGhvc3RuYW1lIHdoaWNoIGNvbnRhaW5zIG5vIHBvcnQgbnVtYmVyLlxuICAvL1xuICBpZiAoIXJlcXVpcmVkKHVybC5wb3J0LCB1cmwucHJvdG9jb2wpKSB7XG4gICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgdXJsLnBvcnQgPSAnJztcbiAgfVxuXG4gIC8vXG4gIC8vIFBhcnNlIGRvd24gdGhlIGBhdXRoYCBmb3IgdGhlIHVzZXJuYW1lIGFuZCBwYXNzd29yZC5cbiAgLy9cbiAgdXJsLnVzZXJuYW1lID0gdXJsLnBhc3N3b3JkID0gJyc7XG4gIGlmICh1cmwuYXV0aCkge1xuICAgIGluc3RydWN0aW9uID0gdXJsLmF1dGguc3BsaXQoJzonKTtcbiAgICB1cmwudXNlcm5hbWUgPSBpbnN0cnVjdGlvblswXSB8fCAnJztcbiAgICB1cmwucGFzc3dvcmQgPSBpbnN0cnVjdGlvblsxXSB8fCAnJztcbiAgfVxuXG4gIHVybC5vcmlnaW4gPSB1cmwucHJvdG9jb2wgIT09ICdmaWxlOicgJiYgaXNTcGVjaWFsKHVybC5wcm90b2NvbCkgJiYgdXJsLmhvc3RcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICAvL1xuICAvLyBUaGUgaHJlZiBpcyBqdXN0IHRoZSBjb21waWxlZCByZXN1bHQuXG4gIC8vXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogVGhpcyBpcyBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNoYW5naW5nIHByb3BlcnRpZXMgaW4gdGhlIFVSTCBpbnN0YW5jZSB0b1xuICogaW5zdXJlIHRoYXQgdGhleSBhbGwgcHJvcGFnYXRlIGNvcnJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFydCAgICAgICAgICBQcm9wZXJ0eSB3ZSBuZWVkIHRvIGFkanVzdC5cbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlICAgICAgICAgIFRoZSBuZXdseSBhc3NpZ25lZCB2YWx1ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gZm4gIFdoZW4gc2V0dGluZyB0aGUgcXVlcnksIGl0IHdpbGwgYmUgdGhlIGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIHRvIHBhcnNlIHRoZSBxdWVyeS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4gc2V0dGluZyB0aGUgcHJvdG9jb2wsIGRvdWJsZSBzbGFzaCB3aWxsIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkIGZyb20gdGhlIGZpbmFsIHVybCBpZiBpdCBpcyB0cnVlLlxuICogQHJldHVybnMge1VSTH0gVVJMIGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc2V0KHBhcnQsIHZhbHVlLCBmbikge1xuICB2YXIgdXJsID0gdGhpcztcblxuICBzd2l0Y2ggKHBhcnQpIHtcbiAgICBjYXNlICdxdWVyeSc6XG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSAoZm4gfHwgcXMucGFyc2UpKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BvcnQnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICghcmVxdWlyZWQodmFsdWUsIHVybC5wcm90b2NvbCkpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgICAgIHVybFtwYXJ0XSA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZSArJzonKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0bmFtZSc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHVybC5wb3J0KSB2YWx1ZSArPSAnOicrIHVybC5wb3J0O1xuICAgICAgdXJsLmhvc3QgPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKC86XFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJzonKTtcbiAgICAgICAgdXJsLnBvcnQgPSB2YWx1ZS5wb3AoKTtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWUuam9pbignOicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWU7XG4gICAgICAgIHVybC5wb3J0ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncHJvdG9jb2wnOlxuICAgICAgdXJsLnByb3RvY29sID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHVybC5zbGFzaGVzID0gIWZuO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwYXRobmFtZSc6XG4gICAgY2FzZSAnaGFzaCc6XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNoYXIgPSBwYXJ0ID09PSAncGF0aG5hbWUnID8gJy8nIDogJyMnO1xuICAgICAgICB1cmxbcGFydF0gPSB2YWx1ZS5jaGFyQXQoMCkgIT09IGNoYXIgPyBjaGFyICsgdmFsdWUgOiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGlucyA9IHJ1bGVzW2ldO1xuXG4gICAgaWYgKGluc1s0XSkgdXJsW2luc1sxXV0gPSB1cmxbaW5zWzFdXS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6JyAmJiBpc1NwZWNpYWwodXJsLnByb3RvY29sKSAmJiB1cmwuaG9zdFxuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxuICAgIDogJ251bGwnO1xuXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG5cbiAgcmV0dXJuIHVybDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgYmFjayBpbiB0byBhIHZhbGlkIGFuZCBmdWxsIFVSTCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5naWZ5IE9wdGlvbmFsIHF1ZXJ5IHN0cmluZ2lmeSBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IENvbXBpbGVkIHZlcnNpb24gb2YgdGhlIFVSTC5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcoc3RyaW5naWZ5KSB7XG4gIGlmICghc3RyaW5naWZ5IHx8ICdmdW5jdGlvbicgIT09IHR5cGVvZiBzdHJpbmdpZnkpIHN0cmluZ2lmeSA9IHFzLnN0cmluZ2lmeTtcblxuICB2YXIgcXVlcnlcbiAgICAsIHVybCA9IHRoaXNcbiAgICAsIHByb3RvY29sID0gdXJsLnByb3RvY29sO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5jaGFyQXQocHJvdG9jb2wubGVuZ3RoIC0gMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIHZhciByZXN1bHQgPSBwcm90b2NvbCArICh1cmwuc2xhc2hlcyB8fCBpc1NwZWNpYWwodXJsLnByb3RvY29sKSA/ICcvLycgOiAnJyk7XG5cbiAgaWYgKHVybC51c2VybmFtZSkge1xuICAgIHJlc3VsdCArPSB1cmwudXNlcm5hbWU7XG4gICAgaWYgKHVybC5wYXNzd29yZCkgcmVzdWx0ICs9ICc6JysgdXJsLnBhc3N3b3JkO1xuICAgIHJlc3VsdCArPSAnQCc7XG4gIH1cblxuICByZXN1bHQgKz0gdXJsLmhvc3QgKyB1cmwucGF0aG5hbWU7XG5cbiAgcXVlcnkgPSAnb2JqZWN0JyA9PT0gdHlwZW9mIHVybC5xdWVyeSA/IHN0cmluZ2lmeSh1cmwucXVlcnkpIDogdXJsLnF1ZXJ5O1xuICBpZiAocXVlcnkpIHJlc3VsdCArPSAnPycgIT09IHF1ZXJ5LmNoYXJBdCgwKSA/ICc/JysgcXVlcnkgOiBxdWVyeTtcblxuICBpZiAodXJsLmhhc2gpIHJlc3VsdCArPSB1cmwuaGFzaDtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5VcmwucHJvdG90eXBlID0geyBzZXQ6IHNldCwgdG9TdHJpbmc6IHRvU3RyaW5nIH07XG5cbi8vXG4vLyBFeHBvc2UgdGhlIFVSTCBwYXJzZXIgYW5kIHNvbWUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgYmUgdXNlZnVsIGZvclxuLy8gb3RoZXJzIG9yIHRlc3RpbmcuXG4vL1xuVXJsLmV4dHJhY3RQcm90b2NvbCA9IGV4dHJhY3RQcm90b2NvbDtcblVybC5sb2NhdGlvbiA9IGxvbGNhdGlvbjtcblVybC50cmltTGVmdCA9IHRyaW1MZWZ0O1xuVXJsLnFzID0gcXM7XG5cbm1vZHVsZS5leHBvcnRzID0gVXJsO1xuIiwiLy8gVGhlIHJlZ2VuZXJhdG9yIHJ1bnRpbWUgaXMgbmVlZGVkIHNpbmNlIHRoZSB0ZXN0IHVzZSBmdW5jdGlvbnNcbi8vIHdpdGggdGhlIGFzeW5jL2F3YWl0IGtleXdvcmRzLiBTZWVcbi8vIGh0dHBzOi8vYmFiZWxqcy5pby9kb2NzL2VuL2JhYmVsLXBsdWdpbi10cmFuc2Zvcm0tcmVnZW5lcmF0b3JcbmltcG9ydCAncmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lJ1xuLy8gUG9seWZpbGwgYFByb21pc2VgIGZvciBJbnRlcm5ldCBFeHBsb3Jlci5cbmltcG9ydCAnZXM2LXByb21pc2UvYXV0bydcblxuLy8gVGhpcyBpcyBhIGZ1biBwaWVjZSBvZiBjb2RlLiBMZXQgbWUgdGVsbCB5b3UgdGhlIHN0b3J5IGJlaGluZCBpdDpcbi8vIEludGVybmV0IEV4cGxvcmVyIDEwIGFuZCAxMSBoYXZlIGEgYnVnIHdoZXJlIHRoZSBldmVudCBoYW5kbGVyc1xuLy8gZm9yIFhNTEh0dHBSZXF1ZXN0cyB3aWxsIGJlIGludm9rZWQgd2l0aCBhIHNpZ25pZmljYW50IGRlbGF5IGFmdGVyXG4vLyB0aGUgYWN0dWFsIHJlcXVlc3QgaGFzIGJlZW4gZmluaXNoZWQuIFNvLCBldmVuIGlmIHRoZSBIVFRQIHJlcXVlc3Rcbi8vIG9ubHkgdG9vayAxcyB0byBjb21wbGV0ZSwgSUUgd2lsbCB3YWl0IGFub3RoZXIgMjBzIGJlZm9yZSBpdCBkZWNpZGVzXG4vLyB0byB0ZWxsIHlvdXIgYXBwbGljYXRpb24gdGhhdCB0aGUgcmVxdWVzdCBoYXMgYmVlbiBmaW5pc2hlZC4gVGhpc1xuLy8gd2FzIG5vdCBhIGJpZyBwcm9ibGVtIGluIGRhaWx5IHVzZSBzaW5jZSB0aGlzIGlzc3VlIGRpZCBvbmx5IG9jY3VyXG4vLyB3aGVuIHRoZSB1c2VyIGRpZCBub3QgaW50ZXJhY3Qgd2l0aCB0aGUgd2VicGFnZSwgZS5nLiBtb3ZlIHRoZSBtb3VzZS5cbi8vIEhvd2V2ZXIsIHdoZW4gdGVzdGluZyBpbiBhdXRvbWF0ZWQgYnJvd3NzZXJzLCBubyB1c2VyIGludGVyYWN0aW9uIHdhc1xuLy8gb2NjdXJyaW5nLlxuLy8gRXZlbnR1YWxseSwgc29tZW9uZSBmaWd1cmVkIG91dCB0aGF0IHRoaXMgd2FzIHJlbGF0ZWQgdG8gYSBQcm9taXNlXG4vLyBwb2x5ZmlsbCB0aGF0IGlzIHVzZWQgYnkgdGhlIGF4aW9zIEhUVFAgY2xpZW50LiBUaGlzIHNvbHV0aW9uIGlzXG4vLyB0byB1c2UgYSB0aW1lb3V0LCBhcyBmb2xsb3dzLCB3aGljaCBpcyBlbm91Z2ggdG8gY2F1c2UgdGhlIG5ldHdvcmtcbi8vIGRlbGF5cyB0byB2YW5pc2guXG4vLyBXaG9ldmVyIGZvdW5kIHRoYXQgcGF0Y2gsIEkgaG9wZSB0aGV5IHdpbGwgZ28gdG8gaGVhdmVuLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9heGlvcy9heGlvcy9pc3N1ZXMvMTg2MlxuZnVuY3Rpb24gdCAoKSB7XG4gIHdpbmRvdy5zZXRUaW1lb3V0KHQsIDEwKVxufVxudCgpXG5cbmJlZm9yZUVhY2goKCkgPT4ge1xuICAvLyBDbGVhciBsb2NhbFN0b3JhZ2UgYmVmb3JlIGV2ZXJ5IHRlc3QgdG8gcHJldmVudCBzdG9yZWQgVVJMcyB0b1xuICAvLyBpbnRlcmZlcmUgd2l0aCBvdXIgc2V0dXAuXG4gIGxvY2FsU3RvcmFnZS5jbGVhcigpXG59KVxuXG5yZXF1aXJlKCcuL2hlbHBlcnMvcHVwcGV0ZWVyL3JlcG9ydGVyLmpzJylcbnJlcXVpcmUoJy4vdGVzdC1jb21tb24uanMnKVxucmVxdWlyZSgnLi90ZXN0LWJyb3dzZXItc3BlY2lmaWMuanMnKVxucmVxdWlyZSgnLi90ZXN0LXBhcmFsbGVsLXVwbG9hZHMuanMnKVxucmVxdWlyZSgnLi90ZXN0LXRlcm1pbmF0ZS5qcycpXG5yZXF1aXJlKCcuL3Rlc3QtZW5kLXRvLWVuZC5qcycpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFzeW5jIGZ1bmN0aW9uIGFzc2VydFVybFN0b3JhZ2UgKHVybFN0b3JhZ2UpIHtcbiAgLy8gSW4gdGhlIGJlZ2lubmluZyBvZiB0aGUgdGVzdCwgdGhlIHN0b3JhZ2Ugc2hvdWxkIGJlIGVtcHR5LlxuICBsZXQgcmVzdWx0ID0gYXdhaXQgdXJsU3RvcmFnZS5maW5kQWxsVXBsb2FkcygpXG4gIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW10pXG5cbiAgLy8gQWRkIGEgZmV3IHVwbG9hZHMgaW50byB0aGUgc3RvcmFnZVxuICBjb25zdCBrZXkxID0gYXdhaXQgdXJsU3RvcmFnZS5hZGRVcGxvYWQoJ2ZpbmdlcnByaW50QScsIHsgaWQ6IDEgfSlcbiAgY29uc3Qga2V5MiA9IGF3YWl0IHVybFN0b3JhZ2UuYWRkVXBsb2FkKCdmaW5nZXJwcmludEEnLCB7IGlkOiAyIH0pXG4gIGNvbnN0IGtleTMgPSBhd2FpdCB1cmxTdG9yYWdlLmFkZFVwbG9hZCgnZmluZ2VycHJpbnRCJywgeyBpZDogMyB9KVxuXG4gIGV4cGVjdCgvXnR1czo6ZmluZ2VycHJpbnRBOjovLnRlc3Qoa2V5MSkpLnRvQmUodHJ1ZSlcbiAgZXhwZWN0KC9edHVzOjpmaW5nZXJwcmludEE6Oi8udGVzdChrZXkyKSkudG9CZSh0cnVlKVxuICBleHBlY3QoL150dXM6OmZpbmdlcnByaW50Qjo6Ly50ZXN0KGtleTMpKS50b0JlKHRydWUpXG5cbiAgLy8gUXVlcnkgdGhlIGp1c3Qgc3RvcmVkIHVwbG9hZHMgaW5kaXZpZHVhbGx5XG4gIHJlc3VsdCA9IGF3YWl0IHVybFN0b3JhZ2UuZmluZFVwbG9hZHNCeUZpbmdlcnByaW50KCdmaW5nZXJwcmludEEnKVxuICBzb3J0KHJlc3VsdClcbiAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChbXG4gICAgeyBpZDogMSwgdXJsU3RvcmFnZUtleToga2V5MSB9LFxuICAgIHsgaWQ6IDIsIHVybFN0b3JhZ2VLZXk6IGtleTIgfSxcbiAgXSlcblxuICByZXN1bHQgPSBhd2FpdCB1cmxTdG9yYWdlLmZpbmRVcGxvYWRzQnlGaW5nZXJwcmludCgnZmluZ2VycHJpbnRCJylcbiAgc29ydChyZXN1bHQpXG4gIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW1xuICAgIHsgaWQ6IDMsIHVybFN0b3JhZ2VLZXk6IGtleTMgfSxcbiAgXSlcblxuICAvLyBDaGVjayB0aGF0IHdlIGNhbiByZXRyaWV2ZSBhbGwgc3RvcmVkIHVwbG9hZHNcbiAgcmVzdWx0ID0gYXdhaXQgdXJsU3RvcmFnZS5maW5kQWxsVXBsb2FkcygpXG4gIHNvcnQocmVzdWx0KVxuICBleHBlY3QocmVzdWx0KS50b0VxdWFsKFtcbiAgICB7IGlkOiAxLCB1cmxTdG9yYWdlS2V5OiBrZXkxIH0sXG4gICAgeyBpZDogMiwgdXJsU3RvcmFnZUtleToga2V5MiB9LFxuICAgIHsgaWQ6IDMsIHVybFN0b3JhZ2VLZXk6IGtleTMgfSxcbiAgXSlcblxuICAvLyBDaGVjayB0aGF0IGl0IGNhbiByZW1vdmUgYW4gdXBsb2FkIGFuZCB3aWxsIG5vdCByZXR1cm4gaXQgYmFja1xuICBhd2FpdCB1cmxTdG9yYWdlLnJlbW92ZVVwbG9hZChrZXkyKVxuICBhd2FpdCB1cmxTdG9yYWdlLnJlbW92ZVVwbG9hZChrZXkzKVxuXG4gIHJlc3VsdCA9IGF3YWl0IHVybFN0b3JhZ2UuZmluZFVwbG9hZHNCeUZpbmdlcnByaW50KCdmaW5nZXJwcmludEEnKVxuICBleHBlY3QocmVzdWx0KS50b0VxdWFsKFtcbiAgICB7IGlkOiAxLCB1cmxTdG9yYWdlS2V5OiBrZXkxIH0sXG4gIF0pXG5cbiAgcmVzdWx0ID0gYXdhaXQgdXJsU3RvcmFnZS5maW5kVXBsb2Fkc0J5RmluZ2VycHJpbnQoJ2ZpbmdlcnByaW50QicpXG4gIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW10pXG59XG5cbi8vIFNvcnQgdGhlIHJlc3VsdHMgZnJvbSB0aGUgVVJMIHN0b3JhZ2Ugc2luY2UgdGhlIG9yZGVyIGluIG5vdCBkZXRlcm1pbmlzdGljLlxuZnVuY3Rpb24gc29ydCAocmVzdWx0KSB7XG4gIHJlc3VsdC5zb3J0KChhLCBiKSA9PiBhLmlkIC0gYi5pZClcbn1cbiIsIi8qIGVzbGludCBuby1jb25zb2xlOiAwICovXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IDAgKi9cblxudmFyIHRlc3RzQ29tcGxldGVkID0gZmFsc2VcbnZhciB0ZXN0c1Bhc3NlZCA9IHRydWVcblxuLy8gVGhpcyByZXBvcnRlciBpcyB1c2VkIGJ5IGJpbi9wdXBwZXRlZXItamFzbWluZS5qcyB0byBvYnRhaW4gdGhlIHRlc3QgcmVzdWx0cy5cbi8vIFNlZSBodHRwczovL2phc21pbmUuZ2l0aHViLmlvL2FwaS9lZGdlL1JlcG9ydGVyLmh0bWwgZm9yIG1vcmUgZGV0YWlscyBvbiB0aGVcbi8vIGZ1bmN0aW9uIHNpZ25hdHVyZXMuXG52YXIgcmVwb3J0ZXIgPSB7XG4gIGphc21pbmVTdGFydGVkIChzdWl0ZUluZm8pIHsgfSxcbiAgc3VpdGVTdGFydGVkIChyZXN1bHQpIHsgfSxcbiAgc3BlY1N0YXJ0ZWQgKHJlc3VsdCkgeyB9LFxuICBzcGVjRG9uZSAocmVzdWx0KSB7XG4gICAgLy8gUHJpbnQgdGhlIHRlc3QgcmVzdWx0IHRvIHRoZSBjb25zb2xlLlxuICAgIHZhciBwYXNzZWQgPSByZXN1bHQuc3RhdHVzID09PSAncGFzc2VkJ1xuICAgIHZhciBwcmVmaXggPSBwYXNzZWQgPyAn4pyTJyA6ICfinJgnXG4gICAgY29uc29sZS5sb2cocHJlZml4LCByZXN1bHQuZnVsbE5hbWUpXG5cbiAgICB0ZXN0c0NvbXBsZXRlZCA9IHRydWVcbiAgICB0ZXN0c1Bhc3NlZCA9IHRlc3RzUGFzc2VkICYmIHBhc3NlZFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zb2xlLmxvZyhgRmFpbHVyZTogJHtyZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zW2ldLm1lc3NhZ2V9YClcbiAgICAgIGNvbnNvbGUubG9nKHJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnNbaV0uc3RhY2spXG4gICAgICBjb25zb2xlLmxvZygnJylcbiAgICB9XG4gIH0sXG4gIHN1aXRlRG9uZSAocmVzdWx0KSB7IH0sXG4gIGphc21pbmVEb25lIChyZXN1bHQpIHtcbiAgICB2YXIgc3VjY2VzcyA9IHRlc3RzQ29tcGxldGVkICYmIHRlc3RzUGFzc2VkXG5cbiAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgY29uc29sZS5sb2coJ1Rlc3RzIHBhc3NlZCEnKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnVGVzdHMgZmFpbGVkIScpXG4gICAgfVxuXG4gICAgLy8gVGhlIF9famFzbWluZUNhbGxiYWNrIGZ1bmN0aW9uIGlzIGV4cG9zZWQgYnkgdGhlIGJpbi9wdXBwZXRlZXItamFzbWluZS5qc1xuICAgIC8vIHNjcmlwdC4gU2VlIGl0IGZvciBtb3JlIGRldGFpbHMuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuX19qYXNtaW5lQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdpbmRvdy5fX2phc21pbmVDYWxsYmFjayhzdWNjZXNzKVxuICAgIH1cbiAgfSxcbn1cblxud2luZG93Lmphc21pbmUuZ2V0RW52KCkuYWRkUmVwb3J0ZXIocmVwb3J0ZXIpXG4iLCJjb25zdCBpc0Jyb3dzZXIgID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbmNvbnN0IGlzTm9kZSAgICAgPSAhaXNCcm93c2VyXG5cbi8qKlxuICogT2J0YWluIGEgcGxhdGZvcm0gc3BlY2lmaWMgYnVmZmVyIG9iamVjdCwgd2hpY2ggY2FuIGJlXG4gKiBoYW5kbGVkIGJ5IHR1cy1qcy1jbGllbnQuXG4gKi9cbmZ1bmN0aW9uIGdldEJsb2IgKHN0cikge1xuICBpZiAoaXNOb2RlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0cilcbiAgfVxuICByZXR1cm4gbmV3IEJsb2Ioc3RyLnNwbGl0KCcnKSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBwcm9taXNlIGFuZCBvYnRhaW4gdGhlIHJlc29sdmUvcmVqZWN0IGZ1bmN0aW9uc1xuICogb3V0c2lkZSBvZiB0aGUgUHJvbWlzZSBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gZmxhdFByb21pc2UgKCkge1xuICBsZXQgcmVzb2x2ZUZuXG4gIGxldCByZWplY3RGblxuICBjb25zdCBwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlc29sdmVGbiA9IHJlc29sdmVcbiAgICByZWplY3RGbiA9IHJlamVjdFxuICB9KVxuXG4gIHJldHVybiBbcCwgcmVzb2x2ZUZuLCByZWplY3RGbl1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBzcHktYWJsZSBmdW5jdGlvbiB3aGljaCByZXNvbHZlcyBhIFByb21pc2VcbiAqIG9uY2UgaXQgaXMgY2FsbGVkLlxuICovXG5mdW5jdGlvbiB3YWl0YWJsZUZ1bmN0aW9uIChuYW1lID0gJ2Z1bmMnKSB7XG4gIGNvbnN0IFtwcm9taXNlLCByZXNvbHZlXSA9IGZsYXRQcm9taXNlKClcbiAgY29uc3QgZm4gPSBqYXNtaW5lLmNyZWF0ZVNweShuYW1lLCByZXNvbHZlKS5hbmQuY2FsbFRocm91Z2goKVxuXG4gIGZuLnRvQmVDYWxsZWQgPSBwcm9taXNlXG4gIHJldHVybiBmblxufVxuXG4vKipcbiAqIENyZWF0ZSBhIFByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uLlxuICovXG5mdW5jdGlvbiB3YWl0IChkZWxheSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXksICd0aW1lZCBvdXQnKSlcbn1cblxuLyoqXG4gKiBUZXN0SHR0cFN0YWNrIGltcGxlbWVudHMgdGhlIEhUVFAgc3RhY2sgaW50ZXJmYWNlIGZvciB0dXMtanMtY2xpZW50XG4gKiBhbmQgY2FuIGJlIHVzZWQgdG8gYXNzZXJ0IG91dGdvaW5nIHJlcXVlc3RzIGFuZCByZXNwb25kIHdpdGggbW9jayBkYXRhLlxuICovXG5jbGFzcyBUZXN0SHR0cFN0YWNrIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuX3BlbmRpbmdSZXF1ZXN0cyA9IFtdXG4gICAgdGhpcy5fcGVuZGluZ1dhaXRzID0gW11cbiAgfVxuXG4gIGNyZWF0ZVJlcXVlc3QgKG1ldGhvZCwgdXJsKSB7XG4gICAgcmV0dXJuIG5ldyBUZXN0UmVxdWVzdChtZXRob2QsIHVybCwgKHJlcSkgPT4ge1xuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdXYWl0cy5sZW5ndGggPj0gMSkge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5fcGVuZGluZ1dhaXRzLnNoaWZ0KClcbiAgICAgICAgaGFuZGxlcihyZXEpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB0aGlzLl9wZW5kaW5nUmVxdWVzdHMucHVzaChyZXEpXG4gICAgfSlcbiAgfVxuXG4gIG5leHRSZXF1ZXN0ICgpIHtcbiAgICBpZiAodGhpcy5fcGVuZGluZ1JlcXVlc3RzLmxlbmd0aCA+PSAxKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX3BlbmRpbmdSZXF1ZXN0cy5zaGlmdCgpKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5fcGVuZGluZ1dhaXRzLnB1c2gocmVzb2x2ZSlcbiAgICB9KVxuICB9XG59XG5cbmNsYXNzIFRlc3RSZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IgKG1ldGhvZCwgdXJsLCBvblJlcXVlc3RTZW5kKSB7XG4gICAgdGhpcy5tZXRob2QgPSBtZXRob2RcbiAgICB0aGlzLnVybCA9IHVybFxuICAgIHRoaXMucmVxdWVzdEhlYWRlcnMgPSB7fVxuICAgIHRoaXMuYm9keSA9IG51bGxcblxuICAgIHRoaXMuX29uUmVxdWVzdFNlbmQgPSBvblJlcXVlc3RTZW5kXG4gICAgdGhpcy5fb25Qcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgW3RoaXMuX3JlcXVlc3RQcm9taXNlLCB0aGlzLl9yZXNvbHZlUmVxdWVzdCwgdGhpcy5fcmVqZWN0UmVxdWVzdF0gPSBmbGF0UHJvbWlzZSgpXG4gIH1cblxuICBnZXRNZXRob2QgKCkge1xuICAgIHJldHVybiB0aGlzLm1ldGhvZFxuICB9XG5cbiAgZ2V0VVJMICgpIHtcbiAgICByZXR1cm4gdGhpcy51cmxcbiAgfVxuXG4gIHNldEhlYWRlciAoaGVhZGVyLCB2YWx1ZSkge1xuICAgIHRoaXMucmVxdWVzdEhlYWRlcnNbaGVhZGVyXSA9IHZhbHVlXG4gIH1cblxuICBnZXRIZWFkZXIgKGhlYWRlcikge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RIZWFkZXJzW2hlYWRlcl0gfHwgbnVsbFxuICB9XG5cbiAgc2V0UHJvZ3Jlc3NIYW5kbGVyIChwcm9ncmVzc0hhbmRsZXIpIHtcbiAgICB0aGlzLl9vblByb2dyZXNzID0gcHJvZ3Jlc3NIYW5kbGVyXG4gIH1cblxuICBzZW5kIChib2R5ID0gbnVsbCkge1xuICAgIHRoaXMuYm9keSA9IGJvZHlcblxuICAgIGlmIChib2R5KSB7XG4gICAgICB0aGlzLl9vblByb2dyZXNzKDApXG4gICAgICB0aGlzLl9vblByb2dyZXNzKGJvZHkubGVuZ3RoIHx8IGJvZHkuc2l6ZSB8fCAwKVxuICAgIH1cblxuICAgIHRoaXMuX29uUmVxdWVzdFNlbmQodGhpcylcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdFByb21pc2VcbiAgfVxuXG4gIGFib3J0ICgpIHtcbiAgICB0aGlzLl9yZWplY3RSZXF1ZXN0KG5ldyBFcnJvcigncmVxdWVzdCBhYm9ydGVkJykpXG4gIH1cblxuICBnZXRVbmRlcmx5aW5nT2JqZWN0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpXG4gIH1cblxuICByZXNwb25kV2l0aCAocmVzRGF0YSkge1xuICAgIHJlc0RhdGEucmVzcG9uc2VIZWFkZXJzID0gcmVzRGF0YS5yZXNwb25zZUhlYWRlcnMgfHwge31cblxuICAgIGNvbnN0IHJlcyA9IG5ldyBUZXN0UmVzcG9uc2UocmVzRGF0YSlcbiAgICB0aGlzLl9yZXNvbHZlUmVxdWVzdChyZXMpXG4gIH1cblxuICByZXNwb25zZUVycm9yIChlcnIpIHtcbiAgICB0aGlzLl9yZWplY3RSZXF1ZXN0KGVycilcbiAgfVxufVxuXG5jbGFzcyBUZXN0UmVzcG9uc2Uge1xuICBjb25zdHJ1Y3RvciAocmVzKSB7XG4gICAgdGhpcy5fcmVzcG9uc2UgPSByZXNcbiAgfVxuXG4gIGdldFN0YXR1cyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc3BvbnNlLnN0YXR1c1xuICB9XG5cbiAgZ2V0SGVhZGVyIChoZWFkZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzcG9uc2UucmVzcG9uc2VIZWFkZXJzW2hlYWRlcl1cbiAgfVxuXG4gIGdldEJvZHkgKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNwb25zZS5yZXNwb25zZVRleHRcbiAgfVxuXG4gIGdldFVuZGVybHlpbmdPYmplY3QgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgVGVzdEh0dHBTdGFjayxcbiAgd2FpdGFibGVGdW5jdGlvbixcbiAgd2FpdCxcbiAgZ2V0QmxvYixcbn1cbiIsIi8qIGdsb2JhbCBCbG9iICAqL1xuXG5jb25zdCBhc3NlcnRVcmxTdG9yYWdlID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Fzc2VydFVybFN0b3JhZ2UnKVxuY29uc3QgeyBUZXN0SHR0cFN0YWNrLCB3YWl0YWJsZUZ1bmN0aW9uLCB3YWl0IH0gPSByZXF1aXJlKCcuL2hlbHBlcnMvdXRpbHMnKVxuY29uc3QgdHVzID0gcmVxdWlyZSgnLi4vLi4nKVxuXG5kZXNjcmliZSgndHVzJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBsb2NhbFN0b3JhZ2UuY2xlYXIoKVxuICB9KVxuXG4gIGRlc2NyaWJlKCcjVXBsb2FkJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmVzdW1lIGFuIHVwbG9hZCBmcm9tIGEgc3RvcmVkIHVybCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd0dXM6OmZpbmdlcnByaW50ZWQ6OjEzMzcnLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHVwbG9hZFVybDogJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9yZXN1bWluZycsXG4gICAgICB9KSlcblxuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgdmFyIGZpbGUgPSBuZXcgQmxvYignaGVsbG8gd29ybGQnLnNwbGl0KCcnKSlcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgOiAnaHR0cDovL3R1cy5pby91cGxvYWRzJyxcbiAgICAgICAgb25Qcm9ncmVzcyAoKSB7fSxcbiAgICAgICAgZmluZ2VycHJpbnQgKCkge30sXG4gICAgICB9XG4gICAgICBzcHlPbihvcHRpb25zLCAnZmluZ2VycHJpbnQnKS5hbmQucmVzb2x2ZVRvKCdmaW5nZXJwcmludGVkJylcbiAgICAgIHNweU9uKG9wdGlvbnMsICdvblByb2dyZXNzJylcblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG5cbiAgICAgIGNvbnN0IHByZXZpb3VzVXBsb2FkcyA9IGF3YWl0IHVwbG9hZC5maW5kUHJldmlvdXNVcGxvYWRzKClcbiAgICAgIGV4cGVjdChwcmV2aW91c1VwbG9hZHMpLnRvRXF1YWwoW3tcbiAgICAgICAgdXBsb2FkVXJsICAgIDogJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9yZXN1bWluZycsXG4gICAgICAgIHVybFN0b3JhZ2VLZXk6ICd0dXM6OmZpbmdlcnByaW50ZWQ6OjEzMzcnLFxuICAgICAgfV0pXG4gICAgICB1cGxvYWQucmVzdW1lRnJvbVByZXZpb3VzVXBsb2FkKHByZXZpb3VzVXBsb2Fkc1swXSlcblxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgZXhwZWN0KG9wdGlvbnMuZmluZ2VycHJpbnQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGZpbGUsIHVwbG9hZC5vcHRpb25zKVxuXG4gICAgICB2YXIgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvcmVzdW1pbmcnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0hFQUQnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IDExLFxuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL3Jlc3VtaW5nJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1PZmZzZXQnXSkudG9CZSgzKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ10pLnRvQmUoJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nKVxuICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoMTEgLSAzKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxMSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvcmVzdW1pbmcnKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTEsIDExKVxuICAgIH0pXG5cbiAgICBkZXNjcmliZSgnc3RvcmluZyBvZiB1cGxvYWQgdXJscycsICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgOiAnaHR0cDovL3R1cy5pby91cGxvYWRzJyxcbiAgICAgICAgZmluZ2VycHJpbnQgKCkge30sXG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydFVwbG9hZCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZpbGUgPSBuZXcgQmxvYignaGVsbG8gd29ybGQnLnNwbGl0KCcnKSlcbiAgICAgICAgc3B5T24ob3B0aW9ucywgJ2ZpbmdlcnByaW50JykuYW5kLnJlc29sdmVUbygnZmluZ2VycHJpbnRlZCcpXG4gICAgICAgIG9wdGlvbnMub25TdWNjZXNzID0gd2FpdGFibGVGdW5jdGlvbignb25TdWNjZXNzJylcblxuICAgICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgICBleHBlY3Qob3B0aW9ucy5maW5nZXJwcmludCkudG9IYXZlQmVlbkNhbGxlZCgpXG5cbiAgICAgICAgdmFyIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIExvY2F0aW9uOiAnL3VwbG9hZHMvYmxhcmdoJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIFdhaXQgYSBzaG9ydCBkZWxheSB0byBhbGxvdyB0aGUgUHJvbWlzZXMgdG8gc2V0dGxlXG4gICAgICAgIGF3YWl0IHdhaXQoMTApXG4gICAgICB9XG5cbiAgICAgIHZhciBmaW5pc2hVcGxvYWQgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTEsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG4gICAgICB9XG5cbiAgICAgIGl0KCdzaG91bGQgc3RvcmUgYW5kIHJldGFpbiB3aXRoIGRlZmF1bHQgb3B0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgb3B0aW9ucy5yZW1vdmVGaW5nZXJwcmludE9uU3VjY2VzcyA9IGZhbHNlXG4gICAgICAgIGF3YWl0IHN0YXJ0VXBsb2FkKClcblxuICAgICAgICBjb25zdCBrZXkgPSBsb2NhbFN0b3JhZ2Uua2V5KDApXG4gICAgICAgIGV4cGVjdChrZXkuaW5kZXhPZigndHVzOjpmaW5nZXJwcmludGVkOjonKSkudG9CZSgwKVxuXG4gICAgICAgIGNvbnN0IHN0b3JlZFVwbG9hZCA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSlcbiAgICAgICAgZXhwZWN0KHN0b3JlZFVwbG9hZC51cGxvYWRVcmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnKVxuICAgICAgICBleHBlY3Qoc3RvcmVkVXBsb2FkLnNpemUpLnRvQmUoMTEpXG5cbiAgICAgICAgYXdhaXQgZmluaXNoVXBsb2FkKClcblxuICAgICAgICBleHBlY3QobG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSkudG9CZShKU09OLnN0cmluZ2lmeShzdG9yZWRVcGxvYWQpKVxuICAgICAgfSlcblxuICAgICAgaXQoJ3Nob3VsZCBzdG9yZSBhbmQgcmVtb3ZlIHdpdGggb3B0aW9uIHJlbW92ZUZpbmdlcnByaW50T25TdWNjZXNzIHNldCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgb3B0aW9ucy5yZW1vdmVGaW5nZXJwcmludE9uU3VjY2VzcyA9IHRydWVcbiAgICAgICAgYXdhaXQgc3RhcnRVcGxvYWQoKVxuXG4gICAgICAgIGNvbnN0IGtleSA9IGxvY2FsU3RvcmFnZS5rZXkoMClcbiAgICAgICAgZXhwZWN0KGtleS5pbmRleE9mKCd0dXM6OmZpbmdlcnByaW50ZWQ6OicpKS50b0JlKDApXG5cbiAgICAgICAgY29uc3Qgc3RvcmVkVXBsb2FkID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpKVxuICAgICAgICBleHBlY3Qoc3RvcmVkVXBsb2FkLnVwbG9hZFVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcpXG4gICAgICAgIGV4cGVjdChzdG9yZWRVcGxvYWQuc2l6ZSkudG9CZSgxMSlcblxuICAgICAgICBhd2FpdCBmaW5pc2hVcGxvYWQoKVxuICAgICAgICBleHBlY3QobG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSkudG9CZShudWxsKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBkZWxldGUgdXBsb2FkIHVybHMgb24gYSA0WFgnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICB2YXIgZmlsZSA9IG5ldyBCbG9iKCdoZWxsbyB3b3JsZCcuc3BsaXQoJycpKVxuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludCA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICBmaW5nZXJwcmludCAoKSB7fSxcbiAgICAgIH1cbiAgICAgIHNweU9uKG9wdGlvbnMsICdmaW5nZXJwcmludCcpLmFuZC5yZXNvbHZlVG8oJ2ZpbmdlcnByaW50ZWQnKVxuXG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcblxuICAgICAgdXBsb2FkLnJlc3VtZUZyb21QcmV2aW91c1VwbG9hZCh7XG4gICAgICAgIHVwbG9hZFVybCAgICA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMvcmVzdW1pbmcnLFxuICAgICAgICB1cmxTdG9yYWdlS2V5OiAndHVzOjpmaW5nZXJwcmludGVkOjoxMzM3JyxcbiAgICAgIH0pXG5cbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIHZhciByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9yZXN1bWluZycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnSEVBRCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNDAwLFxuICAgICAgfSlcblxuICAgICAgYXdhaXQgd2FpdCgxMClcblxuICAgICAgZXhwZWN0KGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0dXM6OmZpbmdlcnByaW50ZWQ6OjEzMzcnKSkudG9CZShudWxsKVxuICAgIH0pXG5cbiAgICBkZXNjcmliZSgndXBsb2FkaW5nIGRhdGEgZnJvbSBhIFJlYWRlcicsICgpID0+IHtcbiAgICAgIGZ1bmN0aW9uIG1ha2VSZWFkZXIgKGNvbnRlbnQsIHJlYWRTaXplID0gY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0ge1xuICAgICAgICAgIHZhbHVlOiBjb250ZW50LnNwbGl0KCcnKSxcbiAgICAgICAgICByZWFkICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSxcbiAgICAgICAgICAgICAgZG9uZSA9IGZhbHNlXG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZS5zbGljZSgwLCByZWFkU2l6ZSlcbiAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWUuc2xpY2UocmVhZFNpemUpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkb25lID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHZhbHVlLCBkb25lIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYW5jZWw6IHdhaXRhYmxlRnVuY3Rpb24oJ2NhbmNlbCcpLFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlYWRlclxuICAgICAgfVxuXG4gICAgICBhc3luYyBmdW5jdGlvbiBhc3NlcnRSZWFkZXJVcGxvYWQgKHsgcmVhZFNpemUsIGNodW5rU2l6ZSB9KSB7XG4gICAgICAgIHZhciByZWFkZXIgPSBtYWtlUmVhZGVyKCdoZWxsbyB3b3JsZCcsIHJlYWRTaXplKVxuXG4gICAgICAgIHZhciB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIGh0dHBTdGFjayAgICAgICAgICAgOiB0ZXN0U3RhY2ssXG4gICAgICAgICAgZW5kcG9pbnQgICAgICAgICAgICA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICAgIGNodW5rU2l6ZSxcbiAgICAgICAgICBvblByb2dyZXNzICAgICAgICAgIDogd2FpdGFibGVGdW5jdGlvbignb25Qcm9ncmVzcycpLFxuICAgICAgICAgIG9uU3VjY2VzcyAgICAgICAgICAgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvblN1Y2Nlc3MnKSxcbiAgICAgICAgICBmaW5nZXJwcmludCAoKSB7fSxcbiAgICAgICAgICB1cGxvYWRMZW5ndGhEZWZlcnJlZDogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgICBzcHlPbihvcHRpb25zLCAnZmluZ2VycHJpbnQnKS5hbmQucmVzb2x2ZVRvKCdmaW5nZXJwcmludGVkJylcblxuICAgICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQocmVhZGVyLCBvcHRpb25zKVxuICAgICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICAgIGV4cGVjdChvcHRpb25zLmZpbmdlcnByaW50KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChyZWFkZXIsIHVwbG9hZC5vcHRpb25zKVxuXG4gICAgICAgIHZhciByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTGVuZ3RoJ10pLnRvQmUodW5kZWZpbmVkKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtRGVmZXItTGVuZ3RoJ10pLnRvQmUoMSlcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgTG9jYXRpb246ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDApXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKS50b0JlKCdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJylcbiAgICAgICAgZXhwZWN0KHJlcS5ib2R5Lmxlbmd0aCkudG9CZSgxMSlcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxMSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIGF3YWl0IG9wdGlvbnMub25Qcm9ncmVzcy50b0JlQ2FsbGVkXG4gICAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDExLCBudWxsKVxuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDExKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTGVuZ3RoJ10pLnRvQmUoMTEpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKS50b0JlKCdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJylcbiAgICAgICAgZXhwZWN0KHJlcS5ib2R5KS50b0JlKG51bGwpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTEsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG4gICAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoJylcbiAgICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTEsIDExKVxuICAgICAgfVxuXG4gICAgICBpdCgnc2hvdWxkIHVwbG9hZCBkYXRhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBhc3NlcnRSZWFkZXJVcGxvYWQoeyBjaHVua1NpemU6IDEwMCwgcmVhZFNpemU6IDEwMCB9KVxuICAgICAgfSlcblxuICAgICAgaXQoJ3Nob3VsZCByZWFkIG11bHRpcGxlIHRpbWVzIGZyb20gdGhlIHJlYWRlcicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgYXNzZXJ0UmVhZGVyVXBsb2FkKHsgY2h1bmtTaXplOiAxMDAsIHJlYWRTaXplOiA2IH0pXG4gICAgICB9KVxuXG4gICAgICBpdCgnc2hvdWxkIHVzZSBtdWx0aXBsZSBQQVRDSCByZXF1ZXN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgdmFyIHJlYWRlciA9IG1ha2VSZWFkZXIoJ2hlbGxvIHdvcmxkJywgMSlcblxuICAgICAgICB2YXIgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBodHRwU3RhY2sgICAgICAgICAgIDogdGVzdFN0YWNrLFxuICAgICAgICAgIGVuZHBvaW50ICAgICAgICAgICAgOiAnaHR0cDovL3R1cy5pby91cGxvYWRzJyxcbiAgICAgICAgICBjaHVua1NpemUgICAgICAgICAgIDogNixcbiAgICAgICAgICBvblByb2dyZXNzICAgICAgICAgIDogd2FpdGFibGVGdW5jdGlvbignb25Qcm9ncmVzcycpLFxuICAgICAgICAgIG9uU3VjY2VzcyAgICAgICAgICAgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvblN1Y2Nlc3MnKSxcbiAgICAgICAgICBmaW5nZXJwcmludCAoKSB7fSxcbiAgICAgICAgICB1cGxvYWRMZW5ndGhEZWZlcnJlZDogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgICBzcHlPbihvcHRpb25zLCAnZmluZ2VycHJpbnQnKS5hbmQucmVzb2x2ZVRvKCdmaW5nZXJwcmludGVkJylcblxuICAgICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQocmVhZGVyLCBvcHRpb25zKVxuICAgICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICAgIGV4cGVjdChvcHRpb25zLmZpbmdlcnByaW50KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChyZWFkZXIsIHVwbG9hZC5vcHRpb25zKVxuXG4gICAgICAgIHZhciByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTGVuZ3RoJ10pLnRvQmUodW5kZWZpbmVkKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtRGVmZXItTGVuZ3RoJ10pLnRvQmUoMSlcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgTG9jYXRpb246ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDApXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKS50b0JlKCdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJylcbiAgICAgICAgZXhwZWN0KHJlcS5ib2R5Lmxlbmd0aCkudG9CZSg2KVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDYsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBhd2FpdCBvcHRpb25zLm9uUHJvZ3Jlc3MudG9CZUNhbGxlZFxuICAgICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg2LCBudWxsKVxuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1PZmZzZXQnXSkudG9CZSg2KVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICAgIGV4cGVjdChyZXEuYm9keS5sZW5ndGgpLnRvQmUoNSlcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxMSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDExKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTGVuZ3RoJ10pLnRvQmUoMTEpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKS50b0JlKCdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJylcbiAgICAgICAgZXhwZWN0KHJlcS5ib2R5KS50b0JlKG51bGwpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTEsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG4gICAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoJylcbiAgICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTEsIDExKVxuICAgICAgfSlcblxuICAgICAgaXQoJ3Nob3VsZCByZXRyeSB0aGUgUE9TVCByZXF1ZXN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICB2YXIgcmVhZGVyID0gbWFrZVJlYWRlcignaGVsbG8gd29ybGQnLCAxKVxuXG4gICAgICAgIHZhciB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIGh0dHBTdGFjayAgICAgICAgICAgOiB0ZXN0U3RhY2ssXG4gICAgICAgICAgZW5kcG9pbnQgICAgICAgICAgICA6ICdodHRwOi8vdHVzLmlvL2ZpbGVzLycsXG4gICAgICAgICAgY2h1bmtTaXplICAgICAgICAgICA6IDExLFxuICAgICAgICAgIHJldHJ5RGVsYXlzICAgICAgICAgOiBbMTAsIDEwLCAxMF0sXG4gICAgICAgICAgb25TdWNjZXNzICAgICAgICAgICA6IHdhaXRhYmxlRnVuY3Rpb24oJ29uU3VjY2VzcycpLFxuICAgICAgICAgIHVwbG9hZExlbmd0aERlZmVycmVkOiB0cnVlLFxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKHJlYWRlciwgb3B0aW9ucylcbiAgICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgICB2YXIgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICBMb2NhdGlvbjogJy9maWxlcy9mb28nLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxMSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZSgxMSlcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxMSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWRcbiAgICAgIH0pXG5cbiAgICAgIGl0KCdzaG91bGQgcmV0cnkgdGhlIGZpcnN0IFBBVENIIHJlcXVlc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHZhciByZWFkZXIgPSBtYWtlUmVhZGVyKCdoZWxsbyB3b3JsZCcsIDEpXG5cbiAgICAgICAgdmFyIHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgaHR0cFN0YWNrICAgICAgICAgICA6IHRlc3RTdGFjayxcbiAgICAgICAgICBlbmRwb2ludCAgICAgICAgICAgIDogJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJyxcbiAgICAgICAgICBjaHVua1NpemUgICAgICAgICAgIDogMTEsXG4gICAgICAgICAgcmV0cnlEZWxheXMgICAgICAgICA6IFsxMCwgMTAsIDEwXSxcbiAgICAgICAgICBvblN1Y2Nlc3MgICAgICAgICAgIDogd2FpdGFibGVGdW5jdGlvbignb25TdWNjZXNzJyksXG4gICAgICAgICAgdXBsb2FkTGVuZ3RoRGVmZXJyZWQ6IHRydWUsXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQocmVhZGVyLCBvcHRpb25zKVxuICAgICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICAgIHZhciByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy8nKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIExvY2F0aW9uOiAnL2ZpbGVzL2ZvbycsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0hFQUQnKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDAsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDExLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUxlbmd0aCddKS50b0JlKDExKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDExLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZFxuICAgICAgfSlcblxuICAgICAgaXQoJ3Nob3VsZCByZXRyeSBmb2xsb3dpbmcgUEFUQ0ggcmVxdWVzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHZhciByZWFkZXIgPSBtYWtlUmVhZGVyKCdoZWxsbyB3b3JsZCB0aGVyZSEnKVxuXG4gICAgICAgIHZhciB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIGh0dHBTdGFjayAgICAgICAgICAgOiB0ZXN0U3RhY2ssXG4gICAgICAgICAgZW5kcG9pbnQgICAgICAgICAgICA6ICdodHRwOi8vdHVzLmlvL2ZpbGVzLycsXG4gICAgICAgICAgY2h1bmtTaXplICAgICAgICAgICA6IDYsXG4gICAgICAgICAgcmV0cnlEZWxheXMgICAgICAgICA6IFsxMCwgMTAsIDEwXSxcbiAgICAgICAgICBvblN1Y2Nlc3MgKCkge30sXG4gICAgICAgICAgdXBsb2FkTGVuZ3RoRGVmZXJyZWQ6IHRydWUsXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQocmVhZGVyLCBvcHRpb25zKVxuICAgICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICAgIHZhciByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy8nKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIExvY2F0aW9uOiAnL2ZpbGVzL2ZvbycsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDYsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0hFQUQnKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDYsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDEyLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxOCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZSgxOClcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxOCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWRcbiAgICAgIH0pXG5cbiAgICAgIGl0KCdzaG91bGQgY2FuY2VsIHRoZSByZWFkZXIgd2hlbiBhYm9ydGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICB2YXIgcmVhZGVyID0gbWFrZVJlYWRlcignaGVsbG8gdGhlcmUgd29ybGQnKVxuXG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIGh0dHBTdGFjayAgICAgICAgICAgOiBuZXcgVGVzdEh0dHBTdGFjaygpLFxuICAgICAgICAgIGVuZHBvaW50ICAgICAgICAgICAgOiAnaHR0cDovL3R1cy5pby9maWxlcy8nLFxuICAgICAgICAgIGNodW5rU2l6ZSAgICAgICAgICAgOiA2LFxuICAgICAgICAgIHJldHJ5RGVsYXlzICAgICAgICAgOiBbMTAsIDEwLCAxMF0sXG4gICAgICAgICAgb25TdWNjZXNzICgpIHt9LFxuICAgICAgICAgIHVwbG9hZExlbmd0aERlZmVycmVkOiB0cnVlLFxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKHJlYWRlciwgb3B0aW9ucylcbiAgICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgICAvLyBXZSB3YWl0IHVudGlsIHRoZSBmaXJzdCByZXF1ZXN0IGFycml2ZXMsIHNvIHRoYXQgdGhlIGZpcnN0IHByb21pc2VzIGhhdmUgcmVzb2x2ZWQuXG4gICAgICAgIGF3YWl0IG9wdGlvbnMuaHR0cFN0YWNrLm5leHRSZXF1ZXN0KClcblxuICAgICAgICB1cGxvYWQuYWJvcnQoKVxuXG4gICAgICAgIGF3YWl0IHJlYWRlci5jYW5jZWwudG9CZUNhbGxlZFxuICAgICAgICBleHBlY3QocmVhZGVyLmNhbmNlbCkudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBkZXNjcmliZSgncmVzb2x2aW5nIG9mIFVSSXMnLCAoKSA9PiB7XG4gICAgICAvLyBEaXNhYmxlIHRoZXNlIHRlc3RzIGZvciBJRSAxMCBhbmQgMTEgYmVjYXVzZSBpdCdzIG5vdCBwb3NzaWJsZSB0byBvdmVyd3JpdGVcbiAgICAgIC8vIHRoZSBuYXZpZ2F0b3IucHJvZHVjdCBwcm9wZXJ0eS5cbiAgICAgIHZhciBpc0lFID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdUcmlkZW50LycpID4gMFxuICAgICAgaWYgKGlzSUUpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1NraXBwaW5nIHRlc3RzIGZvciBSZWFjdCBOYXRpdmUgaW4gSW50ZXJuZXQgRXhwbG9yZXInKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHZhciBvcmlnaW5hbFByb2R1Y3QgPSBuYXZpZ2F0b3IucHJvZHVjdFxuXG4gICAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgICAgamFzbWluZS5BamF4Lmluc3RhbGwoKVxuICAgICAgICAvLyBTaW11bGF0ZSBSZWFjdCBOYXRpdmUgZW52aXJvbm1lbnQgdG8gZW5hYmxlIFVSSXMgYXMgaW5wdXQgb2JqZWN0cy5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hdmlnYXRvciwgJ3Byb2R1Y3QnLCB7XG4gICAgICAgICAgdmFsdWUgICAgICAgOiAnUmVhY3ROYXRpdmUnLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgIH0pXG5cbiAgICAgIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgICAgIGphc21pbmUuQWpheC51bmluc3RhbGwoKVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmF2aWdhdG9yLCAncHJvZHVjdCcsIHtcbiAgICAgICAgICB2YWx1ZSAgICAgICA6IG9yaWdpbmFsUHJvZHVjdCxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0pXG4gICAgICB9KVxuXG4gICAgICBpdCgnc2hvdWxkIHVwbG9hZCBhIGZpbGUgZnJvbSBhbiBVUkknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHZhciBmaWxlID0ge1xuICAgICAgICAgIHVyaTogJ2ZpbGU6Ly8vbXkvZmlsZS5kYXQnLFxuICAgICAgICB9XG4gICAgICAgIHZhciB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICAgIGVuZHBvaW50IDogJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycsXG4gICAgICAgICAgb25TdWNjZXNzOiB3YWl0YWJsZUZ1bmN0aW9uKCdvblN1Y2Nlc3MnKSxcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICAgIC8vIFdhaXQgYSBzaG9ydCBpbnRlcnZhbCB0byBtYWtlIHN1cmUgdGhhdCB0aGUgWEhSIGhhcyBiZWVuIHNlbnQuXG4gICAgICAgIGF3YWl0IHdhaXQoMClcblxuICAgICAgICB2YXIgcmVxID0gamFzbWluZS5BamF4LnJlcXVlc3RzLm1vc3RSZWNlbnQoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnZmlsZTovLy9teS9maWxlLmRhdCcpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdHRVQnKVxuICAgICAgICBleHBlY3QocmVxLnJlc3BvbnNlVHlwZSkudG9CZSgnYmxvYicpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgICdVcGxvYWQtTGVuZ3RoJzogMTEsXG4gICAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDMsXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNwb25zZTogbmV3IEJsb2IoJ2hlbGxvIHdvcmxkJy5zcGxpdCgnJykpLFxuICAgICAgICB9KVxuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZSgxMSlcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgTG9jYXRpb246ICcvdXBsb2Fkcy9ibGFyZ2gnLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDApXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKS50b0JlKCdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJylcbiAgICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoMTEpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTEsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG4gICAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoJylcbiAgICAgIH0pXG5cbiAgICAgIGl0KFwic2hvdWxkIGVtaXQgYW4gZXJyb3IgaWYgaXQgY2FuJ3QgcmVzb2x2ZSB0aGUgVVJJXCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgdmFyIGZpbGUgPSB7XG4gICAgICAgICAgdXJpOiAnZmlsZTovLy9teS9maWxlLmRhdCcsXG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgZW5kcG9pbnQ6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICAgIG9uRXJyb3IgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvbkVycm9yJyksXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgICAvLyBXYWl0IGEgc2hvcnQgaW50ZXJ2YWwgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIFhIUiBoYXMgYmVlbiBzZW50LlxuICAgICAgICBhd2FpdCB3YWl0KDApXG5cbiAgICAgICAgdmFyIHJlcSA9IGphc21pbmUuQWpheC5yZXF1ZXN0cy5tb3N0UmVjZW50KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2ZpbGU6Ly8vbXkvZmlsZS5kYXQnKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnR0VUJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXNwb25zZVR5cGUpLnRvQmUoJ2Jsb2InKVxuXG4gICAgICAgIHJlcS5yZXNwb25zZUVycm9yKClcblxuICAgICAgICBhd2FpdCBvcHRpb25zLm9uRXJyb3IudG9CZUNhbGxlZFxuICAgICAgICBleHBlY3Qob3B0aW9ucy5vbkVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChuZXcgRXJyb3IoJ3R1czogY2Fubm90IGZldGNoIGBmaWxlLnVyaWAgYXMgQmxvYiwgbWFrZSBzdXJlIHRoZSB1cmkgaXMgY29ycmVjdCBhbmQgYWNjZXNzaWJsZS4gW29iamVjdCBPYmplY3RdJykpXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJyNMb2NhbFN0b3JhZ2VVcmxTdG9yYWdlJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgYWxsb3cgc3RvcmluZyBhbmQgcmV0cmlldmluZyB1cGxvYWRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgYXNzZXJ0VXJsU3RvcmFnZSh0dXMuZGVmYXVsdE9wdGlvbnMudXJsU3RvcmFnZSlcbiAgICB9KVxuICB9KVxufSlcbiIsImNvbnN0IHsgVGVzdEh0dHBTdGFjaywgd2FpdGFibGVGdW5jdGlvbiwgd2FpdCwgZ2V0QmxvYiB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzL3V0aWxzJylcbmNvbnN0IHR1cyA9IHJlcXVpcmUoJy4uLy4uJylcblxuLy8gVW5jb21tZW50IHRvIGVuYWJsZSBkZWJ1ZyBsb2cgZnJvbSB0dXMtanMtY2xpZW50XG4vLyB0dXMuZW5hYmxlRGVidWdMb2coKTtcblxuZGVzY3JpYmUoJ3R1cycsICgpID0+IHtcbiAgZGVzY3JpYmUoJyNpc1N1cHBvcnRlZCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGJlIHRydWUnLCAoKSA9PiB7XG4gICAgICBleHBlY3QodHVzLmlzU3VwcG9ydGVkKS50b0JlKHRydWUpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnI1VwbG9hZCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHRocm93IGlmIG5vIGVycm9yIGhhbmRsZXIgaXMgYXZhaWxhYmxlJywgKCkgPT4ge1xuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKG51bGwpXG4gICAgICBleHBlY3QodXBsb2FkLnN0YXJ0LmJpbmQodXBsb2FkKSkudG9UaHJvd0Vycm9yKCd0dXM6IG5vIGZpbGUgb3Igc3RyZWFtIHRvIHVwbG9hZCBwcm92aWRlZCcpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgaWYgbm8gZW5kcG9pbnQgYW5kIHVwbG9hZCBVUkwgaXMgcHJvdmlkZWQnLCAoKSA9PiB7XG4gICAgICB2YXIgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlKVxuICAgICAgZXhwZWN0KHVwbG9hZC5zdGFydC5iaW5kKHVwbG9hZCkpLnRvVGhyb3dFcnJvcigndHVzOiBuZWl0aGVyIGFuIGVuZHBvaW50IG9yIGFuIHVwbG9hZCBVUkwgaXMgcHJvdmlkZWQnKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHVwbG9hZCBhIGZpbGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50IDogJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICBoZWFkZXJzICA6IHtcbiAgICAgICAgICBDdXN0b206ICdibGFyZ2gnLFxuICAgICAgICB9LFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIGZvbyAgICAgOiAnaGVsbG8nLFxuICAgICAgICAgIGJhciAgICAgOiAnd29ybGQnLFxuICAgICAgICAgIG5vbmxhdGluOiAnc8WCb8WEY2UnLFxuICAgICAgICAgIG51bWJlciAgOiAxMDAsXG4gICAgICAgIH0sXG4gICAgICAgIHdpdGhDcmVkZW50aWFsczogdHJ1ZSxcbiAgICAgICAgb25Qcm9ncmVzcyAoKSB7fSxcbiAgICAgICAgb25TdWNjZXNzICAgICAgOiB3YWl0YWJsZUZ1bmN0aW9uKCksXG4gICAgICB9XG4gICAgICBzcHlPbihvcHRpb25zLCAnb25Qcm9ncmVzcycpXG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcblxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVycy5DdXN0b20pLnRvQmUoJ2JsYXJnaCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZSgxMSlcbiAgICAgIC8vIGlmIChpc0Jyb3dzZXIpIGV4cGVjdChyZXEud2l0aENyZWRlbnRpYWxzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU1ldGFkYXRhJ10pLnRvQmUoJ2ZvbyBhR1ZzYkc4PSxiYXIgZDI5eWJHUT0sbm9ubGF0aW4gYzhXQ2I4V0VZMlU9LG51bWJlciBNVEF3JylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiAnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcblxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzLkN1c3RvbSkudG9CZSgnYmxhcmdoJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDApXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSgxMSlcbiAgICAgIC8vIGlmIChpc0Jyb3dzZXIpIGV4cGVjdChyZXEud2l0aENyZWRlbnRpYWxzKS50b0JlKHRydWUpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxMSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWRcblxuICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoJylcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDExLCAxMSlcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBjcmVhdGUgYW4gdXBsb2FkIGlmIHJlc3VtaW5nIGZhaWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludCA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICB1cGxvYWRVcmw6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMvcmVzdW1pbmcnLFxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL3Jlc3VtaW5nJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdIRUFEJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDQwNCxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUxlbmd0aCddKS50b0JlKDExKVxuXG4gICAgICAvLyBUaGUgdXBsb2FkIFVSTCBzaG91bGQgYmUgY2xlYXJlZCB3aGVuIHR1cy1qcy5jbGllbnQgdHJpZXMgdG8gY3JlYXRlIGEgbmV3IHVwbG9hZC5cbiAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKG51bGwpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgY3JlYXRlIGFuIHVwbG9hZCB1c2luZyB0aGUgY3JlYXRpb24td2l0aC1kYXRhIGV4dGVuc2lvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjayAgICAgICAgICAgICAgIDogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludCAgICAgICAgICAgICAgICA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICB1cGxvYWREYXRhRHVyaW5nQ3JlYXRpb246IHRydWUsXG4gICAgICAgIG9uUHJvZ3Jlc3MgKCkge30sXG4gICAgICAgIG9uQ2h1bmtDb21wbGV0ZSAoKSB7fSxcbiAgICAgICAgb25TdWNjZXNzICAgICAgICAgICAgICAgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvblN1Y2Nlc3MnKSxcbiAgICAgIH1cblxuICAgICAgc3B5T24ob3B0aW9ucywgJ29uUHJvZ3Jlc3MnKVxuICAgICAgc3B5T24ob3B0aW9ucywgJ29uQ2h1bmtDb21wbGV0ZScpXG5cbiAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgY29uc3QgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTGVuZ3RoJ10pLnRvQmUoMTEpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSgxMSlcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uICAgICAgIDogJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnLFxuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTEsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG5cbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDExLCAxMSlcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uQ2h1bmtDb21wbGV0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTEsIDExLCAxMSlcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uU3VjY2VzcykudG9IYXZlQmVlbkNhbGxlZCgpXG5cbiAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoJylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBjcmVhdGUgYW4gdXBsb2FkIHdpdGggcGFydGlhbCBkYXRhIGFuZCBjb250aW51ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjayAgICAgICAgICAgICAgIDogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludCAgICAgICAgICAgICAgICA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICB1cGxvYWREYXRhRHVyaW5nQ3JlYXRpb246IHRydWUsXG4gICAgICAgIGNodW5rU2l6ZSAgICAgICAgICAgICAgIDogNixcbiAgICAgICAgb25Qcm9ncmVzcyAoKSB7fSxcbiAgICAgICAgb25DaHVua0NvbXBsZXRlICgpIHt9LFxuICAgICAgICBvblN1Y2Nlc3MgICAgICAgICAgICAgICA6IHdhaXRhYmxlRnVuY3Rpb24oJ29uU3VjY2VzcycpLFxuICAgICAgfVxuXG4gICAgICBzcHlPbihvcHRpb25zLCAnb25Qcm9ncmVzcycpXG4gICAgICBzcHlPbihvcHRpb25zLCAnb25DaHVua0NvbXBsZXRlJylcblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICB2YXIgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTGVuZ3RoJ10pLnRvQmUoMTEpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSg2KVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb24gICAgICAgOiAnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcsXG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA2LFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcblxuICAgICAgLy8gT25jZSB0aGUgc2Vjb25kIHJlcXVlc3QgaGFzIGJlZW4gc2VudCwgdGhlIHByb2dyZXNzIGhhbmRsZXIgbXVzdCBoYXZlIGJlZW4gaW52b2tlZC5cbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDYsIDExKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25DaHVua0NvbXBsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg2LCA2LCAxMSlcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uU3VjY2Vzcykubm90LnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnKVxuXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtT2Zmc2V0J10pLnRvQmUoNilcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKS50b0JlKCdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJylcbiAgICAgIGV4cGVjdChyZXEuYm9keS5zaXplKS50b0JlKDUpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbiAgICAgICA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoJyxcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDExLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZFxuXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxMSwgMTEpXG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkNodW5rQ29tcGxldGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDUsIDExLCAxMSlcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uU3VjY2VzcykudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgfSlcblxuICAgIGl0KFwic2hvdWxkIGFkZCB0aGUgcmVxdWVzdCdzIGJvZHkgYW5kIElEIHRvIGVycm9yc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICB2YXIgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2sgICA6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgICAgOiAnaHR0cDovL3R1cy5pby91cGxvYWRzJyxcbiAgICAgICAgYWRkUmVxdWVzdElkOiB0cnVlLFxuICAgICAgICByZXRyeURlbGF5cyA6IG51bGwsXG4gICAgICAgIG9uRXJyb3IgICAgIDogd2FpdGFibGVGdW5jdGlvbignb25FcnJvcicpLFxuICAgICAgfVxuXG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIHZhciByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG5cbiAgICAgIGNvbnN0IHJlcUlkID0gcmVxLnJlcXVlc3RIZWFkZXJzWydYLVJlcXVlc3QtSUQnXVxuICAgICAgZXhwZWN0KHR5cGVvZiByZXFJZCkudG9CZSgnc3RyaW5nJylcbiAgICAgIGV4cGVjdChyZXFJZC5sZW5ndGgpLnRvQmUoMzYpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgIDogNTAwLFxuICAgICAgICByZXNwb25zZVRleHQ6ICdzZXJ2ZXJfZXJyb3InLFxuICAgICAgfSlcblxuICAgICAgY29uc3QgZXJyID0gYXdhaXQgb3B0aW9ucy5vbkVycm9yLnRvQmVDYWxsZWRcblxuICAgICAgZXhwZWN0KGVyci5tZXNzYWdlKS50b0JlKGB0dXM6IHVuZXhwZWN0ZWQgcmVzcG9uc2Ugd2hpbGUgY3JlYXRpbmcgdXBsb2FkLCBvcmlnaW5hdGVkIGZyb20gcmVxdWVzdCAobWV0aG9kOiBQT1NULCB1cmw6IGh0dHA6Ly90dXMuaW8vdXBsb2FkcywgcmVzcG9uc2UgY29kZTogNTAwLCByZXNwb25zZSB0ZXh0OiBzZXJ2ZXJfZXJyb3IsIHJlcXVlc3QgaWQ6ICR7cmVxSWR9KWApXG4gICAgICBleHBlY3QoZXJyLm9yaWdpbmFsUmVxdWVzdCkudG9CZURlZmluZWQoKVxuICAgICAgZXhwZWN0KGVyci5vcmlnaW5hbFJlc3BvbnNlKS50b0JlRGVmaW5lZCgpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgaW52b2tlIHRoZSByZXF1ZXN0IGFuZCByZXNwb25zZSBjYWxsYmFja3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICB2YXIgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgdXBsb2FkVXJsOiAnaHR0cDovL3R1cy5pby91cGxvYWRzL2ZvbycsXG4gICAgICAgIG9uQmVmb3JlUmVxdWVzdCAocmVxKSB7XG4gICAgICAgICAgZXhwZWN0KHJlcS5nZXRVUkwoKSkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2ZvbycpXG4gICAgICAgICAgZXhwZWN0KHJlcS5nZXRNZXRob2QoKSkudG9CZSgnSEVBRCcpXG4gICAgICAgIH0sXG4gICAgICAgIG9uQWZ0ZXJSZXNwb25zZSAocmVxLCByZXMpIHtcbiAgICAgICAgICBleHBlY3QocmVxLmdldFVSTCgpKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvZm9vJylcbiAgICAgICAgICBleHBlY3QocmVxLmdldE1ldGhvZCgpKS50b0JlKCdIRUFEJylcbiAgICAgICAgICBleHBlY3QocmVzLmdldFN0YXR1cygpKS50b0JlKDIwNClcbiAgICAgICAgICBleHBlY3QocmVzLmdldEhlYWRlcignVXBsb2FkLU9mZnNldCcpKS50b0JlKDExKVxuICAgICAgICB9LFxuICAgICAgICBvblN1Y2Nlc3M6IHdhaXRhYmxlRnVuY3Rpb24oJ29uU3VjY2VzcycpLFxuICAgICAgfVxuICAgICAgc3B5T24ob3B0aW9ucywgJ29uQmVmb3JlUmVxdWVzdCcpXG4gICAgICBzcHlPbihvcHRpb25zLCAnb25BZnRlclJlc3BvbnNlJylcblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICB2YXIgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvZm9vJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdIRUFEJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTEsXG4gICAgICAgICAgJ1VwbG9hZC1MZW5ndGgnOiAxMSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWRcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uQmVmb3JlUmVxdWVzdCkudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkFmdGVyUmVzcG9uc2UpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHRocm93IGFuIGVycm9yIGlmIHJlc3VtaW5nIGZhaWxzIGFuZCBubyBlbmRwb2ludCBpcyBwcm92aWRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICB1cGxvYWRVcmw6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMvcmVzdW1pbmcnLFxuICAgICAgICBvbkVycm9yICA6IHdhaXRhYmxlRnVuY3Rpb24oJ29uRXJyb3InKSxcbiAgICAgIH1cblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICB2YXIgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvcmVzdW1pbmcnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0hFQUQnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNDA0LFxuICAgICAgfSlcblxuICAgICAgY29uc3QgZXJyID0gYXdhaXQgb3B0aW9ucy5vbkVycm9yLnRvQmVDYWxsZWRcbiAgICAgIGV4cGVjdChlcnIubWVzc2FnZSkudG9CZSgndHVzOiB1bmFibGUgdG8gcmVzdW1lIHVwbG9hZCAobmV3IHVwbG9hZCBjYW5ub3QgYmUgY3JlYXRlZCB3aXRob3V0IGFuIGVuZHBvaW50KSwgb3JpZ2luYXRlZCBmcm9tIHJlcXVlc3QgKG1ldGhvZDogSEVBRCwgdXJsOiBodHRwOi8vdHVzLmlvL3VwbG9hZHMvcmVzdW1pbmcsIHJlc3BvbnNlIGNvZGU6IDQwNCwgcmVzcG9uc2UgdGV4dDogLCByZXF1ZXN0IGlkOiBuL2EpJylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCByZXNvbHZlIHJlbGF0aXZlIFVSTHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICB2YXIgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgOiAnaHR0cDovL3R1cy5pbzoxMDgwL2ZpbGVzLycsXG4gICAgICB9XG5cbiAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pbzoxMDgwL2ZpbGVzLycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogJy8vbG9jYWxob3N0L3VwbG9hZHMvZm9vJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL2xvY2FsaG9zdC91cGxvYWRzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxMSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKCdodHRwOi8vbG9jYWxob3N0L3VwbG9hZHMvZm9vJylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCB1cGxvYWQgYSBmaWxlIGluIGNodW5rcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludCA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICBjaHVua1NpemU6IDcsXG4gICAgICAgIG9uU3VjY2Vzczogd2FpdGFibGVGdW5jdGlvbignb25TdWNjZXNzJyksXG4gICAgICAgIG9uUHJvZ3Jlc3MgKCkge30sXG4gICAgICAgIG9uQ2h1bmtDb21wbGV0ZSAoKSB7fSxcbiAgICAgIH1cbiAgICAgIHNweU9uKG9wdGlvbnMsICdvblByb2dyZXNzJylcbiAgICAgIHNweU9uKG9wdGlvbnMsICdvbkNodW5rQ29tcGxldGUnKVxuXG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZSgxMSlcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiAnL3VwbG9hZHMvYmxhcmdoJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtT2Zmc2V0J10pLnRvQmUoMClcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKS50b0JlKCdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJylcbiAgICAgIGV4cGVjdChyZXEuYm9keS5zaXplKS50b0JlKDcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDcsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSg0KVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxMSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWRcblxuICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTEsIDExKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25DaHVua0NvbXBsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg3LCA3LCAxMSlcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uQ2h1bmtDb21wbGV0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoNCwgMTEsIDExKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGFkZCB0aGUgb3JpZ2luYWwgcmVxdWVzdCB0byBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICB2YXIgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2sgIDogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludCAgIDogJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycsXG4gICAgICAgIHJldHJ5RGVsYXlzOiBudWxsLFxuICAgICAgICBvbkVycm9yICAgIDogd2FpdGFibGVGdW5jdGlvbignb25FcnJvcicpLFxuICAgICAgfVxuXG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGNvbnN0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiA1MDAsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIEN1c3RvbTogJ2JsYXJnaCcsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBlcnIgPSBhd2FpdCBvcHRpb25zLm9uRXJyb3IudG9CZUNhbGxlZFxuXG4gICAgICBleHBlY3QodXBsb2FkLnVybCkudG9CZShudWxsKVxuICAgICAgZXhwZWN0KGVyci5tZXNzYWdlKS50b0JlKCd0dXM6IHVuZXhwZWN0ZWQgcmVzcG9uc2Ugd2hpbGUgY3JlYXRpbmcgdXBsb2FkLCBvcmlnaW5hdGVkIGZyb20gcmVxdWVzdCAobWV0aG9kOiBQT1NULCB1cmw6IGh0dHA6Ly90dXMuaW8vdXBsb2FkcywgcmVzcG9uc2UgY29kZTogNTAwLCByZXNwb25zZSB0ZXh0OiAsIHJlcXVlc3QgaWQ6IG4vYSknKVxuICAgICAgZXhwZWN0KGVyci5vcmlnaW5hbFJlcXVlc3QpLnRvQmVEZWZpbmVkKClcbiAgICAgIGV4cGVjdChlcnIub3JpZ2luYWxSZXNwb25zZSkudG9CZURlZmluZWQoKVxuICAgICAgZXhwZWN0KGVyci5vcmlnaW5hbFJlc3BvbnNlLmdldEhlYWRlcignQ3VzdG9tJykpLnRvQmUoJ2JsYXJnaCcpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgb25seSBjcmVhdGUgYW4gdXBsb2FkIGZvciBlbXB0eSBmaWxlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYignJylcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgOiAnaHR0cDovL3R1cy5pby91cGxvYWRzJyxcbiAgICAgICAgb25TdWNjZXNzOiB3YWl0YWJsZUZ1bmN0aW9uKCdvblN1Y2Nlc3MnKSxcbiAgICAgIH1cblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBjb25zdCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZSgwKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMvZW1wdHknLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZFxuICAgICAgZXhwZWN0KG9wdGlvbnMub25TdWNjZXNzKS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBub3QgcmVzdW1lIGEgZmluaXNoZWQgdXBsb2FkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50IDogJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycsXG4gICAgICAgIG9uUHJvZ3Jlc3MgKCkge30sXG4gICAgICAgIG9uU3VjY2Vzczogd2FpdGFibGVGdW5jdGlvbignb25TdWNjZXNzJyksXG4gICAgICAgIHVwbG9hZFVybDogJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9yZXN1bWluZycsXG4gICAgICB9XG4gICAgICBzcHlPbihvcHRpb25zLCAnb25Qcm9ncmVzcycpXG5cbiAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgdmFyIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL3Jlc3VtaW5nJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdIRUFEJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1MZW5ndGgnOiAnMTEnLFxuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogJzExJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWRcblxuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTEsIDExKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25TdWNjZXNzKS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCByZXN1bWUgYW4gdXBsb2FkIGZyb20gYSBzcGVjaWZpZWQgdXJsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50IDogJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycsXG4gICAgICAgIHVwbG9hZFVybDogJ2h0dHA6Ly90dXMuaW8vZmlsZXMvdXBsb2FkJyxcbiAgICAgICAgb25Qcm9ncmVzcyAoKSB7fSxcbiAgICAgICAgb25TdWNjZXNzOiB3YWl0YWJsZUZ1bmN0aW9uKCdvblN1Y2Nlc3MnKSxcbiAgICAgICAgZmluZ2VycHJpbnQgKCkge30sXG4gICAgICB9XG4gICAgICBzcHlPbihvcHRpb25zLCAnZmluZ2VycHJpbnQnKS5hbmQucmVzb2x2ZVRvKCdmaW5nZXJwcmludGVkJylcbiAgICAgIHNweU9uKG9wdGlvbnMsICdvblByb2dyZXNzJylcblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBleHBlY3Qob3B0aW9ucy5maW5nZXJwcmludCkudG9IYXZlQmVlbkNhbGxlZCgpXG5cbiAgICAgIHZhciByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvdXBsb2FkJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdIRUFEJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1MZW5ndGgnOiAxMSxcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDMsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvdXBsb2FkJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1PZmZzZXQnXSkudG9CZSgzKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ10pLnRvQmUoJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nKVxuICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoMTEgLSAzKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxMSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWRcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDExLCAxMSlcbiAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL3VwbG9hZCcpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgcmVzdW1lIGEgcHJldmlvdXNseSBzdGFydGVkIHVwbG9hZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludCA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICBvblN1Y2Nlc3M6IHdhaXRhYmxlRnVuY3Rpb24oJ29uU3VjY2VzcycpLFxuICAgICAgICBvbkVycm9yICgpIHt9LFxuICAgICAgfVxuXG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIHZhciByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG5cbiAgICAgIHVwbG9hZC5hYm9ydCgpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDUsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0hFQUQnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA1LFxuICAgICAgICAgICdVcGxvYWQtTGVuZ3RoJzogMTEsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTEsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblN1Y2Nlc3MpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIG92ZXJyaWRlIHRoZSBQQVRDSCBtZXRob2QnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICB2YXIgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2sgICAgICAgICAgOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50ICAgICAgICAgICA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICB1cGxvYWRVcmwgICAgICAgICAgOiAnaHR0cDovL3R1cy5pby9maWxlcy91cGxvYWQnLFxuICAgICAgICBvdmVycmlkZVBhdGNoTWV0aG9kOiB0cnVlLFxuICAgICAgfVxuXG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvdXBsb2FkJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdIRUFEJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1MZW5ndGgnOiAxMSxcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDMsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvdXBsb2FkJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDMpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydYLUhUVFAtTWV0aG9kLU92ZXJyaWRlJ10pLnRvQmUoJ1BBVENIJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTEsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGVtaXQgYW4gZXJyb3IgaWYgYW4gdXBsb2FkIGlzIGxvY2tlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjayAgOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50ICAgOiAnaHR0cDovL3R1cy5pby91cGxvYWRzJyxcbiAgICAgICAgdXBsb2FkVXJsICA6ICdodHRwOi8vdHVzLmlvL2ZpbGVzL3VwbG9hZCcsXG4gICAgICAgIG9uRXJyb3IgICAgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvbkVycm9yJyksXG4gICAgICAgIHJldHJ5RGVsYXlzOiBudWxsLFxuICAgICAgfVxuXG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGNvbnN0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy91cGxvYWQnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0hFQUQnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDQyMywgLy8gTG9ja2VkXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uRXJyb3IudG9CZUNhbGxlZFxuICAgICAgZXhwZWN0KG9wdGlvbnMub25FcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgobmV3IEVycm9yKCd0dXM6IHVwbG9hZCBpcyBjdXJyZW50bHkgbG9ja2VkOyByZXRyeSBsYXRlciwgb3JpZ2luYXRlZCBmcm9tIHJlcXVlc3QgKG1ldGhvZDogSEVBRCwgdXJsOiBodHRwOi8vdHVzLmlvL2ZpbGVzL3VwbG9hZCwgcmVzcG9uc2UgY29kZTogNDIzLCByZXNwb25zZSB0ZXh0OiAsIHJlcXVlc3QgaWQ6IG4vYSknKSlcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBlbWl0IGFuIGVycm9yIGlmIG5vIExvY2F0aW9uIGhlYWRlciBpcyBwcmVzZW50ZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICB2YXIgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2sgIDogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludCAgIDogJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycsXG4gICAgICAgIG9uRXJyb3IgICAgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvbkVycm9yJyksXG4gICAgICAgIHJldHJ5RGVsYXlzOiBudWxsLFxuICAgICAgfVxuXG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGNvbnN0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcblxuICAgICAgLy8gVGhlIExvY2F0aW9uIGhlYWRlciBpcyBvbWl0dGVkIG9uIHB1cnBvc2UgaGVyZVxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDEsXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uRXJyb3IudG9CZUNhbGxlZFxuXG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChuZXcgRXJyb3IoJ3R1czogaW52YWxpZCBvciBtaXNzaW5nIExvY2F0aW9uIGhlYWRlciwgb3JpZ2luYXRlZCBmcm9tIHJlcXVlc3QgKG1ldGhvZDogUE9TVCwgdXJsOiBodHRwOi8vdHVzLmlvL3VwbG9hZHMsIHJlc3BvbnNlIGNvZGU6IDIwMSwgcmVzcG9uc2UgdGV4dDogLCByZXF1ZXN0IGlkOiBuL2EpJykpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgaWYgcmV0cnlEZWxheXMgaXMgbm90IGFuIGFycmF5JywgKCkgPT4ge1xuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwge1xuICAgICAgICBlbmRwb2ludCAgIDogJ2h0dHA6Ly9lbmRwb2ludC8nLFxuICAgICAgICByZXRyeURlbGF5czogNDQsXG4gICAgICB9KVxuICAgICAgZXhwZWN0KHVwbG9hZC5zdGFydC5iaW5kKHVwbG9hZCkpLnRvVGhyb3dFcnJvcigndHVzOiB0aGUgYHJldHJ5RGVsYXlzYCBvcHRpb24gbXVzdCBlaXRoZXIgYmUgYW4gYXJyYXkgb3IgbnVsbCcpXG4gICAgfSlcblxuICAgIC8vIFRoaXMgdGVzdHMgZW5zdXJlcyB0aGF0IHR1cy1qcy1jbGllbnQgY29ycmVjdGx5IHJldHJpZXMgaWYgdGhlXG4gICAgLy8gcmVzcG9uc2UgaGFzIHRoZSBjb2RlIDUwMCBJbnRlcm5hbCBFcnJvciwgNDIzIExvY2tlZCBvciA0MDkgQ29uZmxpY3QuXG4gICAgaXQoJ3Nob3VsZCByZXRyeSB0aGUgdXBsb2FkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrICA6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgICA6ICdodHRwOi8vdHVzLmlvL2ZpbGVzLycsXG4gICAgICAgIHJldHJ5RGVsYXlzOiBbMTAsIDEwLCAxMF0sXG4gICAgICAgIG9uU3VjY2VzcyAgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvblN1Y2Nlc3MnKSxcbiAgICAgIH1cblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzLycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzLycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogJy9maWxlcy9mb28nLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDQyMyxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0hFQUQnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAwLFxuICAgICAgICAgICdVcGxvYWQtTGVuZ3RoJzogMTEsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNDA5LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnSEVBRCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDAsXG4gICAgICAgICAgJ1VwbG9hZC1MZW5ndGgnOiAxMSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTEsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblN1Y2Nlc3MpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgIH0pXG5cbiAgICAvLyBUaGlzIHRlc3RzIGVuc3VyZXMgdGhhdCB0dXMtanMtY2xpZW50IGNvcnJlY3RseSByZXRyaWVzIGlmIHRoZVxuICAgIC8vIHJldHVybiB2YWx1ZSBvZiBvblNob3VsZFJldHJ5IGlzIHRydWUuXG4gICAgaXQoJ3Nob3VsZCByZXRyeSB0aGUgdXBsb2FkIHdoZW4gb25TaG91bGRSZXRyeSBzcGVjaWZpZWQgYW5kIHJldHVybnMgdHJ1ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjayAgICA6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgICAgIDogJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJyxcbiAgICAgICAgcmV0cnlEZWxheXMgIDogWzEwLCAxMCwgMTBdLFxuICAgICAgICBvblN1Y2Nlc3MgICAgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvblN1Y2Nlc3MnKSxcbiAgICAgICAgb25TaG91bGRSZXRyeTogKCkgPT4gdHJ1ZSxcbiAgICAgIH1cblxuICAgICAgc3B5T24ob3B0aW9ucywgJ29uU2hvdWxkUmV0cnknKS5hbmQuY2FsbFRocm91Z2goKVxuICAgICAgc3B5T24odHVzLlVwbG9hZC5wcm90b3R5cGUsICdfZW1pdEVycm9yJykuYW5kLmNhbGxUaHJvdWdoKClcblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzLycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzLycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogJy9maWxlcy9mb28nLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDQyMyxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0hFQUQnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAwLFxuICAgICAgICAgICdVcGxvYWQtTGVuZ3RoJzogMTEsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNDA5LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnSEVBRCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDAsXG4gICAgICAgICAgJ1VwbG9hZC1MZW5ndGgnOiAxMSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTEsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblN1Y2Nlc3MpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuXG4gICAgICBsZXQgZXJyb3IgPSB1cGxvYWQuX2VtaXRFcnJvci5jYWxscy5hcmdzRm9yKDApWzBdXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblNob3VsZFJldHJ5KS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uU2hvdWxkUmV0cnkuY2FsbHMuYXJnc0ZvcigwKSkudG9FcXVhbChbZXJyb3IsIDAsIHVwbG9hZC5vcHRpb25zXSlcbiAgICAgIGVycm9yID0gdXBsb2FkLl9lbWl0RXJyb3IuY2FsbHMuYXJnc0ZvcigxKVswXVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25TaG91bGRSZXRyeS5jYWxscy5hcmdzRm9yKDEpKS50b0VxdWFsKFtlcnJvciwgMSwgdXBsb2FkLm9wdGlvbnNdKVxuICAgIH0pXG5cbiAgICAvLyBUaGlzIHRlc3RzIGVuc3VyZXMgdGhhdCB0dXMtanMtY2xpZW50IGNvcnJlY3RseSBhYm9ydHMgaWYgdGhlXG4gICAgLy8gcmV0dXJuIHZhbHVlIG9mIG9uU2hvdWxkUmV0cnkgaXMgZmFsc2UuXG4gICAgaXQoJ3Nob3VsZCBub3QgcmV0cnkgdGhlIHVwbG9hZCB3aGVuIGNhbGxiYWNrIHNwZWNpZmllZCBhbmQgcmV0dXJucyBmYWxzZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjayAgICA6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgICAgIDogJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJyxcbiAgICAgICAgcmV0cnlEZWxheXMgIDogWzEwLCAxMCwgMTBdLFxuICAgICAgICBvblN1Y2Nlc3MgICAgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvblN1Y2Nlc3MnKSxcbiAgICAgICAgb25FcnJvciAgICAgIDogd2FpdGFibGVGdW5jdGlvbignb25FcnJvcicpLFxuICAgICAgICBvblNob3VsZFJldHJ5OiAoKSA9PiBmYWxzZSxcbiAgICAgIH1cblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBjb25zdCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcblxuICAgICAgLy8gVGhlIGVycm9yIGNhbGxiYWNrIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgdGhlIGZpcnN0IGVycm9yIHJlc3BvbnNlLlxuICAgICAgZXhwZWN0KG9wdGlvbnMub25FcnJvcikubm90LnRvSGF2ZUJlZW5DYWxsZWQoKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25FcnJvci50b0JlQ2FsbGVkXG5cbiAgICAgIGV4cGVjdChvcHRpb25zLm9uU3VjY2Vzcykubm90LnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25FcnJvcikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgbm90IHJldHJ5IGlmIHRoZSBlcnJvciBoYXMgbm90IGJlZW4gY2F1c2VkIGJ5IGEgcmVxdWVzdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjayAgOiBuZXcgVGVzdEh0dHBTdGFjaygpLFxuICAgICAgICBlbmRwb2ludCAgIDogJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJyxcbiAgICAgICAgcmV0cnlEZWxheXM6IFsxMCwgMTAsIDEwXSxcbiAgICAgICAgb25TdWNjZXNzICgpIHt9LFxuICAgICAgICBvbkVycm9yICgpIHt9LFxuICAgICAgfVxuXG4gICAgICBzcHlPbihvcHRpb25zLCAnb25TdWNjZXNzJylcbiAgICAgIHNweU9uKG9wdGlvbnMsICdvbkVycm9yJylcblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICBzcHlPbih1cGxvYWQsICdfY3JlYXRlVXBsb2FkJylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGF3YWl0IHdhaXQoMjAwKVxuXG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ2N1c3RvbSBlcnJvcicpXG4gICAgICB1cGxvYWQuX2VtaXRFcnJvcihlcnJvcilcblxuICAgICAgZXhwZWN0KHVwbG9hZC5fY3JlYXRlVXBsb2FkKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSlcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uRXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGVycm9yKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25TdWNjZXNzKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgc3RvcCByZXRyeWluZyBhZnRlciBhbGwgZGVsYXlzIGhhdmUgYmVlbiB1c2VkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrICA6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgICA6ICdodHRwOi8vdHVzLmlvL2ZpbGVzLycsXG4gICAgICAgIHJldHJ5RGVsYXlzOiBbMTBdLFxuICAgICAgICBvblN1Y2Nlc3MgKCkge30sXG4gICAgICAgIG9uRXJyb3IgICAgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvbkVycm9yJyksXG4gICAgICB9XG4gICAgICBzcHlPbihvcHRpb25zLCAnb25TdWNjZXNzJylcblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzLycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzLycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG5cbiAgICAgIC8vIFRoZSBlcnJvciBjYWxsYmFjayBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIHRoZSBmaXJzdCBlcnJvciByZXNwb25zZS5cbiAgICAgIGV4cGVjdChvcHRpb25zLm9uRXJyb3IpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKClcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uRXJyb3IudG9CZUNhbGxlZFxuXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblN1Y2Nlc3MpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uRXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHN0b3AgcmV0cnlpbmcgd2hlbiB0aGUgYWJvcnQgZnVuY3Rpb24gaXMgY2FsbGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrICA6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgICA6ICdodHRwOi8vdHVzLmlvL2ZpbGVzLycsXG4gICAgICAgIHJldHJ5RGVsYXlzOiBbMTBdLFxuICAgICAgICBvbkVycm9yICgpIHt9LFxuICAgICAgfVxuXG4gICAgICBzcHlPbihvcHRpb25zLCAnb25FcnJvcicpXG5cbiAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgY29uc3QgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzLycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG5cbiAgICAgIHNweU9uKHVwbG9hZCwgJ3N0YXJ0JykuYW5kLmNhbGxUaHJvdWdoKClcblxuICAgICAgdXBsb2FkLmFib3J0KClcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICB9KVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICB0ZXN0U3RhY2submV4dFJlcXVlc3QoKSxcbiAgICAgICAgd2FpdCgxMDApLFxuICAgICAgXSlcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSgndGltZWQgb3V0JylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBzdG9wIHVwbG9hZCB3aGVuIHRoZSBhYm9ydCBmdW5jdGlvbiBpcyBjYWxsZWQgZHVyaW5nIGEgY2FsbGJhY2snLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICB2YXIgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgOiAnaHR0cDovL3R1cy5pby9maWxlcy8nLFxuICAgICAgICBjaHVua1NpemU6IDUsXG4gICAgICAgIG9uQ2h1bmtDb21wbGV0ZSAoKSB7XG4gICAgICAgICAgdXBsb2FkLmFib3J0KClcbiAgICAgICAgfSxcbiAgICAgIH1cblxuICAgICAgc3B5T24ob3B0aW9ucywgJ29uQ2h1bmtDb21wbGV0ZScpLmFuZC5jYWxsVGhyb3VnaCgpXG5cbiAgICAgIGxldCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy8nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246ICcvZmlsZXMvZm9vJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogNSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgIHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpLFxuICAgICAgICB3YWl0KDIwMCksXG4gICAgICBdKVxuXG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkNodW5rQ29tcGxldGUpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSgndGltZWQgb3V0JylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBzdG9wIHVwbG9hZCB3aGVuIHRoZSBhYm9ydCBmdW5jdGlvbiBpcyBjYWxsZWQgZHVyaW5nIHRoZSBQT1NUIHJlcXVlc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICB2YXIgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgOiAnaHR0cDovL3R1cy5pby9maWxlcy8nLFxuICAgICAgICBvbkVycm9yICgpIHt9LFxuICAgICAgfVxuXG4gICAgICBzcHlPbihvcHRpb25zLCAnb25FcnJvcicpLmFuZC5jYWxsVGhyb3VnaCgpXG5cbiAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgY29uc3QgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzLycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG5cbiAgICAgIHVwbG9hZC5hYm9ydCgpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogJy9maWxlcy9mb28nLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCksXG4gICAgICAgIHdhaXQoMjAwKSxcbiAgICAgIF0pXG5cbiAgICAgIGV4cGVjdChvcHRpb25zLm9uRXJyb3IpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoJ3RpbWVkIG91dCcpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgcmVzZXQgdGhlIGF0dGVtcHQgY291bnRlciBpZiBhbiB1cGxvYWQgcHJvY2VlZHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICB2YXIgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2sgIDogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludCAgIDogJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJyxcbiAgICAgICAgcmV0cnlEZWxheXM6IFsxMF0sXG4gICAgICAgIG9uRXJyb3IgKCkge30sXG4gICAgICAgIG9uU3VjY2VzcyAgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvblN1Y2Nlc3MnKSxcbiAgICAgIH1cbiAgICAgIHNweU9uKG9wdGlvbnMsICdvbkVycm9yJylcblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzLycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogJy9maWxlcy9mb28nLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0hFQUQnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAwLFxuICAgICAgICAgICdVcGxvYWQtTGVuZ3RoJzogMTEsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDUsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnSEVBRCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDUsXG4gICAgICAgICAgJ1VwbG9hZC1MZW5ndGgnOiAxMSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTEsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkVycm9yKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblN1Y2Nlc3MpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgIH0pXG4gIH0pXG59KVxuIiwiY29uc3QgYXhpb3MgPSByZXF1aXJlKCdheGlvcycpXG5jb25zdCB7IGdldEJsb2IgfSA9IHJlcXVpcmUoJy4vaGVscGVycy91dGlscycpXG5jb25zdCB0dXMgPSByZXF1aXJlKCcuLi8uLicpXG5cbi8vIFRlc3QgdGltZW91dCBmb3IgZW5kLXRvLWVuZCB0ZXN0cyB3aGVuIHVwbG9hZGluZyB0byByZWFsIHNlcnZlci5cbmNvbnN0IEVORF9UT19FTkRfVElNRU9VVCA9IDIwICogMTAwMFxuXG5kZXNjcmliZSgndHVzJywgKCkgPT4ge1xuICBkZXNjcmliZSgnZW5kLXRvLWVuZCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHVwbG9hZCB0byBhIHJlYWwgdHVzIHNlcnZlcicsIGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHZhciBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBlbmRwb2ludDogJ2h0dHBzOi8vdHVzZC50dXNkZW1vLm5ldC9maWxlcy8nLFxuICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICBub25sYXRpbjogJ3PFgm/FhGNlJyxcbiAgICAgICAgICAgIG51bWJlciAgOiAxMDAsXG4gICAgICAgICAgICBmaWxlbmFtZTogJ2hlbGxvLnR4dCcsXG4gICAgICAgICAgICBmaWxldHlwZTogJ3RleHQvcGxhaW4nLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgb25TdWNjZXNzICgpIHtcbiAgICAgICAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b01hdGNoKC9eaHR0cHM6XFwvXFwvdHVzZFxcLnR1c2RlbW9cXC5uZXRcXC9maWxlc1xcLy8pXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnVXBsb2FkIFVSTDonLCB1cGxvYWQudXJsKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblxuICAgICAgICAgICAgcmVzb2x2ZSh1cGxvYWQpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkVycm9yIChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnIpXG4gICAgICAgICAgfSxcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgICB1cGxvYWQuc3RhcnQoKVxuICAgICAgfSlcbiAgICAgICAgLnRoZW4odmFsaWRhdGVVcGxvYWRDb250ZW50KVxuICAgICAgICAudGhlbigodXBsb2FkKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHVwbG9hZC5hYm9ydCh0cnVlKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gdXBsb2FkKVxuICAgICAgICB9KVxuICAgICAgICAudGhlbih2YWxpZGF0ZVVwbG9hZERlbGV0aW9uKVxuICAgIH0sIEVORF9UT19FTkRfVElNRU9VVClcblxuICAgIGl0KCdzaG91bGQgdXBsb2FkIHRvIGEgcmVhbCB0dXMgc2VydmVyIHdpdGggY3JlYXRpb24td2l0aC11cGxvYWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB2YXIgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgZW5kcG9pbnQ6ICdodHRwczovL3R1c2QudHVzZGVtby5uZXQvZmlsZXMvJyxcbiAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgbm9ubGF0aW46ICdzxYJvxYRjZScsXG4gICAgICAgICAgICBudW1iZXIgIDogMTAwLFxuICAgICAgICAgICAgZmlsZW5hbWU6ICdoZWxsby50eHQnLFxuICAgICAgICAgICAgZmlsZXR5cGU6ICd0ZXh0L3BsYWluJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uU3VjY2VzcyAoKSB7XG4gICAgICAgICAgICBleHBlY3QodXBsb2FkLnVybCkudG9NYXRjaCgvXmh0dHBzOlxcL1xcL3R1c2RcXC50dXNkZW1vXFwubmV0XFwvZmlsZXNcXC8vKVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1VwbG9hZCBVUkw6JywgdXBsb2FkLnVybCkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG5cbiAgICAgICAgICAgIHJlc29sdmUodXBsb2FkKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb25FcnJvciAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyKVxuICAgICAgICAgIH0sXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgICAgdXBsb2FkLnN0YXJ0KClcbiAgICAgIH0pXG4gICAgICAgIC50aGVuKHZhbGlkYXRlVXBsb2FkQ29udGVudClcbiAgICB9LCBFTkRfVE9fRU5EX1RJTUVPVVQpXG4gIH0pXG59KVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVVwbG9hZENvbnRlbnQgKHVwbG9hZCkge1xuICByZXR1cm4gYXhpb3MuZ2V0KHVwbG9hZC51cmwpXG4gICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgZXhwZWN0KHJlcy5zdGF0dXMpLnRvQmUoMjAwKVxuICAgICAgZXhwZWN0KHJlcy5kYXRhKS50b0JlKCdoZWxsbyB3b3JsZCcpXG5cbiAgICAgIHJldHVybiB2YWxpZGF0ZVVwbG9hZE1ldGFkYXRhKHVwbG9hZClcbiAgICB9KVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVVwbG9hZE1ldGFkYXRhICh1cGxvYWQpIHtcbiAgcmV0dXJuIGF4aW9zLmhlYWQodXBsb2FkLnVybCwge1xuICAgIGhlYWRlcnM6IHtcbiAgICAgICdUdXMtUmVzdW1hYmxlJzogJzEuMC4wJyxcbiAgICB9LFxuICB9KS50aGVuKChyZXMpID0+IHtcbiAgICBleHBlY3QocmVzLnN0YXR1cykudG9CZSgyMDApXG4gICAgZXhwZWN0KHJlcy5kYXRhKS50b0JlKCcnKVxuICAgIGV4cGVjdChyZXMuaGVhZGVyc1sndHVzLXJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgZXhwZWN0KHJlcy5oZWFkZXJzWyd1cGxvYWQtb2Zmc2V0J10pLnRvQmUoJzExJylcbiAgICBleHBlY3QocmVzLmhlYWRlcnNbJ3VwbG9hZC1sZW5ndGgnXSkudG9CZSgnMTEnKVxuXG4gICAgLy8gVGhlIHZhbHVlcyBpbiB0aGUgVXBsb2FkLU1ldGFkYXRhIGhlYWRlciBtYXkgbm90IGJlIGluIHRoZSBzYW1lXG4gICAgLy8gb3JkZXIgYXMgd2Ugc3VibWl0dGVkIHRoZW0gKHRoZSBzcGVjaWZpY2F0aW9uIGRvZXMgbm90IHJlcXVpcmVcbiAgICAvLyB0aGF0KS4gVGhlcmVmb3JlLCB3ZSBzcGxpdCB0aGUgdmFsdWVzIGFuZCB2ZXJpZnkgdGhhdCBlYWNoIG9uZVxuICAgIC8vIGlzIHByZXNlbnQuXG4gICAgdmFyIG1ldGFkYXRhU3RyID0gcmVzLmhlYWRlcnNbJ3VwbG9hZC1tZXRhZGF0YSddXG4gICAgZXhwZWN0KG1ldGFkYXRhU3RyKS50b0JlVHJ1dGh5KClcbiAgICB2YXIgbWV0YWRhdGEgPSBtZXRhZGF0YVN0ci5zcGxpdCgnLCcpXG4gICAgZXhwZWN0KG1ldGFkYXRhKS50b0NvbnRhaW4oJ2ZpbGVuYW1lIGFHVnNiRzh1ZEhoMCcpXG4gICAgZXhwZWN0KG1ldGFkYXRhKS50b0NvbnRhaW4oJ2ZpbGV0eXBlIGRHVjRkQzl3YkdGcGJnPT0nKVxuICAgIGV4cGVjdChtZXRhZGF0YSkudG9Db250YWluKCdub25sYXRpbiBjOFdDYjhXRVkyVT0nKVxuICAgIGV4cGVjdChtZXRhZGF0YSkudG9Db250YWluKCdudW1iZXIgTVRBdycpXG4gICAgZXhwZWN0KG1ldGFkYXRhLmxlbmd0aCkudG9CZSg0KVxuXG4gICAgcmV0dXJuIHVwbG9hZFxuICB9KVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVVwbG9hZERlbGV0aW9uICh1cGxvYWQpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPT09IDQwNFxuICB9XG5cbiAgcmV0dXJuIGF4aW9zLmdldCh1cGxvYWQudXJsLCB7IHZhbGlkYXRlU3RhdHVzIH0pXG4gICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgZXhwZWN0KHJlcy5zdGF0dXMpLnRvQmUoNDA0KVxuXG4gICAgICByZXR1cm4gdXBsb2FkXG4gICAgfSlcbn1cbiIsImNvbnN0IHsgVGVzdEh0dHBTdGFjaywgd2FpdGFibGVGdW5jdGlvbiwgd2FpdCwgZ2V0QmxvYiB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzL3V0aWxzJylcbmNvbnN0IHR1cyA9IHJlcXVpcmUoJy4uLy4uJylcblxuZGVzY3JpYmUoJ3R1cycsICgpID0+IHtcbiAgZGVzY3JpYmUoJ3BhcmFsbGVsIHVwbG9hZGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHRocm93IGlmIGluY29tcGF0aWJsZSBvcHRpb25zIGFyZSB1c2VkJywgKCkgPT4ge1xuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwge1xuICAgICAgICBlbmRwb2ludCAgICAgICA6ICdodHRwczovL3R1cy5pby91cGxvYWRzJyxcbiAgICAgICAgcGFyYWxsZWxVcGxvYWRzOiAyLFxuICAgICAgICB1cGxvYWRVcmwgICAgICA6ICdmb28nLFxuICAgICAgfSlcbiAgICAgIGV4cGVjdCh1cGxvYWQuc3RhcnQuYmluZCh1cGxvYWQpKS50b1Rocm93RXJyb3IoJ3R1czogY2Fubm90IHVzZSB0aGUgdXBsb2FkVXJsIG9wdGlvbiB3aGVuIHBhcmFsbGVsVXBsb2FkcyBpcyBlbmFibGVkJylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBzcGxpdCBhIGZpbGUgaW50byBtdWx0aXBsZSBwYXJ0cyBhbmQgY3JlYXRlIGFuIHVwbG9hZCBmb3IgZWFjaCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcblxuICAgICAgY29uc3QgdGVzdFVybFN0b3JhZ2UgPSB7XG4gICAgICAgIGFkZFVwbG9hZDogKGZpbmdlcnByaW50LCB1cGxvYWQpID0+IHtcbiAgICAgICAgICBleHBlY3QoZmluZ2VycHJpbnQpLnRvQmUoJ2ZpbmdlcnByaW50ZWQnKVxuICAgICAgICAgIGV4cGVjdCh1cGxvYWQudXBsb2FkVXJsKS50b0JlVW5kZWZpbmVkKClcbiAgICAgICAgICBleHBlY3QodXBsb2FkLnNpemUpLnRvQmUoMTEpXG4gICAgICAgICAgZXhwZWN0KHVwbG9hZC5wYXJhbGxlbFVwbG9hZFVybHMpLnRvRXF1YWwoW1xuICAgICAgICAgICAgJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMScsXG4gICAgICAgICAgICAnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyJyxcbiAgICAgICAgICBdKVxuXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgndHVzOjpmaW5nZXJwcmludGVkOjoxMzM3JylcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlVXBsb2FkOiAodXJsU3RvcmFnZUtleSkgPT4ge1xuICAgICAgICAgIGV4cGVjdCh1cmxTdG9yYWdlS2V5KS50b0JlKCd0dXM6OmZpbmdlcnByaW50ZWQ6OjEzMzcnKVxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICB9LFxuICAgICAgfVxuICAgICAgc3B5T24odGVzdFVybFN0b3JhZ2UsICdyZW1vdmVVcGxvYWQnKS5hbmQuY2FsbFRocm91Z2goKVxuICAgICAgc3B5T24odGVzdFVybFN0b3JhZ2UsICdhZGRVcGxvYWQnKS5hbmQuY2FsbFRocm91Z2goKVxuXG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrICAgICAgICAgICAgICAgICAgOiB0ZXN0U3RhY2ssXG4gICAgICAgIHVybFN0b3JhZ2UgICAgICAgICAgICAgICAgIDogdGVzdFVybFN0b3JhZ2UsXG4gICAgICAgIHN0b3JlRmluZ2VycHJpbnRGb3JSZXN1bWluZzogdHJ1ZSxcbiAgICAgICAgcmVtb3ZlRmluZ2VycHJpbnRPblN1Y2Nlc3MgOiB0cnVlLFxuICAgICAgICBwYXJhbGxlbFVwbG9hZHMgICAgICAgICAgICA6IDIsXG4gICAgICAgIHJldHJ5RGVsYXlzICAgICAgICAgICAgICAgIDogWzEwXSxcbiAgICAgICAgZW5kcG9pbnQgICAgICAgICAgICAgICAgICAgOiAnaHR0cHM6Ly90dXMuaW8vdXBsb2FkcycsXG4gICAgICAgIGhlYWRlcnMgICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgIEN1c3RvbTogJ2JsYXJnaCcsXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgZm9vOiAnaGVsbG8nLFxuICAgICAgICB9LFxuICAgICAgICBvblByb2dyZXNzICgpIHt9LFxuICAgICAgICBvblN1Y2Nlc3MgIDogd2FpdGFibGVGdW5jdGlvbigpLFxuICAgICAgICBmaW5nZXJwcmludDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCdmaW5nZXJwcmludGVkJyksXG4gICAgICB9XG4gICAgICBzcHlPbihvcHRpb25zLCAnb25Qcm9ncmVzcycpXG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnMuQ3VzdG9tKS50b0JlKCdibGFyZ2gnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTGVuZ3RoJ10pLnRvQmUoNSlcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1Db25jYXQnXSkudG9CZSgncGFydGlhbCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTWV0YWRhdGEnXSkudG9CZVVuZGVmaW5lZCgpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMScsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVycy5DdXN0b20pLnRvQmUoJ2JsYXJnaCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZSg2KVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUNvbmNhdCddKS50b0JlKCdwYXJ0aWFsJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1NZXRhZGF0YSddKS50b0JlVW5kZWZpbmVkKClcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiAnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG5cbiAgICAgIC8vIEFzc2VydCB0aGF0IHRoZSBVUkxzIGhhdmUgYmVlbiBzdG9yZWQuXG4gICAgICBleHBlY3QodGVzdFVybFN0b3JhZ2UuYWRkVXBsb2FkKS50b0hhdmVCZWVuQ2FsbGVkKClcblxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMScpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVycy5DdXN0b20pLnRvQmUoJ2JsYXJnaCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1PZmZzZXQnXSkudG9CZSgwKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ10pLnRvQmUoJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nKVxuICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoNSlcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogNSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzLkN1c3RvbSkudG9CZSgnYmxhcmdoJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDApXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSg2KVxuXG4gICAgICAvLyBSZXR1cm4gYW4gZXJyb3IgdG8gZW5zdXJlIHRoYXQgdGhlIGluZGl2aWR1YWwgcGFydGlhbCB1cGxvYWQgaXMgcHJvcGVybHkgcmV0cmllZC5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDInKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0hFQUQnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1MZW5ndGgnOiAxMSxcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDAsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMicpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVycy5DdXN0b20pLnRvQmUoJ2JsYXJnaCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1PZmZzZXQnXSkudG9CZSgwKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ10pLnRvQmUoJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nKVxuICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoNilcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogNixcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2FkcycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzLkN1c3RvbSkudG9CZSgnYmxhcmdoJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUxlbmd0aCddKS50b0JlVW5kZWZpbmVkKClcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1Db25jYXQnXSkudG9CZSgnZmluYWw7aHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxIGh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMicpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTWV0YWRhdGEnXSkudG9CZSgnZm9vIGFHVnNiRzg9JylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiAnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQzJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWRcblxuICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMycpXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg1LCAxMSlcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDExLCAxMSlcbiAgICAgIGV4cGVjdCh0ZXN0VXJsU3RvcmFnZS5yZW1vdmVVcGxvYWQpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGVtaXQgZXJyb3IgZnJvbSBhIHBhcnRpYWwgdXBsb2FkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjayAgICAgIDogdGVzdFN0YWNrLFxuICAgICAgICBwYXJhbGxlbFVwbG9hZHM6IDIsXG4gICAgICAgIHJldHJ5RGVsYXlzICAgIDogbnVsbCxcbiAgICAgICAgZW5kcG9pbnQgICAgICAgOiAnaHR0cHM6Ly90dXMuaW8vdXBsb2FkcycsXG4gICAgICAgIG9uRXJyb3IgICAgICAgIDogd2FpdGFibGVGdW5jdGlvbignb25FcnJvcicpLFxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgY29uc3QgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUxlbmd0aCddKS50b0JlKDUpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgfSlcblxuICAgICAgY29uc3QgZXJyID0gYXdhaXQgb3B0aW9ucy5vbkVycm9yLnRvQmVDYWxsZWRcbiAgICAgIGV4cGVjdChlcnIubWVzc2FnZSkudG9CZSgndHVzOiB1bmV4cGVjdGVkIHJlc3BvbnNlIHdoaWxlIGNyZWF0aW5nIHVwbG9hZCwgb3JpZ2luYXRlZCBmcm9tIHJlcXVlc3QgKG1ldGhvZDogUE9TVCwgdXJsOiBodHRwczovL3R1cy5pby91cGxvYWRzLCByZXNwb25zZSBjb2RlOiA1MDAsIHJlc3BvbnNlIHRleHQ6ICwgcmVxdWVzdCBpZDogbi9hKScpXG4gICAgICBleHBlY3QoZXJyLm9yaWdpbmFsUmVxdWVzdCkudG9CZShyZXEpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgcmVzdW1lIHRoZSBwYXJ0aWFsIHVwbG9hZHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrICAgICAgOiB0ZXN0U3RhY2ssXG4gICAgICAgIC8vIFRoZSBjbGllbnQgc2hvdWxkIHJlc3VtZSB0aGUgcGFyYWxsZWwgdXBsb2FkcywgZXZlbiBpZiBpdCBpcyBub3RcbiAgICAgICAgLy8gY29uZmlndXJlZCBmb3IgbmV3IHVwbG9hZHMuXG4gICAgICAgIHBhcmFsbGVsVXBsb2FkczogMSxcbiAgICAgICAgZW5kcG9pbnQgICAgICAgOiAnaHR0cHM6Ly90dXMuaW8vdXBsb2FkcycsXG4gICAgICAgIG9uUHJvZ3Jlc3MgKCkge30sXG4gICAgICAgIG9uU3VjY2VzcyAgICAgIDogd2FpdGFibGVGdW5jdGlvbigpLFxuICAgICAgfVxuICAgICAgc3B5T24ob3B0aW9ucywgJ29uUHJvZ3Jlc3MnKVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuXG4gICAgICB1cGxvYWQucmVzdW1lRnJvbVByZXZpb3VzVXBsb2FkKHtcbiAgICAgICAgdXJsU3RvcmFnZUtleSAgICAgOiAndHVzOjpmaW5nZXJwcmludDo6MTMzNycsXG4gICAgICAgIHBhcmFsbGVsVXBsb2FkVXJsczogW1xuICAgICAgICAgICdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDEnLFxuICAgICAgICAgICdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDInLFxuICAgICAgICBdLFxuICAgICAgfSlcblxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdIRUFEJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtTGVuZ3RoJzogNSxcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDIsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMicpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnSEVBRCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IDYsXG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAwLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDEnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcbiAgICAgIGV4cGVjdChyZXEuYm9keS5zaXplKS50b0JlKDMpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDUsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMicpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoNilcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogNixcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2FkcycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtQ29uY2F0J10pLnRvQmUoJ2ZpbmFsO2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMSBodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDInKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246ICdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDMnLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZFxuXG4gICAgICBleHBlY3QodXBsb2FkLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQzJylcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDUsIDExKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTEsIDExKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGFib3J0IGFsbCBwYXJ0aWFsIHVwbG9hZHMgYW5kIHJlc3VtZSBmcm9tIHRoZW0nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrICAgICAgOiB0ZXN0U3RhY2ssXG4gICAgICAgIHBhcmFsbGVsVXBsb2FkczogMixcbiAgICAgICAgZW5kcG9pbnQgICAgICAgOiAnaHR0cHM6Ly90dXMuaW8vdXBsb2FkcycsXG4gICAgICAgIG9uUHJvZ3Jlc3MgKCkge30sXG4gICAgICAgIG9uU3VjY2VzcyAgICAgIDogd2FpdGFibGVGdW5jdGlvbigpLFxuICAgICAgICBmaW5nZXJwcmludCAgICA6ICgpID0+IFByb21pc2UucmVzb2x2ZSgnZmluZ2VycHJpbnRlZCcpLFxuICAgICAgfVxuICAgICAgc3B5T24ob3B0aW9ucywgJ29uUHJvZ3Jlc3MnKVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2FkcycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZSg1KVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUNvbmNhdCddKS50b0JlKCdwYXJ0aWFsJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1NZXRhZGF0YSddKS50b0JlVW5kZWZpbmVkKClcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiAnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2FkcycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZSg2KVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUNvbmNhdCddKS50b0JlKCdwYXJ0aWFsJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1NZXRhZGF0YSddKS50b0JlVW5kZWZpbmVkKClcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiAnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHJlcTEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcTEudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDEnKVxuICAgICAgZXhwZWN0KHJlcTEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICBleHBlY3QocmVxMS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICBleHBlY3QocmVxMS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDApXG4gICAgICBleHBlY3QocmVxMS5yZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ10pLnRvQmUoJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nKVxuICAgICAgZXhwZWN0KHJlcTEuYm9keS5zaXplKS50b0JlKDUpXG5cbiAgICAgIGNvbnN0IHJlcTIgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcTIudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDInKVxuICAgICAgZXhwZWN0KHJlcTIubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICBleHBlY3QocmVxMi5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICBleHBlY3QocmVxMi5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDApXG4gICAgICBleHBlY3QocmVxMi5yZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ10pLnRvQmUoJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nKVxuICAgICAgZXhwZWN0KHJlcTIuYm9keS5zaXplKS50b0JlKDYpXG5cbiAgICAgIHVwbG9hZC5hYm9ydCgpXG5cbiAgICAgIHJlcTEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA1LFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxMi5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDYsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICAvLyBObyBmdXJ0aGVyIHJlcXVlc3RzIHNob3VsZCBiZSBzZW50LlxuICAgICAgY29uc3QgcmVxUHJvbWlzZSA9IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICByZXFQcm9taXNlLFxuICAgICAgICB3YWl0KDEwMCksXG4gICAgICBdKVxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSgndGltZWQgb3V0JylcblxuICAgICAgLy8gUmVzdGFydCB0aGUgdXBsb2FkXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICAvLyBSZXVzZSB0aGUgcHJvbWlzZSBmcm9tIGJlZm9yZSBhcyBpdCBpcyBub3QgY2FuY2VsbGVkLlxuICAgICAgcmVxID0gYXdhaXQgcmVxUHJvbWlzZVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMScpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnSEVBRCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IDUsXG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA1LFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDInKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0hFQUQnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1MZW5ndGgnOiA2LFxuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogNixcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2FkcycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZVVuZGVmaW5lZCgpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtQ29uY2F0J10pLnRvQmUoJ2ZpbmFsO2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMSBodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDInKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246ICdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDMnLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZFxuXG4gICAgICBleHBlY3QodXBsb2FkLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQzJylcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDUsIDExKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTEsIDExKVxuICAgIH0pXG4gIH0pXG59KVxuIiwiLyogZ2xvYmFsIGV4cGVjdEFzeW5jICovXG5jb25zdCB7IFRlc3RIdHRwU3RhY2ssIGdldEJsb2IgfSA9IHJlcXVpcmUoJy4vaGVscGVycy91dGlscycpXG5jb25zdCB0dXMgPSByZXF1aXJlKCcuLi8uLicpXG5cbmRlc2NyaWJlKCd0dXMnLCAoKSA9PiB7XG4gIGRlc2NyaWJlKCd0ZXJtaW5hdGUgdXBsb2FkJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgdGVybWluYXRlIHVwbG9hZCB3aGVuIGFib3J0IGlzIGNhbGxlZCB3aXRoIHRydWUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgYWJvcnRQcm9taXNlXG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICB2YXIgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgOiAnaHR0cDovL3R1cy5pby9maWxlcy8nLFxuICAgICAgICBjaHVua1NpemU6IDUsXG4gICAgICAgIG9uQ2h1bmtDb21wbGV0ZSAoKSB7XG4gICAgICAgICAgYWJvcnRQcm9taXNlID0gdXBsb2FkLmFib3J0KHRydWUpXG4gICAgICAgIH0sXG4gICAgICB9XG5cbiAgICAgIHNweU9uKG9wdGlvbnMsICdvbkNodW5rQ29tcGxldGUnKS5hbmQuY2FsbFRocm91Z2goKVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy8nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246ICcvZmlsZXMvZm9vJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogNSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0RFTEVURScpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgfSlcblxuICAgICAgZXhwZWN0KG9wdGlvbnMub25DaHVua0NvbXBsZXRlKS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICAgIGF3YWl0IGFib3J0UHJvbWlzZVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHJldHJ5IHRlcm1pbmF0ZSB3aGVuIGFuIGVycm9yIGlzIHJldHVybmVkIG9uIGZpcnN0IHRyeScsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBhYm9ydFByb21pc2VcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjayAgOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50ICAgOiAnaHR0cDovL3R1cy5pby9maWxlcy8nLFxuICAgICAgICBjaHVua1NpemUgIDogNSxcbiAgICAgICAgcmV0cnlEZWxheXM6IFsxMCwgMTAsIDEwXSxcbiAgICAgICAgb25DaHVua0NvbXBsZXRlICgpIHtcbiAgICAgICAgICBhYm9ydFByb21pc2UgPSB1cGxvYWQuYWJvcnQodHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgIH1cblxuICAgICAgc3B5T24ob3B0aW9ucywgJ29uQ2h1bmtDb21wbGV0ZScpLmFuZC5jYWxsVGhyb3VnaCgpXG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzLycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogJy9maWxlcy9mb28nLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA1LFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnREVMRVRFJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA0MjMsXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdERUxFVEUnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IGFib3J0UHJvbWlzZVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25DaHVua0NvbXBsZXRlKS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBzdG9wIHJldHJ5aW5nIHdoZW4gYWxsIGRlbGF5cyBhcmUgdXNlZCB1cCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2sgIDogdGVzdFN0YWNrLFxuICAgICAgICByZXRyeURlbGF5czogWzEwLCAxMF0sXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRlcm1pbmF0ZVByb21pc2UgPSB0dXMuVXBsb2FkLnRlcm1pbmF0ZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nLCBvcHRpb25zKVxuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnREVMRVRFJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdERUxFVEUnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0RFTEVURScpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgfSlcblxuICAgICAgYXdhaXQgZXhwZWN0QXN5bmModGVybWluYXRlUHJvbWlzZSkudG9CZVJlamVjdGVkV2l0aEVycm9yKC90dXM6IHVuZXhwZWN0ZWQgcmVzcG9uc2Ugd2hpbGUgdGVybWluYXRpbmcgdXBsb2FkLylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBpbnZva2UgdGhlIHJlcXVlc3QgYW5kIHJlc3BvbnNlIFByb21pc2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBvbkJlZm9yZVJlcXVlc3QgKHJlcSkge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGV4cGVjdChyZXEuZ2V0VVJMKCkpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9mb28nKVxuICAgICAgICAgICAgZXhwZWN0KHJlcS5nZXRNZXRob2QoKSkudG9CZSgnREVMRVRFJylcbiAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIG9uQWZ0ZXJSZXNwb25zZSAocmVxLCByZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBleHBlY3QocmVxLmdldFVSTCgpKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvZm9vJylcbiAgICAgICAgICAgIGV4cGVjdChyZXEuZ2V0TWV0aG9kKCkpLnRvQmUoJ0RFTEVURScpXG4gICAgICAgICAgICBleHBlY3QocmVzLmdldFN0YXR1cygpKS50b0JlKDIwNClcbiAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgICBzcHlPbihvcHRpb25zLCAnb25CZWZvcmVSZXF1ZXN0JylcbiAgICAgIHNweU9uKG9wdGlvbnMsICdvbkFmdGVyUmVzcG9uc2UnKVxuXG4gICAgICBjb25zdCB0ZXJtaW5hdGVQcm9taXNlID0gdHVzLlVwbG9hZC50ZXJtaW5hdGUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9mb28nLCBvcHRpb25zKVxuXG4gICAgICBjb25zdCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0RFTEVURScpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgfSlcblxuICAgICAgYXdhaXQgZXhwZWN0QXN5bmModGVybWluYXRlUHJvbWlzZSkudG9CZVJlc29sdmVkKClcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uQmVmb3JlUmVxdWVzdCkudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkFmdGVyUmVzcG9uc2UpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgIH0pXG4gIH0pXG59KVxuIl19
