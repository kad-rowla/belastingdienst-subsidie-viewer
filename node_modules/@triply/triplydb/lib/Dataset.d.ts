/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { Models, Routes } from "@triply/utils";
import App from "./App.js";
import Service from "./Service.js";
import * as stream from "stream";
import * as n3 from "n3";
import { Account } from "./Account.js";
import AsyncIteratorHelper from "./utils/AsyncIteratorHelper.js";
import Asset from "./Asset.js";
import Graph from "./Graph.js";
import { NamedNode } from "rdf-js";
type JobDefaultsConfig = Omit<Routes.datasets._account._dataset.jobs.Post["Req"]["Body"], "type" | "url" | "downloadUrls">;
interface ImportFromDatasetArgs {
    graphMap?: {
        [from: string]: string | Graph | NamedNode;
    };
    graphNames?: Array<string | Graph | NamedNode>;
    overwrite?: boolean;
}
export type Prefixes = {
    [label: string]: n3.PrefixedToIri | string | NamedNode;
};
type DsResourceType = "assets" | "graphs" | "services";
export type NewService = NewServiceVirtuoso | NewServiceElasticsearch | NewServiceJena;
type NewServiceVirtuoso = {
    type: "virtuoso";
    config?: never;
};
type NewServiceElasticsearch = {
    type: "elasticSearch";
    config?: Models.ServiceConfigElastic;
};
type NewServiceJena = {
    type: "jena";
    config?: Models.ServiceConfigJena;
};
export default class Dataset {
    private _app;
    private _info?;
    private _owner;
    private _lastJob?;
    private _name;
    private _allPrefixes;
    readonly type = "Dataset";
    constructor(app: App, owner: Account, datasetName: string, datasetInfo?: Models.Dataset);
    getServices(): AsyncIteratorHelper<Models.ServiceMetadata, Service>;
    getService<T extends Dataset>(this: T, serviceName: string): Promise<Service>;
    clear(resourceType: DsResourceType, ...rest: DsResourceType[]): Promise<this>;
    getGraph(graphNameOrIri: string | NamedNode): Promise<Graph>;
    deleteGraph(graphNameOrIri: string | NamedNode): Promise<void>;
    private _setInfo;
    private _getDatasetPath;
    private _getDatasetNameWithOwner;
    getInfo(refresh?: boolean): Promise<Models.Dataset>;
    getAsset(assetName: string, versionNumber?: number): Promise<Asset>;
    getAssets(): AsyncIteratorHelper<Models.Asset, Asset>;
    getGraphs(): AsyncIteratorHelper<Models.Graph, Graph>;
    private _getDownloadPath;
    graphsToFile(destinationPath: string, opts?: {
        compressed?: boolean;
        graph?: Graph;
    }): Promise<void>;
    graphsToStream(type: "compressed" | "rdf-js", opts?: {
        graph?: Graph;
        extension?: string;
    }): Promise<stream.Readable>;
    graphsToStore(graph?: Graph): Promise<n3.Store>;
    importFromDataset(fromDataset: Dataset, args?: ImportFromDatasetArgs): Promise<Models.Imports>;
    update(config: Models.UpdateDataset): Promise<this>;
    copy(toAccountName: string, newDatasetName?: string): Promise<Dataset>;
    renameGraph(from: string, to: string): Promise<Graph>;
    delete(): Promise<void>;
    setAvatar(pathBufferOrFile: string | Buffer | File): Promise<this>;
    private _throwIfJobRunning;
    importFromFiles(files: File[] | string[], defaultsConfig?: JobDefaultsConfig): Promise<Dataset>;
    importFromStore(store: n3.Store, opts?: JobDefaultsConfig): Promise<Dataset>;
    importFromUrls(urls: string[], defaultConfig?: JobDefaultsConfig): Promise<Dataset>;
    describe(iri: string | NamedNode): Promise<n3.Quad[]>;
    getStatements(payload: {
        subject?: string;
        predicate?: string;
        object?: string;
        graph?: string;
    }): AsyncIteratorHelper<Models.NtriplyStatement, Models.NtriplyStatement>;
    uploadAsset(fileOrPath: string | File, assetName?: string): Promise<Asset>;
    addService(name: string, opts?: NewService): Promise<Service>;
    ensureService<T extends Dataset>(this: T, name: string, args?: NewService): Promise<Service>;
    addPrefixes(newPrefixes: Prefixes): Promise<{
        [prefixLabel: string]: string;
    }>;
    /**
     * Remove prefixes defined at the dataset level
     */
    removePrefixes(prefixLabels: string[]): Promise<{
        [prefixLabel: string]: string;
    }>;
    /**
     * Getting _all_ prefixes (not just the dataset-scoped ones)
     */
    getPrefixes(refresh?: boolean): Promise<{
        [prefixLabel: string]: string;
    }>;
    nde: {
        datasetregister: {
            /**
             * Register this dataset with the [NDE Dataset register](https://datasetregister.netwerkdigitaalerfgoed.nl/)
             *
             * @param rejectOnValidationError an optional boolean (default = true) indicating that SHACL validation errors should throw an Error.
             *                                If false, the function will not throw but return a Stroe containng the SHACL validation report.
             * @example
             * ```ts
             * App.get(token)
             *   .getAccount(accountName)
             *   .then(account => account.getDataset(datasetName))
             *   .then(dataset => dataset.nde.datasetregister.submit())
             * ```
             */
            submit: (rejectOnValidationError?: boolean) => Promise<n3.Quad[]>;
            /**
             * Validate this dataset against the [NDE Dataset register](https://datasetregister.netwerkdigitaalerfgoed.nl/)
             *
             * @param rejectOnValidationError an optional boolean (default = true) indicating that SHACL validation errors should throw an Error.
             *                                If false, the function will not throw but return a Stroe containng the SHACL validation report.
             * @example
             * ```ts
             * App.get(token)
             *   .getAccount(accountName)
             *   .then(account => account.getDataset(datasetName))
             *   .then(dataset => dataset.nde.datasetregister.submit())
             * ```
             */
            validate: (rejectOnValidationError?: boolean) => Promise<n3.Quad[]>;
        };
    };
}
interface JobConfig extends JobDefaultsConfig {
    app: App;
    datasetPath: string;
    datasetNameWithOwner: string;
}
export declare class JobUpload {
    private _config;
    private _info?;
    private jobUrl?;
    private urlMapper;
    constructor(conf: JobConfig);
    getJobUrl(): string;
    create(): Promise<this>;
    info(): Models.Job;
    private uploadFile;
    uploadFiles(files: string[] | File[]): Promise<this>;
    private refresh;
    exec(): Promise<void>;
}
export {};
//# sourceMappingURL=Dataset.d.ts.map