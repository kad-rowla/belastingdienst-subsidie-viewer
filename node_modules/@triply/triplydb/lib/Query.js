import { parseAndInjectVariablesIntoQuery, validate } from "@triply/utils/sparqlVarUtils.js";
import { _get, _patch, _delete, _post } from "./RequestHandler.js";
import { getErr } from "./utils/Error.js";
import * as n3 from "n3";
import sparqljs from "sparqljs";
import { stringify as stringifyQueryObj } from "query-string";
import AsyncIteratorHelperWithToFile from "./utils/AsyncIteratorHelperWithToFile.js";
export default class Query {
    constructor(app, info, owner) {
        this.type = "Query";
        this._app = app;
        this._info = info;
        this._owner = owner;
    }
    _getQueryType() {
        const queryString = this["_info"].requestConfig?.payload.query;
        if (!queryString)
            throw getErr(`Query ${this._info.name} has no versions.`);
        const parser = new sparqljs.Parser();
        const parsed = parser.parse(queryString);
        if (parsed.type === "query") {
            return parsed.queryType;
        }
        else {
            throw getErr("Update-queries are not supported");
        }
    }
    async _getPath(opts) {
        const accountName = (await this._owner.getInfo()).accountName;
        const pathChunks = ["queries", accountName, this._info.name];
        if (!opts?.ignoreVersion && typeof this._version === "number") {
            pathChunks.push(String(this._version));
        }
        return "/" + pathChunks.join("/");
    }
    async _getQueryNameWithOwner() {
        const ownerName = (await this._owner.getInfo()).accountName;
        return `${ownerName}/${this._info.name}`;
    }
    async getInfo(refresh = false) {
        if (!refresh && this._info)
            return this._info;
        this._info = (await _get({
            errorWithCleanerStack: getErr(`Failed to get information of query ${await this._getQueryNameWithOwner()}.`),
            app: this._app,
            path: await this._getPath(),
        }));
        return this._info;
    }
    async addVersion(args) {
        await this.useVersion("latest");
        let { requestConfig, renderConfig, variables } = await this.getInfo();
        // In theory, a saved query may not have a query string if that query is created via the UI
        // We're catering for that by setting a default below
        if (!requestConfig?.payload.query) {
            requestConfig = {
                payload: {
                    query: "select * where {?sub ?pred ?obj}",
                },
            };
        }
        if (args.output) {
            renderConfig = { output: args.output };
        }
        if (args.queryString) {
            requestConfig = {
                payload: {
                    query: args.queryString,
                },
            };
        }
        if (args.variables) {
            variables = args.variables;
        }
        const updateQueryInfo = {
            requestConfig,
            renderConfig,
            variables,
        };
        await _post({
            app: this._app,
            errorWithCleanerStack: getErr(`Failed to add a new version to query '${this["_info"].name}'`),
            data: updateQueryInfo,
            path: await this._getPath(),
        });
        return this;
    }
    _setInfo(info) {
        this._info = info;
        return this;
    }
    async useVersion(version) {
        const numVersions = this._info.numberOfVersions;
        if (!numVersions)
            throw getErr(`Query ${this._info.name} has no versions.`);
        if (version === "latest") {
            this._version = undefined;
            return this;
        }
        if (version > numVersions || version < 0) {
            throw getErr(`Query ${this._info.name} has ${numVersions} ${numVersions > 1 ? "versions" : "version"}. Version ${version} does not exist.`);
        }
        this._version = version;
        await this.getInfo(true);
        return this;
    }
    async update(config) {
        const updateData = { ...config };
        if (!updateData.dataset) {
            updateData.dataset = this._info.dataset?.id;
        }
        this._setInfo(await _patch({
            errorWithCleanerStack: getErr(`Failed to update query information of ${this._info.name}.`),
            app: this._app,
            path: await this._getPath({ ignoreVersion: true }),
            data: updateData,
        }));
        return this;
    }
    async delete() {
        await _delete({
            errorWithCleanerStack: getErr(`Failed to delete query ${this._info.name}.`),
            app: this._app,
            path: await this._getPath({ ignoreVersion: true }),
            expectedResponseBody: "empty",
        });
    }
    async getString(variableValues) {
        const info = await this.getInfo();
        if (!info.requestConfig?.payload.query) {
            throw getErr(`Query ${this._info.name} has no versions.`);
        }
        if (!info.variables)
            return info.requestConfig.payload.query;
        validate({ variableDefinitions: info.variables, variableValues: variableValues || {} });
        return parseAndInjectVariablesIntoQuery(info.requestConfig.payload.query, {
            variableDefinitions: info.variables,
            variableValues: variableValues || {},
        });
    }
    async getApiUrl(subpath) {
        return this._app["getPostProcessedApiUrl"]((await this.getInfo()).link + subpath);
    }
    async getRunLink() {
        return this.getApiUrl("/run");
    }
    results(variables, opts) {
        const queryType = this._getQueryType();
        const variablesInUrlString = stringifyQueryObj({
            page: 1,
            pageSize: 5000,
            ...(variables || {}),
        });
        if (opts?.cache) {
            opts.cache.cacheId = this._info.id;
        }
        const iteratorOptions = {
            potentialFutureError: getErr(`Failed to run query`),
            getErrorMessage: async () => `Failed to get results for query ${await this.getInfo().then((i) => i.name)}.`,
            app: this._app,
            cache: opts?.cache,
        };
        const getAsyncIteratorHelperWithToFile = (mapResult) => {
            return new AsyncIteratorHelperWithToFile({
                ...iteratorOptions,
                isBindings: true,
                mapResult,
                getUrl: async (contentType) => this._app["_config"].url +
                    ((await this._getPath()) + `/run${contentType ? "." + contentType : ""}?` + variablesInUrlString),
            });
        };
        return {
            statements: () => {
                if (queryType !== "CONSTRUCT" && queryType !== "DESCRIBE") {
                    throw getErr(`Statements are only supported for CONSTRUCT and DESCRIBE queries (got ${queryType}).`);
                }
                const parser = new n3.Parser();
                return new AsyncIteratorHelperWithToFile({
                    ...iteratorOptions,
                    mapResult: async (result) => result,
                    getUrl: async () => this._app["_config"].url + ((await this._getPath()) + "/run.nt?" + variablesInUrlString),
                    parsePage: async (page) => {
                        if (page === "OK")
                            return []; // empty page (jena);
                        // empty page (virtuoso) is a valid empty turtle doc, no check needed.
                        return parser.parse(page);
                    },
                });
            },
            boolean: () => {
                if (queryType !== "ASK") {
                    throw getErr(`Bindings are only supported for ASK queries (got ${queryType}).`);
                }
                return getAsyncIteratorHelperWithToFile((result) => Promise.resolve(result.boolean));
            },
            bindings: () => {
                if (queryType !== "SELECT") {
                    throw getErr(`Bindings are only supported for SELECT queries (got ${queryType}).`);
                }
                return getAsyncIteratorHelperWithToFile((result) => Promise.resolve(result));
            },
        };
    }
}
//# sourceMappingURL=Query.js.map