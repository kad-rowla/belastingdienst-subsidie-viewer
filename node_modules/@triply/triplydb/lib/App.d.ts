import { Models } from "@triply/utils";
import User from "./User.js";
import { Account } from "./Account.js";
import Org from "./Org.js";
import AsyncIteratorHelper from "./utils/AsyncIteratorHelper.js";
export interface AppConfig {
    /**
     * Token
     */
    token?: string;
    /**
     * Api URL
     */
    url?: string;
    /**
     * HTTP proxy
     */
    httpProxy?: string;
    /**
     * HTTPS proxy
     */
    httpsProxy?: string;
}
export default class App {
    private _config;
    private _info?;
    private constructor();
    getConfig(): Omit<AppConfig, "url"> & Required<Pick<AppConfig, "url">>;
    getInfo(): Promise<Models.ClientConfig>;
    getAccount(accountName?: string): Promise<User | Org>;
    getAccounts(): AsyncIteratorHelper<Models.Account, Account>;
    getUser(accountName?: string): Promise<User>;
    getOrganization(accountName: string): Promise<Org>;
    isCompatible(minimumVersion: string): Promise<boolean>;
    /**
     * There may be situations where we access the API via a different domain. E.g., we may
     * host TriplyDB on one domain, but have an ETL access it directly in the kubernetes cluster to avoid latency.
     * In that case we want the TriplyDB-API to post-process link headers from the API, so that we send a next page to
     * the correct location
     */
    private getPostProcessedApiUrl;
    /**
     * Get a TriplyDB-JS instance.
     */
    static get(conf?: AppConfig | string): App;
}
//# sourceMappingURL=App.d.ts.map