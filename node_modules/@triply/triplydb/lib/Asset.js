import * as tus from "@triply/tus-js-client";
import { _delete, _get, getFetchOpts } from "./RequestHandler.js";
import pumpify from "pumpify";
import fetch from "cross-fetch";
import { getErr } from "./utils/Error.js";
import fs from "fs-extra";
import { omit, last } from "lodash-es";
export default class Asset {
    constructor(dataset, info, selectedVersion) {
        this._deleted = false;
        this.type = "Asset";
        this._info = info;
        this._dataset = dataset;
        this._app = dataset["_app"];
        if (selectedVersion !== undefined) {
            this.selectVersion(selectedVersion);
        }
    }
    async _getUrl(versionInfo) {
        if (this._deleted)
            throw getErr("This asset does not exist.");
        const urlparts = [
            this._app["_config"].url,
            await this._dataset["_getDatasetPath"](),
            "/assets",
            `/${this._info.identifier}`,
        ];
        if (versionInfo)
            urlparts.push(`/${versionInfo.id}`);
        return urlparts.join("");
    }
    async toFile(destinationPath, versionNumber) {
        if (this._deleted)
            throw getErr("This asset does not exist.");
        if (versionNumber === undefined)
            versionNumber = this._selectedVersion;
        const url = await this._getUrl(versionNumber === undefined ? this._getLastVersionInfo() : this.getVersionInfo(versionNumber));
        const res = await fetch(url, getFetchOpts({
            method: "get",
        }, { app: this._app }));
        const stream = new pumpify(res.body, fs.createWriteStream(destinationPath));
        await new Promise((resolve, reject) => {
            stream.on("error", reject);
            stream.on("finish", resolve);
        });
    }
    async toStream(versionNumber) {
        if (this._deleted)
            throw getErr("This asset does not exist.");
        if (versionNumber === undefined)
            versionNumber = this._selectedVersion;
        const url = await this._getUrl(versionNumber === undefined ? undefined : this.getVersionInfo(versionNumber));
        const res = await fetch(url, getFetchOpts({
            method: "get",
        }, { app: this._app }));
        return res.body;
    }
    _getLastVersionInfo() {
        if (this._deleted)
            throw getErr("This asset does not exist.");
        const lastVersion = last(this._info.versions);
        if (!lastVersion)
            throw getErr("This asset has no versions");
        return lastVersion;
    }
    getVersionInfo(versionNumber) {
        if (this._deleted)
            throw getErr("This asset does not exist.");
        const version = this._info.versions[versionNumber];
        if (!version)
            throw getErr(`This asset has no version ${versionNumber}`);
        return version;
    }
    getInfo(versionNumber) {
        if (this._deleted)
            throw getErr("This asset does not exist.");
        if (versionNumber === undefined)
            versionNumber = this._selectedVersion;
        let versionInfo = versionNumber === undefined ? this._getLastVersionInfo() : this.getVersionInfo(versionNumber);
        return { ...this._info, ...omit(versionInfo, "id") };
    }
    async refreshInfo() {
        this._info = (await _get({
            errorWithCleanerStack: getErr(`Failed to get refresh info for asset '${this._info.assetName}' from dataset ${await this._dataset["_getDatasetNameWithOwner"]()}.`),
            app: this._app,
            path: await this._dataset["_getDatasetPath"]("/assets"),
            query: { fileName: this._info.assetName },
        }));
        return this;
    }
    selectVersion(versionNumber) {
        if (!this.getInfo().versions[versionNumber])
            throw getErr(`Tried to select version ${versionNumber} but asset '${this.getInfo().assetName}' only has ${this.getInfo().versions.length} versions. (version numbering starts at 0) `);
        this._selectedVersion = versionNumber;
        return this;
    }
    async addVersion(fileOrPath) {
        if (this._deleted)
            throw getErr("This asset does not exist.");
        await Asset.uploadAsset({
            fileOrPath,
            assetName: this._info.assetName,
            dataset: this._dataset,
            versionOf: this._info.identifier,
        });
        await this.refreshInfo();
        return this;
    }
    async delete(versionNumber) {
        if (this._deleted)
            throw getErr("This asset does not exist.");
        if (versionNumber === undefined)
            versionNumber = this._selectedVersion;
        const dsInfo = await this._dataset.getInfo();
        await _delete({
            app: this._app,
            url: await this._getUrl(versionNumber === undefined ? undefined : this.getVersionInfo(versionNumber)),
            errorWithCleanerStack: getErr(`Failed to delete asset ${this._info.assetName} in dataset ${dsInfo.owner.accountName}/${dsInfo.name}.`),
            expectedResponseBody: "empty",
        });
        if (versionNumber === undefined || (versionNumber === 0 && this.getInfo().versions.length === 1)) {
            //deleting everything
            this._deleted = true;
        }
        else {
            if (this._selectedVersion !== undefined) {
                //update the selected version
                if (this._selectedVersion === versionNumber) {
                    this._selectedVersion = undefined; //just use the latest
                }
                else if (this._selectedVersion > versionNumber) {
                    this._selectedVersion = this._selectedVersion - 1;
                }
            }
            await this.refreshInfo();
            return this;
        }
    }
    static async uploadAsset(opts) {
        let rs;
        let fileSize;
        if (typeof opts.fileOrPath === "string") {
            if (fs.createReadStream === undefined) {
                throw getErr('"fs" is not loaded in this environment, use a "File" instead');
            }
            rs = fs.createReadStream(opts.fileOrPath);
            fileSize = (await fs.stat(opts.fileOrPath)).size;
        }
        else {
            rs = opts.fileOrPath;
            fileSize = opts.fileOrPath.size;
        }
        const metadata = {};
        if (opts.assetName)
            metadata.filename = opts.assetName;
        if (opts.versionOf)
            metadata.versionOf = opts.versionOf;
        const info = await opts.dataset.getInfo();
        return new Promise((resolve, reject) => {
            const upload = new tus.Upload(rs, {
                endpoint: `${opts.dataset["_app"]["_config"].url}/datasets/${info.owner.accountName}/${info.name}/assets/add`,
                metadata,
                headers: { Authorization: "Bearer " + opts.dataset["_app"]["_config"].token },
                chunkSize: 5 * 1024 * 1024,
                retryDelays: [2000, 3000, 5000, 10000, 20000],
                uploadSize: fileSize,
                onError: reject,
                onProgress: (_bytesUploaded, _bytesTotal) => { },
                onSuccess: (stringifiedJson) => {
                    if (stringifiedJson === "")
                        return reject(getErr("No response or upload already finished"));
                    try {
                        resolve(JSON.parse(stringifiedJson));
                    }
                    catch (e) {
                        if (e instanceof SyntaxError) {
                            return reject(getErr(`Unexpected response: ${stringifiedJson}`).setCause(e));
                        }
                        return reject(e);
                    }
                },
            });
            upload.start();
        });
    }
}
//# sourceMappingURL=Asset.js.map