import parseLinkHeader from "parse-link-header";
import { requestConfigToFetchConfig } from "../RequestHandler.js";
import { TriplyDbJsError } from "./Error.js";
import fetch from "cross-fetch";
import { isEqual } from "lodash-es";
if (!Symbol.asyncIterator) {
    Symbol.asyncIterator = Symbol.for("Symbol.asyncIterator");
}
export default class AsyncIteratorHelper {
    constructor(conf) {
        this._currentPage = [];
        this._config = conf;
    }
    async possiblyCachedResults(url, reqConfig) {
        if (this._config.cache) {
            try {
                const cached = await this._config.cache.read({ url, config: reqConfig });
                if (cached) {
                    return cached;
                }
            }
            catch (e) {
                if ("message" in e) {
                    e.message = "Error while reading from the cache: " + e.message;
                }
                throw e;
            }
        }
        const res = await fetch(url, reqConfig);
        const statusCode = res.status;
        const responseText = await res.text();
        const contentType = res.headers.get("content-type");
        const linkHeaders = parseLinkHeader(res.headers.get("link") || "");
        const nextPage = linkHeaders?.["next"] && linkHeaders["next"].url
            ? this._config.app["getPostProcessedApiUrl"](linkHeaders["next"].url)
            : null;
        const result = {
            statusCode,
            responseText,
            contentType,
            nextPage,
            statusText: res.statusText,
        };
        this._config.potentialFutureError.statusCode = result.statusCode;
        if (result.statusCode >= 400) {
            let response;
            if (result.contentType && result.contentType.indexOf("application/json") === 0) {
                response = JSON.parse(result.responseText);
            }
            this._config.potentialFutureError.message = await this._config.getErrorMessage();
            let context = { method: "GET", url };
            if (response)
                context.response = response;
            throw this._config.potentialFutureError.addContext(context).setCause(result, response);
        }
        if (this._config.cache) {
            // only write to cache after we check the status
            await this._config.cache.write({ url, config: reqConfig }, result);
        }
        return result;
    }
    async _requestParsedPage() {
        const page = await this._requestPage();
        if (!page)
            return;
        const parsePage = this._config.parsePage || JSON.parse;
        let results;
        try {
            results = await parsePage(page.pageInfo.responseText);
            // if this is a ASK query make sure the results look like a regulair binding result:
            if (isEqual(results, { head: {}, boolean: true }) || isEqual(results, { head: {}, boolean: true })) {
                return [{ boolean: results.boolean }];
            }
            return results;
        }
        catch (e) {
            this._config.potentialFutureError.message =
                (await this._config.getErrorMessage()) + ": Failed to parse response.";
            this._config.potentialFutureError.addContext({ method: "GET", url: page.url }).setCause(page.pageInfo, results);
            throw this._config.potentialFutureError;
        }
    }
    async _requestPage(extensionType) {
        if (this._next === null)
            return; // iteration has finished
        const reqConfig = requestConfigToFetchConfig("GET", {
            app: this._config.app,
        });
        const url = this._next || (await this._config.getUrl(extensionType));
        try {
            const pageInfo = await this.possiblyCachedResults(url, reqConfig);
            this._next = pageInfo.nextPage;
            this._page = pageInfo.responseText;
            return { url, pageInfo };
        }
        catch (e) {
            if (e instanceof TriplyDbJsError)
                throw e;
            this._config.potentialFutureError.message = await this._config.getErrorMessage();
            throw this._config.potentialFutureError.addContext({ method: "GET", url }).setCause(e);
        }
    }
    async _get() {
        // Reverse and use `.pop`, as `shift` is an O(n) operation.
        if (!this._currentPage.length)
            this._currentPage = ((await this._requestParsedPage()) || []).reverse();
        if (this._currentPage.length)
            return this._currentPage.pop();
    }
    async toArray() {
        const results = [];
        for await (const result of this) {
            results.push(result);
        }
        return results;
    }
    [Symbol.asyncIterator]() {
        return {
            next: async () => {
                const info = await this._get();
                if (info) {
                    return {
                        done: false,
                        value: await this._config.mapResult(info),
                    };
                }
                else {
                    return {
                        done: true,
                        value: undefined,
                    };
                }
            },
        };
    }
}
//# sourceMappingURL=AsyncIteratorHelper.js.map