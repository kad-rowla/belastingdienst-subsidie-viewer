import fs from "fs-extra";
import AsyncIteratorHelper from "./AsyncIteratorHelper.js";
import zlib from "zlib";
export default class AsyncIteratorHelperWithToFile extends AsyncIteratorHelper {
    constructor(config) {
        super(config);
        this.isBindings = config.isBindings;
    }
    compress(data) {
        return new Promise((resolve, reject) => {
            zlib.gzip(data, (err, result) => {
                if (err)
                    return reject(err);
                resolve(result);
            });
        });
    }
    getFileHandle(filepath) {
        return fs.open(filepath, "w");
    }
    async writeToFile(fileHandle, body, opts) {
        if (opts?.compressed) {
            await fs.write(fileHandle, await this.compress(body));
        }
        else {
            await fs.write(fileHandle, body);
        }
    }
    async closeFile(fileHandle) {
        await fs.close(fileHandle);
    }
    async toFile(filePath, opts) {
        const f = await this.getFileHandle(filePath);
        let results;
        if (this.isBindings) {
            // Write bindings to file as tsv
            let writeHeader = true;
            while ((results = (await this["_requestPage"]("tsv"))?.pageInfo.responseText)) {
                if (results && results.length && this["_page"]) {
                    const page = this["_page"];
                    if (writeHeader) {
                        await this.writeToFile(f, page, opts);
                    }
                    else {
                        const lineBreak = "\n";
                        const indexOfLineBreak = page.indexOf(lineBreak);
                        const pageNoHeader = page.substring(indexOfLineBreak + lineBreak.length);
                        await this.writeToFile(f, pageNoHeader, opts);
                    }
                    writeHeader = false;
                }
                else {
                    break;
                }
            }
        }
        else {
            // Write statements to file
            while ((results = await this["_requestParsedPage"]())) {
                if (results && results.length && this["_page"]) {
                    await this.writeToFile(f, this["_page"], opts);
                }
                else {
                    break;
                }
            }
        }
        await this.closeFile(f);
    }
}
//# sourceMappingURL=AsyncIteratorHelperWithToFile.js.map