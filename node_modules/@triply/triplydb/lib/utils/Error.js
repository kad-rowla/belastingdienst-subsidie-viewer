import { Response } from "cross-fetch";
const tokenRegex = /[a-z0-9\-\_\.]{280,}/gi;
export class IncompatibleError extends Error {
}
export class TriplyDbJsError extends Error {
    constructor(message, options) {
        if (typeof message === "string") {
            try {
                message = message.replaceAll(tokenRegex, "<token>");
            }
            catch (e) { }
        }
        if (options?.cause) {
            if (options.cause instanceof Error) {
                options.cause.message = options.cause.message.replaceAll(tokenRegex, "<token>");
            }
        }
        super(message, options);
        this.context = {};
    }
    setMessage(msg) {
        this.message = msg.replaceAll(tokenRegex, "<token>");
        return this;
    }
    addContext(data) {
        this.context = { ...this.context, ...data };
        return this;
    }
    setStatusCode(statusCode) {
        this.statusCode = statusCode;
        return this;
    }
    setCause(error, jsonResult) {
        if (error instanceof Error) {
            this.message = `${this.message} (${error.message.replaceAll(tokenRegex, "<token>")})`;
        }
        else if (error instanceof Response) {
            this.message = `${this.message} (${error.status}: ${jsonResult && jsonResult.message ? jsonResult.message : error.statusText})`;
        }
        else {
            this.message = `${this.message} (${error.statusCode}: ${jsonResult && jsonResult.message ? jsonResult.message : error.statusText})`;
        }
        return this;
    }
}
export function getErr(message) {
    const err = new TriplyDbJsError(message);
    // CaptureStackTrace is node-specific, so lets check if the function exists
    Error.captureStackTrace?.(err, getErr);
    return err;
}
//# sourceMappingURL=Error.js.map