import { TriplyDbJsError } from "./Error.js";
import App from "../App.js";
import { Cache } from "./cache.js";
type RequestExtensionType = "csv" | "tsv" | "json" | "srx" | "srj";
export interface AsyncConfig<ResultType, OutputType> {
    getUrl: (extensionType?: RequestExtensionType) => Promise<string>;
    mapResult: (resource: ResultType) => Promise<OutputType>;
    app: App;
    potentialFutureError: TriplyDbJsError;
    getErrorMessage: () => Promise<string>;
    parsePage?: (page: string) => Promise<ResultType[]>;
    cache?: Cache;
}
export default class AsyncIteratorHelper<ResultType, OutputClass> implements AsyncIterable<OutputClass> {
    /**
     *  undefined:  iteration hasn't started
     *  null:       iteration has finished
     */
    private _next;
    private _config;
    private _currentPage;
    private _page;
    constructor(conf: AsyncConfig<ResultType, OutputClass>);
    private possiblyCachedResults;
    private _requestParsedPage;
    private _requestPage;
    private _get;
    toArray(): Promise<OutputClass[]>;
    [Symbol.asyncIterator](): {
        next: () => Promise<{
            done: boolean;
            value: Awaited<OutputClass>;
        } | {
            readonly done: true;
            readonly value: any;
        }>;
    };
}
export {};
//# sourceMappingURL=AsyncIteratorHelper.d.ts.map