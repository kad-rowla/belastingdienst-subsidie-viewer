import { TriplyDbJsError } from "./utils/Error.js";
import fetch from "cross-fetch";
import FormData from "form-data";
import debug from "debug";
import fs from "fs";
const log = debug("triply:triplydb-js:http");
export function normalizePath(path = "") {
    return `/${path}`.replace(new RegExp("//", "g"), "/");
}
export function getUrl(opts) {
    let url;
    if (opts.url) {
        url = new URL(opts.url);
    }
    else {
        if (opts.path?.startsWith("http")) {
            // There is a bug in triplydb-js: we should use `url:` instead of `path:` for these cases
            throw new Error(`Expected a path, but got URL ${opts.path} instead`);
        }
        const apiUrl = opts.app["_config"].url;
        if (!apiUrl)
            throw new Error("Expected a url or path to be set");
        url = new URL(apiUrl + normalizePath(opts?.path));
    }
    if (opts.query) {
        url.search = new URLSearchParams(opts.query).toString();
    }
    return url.toString();
}
/**
 * Either pass a full URL (incl domain) or pass a req opts with things like path
 */
export function _get(opts) {
    return handleFetchAsPromise("GET", opts);
}
export function _delete(opts) {
    return handleFetchAsPromise("DELETE", opts);
}
export function _post(opts) {
    return handleFetchAsPromise("POST", opts);
}
export function _patch(opts) {
    return handleFetchAsPromise("PATCH", opts);
}
export function getFetchOpts(requestInit, opts) {
    const token = opts.app["_config"].token;
    if (!requestInit.headers)
        requestInit.headers = {};
    requestInit.headers["X-Triply-Client"] = "triplydb-js";
    if (token) {
        requestInit.headers["Authorization"] = "Bearer " + token;
    }
    return requestInit;
}
export function requestConfigToFetchConfig(method, config) {
    const reqConfig = { method };
    const headers = {};
    if (config.data) {
        headers["Content-Type"] = "application/json";
        reqConfig.body = JSON.stringify(config.data);
    }
    else if (config.attach) {
        const data = new FormData();
        for (const [name, body] of Object.entries(config.attach)) {
            if (typeof body === "string") {
                data.append(name, fs.createReadStream(body));
            }
            else {
                data.append(name, body);
            }
        }
        reqConfig.body = data;
    }
    reqConfig.headers = headers;
    return getFetchOpts(reqConfig, { app: config.app });
}
async function handleFetchAsPromise(method, opts) {
    const url = getUrl(opts);
    log(`_${method.toLowerCase()}`, url);
    const reqOpts = requestConfigToFetchConfig(method, opts);
    const errorContext = { method, url };
    let response;
    try {
        response = await fetch(url, reqOpts);
    }
    catch (e) {
        // This error only occurs when there are network errors and such
        throw opts.errorWithCleanerStack.addContext(errorContext).setCause(e);
    }
    // We kept the statusCode outside errorContext because the tests were breaking, for example when testing ensureDataset().
    // We can fix the ensureDataset function in another ticket.
    opts.errorWithCleanerStack.statusCode = response.status;
    errorContext.message = response.statusText;
    const consoleOnlyHeader = response.headers.get("x-triply-api");
    if (consoleOnlyHeader) {
        throw opts.errorWithCleanerStack
            .addContext(errorContext)
            .setCause(new Error(`You tried connecting TriplyDB-js to a TriplyDB front-end. Please use the URL of the API instead: ${consoleOnlyHeader}`));
    }
    const expectJsonResponse = !opts.expectedResponseBody || opts.expectedResponseBody === "json";
    const responseContentType = response.headers.get("Content-Type");
    const hasJsonResponse = responseContentType && responseContentType.indexOf("application/json") === 0;
    if (expectJsonResponse && !hasJsonResponse) {
        // This should never happen. If it does, there's probably a bug in our API
        throw opts.errorWithCleanerStack
            .addContext(errorContext)
            .setCause(new Error(`Expected a JSON response, but got ${responseContentType}.`));
    }
    let result;
    if (hasJsonResponse) {
        try {
            result = await response.json();
        }
        catch (e) {
            // We failed to parse the response as json.
            // This should never happen. If it does, there's probably a bug in our API
            throw opts.errorWithCleanerStack.addContext(errorContext).setCause(e);
        }
    }
    else if (opts.expectedResponseBody === "buffer") {
        result = await response.buffer();
    }
    if (response.status === 404) {
        throw opts.errorWithCleanerStack.addContext(errorContext).setCause(new TriplyDbJsError(`It does not exist`));
    }
    if (response.status >= 400) {
        throw opts.errorWithCleanerStack
            .addContext(errorContext)
            .setCause(response, result instanceof Buffer ? undefined : result);
    }
    return result;
}
export async function handleFetchAsStream(method, opts) {
    const url = getUrl(opts);
    log(`_${method.toLowerCase()}`, url);
    const reqOpts = requestConfigToFetchConfig(method, opts);
    const errorContext = { method, url };
    let response;
    try {
        response = await fetch(url, reqOpts);
    }
    catch (e) {
        // This error only occurs when there are network errors and such
        throw opts.errorWithCleanerStack.addContext(errorContext).setCause(e);
    }
    const consoleOnlyHeader = response.headers.get("x-triply-api");
    if (consoleOnlyHeader) {
        throw opts.errorWithCleanerStack
            .addContext(errorContext)
            .setCause(new Error(`You tried connecting TriplyDB-js to a TriplyDB front-end. Please use the URL of the API instead: ${consoleOnlyHeader}`));
    }
    const responseContentType = response.headers.get("Content-Type");
    const hasJsonResponse = responseContentType && responseContentType.indexOf("application/json") === 0;
    let jsonResult;
    if (hasJsonResponse) {
        //We're fetching something as a stream.
        //We're not expecing json here, so this is probably an error response (with json in it)
        try {
            jsonResult = await response.json();
        }
        catch (e) {
            throw opts.errorWithCleanerStack.addContext(errorContext).setCause(e);
        }
    }
    if (response.status >= 400) {
        throw opts.errorWithCleanerStack.addContext(errorContext).setCause(response, jsonResult);
    }
    if (!response.body) {
        throw opts.errorWithCleanerStack.addContext(errorContext).setCause(new Error(`Unexpected empty response.`));
    }
    return response.body;
}
//# sourceMappingURL=RequestHandler.js.map