import * as chai from "chai";
import dedent from "dedent";
import fs from "fs-extra";
import { SPARQL_RESULT_DEFAULT_PAGE_SIZE, SPARQL_RETRY_CONSTRUCT_SHRINK_FACTOR } from "../Constants.js";
import { it } from "../mocha.js";
import { BadRequestError, filterSuggestions, parse, parseAndInjectVariablesIntoQuery, parseAndInjectVariablesIntoQueryAndGetInfo, stringify, validate, } from "../sparqlVarUtils.js";
var expect = chai.expect;
function normalizeQuery(query) {
    return stringify(parse(query));
}
function testInject(query, variableDefinitions, args) {
    expect(parseAndInjectVariablesIntoQuery(query.original, { variableDefinitions, variableValues: args })).to.equal(normalizeQuery(query.expected), "failed to inject variables into query using sparql parser");
}
describe("SPARQL_RETRY_CONSTRUCT_SHRINK_FACTOR", function () {
    it("should be strictly smaller than one.", function () {
        expect(SPARQL_RETRY_CONSTRUCT_SHRINK_FACTOR).to.be.below(1);
    });
    it("should be strictly larger than zero.", function () {
        expect(SPARQL_RETRY_CONSTRUCT_SHRINK_FACTOR).to.be.above(0);
    });
});
describe("Sparql var utils", function () {
    describe("Validate", function () {
        it("With empty input", function () {
            validate({ variableDefinitions: [], variableValues: {} });
        });
        describe("Validate variables", function () {
            it("Should throw when variable is required", function () {
                expect(() => validate({
                    variableDefinitions: [{ name: "s", termType: "NamedNode", required: true }],
                    variableValues: {},
                })).to.throw(/is required/);
            });
            it("Should not throw when variable is optional", function () {
                validate({
                    variableDefinitions: [{ name: "s", termType: "NamedNode", required: false }],
                    variableValues: {},
                });
            });
            it("Should not throw when optional and allowedvalues is set", function () {
                validate({
                    variableDefinitions: [{ name: "s", termType: "NamedNode", allowedValues: ["bla"] }],
                    variableValues: {},
                });
            });
            it("Should throw when passing value not in allowedValue", function () {
                expect(() => validate({
                    variableDefinitions: [{ name: "s", termType: "NamedNode", allowedValues: ["bla"] }],
                    variableValues: { s: "blo" },
                })).to.throw(/must be one of/);
            });
        });
        describe("Pagination vals", function () {
            it("With negative page", function () {
                expect(() => validate({ variableDefinitions: [], variableValues: {}, page: -1 })).to.throw(BadRequestError);
            });
            it("With negative pageSize", function () {
                expect(() => validate({ variableDefinitions: [], variableValues: {}, pageSize: -1 })).to.throw(BadRequestError);
            });
            it("With 0 pageSize", function () {
                expect(() => validate({ variableDefinitions: [], variableValues: {}, pageSize: 0 })).to.throw(BadRequestError);
            });
            it("With 0 page", function () {
                expect(() => validate({ variableDefinitions: [], variableValues: {}, page: 0 })).to.throw(BadRequestError);
            });
            it("With too large pageSize", function () {
                expect(() => validate({ variableDefinitions: [], variableValues: {}, pageSize: 20000 })).to.throw(BadRequestError);
            });
        });
    });
    describe("SparqlJS parser tests", function () {
        it("https://issues.triply.cc/issues/4485", async function () {
            const query = await fs.readFile("./src/__tests__/data/invalidQuery_4757.sparql", "utf-8");
            expect(() => parse(query)).to.throw("Parse error");
        });
        it("With relative IRI", async function () {
            expect(stringify(parse(`select * where {<a> <a> <a>}`))).to.equal(dedent `
      BASE <https://triplydb.com/>
      SELECT * WHERE { <https://triplydb.com/a> <https://triplydb.com/a> <https://triplydb.com/a>. }
      `);
        });
    });
    describe("Replace query variables", function () {
        describe("With custom pagination", function () {
            it("Should do nothing when no pagination is used", function () {
                const result = parseAndInjectVariablesIntoQuery(dedent `
          select * where {
            ?x ?y ?z .
            #paginate 
          }`, {
                    variableDefinitions: [{ name: "s", termType: "NamedNode" }],
                    variableValues: { s: "https://something" },
                });
                expect(result).to.equal(`SELECT * WHERE { ?x ?y ?z. }`);
            });
            describe("Should replace comment", function () {
                function compareWithPagination(input, expected) {
                    const result = parseAndInjectVariablesIntoQuery(input, {
                        variableDefinitions: [{ name: "s", termType: "NamedNode" }],
                        variableValues: { s: "https://something" },
                        page: 10,
                        pageSize: 100,
                    });
                    if (Array.isArray(expected))
                        expected = expected.join("\n");
                    expect(result).to.equal(expected);
                }
                it("Should throw an error when replacing at wrong location", function () {
                    expect(() => compareWithPagination(dedent `
            select * where {
              ?x ?y ?z .
              #PAGINATE
            }
          `, "")).to.throw(/Cannot include custom pagination/);
                });
                it("Should replace multiple occurances of comment", function () {
                    compareWithPagination(dedent `
            select * where {
              {
                select * where {
                  ?x ?y ?z .
                } # paginate
              }
              {
                select * where {
                  ?x ?y ?z .
                } #paginate
              }
            }
          `, dedent `
            SELECT * WHERE {
              {
                SELECT * WHERE { ?x ?y ?z. }
                OFFSET 900
                LIMIT 100
              }
              {
                SELECT * WHERE { ?x ?y ?z. }
                OFFSET 900
                LIMIT 100
              }
            }`);
                });
                it("Should replace existing limit / offset when needed", function () {
                    compareWithPagination(dedent `
            select * where {
              {
                select * where {
                  ?x ?y ?z .
                } LIMIT 10 #paginate
              }
              {
                select * where {
                  ?x ?y ?z .
                } limit 10 offset 20 #paginate
              }
              {
                select * where {
                  ?x ?y ?z .
                } offset 10 limit 20 #paginate
              }
              {
                select * where {
                  ?x ?y ?z .
                } offset 10 #paginate
              }
            }
          `, dedent `
            SELECT * WHERE {
              {
                SELECT * WHERE { ?x ?y ?z. }
                OFFSET 900
                LIMIT 100
              }
              {
                SELECT * WHERE { ?x ?y ?z. }
                OFFSET 900
                LIMIT 100
              }
              {
                SELECT * WHERE { ?x ?y ?z. }
                OFFSET 900
                LIMIT 100
              }
              {
                SELECT * WHERE { ?x ?y ?z. }
                OFFSET 900
                LIMIT 100
              }
            }
            `);
                });
            });
        });
        describe("Handle projection variables", function () {
            function compareInjectSVariable(input, expected) {
                const result = parseAndInjectVariablesIntoQuery(input, {
                    variableDefinitions: [{ name: "s", termType: "NamedNode" }],
                    variableValues: { s: "https://something" },
                });
                if (Array.isArray(expected))
                    expected = expected.join("\n");
                expect(result).to.equal(expected);
            }
            it("should add projection variable even if var is only in projection clause", function () {
                compareInjectSVariable(`SELECT ?s WHERE {}`, `SELECT (<https://something> AS ?s) WHERE {  }`);
            });
            it("should replace the first part of variable expression", function () {
                compareInjectSVariable(`SELECT (?s as ?x) WHERE {}`, `SELECT (<https://something> AS ?x) WHERE {  }`);
            });
            it("should add projection variable for simple query", function () {
                compareInjectSVariable(`SELECT ?s WHERE {?s?p?o}`, `SELECT (<https://something> AS ?s) WHERE { <https://something> ?p ?o. }`);
            });
            it("should correctly add projection variable for nested query", function () {
                compareInjectSVariable(`SELECT ?s WHERE {SELECT ?s {?s?p?o}}`, `SELECT ?s WHERE { SELECT (<https://something> AS ?s) WHERE { <https://something> ?p ?o. } }`);
            });
            it("should correctly handle describe query", function () {
                compareInjectSVariable(`DESCRIBE ?s`, `DESCRIBE <https://something>`);
            });
            it("should not replace projection variable", function () {
                compareInjectSVariable(`SELECT ("sdf" as ?s) WHERE {?s?p?o}`, `SELECT ("sdf" AS ?s) WHERE { <https://something> ?p ?o. }`);
            });
            it("Should replace variable when used in a function", function () {
                compareInjectSVariable(`SELECT (IF(?s, "1", "-1") AS ?something) WHERE {}`, `SELECT (IF(<https://something>, "1", "-1") AS ?something) WHERE {  }`);
            });
            it("Should not replace variable when used in a function and replaced variable is an expression variable", function () {
                compareInjectSVariable(`SELECT (IF("true", "1", "-1") AS ?s) WHERE {?s?p?o}`, `SELECT (IF("true", "1", "-1") AS ?s) WHERE { <https://something> ?p ?o. }`);
            });
            it("should not add alias if alias already exists", function () {
                expect(() => parseAndInjectVariablesIntoQuery(`SELECT ?s ("sdf" as ?s) WHERE {?s?p?o}`, {
                    variableDefinitions: [{ name: "s", termType: "Literal" }],
                    variableValues: { s: "whatever" },
                })).to.throw(/Two or more of the resulting columns have the same name/);
            });
            describe("With group-by", function () {
                it("should add term to group by when needed", function () {
                    compareInjectSVariable(`select ?p { ?s ?p ?o.} group by ?s`, [
                        `SELECT ?p WHERE { <https://something> ?p ?o. }`,
                        `GROUP BY (<https://something> AS ?s)`,
                    ]);
                });
                it("Should re-use project alias when needed", function () {
                    compareInjectSVariable(`select ?s { ?s ?p ?o.} group by ?s`, [
                        `SELECT (<https://something> AS ?s) WHERE { <https://something> ?p ?o. }`,
                        `GROUP BY ?s`,
                    ]);
                });
                it("with nested groupby", function () {
                    compareInjectSVariable(`select ?p ?s WHERE { SELECT ?p ?s WHERE { SELECT ?p ?s WHERE {?s ?p ?o} group by ?s} group by ?s } group by ?s`, [
                        "SELECT ?p ?s WHERE {",
                        "  SELECT ?p ?s WHERE {",
                        "    SELECT ?p (<https://something> AS ?s) WHERE { <https://something> ?p ?o. }",
                        "    GROUP BY ?s",
                        "  }",
                        "  GROUP BY ?s",
                        "}",
                        "GROUP BY ?s",
                    ]);
                });
                it("with nested groupby (without projection var in the middle)", function () {
                    compareInjectSVariable(`select ?s WHERE { SELECT ?p WHERE { SELECT ?s WHERE {?s ?p ?o} group by ?s} } group by ?s`, [
                        "SELECT (<https://something> AS ?s) WHERE {",
                        "  SELECT ?p WHERE {",
                        "    SELECT (<https://something> AS ?s) WHERE { <https://something> ?p ?o. }",
                        "    GROUP BY ?s",
                        "  }",
                        "}",
                        "GROUP BY ?s",
                    ]);
                });
            });
            describe("With order-by", function () {
                it("Should not add an alias", function () {
                    compareInjectSVariable(`select * { ?s ?p ?o.} order by ?s`, [
                        `SELECT * WHERE { <https://something> ?p ?o. }`,
                        `ORDER BY (<https://something>)`,
                    ]);
                });
                it("Should preserve order direction add an alias", function () {
                    compareInjectSVariable(`select ?s { ?s ?p ?o.} order by DESC(?s)`, [
                        `SELECT (<https://something> AS ?s) WHERE { <https://something> ?p ?o. }`,
                        `ORDER BY DESC (<https://something>)`,
                    ]);
                });
            });
        });
        it("Sparqlparser output should not contain a datatype", function () {
            expect(parseAndInjectVariablesIntoQuery(`SELECT * WHERE {?x ?y "amsterdam"}`, {
                variableDefinitions: [],
                variableValues: {},
            })).not.to.contain("http://www.w3.org/2001/XMLSchema#string");
        });
        it(`Should not throw error on undefined value`, function () {
            parseAndInjectVariablesIntoQuery(`
          SELECT * WHERE {
            VALUES ( ?a ?b ) {
              ( "IndividualDifference" UNDEF)
            }
          }`, { variableDefinitions: [{ name: "a", defaultValue: "http://bla", termType: "NamedNode" }], variableValues: {} });
        });
        it(`Should not apply sparql parser when no variables are defined`, function () {
            expect(parseAndInjectVariablesIntoQuery(`someIllegalQuery`, { variableDefinitions: [], variableValues: {} })).to.equal("someIllegalQuery");
        });
        it(`Should not throw error on valid property path`, function () {
            parseAndInjectVariablesIntoQuery(`
prefix : <https://ex.com/>

select * {
:a :a :a ;
  :a [
    :a/:a :a
  ] .
}
`, { variableDefinitions: [{ name: "a", defaultValue: "http://bla", termType: "NamedNode" }], variableValues: {} });
        });
        it(`Check replace`, function () {
            testInject({
                original: `SELECT * WHERE {
            ?s ?p ?o.
            ?s ?p $x.
          }
          `,
                expected: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p "amsterdam".
            }
            `,
            }, [
                {
                    name: "x",
                    termType: "Literal",
                    required: true,
                },
            ], {
                x: "amsterdam",
            });
        });
        it(`Should use default values`, function () {
            testInject({
                original: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p $x.
            }
            `,
                expected: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p "amsterdam".
            }
            `,
            }, [
                {
                    name: "x",
                    termType: "Literal",
                    required: true,
                    defaultValue: "amsterdam",
                },
            ], {});
        });
        it(`Keep original prefix declarations when possible`, function () {
            const result = parseAndInjectVariablesIntoQuery("prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> SELECT * WHERE { ?s ?p ?o . ?s ?p $x . }", {
                variableDefinitions: [
                    {
                        name: "x",
                        termType: "Literal",
                        required: true,
                    },
                ],
                variableValues: {
                    x: "amsterdam",
                },
            });
            expect(result).to.contain("PREFIX rdf:");
        });
        it("Should throw BadArgumentsError when passing inapplicable arg", function () {
            let e;
            try {
                parseAndInjectVariablesIntoQuery(`ask{?s?p?o}`, { variableDefinitions: [], variableValues: {}, page: 1 });
            }
            catch (_e) {
                e = _e;
            }
            expect(e).to.be.instanceof(BadRequestError);
        });
        it(`Should throw when prefix is not defined`, function () {
            const query = `
        PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
        SELECT * WHERE {
          ?s bif:contains ?o.
          ?s ?p ?x.
        }
      `;
            let e;
            try {
                parseAndInjectVariablesIntoQuery(query, {
                    variableDefinitions: [{ name: "s", termType: "NamedNode", defaultValue: "https://bla" }],
                    variableValues: {},
                });
            }
            catch (_e) {
                e = _e;
            }
            expect(e?.message).to.contain("Unknown prefix");
        });
        it(`Don't change variable when not defined`, function () {
            const variables = [
                {
                    name: "x",
                    termType: "Literal",
                    required: false,
                },
            ];
            testInject({
                original: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p ?x.
            }
            `,
                expected: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p ?x.
            }
            `,
            }, variables, {});
        });
        it(`Append language tag`, function () {
            testInject({
                original: `
            ASK WHERE {
              ?s ?p ?o.
              ?s ?p $x.
            }
            `,
                expected: `
            ASK WHERE {
              ?s ?p ?o.
              ?s ?p "newX"@en.
            }
            `,
            }, [
                {
                    name: "x",
                    termType: "Literal",
                    required: false,
                    language: "en",
                },
            ], { x: "newX" });
        });
        it(`Append datatype`, function () {
            testInject({
                original: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p $x.
            }
            `,
                expected: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p "1"^^<http://whatever>.
            }
            `,
            }, [
                {
                    name: "x",
                    termType: "Literal",
                    required: false,
                    datatype: "http://whatever",
                },
            ], { x: "1" });
        });
        it(`Ignore datatype if it's a string`, function () {
            testInject({
                original: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p $x.
            }
            `,
                expected: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p "1".
            }
            `,
            }, [
                {
                    name: "x",
                    termType: "Literal",
                    required: false,
                    datatype: "http://www.w3.org/2001/XMLSchema#string",
                },
            ], { x: "1" });
        });
        it(`Dont append datatype if not set`, function () {
            testInject({
                original: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p $x.
            }
            `,
                expected: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p "1".
            }
            `,
            }, [
                {
                    name: "x",
                    termType: "Literal",
                    required: false,
                },
            ], { x: "1" });
        });
        it(`[parser method] Dont append when xsd is added a prefix`, function () {
            testInject({
                original: `
            PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p $x.
            }
            `,
                expected: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p "1".
            }
            `,
            }, [
                {
                    name: "x",
                    termType: "Literal",
                    required: false,
                },
            ], { x: "1" });
        });
        it(`Deal with hashed IRIs as query argument`, function () {
            testInject({
                original: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p $x.
            }
            `,
                expected: `
            SELECT * WHERE {
              ?s ?p ?o.
              ?s ?p <https://bla#bla>.
            }
            `,
            }, [
                {
                    name: "x",
                    termType: "NamedNode",
                    required: false,
                },
            ], { x: "https://bla#bla" });
        });
        it(`Only change variables when sparql-parser is used`, function () {
            testInject({
                original: `
            SELECT * WHERE {
              ?s ?p "$o".
              ?s ?p $o.
            }`,
                expected: `
            SELECT * WHERE {
              ?s ?p "$o".
              ?s ?p "amsterdam".
            }`,
            }, [
                {
                    name: "o",
                    termType: "Literal",
                    required: true,
                },
            ], { o: "amsterdam" });
        });
        it(`Match full queryname`, function () {
            testInject({
                original: `
            SELECT * WHERE {
              BIND(?obje as ?obje2)
              ?s ?p ?objects.
              ?s ?p ?obje.
              ?s ?p ?o.
            }`,
                expected: `
            SELECT * WHERE {
              BIND("amsterdam" as ?obje2)
              ?s ?p ?objects.
              ?s ?p "amsterdam".
              ?s ?p ?o.
            }`,
            }, [
                {
                    name: "obje",
                    termType: "Literal",
                    required: true,
                },
            ], { obje: "amsterdam" });
        });
        it(`Change both $ and ? variables (Naive)`, function () {
            testInject({
                original: `
            SELECT (count(?s) as ?c) {
              ?s $p ?o.
            }
            `,
                expected: `
            SELECT (count(?s) as ?c) {
              ?s <canada:ontario> "amsterdam".
            }
            `,
            }, [
                {
                    name: "p",
                    termType: "NamedNode",
                    required: false,
                },
                {
                    name: "o",
                    termType: "Literal",
                    required: false,
                },
            ], { p: "canada:ontario", o: "amsterdam" });
        });
    });
    describe("Limit and offset", function () {
        it("Should inject limit and offset into SELECT when given", function () {
            const result = parseAndInjectVariablesIntoQuery(`SELECT * WHERE {?x ?y "amsterdam"}`, {
                variableDefinitions: [],
                variableValues: {},
                page: 2,
                pageSize: 3,
            });
            expect(result).to.contain("LIMIT 3");
            expect(result).to.contain("OFFSET 3");
        });
        it("Should inject limit and offset into DESRIBE when given", function () {
            const result = parseAndInjectVariablesIntoQuery(`DESCRIBE <a:a>`, {
                variableDefinitions: [],
                variableValues: {},
                page: 2,
                pageSize: 3,
            });
            expect(result).to.contain("LIMIT 3");
            expect(result).to.contain("OFFSET 3");
        });
        it("Should inject limit and offset into CONSTRUCT when given", function () {
            const result = parseAndInjectVariablesIntoQuery(`CONSTRUCT {?s?p?o} WHERE {?s?p?o}`, {
                variableDefinitions: [],
                variableValues: {},
                page: 2,
                pageSize: 3,
            });
            expect(result).to.contain("LIMIT 3");
            expect(result).to.contain("OFFSET 3");
        });
        it("Should not inject limit or offset when neither page or pageSize is given", function () {
            const result = parseAndInjectVariablesIntoQuery(`SELECT * WHERE {?s?p?o}`, {
                variableDefinitions: [],
                variableValues: {},
            });
            expect(result).not.to.contain("LIMIT");
            expect(result).not.to.contain("OFFSET");
        });
        it("Should handle case where page is given but pageSize is not", function () {
            const result = parseAndInjectVariablesIntoQuery(`SELECT * WHERE {?s?p?o}`, {
                variableDefinitions: [],
                variableValues: {},
                page: 2,
            });
            expect(result).to.contain(`LIMIT ${SPARQL_RESULT_DEFAULT_PAGE_SIZE}`);
            expect(result).to.contain(`OFFSET ${SPARQL_RESULT_DEFAULT_PAGE_SIZE}`);
        });
        it("Should handle case where pageSize is given but page is not", function () {
            const result = parseAndInjectVariablesIntoQuery(`SELECT * WHERE {?s?p?o}`, {
                variableDefinitions: [],
                variableValues: {},
                pageSize: 50,
            });
            expect(result).to.contain("LIMIT 50");
            expect(result).not.to.contain("OFFSET");
        });
        it("Running a query with blank node twice should return the same bnode identifier", function () {
            const testQuery = `SELECT * WHERE {[]?p?o}`;
            const result = parseAndInjectVariablesIntoQuery(testQuery, {
                variableDefinitions: [],
                variableValues: {},
                pageSize: 50,
            });
            const result2 = parseAndInjectVariablesIntoQuery(testQuery, {
                variableDefinitions: [],
                variableValues: {},
                pageSize: 50,
            });
            expect(result).to.equal(result2);
        });
    });
    describe("Detecting a CONSTRUCT query", function () {
        it("should mark a CONSTRUCT query as being one", function () {
            expect(parseAndInjectVariablesIntoQueryAndGetInfo(`CONSTRUCT {?s?p?o} WHERE {?s?p?o}`, {
                variableDefinitions: [],
                variableValues: {},
            }).isConstructQuery).to.equal(true);
        });
        it("should mark a SELECT query as not being a CONSTRUCT query", function () {
            expect(parseAndInjectVariablesIntoQueryAndGetInfo(`SELECT * WHERE {?x ?y "amsterdam"}`, {
                variableDefinitions: [],
                variableValues: {},
            }).isConstructQuery).to.equal(false);
        });
        it("should mark a DESRIBE query as not being a CONSTRUCT query", function () {
            expect(parseAndInjectVariablesIntoQueryAndGetInfo(`DESCRIBE <a:a>`, {
                variableDefinitions: [],
                variableValues: {},
            }).isConstructQuery).to.equal(false);
        });
    });
    describe("Filter term suggestions", function () {
        it("should filter on datatype", function () {
            const filtered = filterSuggestions({
                name: "whatever",
                termType: "Literal",
            }, [`"a"@en`, `"b"`]);
            expect(filtered).to.have.lengthOf(1);
            expect(filtered[0]).to.equal("b");
        });
    });
});
//# sourceMappingURL=sparqlVarUtils-test.js.map