import * as ChildProcess from "child_process";
import stream from "stream";
import * as chai from "chai";
import chaiAsPromised from "chai-as-promised";
import pumpify from "pumpify";
import { it } from "../mocha.js";
import { emitErrorOnNonZeroExitCode, getSafeStdoutStream } from "../proc.js";
chai.use(chaiAsPromised);
const { expect } = chai;
describe("Proc tests", function () {
    describe("Error events from exit events", function () {
        async function procAsPromise(cp) {
            await new Promise((resolve, reject) => {
                cp.on("error", reject);
                cp.on("close", () => resolve());
            });
        }
        it("Should do nothing if there isnt an error", async function () {
            await procAsPromise(emitErrorOnNonZeroExitCode(ChildProcess.spawn("true")));
        });
        it("Should throw regular error with fatal cmd", async function () {
            await expect(procAsPromise(emitErrorOnNonZeroExitCode(ChildProcess.spawn("blabla")))).eventually.rejectedWith(/spawn blabla ENOENT/);
        });
        it("Should throw regular error with non-zero exit code", async function () {
            await expect(procAsPromise(emitErrorOnNonZeroExitCode(ChildProcess.spawn("false")))).eventually.rejectedWith(/failed with code 1/);
        });
    });
    describe("Stdout process handling", function () {
        async function expectStreamToThrow(s, regex) {
            return new Promise((resolve, reject) => {
                s.on("finish", () => {
                    reject(new Error("Unexpected finish event"));
                });
                s.on("end", () => {
                    reject(new Error("Unexpected end event"));
                });
                s.on("error", (e) => {
                    try {
                        expect(e.message).to.match(regex);
                    }
                    catch (e) {
                        return reject(e);
                    }
                    resolve();
                });
            });
        }
        async function expectStreamToSucceed(s) {
            return new Promise((resolve, reject) => {
                let size = 0;
                s.on("data", (chunk) => {
                    size += chunk.length;
                });
                s.on("finish", () => {
                    resolve(size);
                });
                s.on("error", reject);
            });
        }
        describe("Processes that succeed", function () {
            it("With quick cmd and without output", async function () {
                const size = await expectStreamToSucceed(getSafeStdoutStream(ChildProcess.spawn("true")));
                expect(size).to.equal(0);
            });
            it("Should deal with backpressure", async function () {
                const stdoutStream = getSafeStdoutStream(ChildProcess.spawn("head", ["-c", "1000000", "/dev/urandom"]));
                const slowStream = new stream.Transform({
                    write: (_chunk, _enconding, cb) => {
                        setTimeout(cb, 2);
                    },
                });
                await expectStreamToSucceed(new pumpify(stdoutStream, slowStream));
            });
        });
        describe("Processes that fail", function () {
            it("Should handle cmd that doesnt exist (proc error)", async function () {
                await expectStreamToThrow(getSafeStdoutStream(ChildProcess.spawn("asdf")), /spawn asdf ENOENT/);
            });
            it("Should handle cmd that throws an error", async function () {
                await expectStreamToThrow(getSafeStdoutStream(ChildProcess.spawn("false")), /Cmd.*false.* failed with code 1/);
            });
        });
        describe("Confirm assumptions", function () {
            function testSpawnedProc(cmd, args, opts) {
                return new Promise((resolve) => {
                    let procClosed = false;
                    const debugInfo = {
                        bytesReceived: 0,
                        eventOrder: [],
                    };
                    const cp = ChildProcess.spawn(cmd, args)
                        .on("error", () => {
                        debugInfo.eventOrder.push("cp-error");
                    })
                        .on("close", () => {
                        procClosed = true;
                        debugInfo.eventOrder.push("cp-close");
                        if (!opts?.slowStream) {
                            resolve(debugInfo);
                        }
                    })
                        .on("exit", () => {
                        debugInfo.eventOrder.push("cp-exit");
                    });
                    cp.stdout
                        .on("end", () => {
                        debugInfo.eventOrder.push("stdout-end");
                    })
                        .on("finish", () => {
                        debugInfo.eventOrder.push("stdout-finish");
                    })
                        .on("error", () => {
                        debugInfo.eventOrder.push("stdout-error");
                    });
                    if (opts?.slowStream) {
                        cp.stdout.pipe(new stream.Transform({
                            write: (chunk, _enconding, cb) => {
                                debugInfo.bytesReceived += chunk.length;
                                setTimeout(cb, 2);
                            },
                        }).on("finish", () => {
                            if (procClosed) {
                                resolve(debugInfo);
                            }
                            else {
                                cp.on("close", () => resolve(debugInfo));
                            }
                        }));
                    }
                    else {
                        cp.stdout.on("data", (data) => {
                            debugInfo.bytesReceived += data.length;
                        });
                    }
                });
            }
            describe("With slow stream processing", function () {
                it("With cmd writes a lot of data", async function () {
                    this.timeout(10000);
                    const debugInfo = await testSpawnedProc("head", ["-c", "1000000", "/dev/urandom"], { slowStream: true });
                    expect(debugInfo).to.deep.equal({
                        bytesReceived: 1000000,
                        eventOrder: [
                            "cp-exit",
                            "stdout-end",
                            "stdout-finish",
                            "cp-close",
                        ],
                    });
                });
                it("With cmd that's quick and succeeds", async function () {
                    this.timeout(10000);
                    const debugInfo = await testSpawnedProc("true", [], { slowStream: true });
                    expect(debugInfo).to.deep.equal({
                        bytesReceived: 0,
                        eventOrder: [
                            "stdout-end",
                            "stdout-finish",
                            "cp-exit",
                            "cp-close",
                        ],
                    });
                });
                it("With cmd that's quick and fails", async function () {
                    this.timeout(10000);
                    const debugInfo = await testSpawnedProc("false", [], { slowStream: true });
                    expect(debugInfo).to.deep.equal({
                        bytesReceived: 0,
                        eventOrder: [
                            "stdout-end",
                            "stdout-finish",
                            "cp-exit",
                            "cp-close",
                        ],
                    });
                });
            });
            describe("With fast stream processing", function () {
                it("With empty cmd", async function () {
                    const debugInfo = await testSpawnedProc("true", []);
                    expect(debugInfo).to.deep.equal({
                        bytesReceived: 0,
                        eventOrder: [
                            "stdout-end",
                            "stdout-finish",
                            "cp-exit",
                            "cp-close",
                        ],
                    });
                });
                it("With command that doesnt exit", async function () {
                    const debugInfo = await testSpawnedProc("asdf", []);
                    expect(debugInfo).to.deep.equal({
                        bytesReceived: 0,
                        eventOrder: [
                            "cp-error",
                            "stdout-end",
                            "stdout-finish",
                            "cp-close",
                        ],
                    });
                });
                it("With empty cmd that fails", async function () {
                    const debugInfo = await testSpawnedProc("false", []);
                    expect(debugInfo).to.deep.equal({
                        bytesReceived: 0,
                        eventOrder: [
                            "stdout-end",
                            "stdout-finish",
                            "cp-exit",
                            "cp-close",
                        ],
                    });
                });
                it("With cmd that waits a bit", async function () {
                    const debugInfo = await testSpawnedProc("sleep", ["0.1"]);
                    expect(debugInfo).to.deep.equal({
                        bytesReceived: 0,
                        eventOrder: [
                            "stdout-end",
                            "stdout-finish",
                            "cp-exit",
                            "cp-close",
                        ],
                    });
                });
                it("With cmd writes a bit of data", async function () {
                    const debugInfo = await testSpawnedProc("head", ["-c", "1000", "/dev/urandom"]);
                    expect(debugInfo).to.deep.equal({
                        bytesReceived: 1000,
                        eventOrder: [
                            "stdout-end",
                            "stdout-finish",
                            "cp-exit",
                            "cp-close",
                        ],
                    });
                });
                it("With cmd writes a lot of data", async function () {
                    this.timeout(10000);
                    const debugInfo = await testSpawnedProc("head", ["-c", "1000000", "/dev/urandom"]);
                    expect(debugInfo).to.deep.equal({
                        bytesReceived: 1000000,
                        eventOrder: [
                            "stdout-end",
                            "stdout-finish",
                            "cp-exit",
                            "cp-close",
                        ],
                    });
                });
            });
        });
    });
});
//# sourceMappingURL=proc-test.js.map