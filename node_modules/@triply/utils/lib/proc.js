import * as stream from "stream";
import debug from "debug";
import pumpify from "pumpify";
const log = debug("triply:utils:proc");
export class ChildProcError extends Error {
    exitInfo;
    errorFromProc;
    constructor(message, opts) {
        super(message);
        this.exitInfo = opts.exitInfo;
        this.errorFromProc = opts.errorFromProc;
    }
}
export function emitErrorOnNonZeroExitCode(proc) {
    let stderr = "";
    proc.stderr.on("data", function (data) {
        if (stderr.length > 10000)
            return;
        stderr += data.toString();
    });
    proc.on("exit", function (exitCode, signal) {
        log("Proc exit event", { exitCode, signal });
        if (exitCode !== 0 || signal !== null) {
            const err = possiblyConstructErrObj({
                spawnCmd: proc.spawnargs,
                stderr,
                exitInfo: { exitCode, signal },
            });
            if (err) {
                proc.emit("error", err);
            }
        }
    });
    return proc;
}
export function getSafeStdoutStream(proc) {
    let errorFromProc;
    let exitInfo;
    let stderr = "";
    if (!proc.stdout || !proc.stderr) {
        throw new Error("Received a child process without stdout or stderr stream. Did you instantiate the process with some custom stdio settings?");
    }
    proc.once("error", function (e) {
        log("Proc error");
        errorFromProc = e;
    });
    proc.once("exit", function (exitCode, signal) {
        log("Proc exit event", { exitCode, signal });
        exitInfo = { exitCode, signal };
    });
    proc.stderr.on("data", function (data) {
        if (stderr.length > 10000)
            return;
        stderr += data.toString();
    });
    return new pumpify(proc.stdout.on("end", function () {
        log("stdout end event");
    }), new stream.PassThrough({
        flush(callback) {
            log("passthrough flush");
            if (errorFromProc || exitInfo) {
                callback(possiblyConstructErrObj({
                    errorFromProc,
                    exitInfo,
                    spawnCmd: proc.spawnargs,
                    stderr,
                }));
            }
            else {
                proc.once("exit", function (exitCode, signal) {
                    callback(possiblyConstructErrObj({
                        errorFromProc,
                        exitInfo: { exitCode, signal },
                        spawnCmd: proc.spawnargs,
                        stderr,
                    }));
                });
            }
        },
    }));
}
function possiblyConstructErrObj(opts) {
    if (opts.errorFromProc)
        return opts.errorFromProc;
    if (opts.exitInfo) {
        if (opts.exitInfo.exitCode !== 0 || opts.exitInfo.signal) {
            let errMessage = `Cmd '${opts.spawnCmd.join(" ")}' failed with `;
            if (opts.exitInfo.signal) {
                errMessage += `signal ${opts.exitInfo.signal}`;
            }
            else {
                errMessage += `code ${opts.exitInfo.exitCode}`;
            }
            if (opts.stderr.length) {
                errMessage += `: ${opts.stderr}`;
            }
            return new ChildProcError(errMessage, { exitInfo: opts.exitInfo, errorFromProc: opts.errorFromProc });
        }
    }
}
//# sourceMappingURL=proc.js.map