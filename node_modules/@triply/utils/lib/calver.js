import { padStart } from "lodash-es";
const positiveIntCheck = /^\d+$/;
function asPositiveInt(val) {
    if (typeof val === "string" && positiveIntCheck.test(val)) {
        return Number(val);
    }
    throw new Error(`Expected '${val}' to be a (positive) integer`);
}
function parseAndValidateCalver(calver, opts) {
    return validate(parse(calver), opts);
}
export function parse(calver) {
    const [base, patch] = calver.split("-");
    const [year, month, versionInMonth] = base.split(".");
    try {
        return {
            yearShort: asPositiveInt(year),
            month: asPositiveInt(month),
            versionInMonth: asPositiveInt(versionInMonth),
            patch: patch ? asPositiveInt(patch) : undefined,
            originalSegments: [year, month, versionInMonth, patch],
        };
    }
    catch (e) {
        throw new Error(`Failed to parse calver string ${calver}: ${e.message}`);
    }
}
export function validate(calverOrSemver, opts) {
    if (parsedVersionIsSemver(calverOrSemver))
        return calverOrSemver;
    if (calverOrSemver.month < 1 || calverOrSemver.month > 12) {
        throw new Error(`Invalid month number ${calverOrSemver.month}`);
    }
    if (calverOrSemver.originalSegments?.[1].length === 1) {
        throw new Error(`Expected calver month-segment to have length of two. Instead, got value ${calverOrSemver.originalSegments[1]}`);
    }
    const date = opts?.currentDate || new Date();
    if (calverOrSemver.yearShort > getShortYear(date) ||
        (calverOrSemver.yearShort === getShortYear(date) && calverOrSemver.month > date.getMonth() + 1)) {
        throw new Error(`Failed to validate ${serializeCalver(calverOrSemver)}:  This is a date in the future`);
    }
    return calverOrSemver;
}
export function serializeCalver(calver) {
    const base = [calver.yearShort, padStart(String(calver.month), 2, "0"), calver.versionInMonth].join(".");
    if (calver.patch) {
        return base + `-${calver.patch}`;
    }
    return base;
}
function getShortYear(date) {
    return Number(String(date.getFullYear()).substring(2));
}
export function increment(currentVersion, opts) {
    const parsedCurrentVersion = parseAndValidateCalver(currentVersion, { currentDate: opts?.currentDate });
    if (opts?.patch) {
        if (parsedCurrentVersion.patch !== undefined) {
            parsedCurrentVersion.patch++;
        }
        else {
            parsedCurrentVersion.patch = 1;
        }
        return serializeCalver(parsedCurrentVersion);
    }
    const date = opts?.currentDate || new Date();
    const currentYearShort = getShortYear(date);
    const currentMonth = date.getMonth() + 1;
    if (currentYearShort !== parsedCurrentVersion.yearShort || currentMonth !== parsedCurrentVersion.month) {
        return serializeCalver({
            yearShort: currentYearShort,
            month: currentMonth,
            versionInMonth: 0,
        });
    }
    else {
        return serializeCalver({
            ...parsedCurrentVersion,
            versionInMonth: parsedCurrentVersion.versionInMonth + 1,
            patch: undefined,
        });
    }
}
export function isSemver(version, opts) {
    try {
        return !!parsedVersionIsSemver(parseAndValidateCalver(version, opts));
    }
    catch {
        return false;
    }
}
export function isCalver(version) {
    try {
        return !parsedVersionIsSemver(parseAndValidateCalver(version, {
            currentDate: new Date("2040"),
        }));
    }
    catch (e) {
        return false;
    }
}
function parsedVersionIsSemver(parsedVersion) {
    return parsedVersion.yearShort < 21;
}
function compare(lhs, rhs, opts) {
    const lhsIsSemver = parsedVersionIsSemver(parseAndValidateCalver(lhs, opts));
    const rhsIsSemver = parsedVersionIsSemver(parseAndValidateCalver(rhs, opts));
    if (lhsIsSemver && rhsIsSemver)
        throw new Error(`Assuming ${lhs} and ${rhs} are both semver's. We do not support comparing semver alone`);
    if (lhsIsSemver)
        return -1;
    if (rhsIsSemver)
        return 1;
    return lhs.localeCompare(rhs);
}
export function gt(lhs, rhs, opts) {
    return compare(lhs, rhs, opts) > 0;
}
export function gte(lhs, rhs, opts) {
    return compare(lhs, rhs, opts) >= 0;
}
export function lt(lhs, rhs, opts) {
    return compare(lhs, rhs, opts) < 0;
}
export function lte(lhs, rhs, opts) {
    return compare(lhs, rhs, opts) <= 0;
}
//# sourceMappingURL=calver.js.map