import eachDeep from "deepdash/eachDeep";
import { escapeRegExp, fromPairs } from "lodash-es";
import * as N3 from "n3";
import numeral from "numeral";
import { stringToTerm } from "rdf-string";
import SparqlJs from "sparqljs";
import { RESERVED_SPARQL_VARNAMES, SPARQL_RESULT_DEFAULT_PAGE_SIZE } from "./Constants.js";
function getParser(opts) {
    const defaultParserOptions = {
        skipUngroupedVariableCheck: true,
    };
    return new SparqlJs.Parser({
        ...defaultParserOptions,
        baseIRI: opts?.includeBaseIri ? "https://triplydb.com/" : undefined,
    });
}
function getGenerator() {
    return new SparqlJs.Generator({ allPrefixes: true });
}
const SparqlParser = getParser();
const SparqlParserWithBaseIri = getParser({ includeBaseIri: true });
const SparqlGenerator = getGenerator();
const stringDatatype = "http://www.w3.org/2001/XMLSchema#string";
const REGEX_REPLACE_STRING_DATATYPE = new RegExp(escapeRegExp(`^^<${stringDatatype}>`), "gm");
export function parse(query) {
    SparqlParser._resetBlanks();
    if (query.trim().length === 0)
        throw new Error("Empty query string");
    try {
        return SparqlParser.parse(query);
    }
    catch (e) {
        if (e.message.includes("Cannot resolve relative IRI")) {
            SparqlParserWithBaseIri._resetBlanks();
            return SparqlParserWithBaseIri.parse(query);
        }
        throw e;
    }
}
export function stringify(query) {
    return SparqlGenerator.stringify(query).replace(REGEX_REPLACE_STRING_DATATYPE, "");
}
export class BadRequestError extends Error {
    constructor(message) {
        super(message);
        this.name = "BadArgumentsError";
    }
}
function resetParentAlias(parents, variableName) {
    if (!parents)
        return;
    let immediateParentFound = false;
    for (const parent of parents.reverse()) {
        if (!parent.value.variables)
            continue;
        if (!immediateParentFound) {
            immediateParentFound = true;
            continue;
        }
        const projectionVariables = parent.value.variables;
        if (projectionVariables) {
            for (let i = 0; i < projectionVariables.length; i++) {
                const projectVariable = projectionVariables[i];
                if ("expression" in projectVariable && projectVariable.variable.value === variableName) {
                    projectionVariables[i] = projectVariable.variable;
                }
            }
        }
        return;
    }
}
function hasParentProjectionVariable(parents, variableName) {
    if (!parents)
        return false;
    for (const parent of parents.reverse()) {
        if (!parent.value.variables)
            continue;
        const projectionVariables = parent.value.variables;
        return projectionVariables.some((projectionVariable) => {
            if ("termType" in projectionVariable &&
                projectionVariable.termType === "Variable" &&
                projectionVariable.value === variableName) {
                return true;
            }
            return "expression" in projectionVariable && projectionVariable.variable.value === variableName;
        });
    }
}
export function injectInPlace(parsedQuery, opts) {
    injectPaginationInPlace(parsedQuery, opts);
    const { variableDefinitions, variableValues } = opts;
    const variableDefinitionsMap = fromPairs(variableDefinitions.map((d) => [d.name, d]));
    function getReplaceInfo(variableName) {
        const variableDefinition = variableDefinitionsMap[variableName];
        if (!variableDefinition)
            return;
        const stringReplacement = variableValues[variableName] || variableDefinition.defaultValue;
        if (!stringReplacement)
            return;
        return {
            stringReplacement,
            variableDefinition,
        };
    }
    function replaceVar(variableName) {
        const replaceInfo = getReplaceInfo(variableName);
        if (!replaceInfo)
            return;
        if (replaceInfo.variableDefinition.termType === "NamedNode") {
            return N3.DataFactory.namedNode(replaceInfo.stringReplacement);
        }
        else {
            if (replaceInfo.variableDefinition.language) {
                return N3.DataFactory.literal(replaceInfo.stringReplacement, replaceInfo.variableDefinition.language);
            }
            else if (replaceInfo.variableDefinition.datatype) {
                return N3.DataFactory.literal(replaceInfo.stringReplacement, N3.DataFactory.namedNode(replaceInfo.variableDefinition.datatype));
            }
            else {
                return N3.DataFactory.literal(replaceInfo.stringReplacement);
            }
        }
    }
    if (variableDefinitions.length > 0) {
        for (const p in parsedQuery.prefixes) {
            if (parsedQuery.prefixes[p] === "http://www.w3.org/2001/XMLSchema#") {
                delete parsedQuery.prefixes[p];
            }
        }
        function inSelectVariablesClause(parents) {
            return (parents &&
                parents.some((parent) => {
                    return (parent.key === "variables" &&
                        parent.parent?.value.queryType === "SELECT");
                }));
        }
        function isVariableExpression(value) {
            return !!(value && typeof value === "object" && "expression" in value && "variable" in value);
        }
        function isUsedInVariableExpression(value, variableName) {
            return isVariableExpression(value) && value.variable.value === variableName;
        }
        function inOperatorArgument(parents) {
            return parents && parents.some((parent) => parent.key === "args");
        }
        eachDeep(parsedQuery, (value, key, parentValue, context) => {
            if (inSelectVariablesClause(context.parents) && value && value.termType === "Variable") {
                if (!inOperatorArgument(context.parents)) {
                    if (isVariableExpression(parentValue)) {
                        if (key === "expression") {
                            const projectionVariable = value;
                            const projectionVariableName = projectionVariable.value;
                            const replaceWith = replaceVar(projectionVariableName);
                            if (replaceWith) {
                                parentValue[key] = replaceWith;
                            }
                        }
                        return;
                    }
                    const projectionVariable = value;
                    const projectionVariableName = projectionVariable.value;
                    const replaceWith = replaceVar(projectionVariableName);
                    if (replaceWith) {
                        parentValue[key] = {
                            expression: replaceWith,
                            variable: projectionVariable,
                        };
                        resetParentAlias(context.parents, projectionVariableName);
                        return false;
                    }
                }
            }
            if (key === "group") {
                const groupByItems = value;
                for (let i = 0; i < groupByItems.length; i++) {
                    const groupByItem = groupByItems[i];
                    if (groupByItem.expression &&
                        "termType" in groupByItem.expression &&
                        groupByItem.expression.termType === "Variable") {
                        const groupByVariableName = groupByItem.expression.value;
                        if (hasParentProjectionVariable(context.parents, groupByVariableName)) {
                            continue;
                        }
                        const replaceWith = replaceVar(groupByVariableName);
                        if (replaceWith) {
                            groupByItems[i] = {
                                expression: replaceWith,
                                variable: groupByItem.expression,
                            };
                        }
                    }
                }
                return false;
            }
            if (value && value.termType === "Variable") {
                const term = value;
                if (!isUsedInVariableExpression(parentValue, term.value)) {
                    const replaceWith = replaceVar(term.value);
                    if (replaceWith) {
                        parentValue[key] = replaceWith;
                        return false;
                    }
                }
            }
        });
    }
}
function getLimitAndOffset(opts) {
    const appliedPageSize = opts.pageSize !== undefined ? opts.pageSize : SPARQL_RESULT_DEFAULT_PAGE_SIZE;
    const appliedPage = opts.page !== undefined ? opts.page : 1;
    return {
        limit: appliedPageSize,
        offset: (appliedPage - 1) * appliedPageSize,
    };
}
const paginateRegex = /((limit|offset)\s*\d+\s*)*#\s*paginate/gi;
export function injectPaginationInPlace(parsedQuery, opts) {
    const { page, pageSize } = opts;
    if (page !== undefined || pageSize !== undefined) {
        if (parsedQuery.type !== "query") {
            throw new BadRequestError("Arguments `page` and `pageSize` are not supported for update queries");
        }
        if (parsedQuery.queryType === "ASK") {
            throw new BadRequestError("Arguments `page` and `pageSize` only apply to queries of type `SELECT`, `CONSTRUCT` and `DESCRIBE`.");
        }
        const { limit, offset } = getLimitAndOffset({ page, pageSize });
        const replacedQuery = opts.queryString.replaceAll(paginateRegex, `limit ${limit} offset ${offset}`);
        if (replacedQuery === opts.queryString) {
            parsedQuery.limit = limit;
            parsedQuery.offset = offset;
        }
        else {
            try {
                const parsedQueryWithCustomPagination = parse(replacedQuery);
                const keysToReplace = new Set([...Object.keys(parsedQuery), ...Object.keys(parsedQueryWithCustomPagination)]);
                for (const key of keysToReplace) {
                    parsedQuery[key] = parsedQueryWithCustomPagination[key];
                }
            }
            catch (e) {
                throw new BadRequestError("Cannot include custom pagination ('#paginate') functionality, as this results in an invalid query");
            }
        }
    }
}
export function parseAndInjectVariablesIntoQueryAndGetInfo(queryString, opts) {
    try {
        const queryWithInjectedVariables = parse(queryString);
        injectInPlace(queryWithInjectedVariables, { ...opts, queryString });
        return {
            query: stringify(queryWithInjectedVariables),
            isConstructQuery: queryWithInjectedVariables.type === "query" && queryWithInjectedVariables.queryType === "CONSTRUCT",
            limit: queryWithInjectedVariables.limit,
            offset: queryWithInjectedVariables.offset,
        };
    }
    catch (e) {
        if (opts.page === undefined && opts.pageSize === undefined && opts.variableDefinitions.length === 0)
            return { query: queryString };
        throw e;
    }
}
export function parseAndInjectVariablesIntoQuery(queryString, opts) {
    const { variableDefinitions, page, pageSize } = opts;
    if (variableDefinitions.length === 0 && page === undefined && pageSize === undefined) {
        return queryString;
    }
    const parsedQuery = parse(queryString);
    injectInPlace(parsedQuery, { ...opts, queryString });
    return stringify(parsedQuery);
}
export function filterSuggestions(forVariableConfiguration, suggestions) {
    return suggestions
        .map((suggestedString) => {
        const suggestedTerm = stringToTerm(suggestedString);
        if (suggestedTerm.termType !== forVariableConfiguration.termType)
            return undefined;
        if (suggestedTerm.termType === "Literal" && forVariableConfiguration.termType === "Literal") {
            if ("datatype" in forVariableConfiguration) {
                if (suggestedTerm.datatype.value !== `<${forVariableConfiguration.datatype}>`)
                    return undefined;
            }
            else if ("language" in forVariableConfiguration) {
                if (suggestedTerm.language !== forVariableConfiguration.language)
                    return undefined;
            }
            else {
                if (suggestedTerm?.datatype.value !== "http://www.w3.org/2001/XMLSchema#string" || suggestedTerm.language)
                    return undefined;
            }
        }
        return suggestedTerm.value;
    })
        .filter((s) => !!s);
}
function validateSparqlQueryApiVariables(opts) {
    for (const variableDef of opts.variableDefinitions) {
        if (variableDef.required && !variableDef.defaultValue && !(variableDef.name in opts.variableValues)) {
            throw new BadRequestError(`Argument '${variableDef.name}' is required`);
        }
    }
    for (const arg of Object.keys(opts.variableValues)) {
        if (RESERVED_SPARQL_VARNAMES.includes(arg))
            continue;
        const variable = opts.variableDefinitions.find((x) => x.name === arg);
        if (variable === undefined) {
            throw new BadRequestError(`Argument ${arg} is not allowed`);
        }
        if (variable.allowedValues && variable.allowedValues.length > 0) {
            const value = opts.variableValues[arg];
            if (!value || variable.allowedValues.indexOf(value) < 0) {
                const allowed = variable.allowedValues.join(", ");
                throw new BadRequestError(`"${variable.name}" must be one of [${allowed}]`);
            }
        }
    }
}
function checkIsFinitePositive(opts) {
    const n = Math.floor(opts.val);
    if (n === Infinity || n !== opts.val || n < 1) {
        throw new BadRequestError(`Argument '${opts.argument}' must be a positive integer`);
    }
    if (opts.max && n > opts.max) {
        throw new BadRequestError(`Argument '${opts.argument}' may be at most ${numeral(opts.max).format("0,0")}`);
    }
}
export function validate(opts) {
    if (opts.page !== undefined) {
        checkIsFinitePositive({
            argument: "page",
            val: opts.page,
        });
    }
    if (opts.pageSize !== undefined) {
        checkIsFinitePositive({
            argument: "pageSize",
            val: opts.pageSize,
            max: opts.maximumResultSize || 10000,
        });
    }
    if (opts.pageMeta !== undefined) {
        if (opts.pageMeta.maxRetries !== undefined) {
            checkIsFinitePositive({
                argument: "maxRetries",
                val: opts.pageMeta.maxRetries,
            });
        }
    }
    validateSparqlQueryApiVariables(opts);
}
//# sourceMappingURL=sparqlVarUtils.js.map