#!/usr/bin/env node
import { exec } from "child_process";
import chalk from "chalk";
import { findUp } from "find-up";
import fs from "fs-extra";
import { difference, flatten, isEmpty, repeat, sumBy, uniq } from "lodash-es";
import yaml from "yaml";
const severities = ["info", "low", "moderate", "high", "critical"];
async function getAuditResponse() {
    const response = await new Promise((resolve, reject) => {
        exec("yarn npm audit --recursive --environment production  --all --json", (error, stdout) => {
            if (error)
                return reject(error);
            resolve(stdout);
        });
    });
    return JSON.parse(response);
}
function lineLogger(padStartLength) {
    return function logger(logString) {
        console.info(repeat(" ", padStartLength) + logString);
    };
}
function tupleToString(key, val) {
    return `${chalk.bold(key)}: ${val}`;
}
function isAllowed(config, ghAdvisoryId, path) {
    const advistoryAllowList = config.allowList[ghAdvisoryId];
    if (!advistoryAllowList)
        return false;
    return advistoryAllowList.some((paths) => paths.path === path);
}
const log0 = console.info;
const log1 = lineLogger(1);
const log2 = lineLogger(3);
const log3 = lineLogger(5);
function logAdvisory(advisory, config) {
    const versions = uniq(advisory.findings.map((finding) => finding.version));
    const paths = uniq(flatten(advisory.findings.map((finding) => finding.paths)));
    const minSeverityIndex = severities.indexOf(config.severity);
    if (severities.indexOf(advisory.severity) < minSeverityIndex)
        return { foundVulnerabilities: [], allowListedVulnerabilities: [] };
    const allowedPaths = paths.filter((path) => isAllowed(config, advisory.github_advisory_id, path));
    const foundPaths = difference(paths, allowedPaths);
    if (foundPaths.length) {
        log1(tupleToString(advisory.module_name, chalk.cyanBright(versions.join(", "))));
        log2(tupleToString("Issue", advisory.title));
        log2(tupleToString("ID", advisory.github_advisory_id));
        log2(tupleToString("URL", chalk.magenta(advisory.url)));
        log2(tupleToString("Severity", advisory.severity));
        log2(tupleToString("Vulnerable", chalk.cyanBright(advisory.vulnerable_versions)));
        log2(tupleToString("Patched", chalk.cyanBright(advisory.patched_versions)));
        log2(tupleToString("Recommendation", advisory.recommendation));
        log2(tupleToString("Paths", chalk.italic(`(Run \`yarn why ${advisory.module_name} --recursive\` to see more detailed dependency information)`)));
        for (const path of foundPaths) {
            log3(chalk.cyanBright(path));
        }
        log0();
    }
    return {
        foundVulnerabilities: foundPaths,
        allowListedVulnerabilities: allowedPaths,
    };
}
function logSummary(summary, allAllowListed, allFound, config) {
    if (summary.devDependencies) {
        log0(chalk.yellow("The results contain dev dependencies. This is probably not what you want. To only audit production dependencies with this script then make sure to install production dependencies only, e.g. running `yarn workspaces focus --all --production`"));
        log0();
    }
    const numAllowListed = sumBy(Object.values(allAllowListed), (paths) => paths.length);
    const numFound = sumBy(Object.values(allFound), (paths) => paths.length);
    let unusedAllowListPatterns = {};
    for (const id in config.allowList) {
        if (!allAllowListed[id]) {
            unusedAllowListPatterns[id] = config.allowList[id].map((paths) => paths.path);
        }
        else {
            const unusedPaths = difference(config.allowList[id].map((paths) => paths.path), allAllowListed[id]);
            if (unusedPaths.length) {
                unusedAllowListPatterns[id] = unusedPaths;
            }
        }
    }
    log0(`Inspected ${summary.totalDependencies} Vulnerabilities:`);
    log1(chalk.green(`${numAllowListed} allow-listed vulnerabilities`));
    const redOrGreen = numFound ? chalk.red : chalk.green;
    log1(redOrGreen(`${numFound} found vulnerabilities with a severity ${config.severity}+`));
    if (numFound && process.env["CI"]) {
        log0();
        log0(tupleToString(`To inspect the vulnerabilities locally, run the following`, ""));
        log2(`yarn workspaces focus --production --all`);
        log2(`yarn auditor`);
        log0(chalk.italic("After applying the above, run `yarn` to install all of your dev dependencies again"));
    }
    if (!isEmpty(unusedAllowListPatterns)) {
        log0();
        log0(chalk.yellow("The following allow-list rules were unused, and can probably be removed:"));
        for (const id in unusedAllowListPatterns) {
            log1(tupleToString(id, ""));
            for (const path of unusedAllowListPatterns[id]) {
                log2(chalk.italic(path));
            }
        }
    }
}
async function getConfig() {
    const configFile = await findUp(".auditor.yml");
    if (!configFile)
        throw new Error("Could not find .auditor.yml file");
    const config = yaml.parse(await fs.readFile(configFile, "utf-8"));
    if (!config)
        throw new Error(".auditor.yml file is empty");
    if (!config.severity)
        config.severity = "info";
    if (!config.allowList)
        config.allowList = {};
    if (severities.indexOf(config.severity) < 0) {
        throw new Error(`Unexpected severity found in config file: ${config.severity}`);
    }
    for (const id in config.allowList) {
        const allowListItem = config.allowList[id];
        for (const path of allowListItem) {
            if (!path.issue) {
                throw new Error(`Invalid auditor allowlist. Expected ID ${id} and path '${path.path}' to reference an issue`);
            }
        }
    }
    return config;
}
async function run() {
    const auditResults = await getAuditResponse();
    const config = await getConfig();
    const allAllowListed = {};
    const allFoundVulnerabilities = {};
    for (const npmAdvisoryId in auditResults.advisories) {
        const advisory = auditResults.advisories[npmAdvisoryId];
        const { allowListedVulnerabilities, foundVulnerabilities } = logAdvisory(advisory, config);
        const githubAllowListId = advisory.github_advisory_id;
        if (!allAllowListed[githubAllowListId])
            allAllowListed[githubAllowListId] = [];
        allAllowListed[githubAllowListId].push(...allowListedVulnerabilities);
        if (!allFoundVulnerabilities[githubAllowListId])
            allFoundVulnerabilities[githubAllowListId] = [];
        allFoundVulnerabilities[githubAllowListId].push(...foundVulnerabilities);
    }
    logSummary(auditResults.metadata, allAllowListed, allFoundVulnerabilities, config);
    if (flatten(Object.values(allFoundVulnerabilities)).length)
        process.exit(6);
}
run().catch((e) => {
    console.error(e);
    process.exit(1);
});
//# sourceMappingURL=auditor.js.map