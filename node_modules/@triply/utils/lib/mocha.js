import { after as mochaAfter, afterEach as mochaAfterEach, before as mochaBefore, beforeEach as mochaBeforeEach, it as mochaIt, } from "mocha";
function forceLargeTimeout(fn) {
    return async function () {
        const origTimeout = this.timeout;
        this.timeout("600s");
        this.timeout = ((time) => {
            return origTimeout.apply(this, [time === undefined ? time : "600s"]);
        });
        let result;
        try {
            result = await fn.apply(this);
        }
        finally {
            this.timeout = origTimeout;
        }
        return result;
    };
}
function addIgnoreFunctionality(fn) {
    return async function () {
        this.ignoreWhen = (ignoreFn) => {
            this._ignoreWhen = ignoreFn;
        };
        try {
            await fn.apply(this);
        }
        catch (e) {
            if (e instanceof Error && this._ignoreWhen?.(e)) {
                console.error("Test failed, but ignoring the error");
                console.error(e);
                return;
            }
            throw e;
        }
        finally {
            this._ignoreWhen = undefined;
        }
    };
}
function addSilenceTransmittedErrorsFunctionality(fn) {
    return async function () {
        this.silenceTransmittedErrors = () => {
            global.silenceTransmittedErrors = true;
        };
        try {
            await fn.apply(this);
        }
        finally {
            delete global.silenceTransmittedErrors;
        }
    };
}
export function getWrappedMochaFunctions(...wrappers) {
    wrappers.push(forceLargeTimeout);
    wrappers.push(addIgnoreFunctionality);
    wrappers.push(addSilenceTransmittedErrorsFunctionality);
    function getWrapper(fn) {
        let wrapped = fn;
        for (const wrapper of wrappers) {
            wrapped = wrapper(wrapped);
        }
        return wrapped;
    }
    function it(title, fn) {
        return mochaIt(title, getWrapper(fn));
    }
    it.only = function (title, fn) {
        return mochaIt.only(title, getWrapper(fn));
    };
    it.skip = function (title, fn) {
        return mochaIt.skip(title, getWrapper(fn));
    };
    function before(fn) {
        return mochaBefore(getWrapper(fn));
    }
    function beforeEach(fn) {
        return mochaBeforeEach(getWrapper(fn));
    }
    function after(fn) {
        return mochaAfter(getWrapper(fn));
    }
    function afterEach(fn) {
        return mochaAfterEach(getWrapper(fn));
    }
    return {
        it,
        before,
        beforeEach,
        after,
        afterEach,
    };
}
const defaultMochaFunctions = getWrappedMochaFunctions();
export const it = defaultMochaFunctions.it;
export const before = defaultMochaFunctions.before;
export const beforeEach = defaultMochaFunctions.beforeEach;
export const after = defaultMochaFunctions.after;
export const afterEach = defaultMochaFunctions.afterEach;
//# sourceMappingURL=mocha.js.map