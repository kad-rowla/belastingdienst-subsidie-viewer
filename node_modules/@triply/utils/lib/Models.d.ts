import { estypes } from "@elastic/elasticsearch";
import { MarkRequired } from "ts-essentials";
import { DatasetLicenseId, QUERY_TYPES } from "./Constants.js";
import { Prefix, PrefixInfo, Statement } from "./index.js";
export { Statement } from "./index.js";
export { Prefix, PrefixInfo } from "./index.js";
export declare const ANONYMOUS_KEY = "__triply-anonymous";
export interface ParsingContext {
    line: number;
    lines?: {
        [line: number]: string;
    };
    token?: Token;
    previousToken?: Token;
}
export interface ErrorResponse {
    [ANONYMOUS_KEY]?: true;
    stackTraces?: string;
    code?: number;
    message: string;
    errors?: ErrorResponse[];
    serverError?: string;
    files?: string[];
    parsingContext?: ParsingContext;
    failedFileType?: "xml" | "nquads" | "ntriples" | "turtle" | "trig" | "bzip" | "gzip" | "zip" | "rar" | "7z" | "tar" | string;
}
export interface JwtPayload {
    imp?: string;
    uid: string;
    aud?: string;
    ssa?: number;
    mfa?: {
        type: "authenticator";
        id: string;
    };
    iss?: string;
    jti?: string;
    exp?: number;
    iat?: number;
}
export interface Scopes {
    acc?: Array<"pub" | "priv" | "a">;
    ds?: Array<"c" | "r" | "u" | "d" | "a">;
    us?: Array<"u" | "a">;
    tok?: Array<"c" | "a">;
    cust?: string[];
}
export type OrgRole = "owner" | "member";
export interface OrgMember {
    role: OrgRole;
    user: User;
    createdAt: string;
    updatedAt: string;
}
export interface OrgMemberUpdate {
    role: OrgRole;
}
export type AccountType = "user" | "org";
export type PinnedItemType = "Dataset" | "Query" | "Story";
export interface PinnedDataset {
    type: "Dataset";
    item: DatasetPublic;
}
export interface PinnedQuery {
    type: "Query";
    item: Query;
}
export interface PinnedStory {
    type: "Story";
    item: Story;
}
export type PinnedItem = PinnedDataset | PinnedQuery | PinnedStory;
export interface PinnedItemUpdate {
    type: PinnedItemType;
    item: string;
}
export interface AccountPublic {
    avatarUrl?: string;
    accountName: string;
    name?: string;
    description: string;
    uid: string;
    createdAt: string;
    pinnedItems?: PinnedItem[];
    datasetCount?: number;
    queryCount?: number;
    storyCount?: number;
}
export interface AccountPrivate {
    email?: string;
    updatedAt: string;
    mfaEnabled?: boolean;
}
export interface AccountUpdate {
    name?: string;
    email?: string;
    accountName?: string;
    pinnedItems?: PinnedItemUpdate[];
    description?: string;
    mfaEnabled?: boolean;
}
export type Account = User | Org;
export type UserRole = "superAdmin" | "siteAdmin" | "regular" | "light" | "none";
export type ConsentStatus = "ok" | "expiring" | "expired" | "unset";
export interface UserPublic {
    type: "user";
    role?: UserRole;
    orgs?: Org[];
}
export interface UserPrivate {
    impersonated?: true;
    authMethod: string;
    verified: boolean;
    legalConsent?: ConsentStatus;
    disabled: boolean;
    expiresAt?: string;
    role?: UserRole;
    lastActivity?: string;
    mfaEnabled?: boolean;
    usageInfo?: {
        services: string[];
        graphCount: number;
        statementCount: number;
        assetBytes: number;
    };
}
export interface UserUpdate extends AccountUpdate {
    role?: UserRole;
    disabled?: boolean;
    expiresAt?: string;
    verified?: boolean;
    legalConsent?: boolean;
}
export type User = Partial<AccountPrivate> & Partial<UserPrivate> & AccountPublic & UserPublic;
export interface BulkUserReport {
    success: number;
    errors: {
        account: string;
        message: string;
    }[];
}
export interface OrgPublic {
    type: "org";
    members?: OrgMember[];
}
export interface OrgPrivate {
}
export interface OrgUpdate extends AccountUpdate {
}
export type Org = Partial<AccountPrivate> & Partial<OrgPrivate> & AccountPublic & OrgPublic;
export type AccessLevel = "public" | "private" | "internal";
export type Dataset = DatasetPublic;
export interface DatasetPublic {
    id: string;
    name: string;
    description: string;
    displayName: string;
    avatarUrl: string | undefined;
    owner: Account;
    accessLevel: AccessLevel;
    license: DatasetLicenseId;
    createdAt: string;
    updatedAt: string;
    graphCount: number;
    statements: number;
    lastGraphsUpdateTime?: string;
    serviceCount: number;
    assetCount: number;
    topics: Topic[];
    prefixes: Prefixes;
    implicitTopics: Topic[];
    exampleResources: string[];
}
export interface DatasetVerbose extends DatasetPublic {
    services: Array<ServiceMetadata>;
    largestGraphs: Graphs;
    openJobs?: Job[];
}
export interface UpdateDataset {
    displayName?: string;
    description?: string;
    name?: string;
    accessLevel?: AccessLevel;
    license?: DatasetLicenseId | null;
    topics?: string[];
    exampleResources?: string[];
}
export interface NewDataset {
    name?: string;
    displayName?: string;
    toAccount?: string;
    description?: string;
    accessLevel?: AccessLevel;
    license?: DatasetLicenseId;
}
export type QueryType = (typeof QUERY_TYPES)[number];
export type ServiceStatus = "starting" | "running" | "stopping" | "stopped" | "removing" | "updating" | "error";
export type LoadStatus = "loaded" | "loading" | "error" | "notLoaded";
export type ServiceType = "elasticSearch" | "virtuoso" | "jena" | "blazegraph" | "prolog";
export type Capability = "sparql" | "sparqlApi" | "elasticSearch" | "simpleTextSearch";
export interface ServiceGraphInfo {
    graphName: string;
    status: LoadStatus;
    statements: number;
    error?: string;
}
export type ServiceConfig = ServiceConfigJena | ServiceConfigElastic;
export interface ServiceConfigJena {
    reasonerType: JenaReasoner;
}
export interface ServiceConfigElastic {
    componentTemplates?: estypes.ClusterPutComponentTemplateRequest[];
    indexTemplates?: estypes.IndicesPutIndexTemplateRequest[];
}
export interface ServiceMetadata {
    type: ServiceType;
    version: string;
    capabilities: Capability[];
    name: string;
    id: string;
    numberOfLoadedStatements?: number;
    numberOfLoadedGraphs?: number;
    numberOfGraphs?: number;
    numberOfGraphErrors?: number;
    error?: ErrorResponse;
    status: ServiceStatus;
    endpoint?: string;
    outOfSync?: boolean;
    loadedAt?: string;
    createdAt: string;
    config?: ServiceConfig;
    autoResume?: boolean;
    queriedAtUncached?: string;
    queriedAt?: string;
    autostopsAt?: string;
    dataset?: Dataset;
    adminInfo?: {
        fromOrchestrator?: {};
        fromService?: {};
    };
    canUpdate?: boolean;
    foundInDocker?: boolean;
    foundInMongo?: boolean;
}
export interface ServiceLogs {
    logs: string;
    tail: number;
}
export type JenaReasoner = "OWL" | "RDFS" | "None";
export interface ServiceActions {
    start?: boolean;
    stop?: boolean;
    stopWithAutoresume?: boolean;
    sync?: boolean;
    restart?: boolean;
}
export interface CreateServiceBase {
    type: ServiceType;
    name: string;
    memoryLimit?: number | string;
    config?: unknown;
}
export interface CreateServiceVirtuoso extends CreateServiceBase {
    type: "virtuoso";
    config?: never;
}
export interface CreateServiceBlazegraph extends CreateServiceBase {
    type: "blazegraph";
    config?: never;
}
export interface CreateServiceElasticSearch extends CreateServiceBase {
    type: "elasticSearch";
    config?: {
        componentTemplates?: estypes.ClusterPutComponentTemplateRequest[];
        indexTemplates?: estypes.IndicesPutIndexTemplateRequest[];
    };
}
export interface CreateServiceProlog extends CreateServiceBase {
    type: "prolog";
    config?: never;
}
export interface CreateServiceJena extends CreateServiceBase {
    type: "jena";
    config?: {
        reasonerType: JenaReasoner;
    };
}
export type CreateService = CreateServiceBlazegraph | CreateServiceVirtuoso | CreateServiceJena | CreateServiceProlog | CreateServiceElasticSearch;
export interface UpdateService {
    name: string;
}
export interface Token {
    description: string;
    issuedAt: string;
    lastAccessed?: string | null;
    token?: string;
    tokenId: string;
    ownerId: string;
    scopes: Scopes;
}
export type CreateToken = Pick<Token, "description" | "scopes">;
export type FeatureToggle = "rocksRead" | "rocksWrite" | "ldKitchen";
export type FeatureToggles = {
    [feature in FeatureToggle]: {
        value: boolean;
        label?: string;
    };
};
export type PinnedDatasetWithDescriptions = PinnedDataset & {
    descriptions: {
        [resource: string]: NtriplyStatements;
    };
};
export interface FrontPage {
    items: Array<PinnedQuery | PinnedStory | PinnedDatasetWithDescriptions>;
}
export type LogoBackgroundType = "circle" | "square" | "none";
export interface ClientConfig {
    branding: {
        name: string;
        logo: string;
        logoBgType: LogoBackgroundType;
        logoBgColor: string;
        logoLg: string;
        banner?: string;
        tagline: string;
        description: string;
        welcomeMessage: string;
    };
    consoleUrl?: string;
    apiUrl?: string;
    contactEmail: string;
    prefixes: Prefixes;
    jenaServicesEnabled?: boolean;
    elasticServicesEnabled?: boolean;
    virtuosoServicesEnabled?: boolean;
    enabledServices: Array<ServiceType>;
    starterDataset?: Dataset;
    enabledOauth?: string[];
    enforceTfa?: EnforceTfaSetting;
    passwordSignup?: boolean;
    saml?: Array<{
        label: string;
        idp: string;
    }>;
    version?: string;
    statements?: number;
    buildDate: string;
    buildId: string;
    permittedSignupDomains?: string;
    enabledCache?: {
        [cache in CacheType]: boolean;
    };
    featureToggles?: FeatureToggles;
    triplydb?: {
        numAvailableAccounts?: number;
        serviceExpirationDays?: number;
        userServiceLimit?: number;
        serviceStatementLimit?: number;
        userGraphLimit?: number;
        userStatementLimit?: number;
        userAssetByteLimit?: number;
    };
    legal?: {
        latestRequiredConsentUpdate: string;
        privacyPolicyUrl: string;
        generalTermsUrl: string;
    };
    memoryFree?: number;
    memoryTotal?: number;
    limitStatus?: "warning" | "exceeded";
    debugNamespaces?: string;
    instanceUpdatedAt?: string;
    instanceStartedAt?: string;
    licenceExpireDate?: string;
    counts?: {
        queries: number;
        datasets: number;
        stories: number;
    };
    speedyEnabled?: true;
}
export interface FrontpageUpdate {
    items: PinnedItemUpdate[];
}
export interface ClientConfigUpdate {
    branding?: {
        name?: string;
        logo?: string;
        logoBgType?: LogoBackgroundType;
        logoBgColor?: string;
        logoLg?: string;
        tagline?: string;
        description?: string;
        welcomeMessage?: string;
    };
    contactEmail?: string;
    prefixes?: Prefixes;
    starterDataset?: string;
    enabledOauth?: string[];
    enabledSaml?: string[];
    enforceTfa?: EnforceTfaSetting | false;
    passwordSignup?: boolean;
    permittedSignupDomains?: string;
    featureToggles?: {
        [feature in FeatureToggle]?: boolean;
    };
    isGeneralPublicInstanceDev?: boolean;
}
export type EnforceTfaSetting = {
    userRole: "admins" | "all";
    authMethod?: "password" | "all";
};
export type TaskMode = "automatic" | "manual";
export interface BackgroundTask {
    id: string;
    label: string;
    description: string;
    mode: TaskMode;
    current?: BackgroundTaskExecution;
    history: Array<BackgroundTaskExecution>;
}
export interface BackgroundTaskAction {
    executionId?: string;
    action: "start" | "abort" | "clear-history";
}
export interface BackgroundTaskExecution {
    startedAt: string;
    stoppedAt?: string;
    apiVersion: string;
    trigger: TaskMode;
    report: string;
    status: "aborted" | "running" | "finished";
    id: string;
    activeWorkers: string[];
}
export interface RedirectRule {
    matchingMethod: "prefix" | "regexp";
    match: string;
    toDataset: Dataset | string;
    id?: string;
}
export interface AdminCacheUpdate {
    clearCache?: CacheType;
    enableCache?: {
        type: CacheType;
        enabled: boolean;
    };
}
export type MiddlewareCacheType = "frontpage" | "sparql" | "savedQuery" | "elasticSearch" | "describe";
export type CacheType = "hdtFilePointer" | MiddlewareCacheType;
export interface AdminDebugUpdate {
    namespace: string;
}
export interface DescribePaginationOptions<P = string> {
    page: number;
    predicate?: P;
    direction: "backward" | "forward";
}
export interface DescribeArguments extends Partial<DescribePaginationOptions> {
    resource: string;
    concise?: undefined;
}
export type Prefixes = Array<Prefix>;
export interface PrefixUpdate {
    prefixLabel: string;
    iri: string;
}
export type Imports = Array<Import>;
export interface Import {
    dataset: {
        ownerName?: string;
        datasetName?: string;
    };
    graphs: Array<{
        id: string;
        from: string;
        to: string;
        numberOfStatements: number;
    }>;
}
export type UpdateImports = Array<UpdateImport>;
export interface UpdateImport {
    dataset: {
        ownerName: string;
        datasetName: string;
    };
    graphs: Array<{
        from: string;
        to?: string;
        overwrite?: boolean;
    }>;
}
export type Graphs = Array<Graph>;
export type QualityReportSummary = {
    numberOfErrors: number;
    numberOfInvalidIris?: number;
    numberOfLanguageTagErrors?: number;
    numberOfDatatypeErrors?: number;
    languageTagErrors?: {
        count: number;
        examples: {
            value: string;
            message: string;
            context: {
                subject: string;
                predicate: string;
                object: string;
            };
        }[];
    };
    datatypeErrors?: {
        [datatype: string]: {
            datatype: string;
            count: number;
            examples: {
                value: string;
                message: string;
                context: {
                    subject: string;
                    predicate: string;
                    object: string;
                };
            }[];
        };
    };
    iriErrors?: {
        count: number;
        examples: {
            value: string;
            message: string;
            context: {
                subject: string;
                predicate: string;
                object: string;
            };
        }[];
    };
};
export interface Graph {
    graphName: string;
    id: string;
    numberOfStatements: number;
    importedAt?: string;
    uploadedAt?: string;
    importedFrom?: {
        dataset?: string;
        graphName: string;
        datasetName?: string;
        datasetAvatarUrl?: string;
    };
    qualityReport?: QualityReportSummary;
}
export type ClassHierarchy = {
    name: string;
    parent?: string;
    numberOfDirectInstances: number;
    prefixInfo?: PrefixInfo;
}[];
export type PropertyStats = {
    iri: string;
    number: number;
}[];
export type ClassFrequency = {
    iri: string;
    number: number;
    properties: PropertyStats;
}[];
export type Hooks = Array<Hook>;
export interface Hook extends HookCreate {
    id: string;
}
export interface HookCreate {
    url: string;
    active: boolean;
    payloadFormat: "JSON" | "formEncoded";
    onEvents: {
        graphImport: boolean;
        linkedDataUpload: boolean;
        fileUpload: boolean;
    };
}
export type WebHookTriggerRecords = Array<WebHookTriggerRecord>;
export interface WebHookTriggerRecord {
    id?: string;
    _id?: string;
    url: string;
    createdAt?: string;
    updatedAt?: string;
    statusCode: number;
    responseText: string;
    errorCode: string;
    errorMessage: string;
    eventName: string;
    payloadFormat: string;
    payload: Object;
}
export type Assets = Array<Asset>;
export interface Asset {
    assetName: string;
    createdAt: string;
    identifier: string;
    versions: AssetVersion[];
    url: string;
}
export interface AssetVersion {
    id: string;
    uploadedAt: string;
    url: string;
    fileSize: number;
}
export type Queries = Array<Query>;
export interface Query {
    id: string;
    name: string;
    displayName?: string;
    description: string;
    owner: Account;
    accessLevel: AccessLevel;
    dataset?: Dataset;
    service: string;
    link: string;
    autoselectService: boolean;
    preferredService?: string;
    version: number;
    numberOfVersions: number;
    requestConfig?: QueryRequestConfig;
    renderConfig?: QueryRenderConfig;
    createdAt: string;
    updatedAt: string;
    variables?: VariableConfig[];
}
export interface QueryRequestConfig {
    payload: SparqlQuery;
    headers?: {
        [key: string]: string;
    };
    ldFrame?: object;
}
export interface QueryRenderConfig {
    output: string;
    settings?: any;
}
interface CommonVariableConfig {
    name: string;
    defaultValue?: string;
    required?: boolean;
    allowedValues?: string[];
}
export interface NamedNodeConfig extends CommonVariableConfig {
    termType: "NamedNode";
}
export interface LiteralConfig extends CommonVariableConfig {
    termType: "Literal";
    datatype?: string;
    language?: string;
}
export type VariableConfig = NamedNodeConfig | LiteralConfig;
export interface QueryMetaUpdate {
    name?: string;
    displayName?: string;
    description?: string;
    accessLevel?: AccessLevel;
    dataset?: string;
    preferredService?: string;
    autoselectService?: boolean;
}
export type QueryCreate = MarkRequired<QueryMetaUpdate, "name"> & Partial<QueryVersionUpdate> & {
    generateNewName?: boolean;
};
export interface QueryVersionUpdate {
    requestConfig: QueryRequestConfig;
    renderConfig?: QueryRenderConfig;
    variables?: VariableConfig[];
}
export interface SparqlQuery {
    query: string;
    "default-graph-uri"?: string | string[];
    "named-graph-uri"?: string | string[];
    format?: string;
    timeout?: number;
    debug?: string;
}
export interface SimpleSearchQuery {
    query: string;
}
export interface AdvancedSearchQuery {
    [key: string]: any;
}
export interface HdtQuery {
    subject?: string;
    predicate?: string;
    object?: string;
    graph?: string;
    fileIndex?: number;
    offset?: number;
    expectedFileWindow?: number;
    limit?: number;
}
export interface HdtQueryShort {
    s?: string;
    p?: string;
    o?: string;
    g?: string;
    fi?: number;
    ofs?: number;
    fw?: number;
    l?: number;
}
export type QueryResults = Statement[];
export interface FindTermsQuery {
    pos: "subject" | "predicate" | "object" | "graph";
    graph?: string;
    q?: string;
    limit?: number;
}
export type FindTermsResult = string[];
export type QueryResult = Statement;
export type JobStatuses = "created" | "indexing" | "finished" | "canceled" | "error" | "downloading";
export type JobFileInfo = {
    fileName: string;
    fileSize: number;
    sourceFileId: string;
};
export type JobTypes = "upload" | "download";
export interface Job {
    baseIRI?: string;
    createdAt: string;
    datasetId: string;
    defaultGraphName?: string;
    downloadedBytes: number;
    downloadingProgress: number;
    downloadUrls?: string[];
    error?: ErrorResponse;
    files: JobFileInfo[];
    graphNames?: string[];
    indexedGraphCount: number;
    indexingProgress: number;
    jobId: string;
    jobUrl: string;
    skippedFileCount: number;
    skippedFileNames: string[];
    status: JobStatuses;
    type: JobTypes;
    updatedAt: string;
}
export interface Error {
    code?: number;
    message: string;
}
export interface Topic {
    id: string;
    iri: string;
    label: string;
    description?: string;
    parent?: string;
}
export type TopicUpdates = Array<TopicUpdate>;
export interface TopicUpdate {
    id?: string;
    iri?: string;
    label?: string;
    description?: string;
    parent?: string;
}
export interface SearchResults {
    datasets: Dataset[];
    accounts: Account[];
    moreDatasets: boolean;
    moreAccounts: boolean;
}
export interface ShortUrl {
    shortUrl: string;
    longUrl: string;
}
export interface LimitConfigLeaf {
    soft?: number;
    hard?: number;
}
export interface LimitJsonLeaf {
    limit?: number;
    count: number;
}
interface CountAndStatements<T> {
    count: T;
    statements: T;
}
type PartialIf<T, C> = C extends true ? Partial<T> : T;
type PartialCountAndStatementsIf<T, C> = PartialIf<CountAndStatements<T>, C>;
export interface InstanceLimits<T, C> {
    users: T;
    organizations: T;
    datasets: T;
    graphs: PartialIf<{
        unique: PartialCountAndStatementsIf<T, C>;
        all: PartialCountAndStatementsIf<T, C>;
    }, C>;
    services: Partial<{
        [key in ServiceType]: PartialCountAndStatementsIf<T, C>;
    }> & PartialIf<{
        all: PartialCountAndStatementsIf<T, C>;
    }, C>;
}
export type InstanceLimitsConfig = Partial<InstanceLimits<LimitConfigLeaf, true>>;
export type InstanceLimitsJson = InstanceLimits<LimitJsonLeaf, false>;
export type StoryElementType = "query" | "paragraph";
export interface StoryElement {
    id: string;
    type: StoryElementType;
    query?: Query;
    queryVersion?: number;
    paragraph?: string;
    caption?: string;
}
export interface Story {
    id: string;
    name: string;
    displayName?: string;
    owner: Account;
    accessLevel: AccessLevel;
    link: string;
    content: StoryElement[];
    createdAt: string;
    updatedAt: string;
    bannerUrl?: string;
}
export interface StoryElementUpdate {
    id?: string;
    type: StoryElementType;
    query?: string;
    queryVersion?: number;
    paragraph?: string;
    caption?: string;
}
export interface StoryUpdate {
    name?: string;
    displayName?: string;
    accessLevel?: AccessLevel;
    content?: StoryElementUpdate[];
}
export interface StoryCreate {
    name: string;
    displayName?: string;
    accessLevel?: AccessLevel;
    content?: StoryElementUpdate[];
}
export type RegisterOrLogin = "register" | "login";
export interface SimpleDataset {
    id: string;
    ownerAccountDisplayName?: string;
    ownerAccountName: string;
    displayName?: string;
    name: string;
    avatarUrl?: string;
    createdAt: string;
    created: string | undefined;
    owner: string;
    access: AccessLevel;
    sparql: string;
    search: string;
    statements: number;
    topic: string[];
    license: DatasetLicenseId | "Unset";
}
export interface FacetItem {
    label: string;
    owner?: string;
    id: string;
    count: number;
    active?: boolean;
}
export interface FilterItem {
    min: number;
    max: number;
}
export interface DatasetFacets {
    facets: {
        created: FacetItem[];
        owner: FacetItem[];
        access: FacetItem[];
        license: FacetItem[];
        sparql?: FacetItem;
        search?: FacetItem;
        statements: FacetItem[];
        topic: FacetItem[];
    };
    results: SimpleDataset[];
    count: number;
    page: number;
}
export interface SimpleStory {
    id: string;
    ownerAccountDisplayName?: string;
    ownerAccountName: string;
    displayName?: string;
    name: string;
    bannerUrl?: string;
    createdAt: string;
    created: string | undefined;
    owner: string;
    access: AccessLevel;
    dataset: string[];
    query: string[];
}
export interface StoryFacets {
    facets: {
        created: FacetItem[];
        owner: FacetItem[];
        access: FacetItem[];
        dataset?: FacetItem[];
        query?: FacetItem[];
    };
    results: SimpleStory[];
    count: number;
    page: number;
}
export interface SimpleQuery {
    id: string;
    ownerAccountDisplayName?: string;
    ownerAccountName: string;
    displayName?: string;
    name: string;
    createdAt: string;
    created: string | undefined;
    owner: string;
    access: AccessLevel;
    dataset: string;
    visualization: string;
}
export interface QueryFacets {
    facets: {
        created: FacetItem[];
        owner: FacetItem[];
        access: FacetItem[];
        dataset: FacetItem[];
        visualization: FacetItem[];
    };
    results: SimpleQuery[];
    count: number;
    page: number;
}
export interface SimpleOrganization {
    id: string;
    displayName?: string;
    name: string;
    avatarUrl?: string;
    createdAt: string;
    members: number;
    created: string | undefined;
}
export interface OrganizationFacets {
    facets: {
        created: FacetItem[];
    };
    filters: {
        members: FilterItem;
        datasets: FilterItem;
        stories: FilterItem;
        queries: FilterItem;
    };
    results: SimpleOrganization[];
    count: number;
    page: number;
}
export interface SomeDataset {
    id: string;
    name: string;
    displayName?: string;
    accountId: string;
    accountName: string;
    accountDisplayName?: string;
    avatarUrl?: string;
}
export interface SomeStory {
    id: string;
    name: string;
    displayName?: string;
    accountId: string;
    accountName: string;
    accountDisplayName?: string;
    bannerUrl?: string;
}
export interface SomeQuery {
    id: string;
    name: string;
    displayName?: string;
    accountId: string;
    accountName: string;
    accountDisplayName?: string;
    resultType?: string;
}
export interface SomeUser {
    uid: string;
    accountName: string;
    name?: string;
    avatarUrl?: string;
}
export interface SomeOrg {
    uid: string;
    accountName: string;
    name?: string;
    avatarUrl?: string;
}
export type NtriplyStatement = [NtriplyTerm, NtriplyTerm, NtriplyTerm, NtriplyTerm] | [NtriplyTerm, NtriplyTerm, NtriplyTerm];
export type NtriplyStatements = NtriplyStatement[];
export interface NtriplyTerm {
    termType: "NamedNode" | "BlankNode" | "Literal";
    value: string;
    language?: string;
    datatype?: string;
}
//# sourceMappingURL=Models.d.ts.map