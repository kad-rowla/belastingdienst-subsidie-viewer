import type Query from '@triply/triplydb/Query.js'
import { type VocabItem } from '../../Interfaces/VocabItem.js'
import path from 'path'
import chalk from 'chalk'
import { writeFileSync, existsSync, mkdirSync } from 'fs'

export default async function generateJsonFile (query: Query, displayName: string, description: string, prefix: string, iri: string): Promise<void> {
  // the query returns multiple entries for the same key, maybe someone can create a better query ...
  // using a map we will make it unique:
  const map = new Map<string, VocabItem>()

  ;(await query.results().bindings().toArray()).forEach((item) => {
    const key = item.key
    if (!map.has(key)) {
      delete item.key
      for (const key of Object.keys(item)) {
        if (item[key] === '') {
          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
          delete item[key]
        } else if (key.startsWith('vsc_')) {
          item[key.replace('vsc_', '')] = item[key]
          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
          delete item[key]
        }
      }
      map.set(key, item as any as VocabItem)
    }
  })
  const items: Record<string, VocabItem> = {}
  for (const [key, vocabItem] of map) {
    items[key] = vocabItem
  }

  const vocab = {
    displayName,
    description,
    prefix,
    iri,
    generated: new Date().toISOString(),
    items
  }

  const json = JSON.stringify(vocab, null, 2)
  const file = path.join(process.cwd(), 'static', 'Vocabularies', 'Generated', `${prefix}.json`)
  if (!existsSync(path.dirname(file))) {
    mkdirSync(path.dirname(file), { recursive: true })
  }
  writeFileSync(file, json, 'utf-8')
  process.stdout.write(chalk.bold('json done\n'))
}
