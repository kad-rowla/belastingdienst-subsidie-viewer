import Iri, { isIri } from './Iri.js'

const $SIGNATURE = '@triplyetl/vocabularies/Vocabulary'
export default class Vocabulary<NameSpace extends string = string> {
  public readonly $signature = $SIGNATURE

  protected $iris: Iri[] = []

  public constructor (public $namespace: NameSpace) {}

  public toString (): NameSpace {
    return this.$namespace
  }

  public toIri (): Iri<NameSpace> {
    return new Iri(this.$namespace)
  }

  public concat<Path extends string>(path: Path): Iri<`${NameSpace}${Path}`> {
    return new Iri<`${NameSpace}${Path}`>(`${this.$namespace}${path}`)
  }

  public toRecord (): Record<string, Iri> {
    const record: Record<string, Iri> = {}
    Object.keys(this).forEach((key) => {
      // @ts-expect-error we know now that 'key' is a class member of this
      if (isIri(this[key])) {
        // @ts-expect-error we know now that 'key' is a class member of this
        record[key] = this[key]
      }
    })
    return record
  }

  public static isVocabulary (vocab: any): vocab is Vocabulary {
    return typeof vocab === 'object' && Boolean(Object.hasOwn(vocab, '$signature')) && vocab.$signature === $SIGNATURE
  }

  // * [Symbol.iterator] (): IterableIterator<any> {
  //   const keys = Object.keys(this).filter((key) => !['toString', 'toIri', 'concat'].includes(key))
  //   for (let i = 0; i < keys.length; ++i) {
  //     yield keys[i]
  //   }
  // }
}
