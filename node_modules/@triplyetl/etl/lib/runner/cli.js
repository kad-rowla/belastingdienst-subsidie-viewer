#!/usr/bin/env node
import "source-map-support/register.js";
import { Option, program } from "commander";
import { render } from "ink";
import Main from "./Main.js";
import React from "react";
import CliContext from "./CliContext.js";
import path from "path";
import chalk from "chalk";
import ErrorBoundary from "./ErrorBoundary.js";
import fs from "fs-extra";
import Stacktrace from "./components/Stacktrace.js";
import { includeEtlVariablesInEnv } from "../utils/index.js";
import strtodate from "../utils/strtodate.js";
includeEtlVariablesInEnv();
/**
 * Try to reconstruct the original command with which the CLI was executed
 * That way, we can present the user with a modified version to e.g. enable debugging a etl record
 * It's also used for parsing command line arguments. Otherwise `npx` would not pass any arguments to this process, so we cant use process.argv
 */
const npmArgString = process.env["npm_config_argv"];
let cmd;
// Only use the cmd in CLI feedback messages when it corresponds to what the user typed
// I.e., we should render it when the user types `yarn exec etl`. We should not render it when
// the runs a custom package.json script called `yarn run start` (that internally calls etl)
let useCmdInCliFeedback = false;
//Only take npm arg string into account when it's executed directly (and not layered in another yarn script)
if (npmArgString && npmArgString.indexOf(`"etl"`) >= 0) {
    const npmArgs = JSON.parse(npmArgString);
    cmd = ["yarn", ...npmArgs.original];
    useCmdInCliFeedback = true;
}
else {
    cmd = process.argv.map((v) => {
        if (v.indexOf("/usr/bin/") === 0) {
            //Rewrite /usr/bin/yarn into yarn
            return v.substring("/usr/bin/".length);
        }
        if (v.indexOf("/") === 0) {
            //Assuming this is a reference to a file or something
            return path.relative(process.cwd(), v);
        }
        return v;
    });
}
let defaultTriplyDBToken = process.env["TRIPLYDB_TOKEN"] || undefined;
let defaultTriplyDBApi = process.env["TRIPLYDB_API"] || undefined;
let defaultTriplyDBAccount = process.env["TRIPLYDB_ACCOUNT"] || undefined;
/**
 * Historically we use '--from-record-id' and '--head', we now use '--offset' and '--limit',
 * but we keep the original arguments as legacy (hidden options).
 *
 * @see https://git.triply.cc/triply/etl/-/issues/214
 */
const fromRecordIdOption = new Option("--from-record-id <number>", "Only process from this record ID onwards");
fromRecordIdOption.hidden = true;
const headOption = new Option("--head [number]", "Only process the first <n> number of records. Defaults to <n> 10 when not specified.");
headOption.hidden = true;
const createErrorTrace = new Option("--create-error-trace", "Create an error trace if an error occurs.");
createErrorTrace.defaultValue = false;
createErrorTrace.makeOptionMandatory(false);
program
    .name("etl")
    .description("CLI runner for executing an ETL pipeline")
    .helpOption("-h, --help", "Display help for command")
    .usage("[options] [etl-javascript-file]")
    .addOption(fromRecordIdOption)
    .addOption(headOption)
    .option("--offset <number>", "Only process from this record ID onwards")
    .option("--limit [number]", "Only process the first <n> number of records. Defaults to <n> 10 when not specified.")
    .option("--verbose", "make the ETL print out messages, use multiple times to increase the verbosity", (_, previousVal) => previousVal + 1, 0)
    .option("--plain", "Print plain output without progress bar")
    .option("--data-dir <dir>", "Location to store intermediate and output files", "./data")
    .option("--token <token>", "TriplyDB API token (default: $TRIPLYDB_TOKEN)")
    .option("--account <accountname>", "TriplyDB account name (default: $TRIPLYDB_ACCOUNT, or the account that owns the API token)", defaultTriplyDBAccount)
    .option("--api <url>", "URL of the triply API. (default: $TRIPLYDB_API, or the API where the token is registered)", defaultTriplyDBApi)
    .option("--trace <tracefile>", "Debug an ETL pipeline using a trace file. To create a tracefile, use the mw.debug.traceStart() and mw.debug.traceEnd() middlewares")
    .option("--trace-error <tracefile>", "Debug an Error throw in an ETL pipeline using a trace file. These files are created automatically when an Error is produced during an ETL run")
    .option("--log-dir <dir>", "Store log files in this directory")
    .option("--timeout <time>", "Timeout ETL after set duration with human readable string (e.g. '15 seconds', '30 mins', '1 hour 20 minutes')")
    .addOption(createErrorTrace)
    .parse(cmd);
const options = program.opts();
process.on("uncaughtException", function (err) {
    err.message =
        err.message +
            " This error indicates that an error is thrown somewhere where it is not properly caught. For instance, in an event listener.";
    render(React.createElement(CliContext.Provider, { value: { useCmdInCliFeedback, dataDir: options.dataDir, verbosity: 1, cmd: cmd, etlFile: relativeEtlFile } },
        React.createElement(Stacktrace, { error: err, verbosity: 1 })));
    process.exit(1);
});
process.on("unhandledRejection", (reason, p) => {
    console.error("Unhandled Rejection at: Promise", p, "reason:", reason);
    process.exit(1);
});
let initError;
let getApp;
//Manipulating the args. Commander may consider more things an 'arg' as we might be
//passing the npm_config_argv from the environment variables. So, manipulate this a bit
let customArgs = program.args.filter((a) => a !== "etl");
if (customArgs.length !== 1) {
    if (customArgs.length === 0) {
        customArgs = ["lib/main.js"];
    }
    else {
        console.error(chalk.red(`You provided the following ETL files as argument: ${customArgs.join(", ")}. Please only provide one file.`));
        console.error();
        program.outputHelp();
        process.exit(1);
    }
}
let timeout;
if (options.timeout) {
    try {
        if (options.timeout.toLowerCase() == "false") {
            //do nothing
            timeout = undefined;
        }
        else if (/^\d+$/.test(options.timeout.trim())) {
            throw Error("Only numbers were provided while expecting a human readable string.");
        }
        else {
            timeout = strtodate(options.timeout).getTime() - new Date().getTime() + 1; // +1 because of an inaccuracy of 1ms
        }
    }
    catch (error) {
        console.error(chalk.red(`Invalid --timeout argument given. Expected a human readable duration (e.g. '15 seconds', '30 mins', '1 hour 20 minutes').\n${error.message}`));
        program.outputHelp();
        process.exit(1);
    }
}
// legacy mode for --from-record-id and --head
if (options.offset && options.fromRecordId) {
    console.error(chalk.red("Do not mix '--offset' with '--from-record-id'."));
    process.exit(1);
}
else if (options.fromRecordId) {
    options.offset = options.fromRecordId;
}
if (!options.offset && process.env.OFFSET) {
    options.offset = process.env.OFFSET;
}
if (options.head && options.limit) {
    console.error(chalk.red("Do not mix '--limit' with '--head'."));
    process.exit(1);
}
else if (options.head) {
    options.limit = options.head;
}
if (!options.limit && process.env.LIMIT) {
    options.limit = process.env.LIMIT;
}
if (options.offset && isNaN(options.offset)) {
    console.error(chalk.red("Invalid --offset argument given. Expected a number"));
    console.error();
    program.outputHelp();
    process.exit(1);
}
let limit;
if (options.limit !== false && options.limit !== "false") {
    if (options.limit === true) {
        limit = 10;
    }
    else if (options.limit) {
        if (isNaN(options.limit)) {
            console.error(chalk.red("Invalid --limit argument given. Expected a number"));
            console.error();
            program.outputHelp();
            process.exit(1);
        }
        limit = options.limit;
    }
}
const relativeEtlFile = customArgs[0];
let etlFile = path.resolve(relativeEtlFile); //make it absolute, so the requirestatement to this file works properly
if (relativeEtlFile.match(/^(issue-)?\d+.?(js|ts)?$/)) {
    etlFile = path.resolve(`lib/sandbox/${relativeEtlFile}`);
}
if (etlFile.endsWith(".ts")) {
    console.error(chalk.red(`File ${customArgs[0]} references a typescript file. Please provide a javascript file as argument instead`));
    process.exit(1);
}
if (etlFile.endsWith("."))
    etlFile = `${etlFile}js`;
if (!etlFile.endsWith(".js"))
    etlFile = `${etlFile}.js`;
// developers delight: `npx etl [#issue]` will look for a file with that name in the sandbox:
if (!fs.pathExistsSync(etlFile)) {
    console.error(chalk.red(`File ${customArgs[0]} does not exist`));
    process.exit(1);
}
let debugTrace;
if (options.trace) {
    if (!fs.pathExistsSync(options.trace)) {
        console.error(chalk.red(`File ${options.trace} does not exist`));
        process.exit(1);
    }
    debugTrace = fs.readJsonSync(options.trace);
}
if (!!options.traceError) {
    if (!fs.pathExistsSync(options.traceError)) {
        console.error(chalk.red(`File ${options.traceError} does not exist`));
        process.exit(1);
    }
    debugTrace = fs.readJsonSync(options.traceError);
}
try {
    // On windows, an absolute path may look like 'c://' and the `import` expects a valid URL
    // we have to prefix the absolute path with `file://`
    getApp = await import(`file://${etlFile}`);
}
catch (e) {
    initError = e;
}
if (!initError && typeof getApp.default !== "function") {
    console.error(chalk.red(`Expected ${etlFile} to export a default function, e.g. \`export default function(){return new Etl()}\``));
    process.exit(1);
}
if (options.plain)
    process.env["CI"] = "true";
let logId;
if (options.logDir) {
    fs.mkdirpSync(options.logDir);
    // logId = format(new Date(), "kk-mm-ss-SSS");
    logId = new Date().toISOString();
}
// Issue #116: CLI output resets terminal history when height/width dimension is too small - caused by ink module (https://github.com/vadimdemedes/ink/blob/dac969b5d2e9996c2fa759eb25e791197b450713/src/ink.tsx#L176)
const { waitUntilExit } = render(React.createElement(CliContext.Provider, { value: {
        etlFile: relativeEtlFile,
        verbosity: options.verbose,
        token: options.token || defaultTriplyDBToken,
        dataDir: options.dataDir,
        tokenApiUrl: options.api,
        account: options.account,
        useCmdInCliFeedback,
        cmd: cmd,
        logDir: options.logDir,
        logId,
        offset: options.offset ? Number(options.offset) : undefined,
        timeout,
        limit,
        debugTrace,
        errorTrace: !!options.traceError,
        createErrorTrace: options.createErrorTrace ?? false,
    } },
    React.createElement(ErrorBoundary, null,
        React.createElement(Main, { initError: initError, getEtl: getApp?.default }))));
waitUntilExit()
    .then(() => { })
    .catch(() => {
    process.exit(1);
});
//# sourceMappingURL=cli.js.map