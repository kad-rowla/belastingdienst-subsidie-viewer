/**
 * Based on https://raw.githubusercontent.com/vadimdemedes/ink/master/src/components/ErrorOverview.tsx
 * Manipulated this component to get more readable stack trace (not grey on black...)
 */
import React from "react";
import StackUtils from "stack-utils";
import { Text, Box, useApp } from "ink";
import * as fs from "fs";
import codeExcerpt from "code-excerpt";
import { isEmpty, uniq } from "lodash-es";
import { getErr } from "../../utils/Error.js";
import URL from "url";
const stackUtils = new StackUtils({
    cwd: process.cwd(),
    internals: StackUtils.nodeInternals(),
});
const Stacktrace = ({ error: _error, verbosity }) => {
    const error = getErr(_error);
    const { exit } = useApp();
    let stack;
    const origError = error.getErrForStacktrace();
    let callSite = error.callSite || {};
    React.useEffect(() => {
        // we need to wrap the exit in a setTimeout to avoid the Static component rendering twice
        // see https://github.com/vadimdemedes/ink/issues/397
        setTimeout(() => exit(new Error("Exit")), 0);
    }, [exit]);
    /**
     * If we don't have a callsite property, use the stack trace to present the snippet
     */
    if (verbosity && isEmpty(callSite)) {
        stack = origError.stack ? origError.stack.split("\n").slice(1) : undefined;
        const origin = stack ? stackUtils.parseLine(stack[0]) : undefined;
        callSite = {
            char: origin?.column,
            line: origin?.line,
            file: origin?.file,
            method: origin?.method,
        };
    }
    return (React.createElement(Box, { flexDirection: "column" },
        callSite && React.createElement(Excerpt, { callSite: callSite }),
        !!verbosity && origError.stack && (React.createElement(Box, { marginTop: 1, flexDirection: "column" }, 
        //Making the stack uniq, to avoid possibly react key issues
        uniq(origError.stack.split("\n").slice(1)).map((line) => {
            const parsedLine = stackUtils.parseLine(line);
            // If the line from the stack cannot be parsed, we print out the unparsed line.
            if (!parsedLine) {
                return (React.createElement(Box, { key: line },
                    React.createElement(Text, { dimColor: true }, "- "),
                    React.createElement(Text, { dimColor: true, bold: true }, line)));
            }
            return (React.createElement(Box, { key: line },
                React.createElement(Text, { dimColor: true }, "- "),
                React.createElement(Text, { color: "white", bold: true }, parsedLine.function),
                React.createElement(Text, { color: "white" },
                    " ",
                    "(",
                    parsedLine.file,
                    ":",
                    parsedLine.line,
                    ":",
                    parsedLine.column,
                    ")")));
        })))));
};
export function getExcerpt(location, opts) {
    const locationPath = location.file && URL.fileURLToPath(location.file);
    if (location && locationPath && location.line && fs.existsSync(locationPath)) {
        const sourceCode = fs.readFileSync(locationPath, "utf8");
        const around = opts?.around === undefined ? 3 : opts.around;
        let excerpt = codeExcerpt(sourceCode, location.line, { around });
        let lineWidth = 0;
        if (excerpt) {
            for (const excerptLint of excerpt) {
                lineWidth = Math.max(lineWidth, String(excerptLint.line).length);
            }
            return { excerpt, lineWidth };
        }
    }
    return {};
}
const Excerpt = ({ callSite, around }) => {
    const { excerpt, lineWidth } = getExcerpt(callSite, { around });
    if (!excerpt)
        return React.createElement(React.Fragment, null);
    return (React.createElement(Box, { paddingX: 1, borderStyle: "single", borderColor: "white", flexDirection: "column" },
        React.createElement(Box, { flexDirection: "column", alignItems: "center" },
            React.createElement(Text, { backgroundColor: "red", color: "white" },
                callSite.file,
                ":",
                callSite.line,
                ":",
                callSite.char)),
        excerpt.map(({ line, value }) => (React.createElement(Box, { key: line },
            React.createElement(Box, { width: (lineWidth || 0) + 1 },
                React.createElement(Text, { dimColor: line !== callSite.line, backgroundColor: line === callSite.line ? "red" : undefined, color: line === callSite.line ? "white" : undefined },
                    String(line).padStart(lineWidth || 0, " "),
                    ":")),
            React.createElement(Text, { key: line, backgroundColor: line === callSite.line ? "red" : undefined, color: line === callSite.line ? "white" : undefined }, " " + value))))));
};
export default Stacktrace;
//# sourceMappingURL=Stacktrace.js.map