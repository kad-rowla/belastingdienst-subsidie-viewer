import chai from "chai";
import { triple } from "../index.js";
import { getEtlForTesting, getEtlForTestingNoExtractor } from "../../../../__tests__/getEtlForTesting.js";
import { getFactory } from "@triplydb/data-factory";
import * as vocab from "@triplyetl/vocabularies";
import { Iri, fromJson } from "../../../../../generic/index.js";
import { sdo, a } from "@triplyetl/vocabularies";
import { addLiteral, addValue, addIri } from "../../../transformations/index.js";
import { str, literal, iri, list } from "../../term/index.js";
const DataFactory = getFactory();
const assert = chai.assert;
describe("writing.triple", () => {
    it("should create triples", () => {
        return getEtlForTesting([
            addLiteral({ content: str("Heineken"), language: vocab.language.nl, key: "naam" }),
            addValue({ content: "Heineken", key: "naamPrimitive" }),
            addIri({ content: str("http://ex.com/Brewery"), key: "subject" }),
            addIri({ content: str("http://ex.com/name"), key: "predicate" }),
            addIri({ content: str("http://ex.com/Heineken"), key: "objectIri" }),
            triple(vocab.sdo.Brewery, vocab.rdf.type, vocab.sdo.FoodEstablishment),
            triple(vocab.sdo.Brewery, vocab.sdo.name, literal(str("Naam"), vocab.languageTag("nl"))),
            triple(vocab.sdo.Brewery, vocab.sdo.name, "objectIri"),
            triple(vocab.sdo.Brewery, vocab.sdo.name, "naam"),
            triple(vocab.sdo.Brewery, vocab.sdo.name, str("Heineken Brouwerij")),
            triple(vocab.sdo.Brewery, vocab.sdo.name, "naamPrimitive"),
            async (ctx, next) => {
                assert.equal(6, ctx.store.getQuads({}).length);
                return next();
            },
        ]).run();
    });
    it("should create a triple from static strings", () => {
        const subject = "http://ex.com/Brewery";
        const predicate = "http://ex.com/name";
        const object = str("Heineken");
        return getEtlForTesting([
            triple(str(subject), str(predicate), str(object)),
            async (ctx, next) => {
                assert.equal(1, ctx.store.getQuads({ subject: DataFactory.namedNode(subject) }).length);
                assert.equal(1, ctx.store.getQuads({ subject: DataFactory.namedNode(subject), predicate: DataFactory.namedNode(predicate) })
                    .length);
                assert.equal(1, ctx.store.getQuads({
                    subject: DataFactory.namedNode(subject),
                    predicate: DataFactory.namedNode(predicate),
                    object: DataFactory.literal(object.toString()),
                }).length);
                return next();
            },
        ]).run();
    });
    it("should create a triple from strings stored in keys", () => {
        const subject = "http://ex.com/Brewery";
        const predicate = "http://ex.com/name";
        const object = "Heineken";
        return getEtlForTesting([
            addValue({ key: "S", content: subject }),
            addValue({ key: "P", content: predicate }),
            addValue({ key: "O", content: object }),
            triple("S", "P", "O"),
            async (ctx, next) => {
                const subjectNode = DataFactory.namedNode(subject);
                const predicateNode = DataFactory.namedNode(predicate);
                const objectNode = DataFactory.literal(object);
                assert.equal(1, ctx.store.getQuads({ subject: subjectNode }).length);
                assert.equal(1, ctx.store.getQuads({ subject: subjectNode, predicate: predicateNode }).length);
                assert.equal(1, ctx.store.getQuads({ subject: subjectNode, predicate: predicateNode, object: objectNode }).length);
                return next();
            },
        ]).run();
    });
    it("should create a triple where object is a typed literal", () => {
        const subject = "http://ex.com/Brewery";
        const predicate = "http://ex.com/name";
        const object = "2022";
        const etl = getEtlForTesting([
            addValue({ key: "S", content: str(subject) }),
            addValue({ key: "P", content: str(predicate) }),
            addLiteral({ key: "O", content: str(object), datatype: vocab.xsd.gYear }),
            triple("S", "P", "O"),
            async (ctx, next) => {
                const subjectNode = DataFactory.namedNode(subject);
                const predicateNode = DataFactory.namedNode(predicate);
                const objectNode = DataFactory.literal(object, vocab.xsd.gYear);
                assert.equal(1, ctx.store.getQuads({ subject: subjectNode }).length);
                assert.equal(1, ctx.store.getQuads({ subject: subjectNode, predicate: predicateNode }).length);
                assert.equal(1, ctx.store.getQuads({ subject: subjectNode, predicate: predicateNode, object: objectNode }).length);
                return next();
            },
        ]);
        return chai.expect(etl.run()).to.eventually.be.fulfilled;
    });
    it("Should work on arrays with numbers", () => {
        return getEtlForTesting([
            addValue({ key: "keyNumberArray", content: [3, 4.123, BigInt(666)] }),
            triple(sdo.Person, sdo.numChildren, "keyNumberArray"),
            triple(sdo.Person, sdo.numAdults, [3, 4.123, BigInt(666)]),
            async (ctx, next) => {
                assert.equal(ctx.store.getQuads({}).length, 6);
                assert.equal(ctx.store.getQuads({ predicate: sdo.numChildren, object: DataFactory.literal(3, vocab.xsd.integer) }).length, 1);
                assert.equal(ctx.store.getQuads({ predicate: sdo.numAdults, object: DataFactory.literal(3, vocab.xsd.integer) }).length, 1);
                assert.equal(ctx.store.getQuads({ predicate: sdo.numChildren, object: DataFactory.literal(4.123, vocab.xsd.float) })
                    .length, 1);
                assert.equal(ctx.store.getQuads({ predicate: sdo.numAdults, object: DataFactory.literal(4.123, vocab.xsd.float) }).length, 1);
                assert.equal(ctx.store.getQuads({
                    predicate: sdo.numChildren,
                    object: DataFactory.literal(BigInt(666).toString(), vocab.xsd.double),
                }).length, 1);
                assert.equal(ctx.store.getQuads({
                    predicate: sdo.numAdults,
                    object: DataFactory.literal(BigInt(666).toString(), vocab.xsd.double),
                }).length, 1);
                return next();
            },
        ]).run();
    });
    it("should work with different objects", () => {
        const prefix = Iri("https://ex.com/");
        const now = new Date();
        return getEtlForTesting([
            addValue({ key: "keyString", content: "this is a key" }),
            addValue({ key: "keyStringArray", content: "this is a key".split(" ").map((v) => str(v)) }),
            addValue({ key: "keyNumber", content: 1 }),
            addValue({ key: "keyNumberArray", content: [1, 2, 3, 4] }),
            addValue({ key: "keyNumberFloatArray", content: [1.34, 2.45, 3.67, 4.89] }),
            addValue({ key: "keyBoolean", content: true }),
            addValue({ key: "keyMixed", content: [1, str("foo"), true, now, BigInt(1234)] }),
            addIri({ prefix, key: "keyIri", content: str("456") }),
            triple(prefix.concat("123"), prefix.concat("keyString"), "keyString"),
            triple(prefix.concat("123"), prefix.concat("keyStringArray"), "keyStringArray"),
            triple(prefix.concat("123"), prefix.concat("keyNumber"), "keyNumber"),
            triple(prefix.concat("123"), prefix.concat("keyNumberArray"), "keyNumberArray"),
            triple(prefix.concat("123"), prefix.concat("keyNumberFloatArray"), "keyNumberFloatArray"),
            triple(prefix.concat("123"), prefix.concat("keyBoolean"), "keyBoolean"),
            triple(prefix.concat("123"), prefix.concat("keyMixed"), "keyMixed"),
            triple(prefix.concat("123"), prefix.concat("keyIri"), "keyIri"),
            triple(prefix.concat("123"), prefix.concat("boolean"), true),
            triple(prefix.concat("123"), prefix.concat("int"), 123),
            triple(prefix.concat("123"), prefix.concat("float"), 123.456),
            triple(prefix.concat("123"), prefix.concat("string"), str("string")),
            triple(prefix.concat("123"), prefix.concat("literal"), DataFactory.literal("literal")),
            triple(prefix.concat("123"), prefix.concat("date"), now),
            async (ctx, next) => {
                assert.isTrue(ctx.store
                    .getQuads({ predicate: prefix.concat("keyString") })[0]
                    .object.equals(DataFactory.literal("this is a key")));
                const quads = ctx.store.getQuads({ predicate: prefix.concat("keyStringArray") });
                const values = "this is a key".split(" ");
                assert.equal(values.length, quads.length);
                for (let i = 0; i < values.length; i++) {
                    assert.isTrue(quads[i].object.equals(DataFactory.literal(values[i])));
                }
                assert.isTrue(ctx.store
                    .getQuads({ predicate: prefix.concat("keyNumber") })[0]
                    .object.equals(DataFactory.literal(1, vocab.xsd.integer)));
                const quadsNumber = ctx.store.getQuads({ predicate: prefix.concat("keyNumberArray") });
                const valuesNumber = [1, 2, 3, 4];
                assert.equal(valuesNumber.length, quadsNumber.length);
                for (let i = 0; i < valuesNumber.length; i++) {
                    assert.isTrue(quadsNumber[i].object.equals(DataFactory.literal(valuesNumber[i], vocab.xsd.integer)));
                }
                const quadsNumberFloat = ctx.store.getQuads({ predicate: prefix.concat("keyNumberFloatArray") });
                const valuesNumberFloat = [1.34, 2.45, 3.67, 4.89];
                assert.equal(valuesNumberFloat.length, quadsNumberFloat.length);
                for (let i = 0; i < valuesNumberFloat.length; i++) {
                    assert.isTrue(quadsNumberFloat[i].object.equals(DataFactory.literal(valuesNumberFloat[i], vocab.xsd.float)));
                }
                assert.isTrue(ctx.store
                    .getQuads({ predicate: prefix.concat("keyBoolean") })[0]
                    .object.equals(DataFactory.literal("true", vocab.xsd.boolean)), "keyBoolean failed");
                assert.isTrue(ctx.store.getQuads({ predicate: prefix.concat("keyIri") })[0].object.equals(prefix.concat("456")), "keyIri failed");
                assert.isTrue(ctx.store
                    .getQuads({ predicate: prefix.concat("boolean") })[0]
                    .object.equals(DataFactory.literal("true", vocab.xsd.boolean)), "boolean failed");
                assert.isTrue(ctx.store
                    .getQuads({ predicate: prefix.concat("int") })[0]
                    .object.equals(DataFactory.literal(123, vocab.xsd.integer)), "int failed");
                assert.isTrue(ctx.store
                    .getQuads({ predicate: prefix.concat("float") })[0]
                    .object.equals(DataFactory.literal(123.456, vocab.xsd.float)), "float failed");
                assert.isTrue(ctx.store.getQuads({ predicate: prefix.concat("string") })[0].object.equals(DataFactory.literal("string")), "string failed");
                assert.isTrue(ctx.store.getQuads({ predicate: prefix.concat("literal") })[0].object.equals(DataFactory.literal("literal")), "literal failed");
                assert.isTrue(ctx.store
                    .getQuads({ predicate: prefix.concat("date") })[0]
                    .object.equals(DataFactory.literal(now.toISOString(), vocab.xsd.dateTime)), "date failed");
                return next();
            },
        ]).run();
    });
    it("should work with Etl Core list() (rdf:list)", () => {
        const prefix = Iri("https://ex.com/");
        return getEtlForTesting([
            triple(iri(prefix, "foo"), vocab.sh.ignoredProperties, list(prefix, [vocab.rdf.type])),
            async (ctx, next) => {
                assert.equal(ctx.store.getQuads({ predicate: vocab.rdf.first }).length, 1);
                assert.isTrue(ctx.store.getQuads({ predicate: vocab.rdf.first })[0].object.equals(vocab.rdf.type));
                return next();
            },
        ]).run();
    });
    it("Should fix issue #16", () => {
        // Reported bug "In-line use of iri() does not work in couples()"
        // is actually a bug in triple()
        const prefix = Iri("http://ex.com/");
        return getEtlForTesting([
            triple(prefix.concat("Heineken"), iri(prefix, str("type")), vocab.sdo.Brewery),
            async (ctx, next) => {
                assert.equal(1, ctx.store.getQuads({}).length);
                assert.equal(1, ctx.store.getQuads({
                    subject: DataFactory.namedNode("http://ex.com/Heineken"),
                    predicate: DataFactory.namedNode("http://ex.com/type"),
                    object: vocab.sdo.Brewery,
                }).length);
                return next();
            },
        ]).run();
    });
    it("Should work with the predicate as an ir(prefix, <keyName>)", () => {
        const prefix = Iri("http://ex.com/");
        return getEtlForTesting([
            triple(prefix.concat("Heineken"), iri(prefix, "foo"), vocab.sdo.Brewery),
            async (ctx, next) => {
                assert.equal(1, ctx.store.getQuads({}).length);
                assert.equal(1, ctx.store.getQuads({
                    subject: DataFactory.namedNode("http://ex.com/Heineken"),
                    predicate: DataFactory.namedNode("http://ex.com/bar"),
                    object: vocab.sdo.Brewery,
                }).length);
                return next();
            },
        ]).run();
    });
    it("Should work on the examples from the docs", () => {
        const prefix = {
            person: Iri("http://ex.com/persons/"),
        };
        const data = { id: 1, age: 52 };
        return getEtlForTestingNoExtractor([
            fromJson(data),
            triple(iri(prefix.person, "id"), a, vocab.foaf.Person),
            addIri({ prefix: prefix.person, content: "id", key: "_person" }),
            triple("_person", vocab.sdo.numChildren, literal("age", vocab.xsd.nonNegativeInteger)),
            async (ctx, next) => {
                const subject = prefix.person.concat(data.id.toString());
                assert.equal(1, ctx.store.getQuads({ subject, predicate: a, object: vocab.foaf.Person }).length);
                assert.equal(1, ctx.store.getQuads({
                    subject,
                    predicate: vocab.sdo.numChildren,
                    object: DataFactory.literal(data.age.toString(), vocab.xsd.nonNegativeInteger),
                }).length);
                return next();
            },
        ]).run();
    });
});
//# sourceMappingURL=triple.test.js.map