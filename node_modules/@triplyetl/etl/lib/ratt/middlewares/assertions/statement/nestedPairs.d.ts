import { Middleware } from "../../../../generic/index.js";
import { Pair, SPG } from "./rdf/quad.js";
/**
 * Makes one or more assertions about a nested node.
 *
 * @remarks
 * Since RDF is composed of triples, more complex n-ary information must often
 * be asserted using a nested node.  Such a nested node can be given a name
 * with {@link iri} or {@link addIri}.  In some cases, it is inconvenient to
 * come up with a naming scheme for such intermediate nodes.  In such cases a
 * content-based IRI can be generated with {@link addHashedIri}, or a random
 * IRI can be generated with {@link addRandomIri}.  Finally, a random Skolem
 * IRI can be generated with {@link addSkolemIri} to represent a nested node
 * that can be treated as a 'blank node' in RDF.
 *
 * @param subject - A subject term.  This must be either an {@link iri}.
 *
 * @param predicate - A predicate term.  This must be an {@link iri}.
 *
 * @param nestedNode - The nested node.  This must be an {@link iri}.
 *
 * @param pairs - One or more pairs that make assertions about the nested
 * node.  Every pair consists of a predicate term and an object term (in that
 * order).
 *
 * @example
 * The following example asserts a value together with a unit of measure.
 * A well-known Skolem IRI or 'blank node' is used to attach the value and
 * unit to:
 *
 * ```ts
 * fromJson([{ id: '1', height: 15 }]),
 * addSkolemIri({
 *   prefix: prefix.skolem,
 *   key: '_height',
 * }),
 * nestedPairs(iri(prefix.product, 'id'), sdo.height, '_height',
 *   [qudt.unit, unit.CentiM],
 *   [rdf.value, 'height'],
 * ),
 * ```
 *
 * This generates the following linked data assertyions:
 *
 * ```ttl
 * product:1 sdo:height
 *   [ qudt:unit unit:CentiM;
 *     rdf:value 15 ].
 * ```
 *
 * @example
 * The following example asserts a GeoSPARQL geometry. The geometry is created
 * as a separate node.
 *
 * ```ts
 * fromJson([{ id: '1', geometry: 'Point(1.1 2.2)' }]),
 * nestedpairs(iri(prefix.feature, 'id'), geo.hasGeometry, iri(prefix.geometry, 'id'),
 *   [a, geo.Geometry],
 *   [geo.asWKT, literal('geometry', geo.wktLiteral)],
 * ),
 * ```
 *
 * This generates the following RDF, where a well-known Skolem IRI is used for
 * the geometry 'blank node':
 *
 * ```ttl
 * feature:1 geo:hasGeometry geometry:1.
 * geometry:1
 *   a geo:Geometry;
 *   geo:asWKT 'Point(1.1 2.2)'^^geo:wktLiteral.
 * ```
 *
 * The `nestedpairs()` assertion is a shorter notation for the following
 * sequence of middlewares:
 *
 * ```ts
 * fromJson([{ id: '1', geometry: 'Point(1.1 2.2)' }]),
 * triple(iri(prefix.feature, 'id'), geo.hasGeometry, iri(prefix.geometry, 'id')),
 * pairs(iri(prefix.geometry, 'id'),
 *   [a, geo.Geometry],
 *   [geo.asWKT, literal('geometry', geo.wktLiteral)],
 * ),
 * ```
 */
declare function nestedPairs(subject: SPG, predicate: SPG, pair: Pair, ...pairs: Pair[]): Middleware;
declare function nestedPairs(subject: SPG, predicate: SPG, object: SPG, ...pairs: Pair[]): Middleware;
declare function nestedPairs(graph: SPG, subject: SPG, predicate: SPG, object: SPG, ...pairs: Pair[]): Middleware;
export default nestedPairs;
//# sourceMappingURL=nestedPairs.d.ts.map