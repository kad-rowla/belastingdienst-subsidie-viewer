import getCurrentLine from "get-current-line";
import { isArray } from "lodash-es";
import { isKey } from "../../../../../generic/Context.js";
import { addMwCallSiteToError, addQuadsToStore } from "../../../../../utils/index.js";
import { isNamedNode, NullableOrEmptyString } from "../../../../../utils/asserts.js";
import { isStatic } from "../../term/str.js";
import { getNamedNodes } from "./utils/getNamedNodes.js";
import { getObjects } from "./utils/getObjects.js";
// Assertions:
export const isSPG = (value) => isStatic(value) || isTermGetterForNamednode(value) || isNamedNode(value) || isKey(value);
export const isO = (value) => isStatic(value) ||
    isObjectLiteral(value) ||
    isObjectLiterals(value) ||
    isNamedNode(value) ||
    isTermGetterForLiteral(value) ||
    isTermGetterForNamednode(value);
export const isOs = (value) => {
    if (!isArray(value))
        return false;
    let i = 0;
    value.forEach((val) => (i += isO(val) ? 1 : 0));
    return i === value.length;
};
export const isObjectLiteral = (value) => typeof value === "string" ||
    typeof value === "boolean" ||
    typeof value === "number" ||
    typeof value === "bigint" ||
    value instanceof Date;
export const isObjectLiterals = (value) => {
    if (!isArray(value))
        return false;
    let i = 0;
    value.forEach((val) => (i += isObjectLiteral(val) ? 1 : 0));
    return i === value.length;
};
export const isPair = (value) => isArray(value) && value.length === 2 && isSPG(value[0]) && isO(value[1]);
export const isPairs = (value) => {
    if (!isArray(value))
        return false;
    let i = 0;
    value.forEach((val) => (i += isPair(val) ? 1 : 0));
    return i === value.length;
};
export const isTriple = (value) => isArray(value) && value.length === 3 && isSPG(value[0]) && isSPG(value[1]) && isO(value[2]);
export const isQuad = (value) => isArray(value) && value.length === 4 && isSPG(value[0]) && isSPG(value[1]) && isSPG(value[2]) && isO(value[3]);
export const isTermGetterForNamednode = (value) => typeof value === "function" &&
    !!value("") &&
    typeof value("") === "object" &&
    "termType" in value("") &&
    value("").termType === "NamedNode";
export const isTermGetterForLiteral = (value) => typeof value === "function" &&
    !!value("") &&
    typeof value("") === "object" &&
    "termType" in value("") &&
    value("").termType === "Literal";
// TODO @DocumentationTeam: add TS doc comment here
export default function _quad(subject, predicate, object, graph) {
    const callSite = getCurrentLine({ frames: 2 });
    return addMwCallSiteToError(async function _triple(ctx, next) {
        try {
            const s = getNamedNodes(ctx, subject);
            const p = getNamedNodes(ctx, predicate);
            const o = getObjects(ctx, object);
            const gs = graph === undefined ? [ctx.app.defaultGraph] : getNamedNodes(ctx, graph);
            for (const g of gs) {
                addQuadsToStore(ctx.store, [[s, p, o, g]]);
                if (s.length && p.length && o.length) {
                    ctx.app["markMwTouched"](callSite);
                }
            }
        }
        catch (e) {
            //Skip this error. If a term is nullable or an empty string, we should simply not store that as a quad
            if (!(e instanceof NullableOrEmptyString)) {
                //adding information to error. Dont want to throw a new error to keep the stacktrace intact.
                e.addQuad = [subject, predicate, object, ctx.app.defaultGraph];
                throw e;
            }
        }
        await next();
    }, { reportTouched: false, callSite, sourceFuncName: "_triple" });
}
//# sourceMappingURL=quad.js.map