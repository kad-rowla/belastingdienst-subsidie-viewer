import chai from "chai";
import * as vocab from "@triplyetl/vocabularies";
import { Etl, forEach, fromJson, Iri } from "../../../../../generic/index.js";
import { getEtlForTesting, getEtlForTestingNoExtractor } from "../../../../__tests__/getEtlForTesting.js";
import { addIri, addLiteral } from "../../../transformations/index.js";
import { triple } from "../../statement/index.js";
import literals from "../literals.js";
import str from "../str.js";
import { getFactory } from "@triplydb/data-factory";
const assert = chai.assert;
const prefix = Iri("http://ex.com/");
const langString = "nl";
describe("literals", () => {
    it("should work with static strings", () => {
        return getEtlForTestingNoExtractor([
            triple(prefix.concat(langString), vocab.sdo.name, str("Koninkrijk der Nederlanden")),
            triple(prefix.concat(langString), vocab.sdo.alternateName, literals([str("Nederland"), str("Holland")], new vocab.LanguageTag(langString))),
            mwTester(),
        ]).run();
    });
    it("should work with a key holding an array", () => {
        return getEtlForTestingNoExtractor([
            fromJson({ countryNames: ["Nederland", "Holland"] }),
            triple(prefix.concat(langString), vocab.sdo.name, str("Koninkrijk der Nederlanden")),
            triple(prefix.concat(langString), vocab.sdo.alternateName, literals("countryNames", new vocab.LanguageTag(langString))),
            mwTester(),
        ]).run();
    });
    it("should work with keys", () => {
        return getEtlForTestingNoExtractor([
            fromJson({ countryName1: "Nederland", countryName2: "Holland" }),
            triple(prefix.concat(langString), vocab.sdo.name, str("Koninkrijk der Nederlanden")),
            triple(prefix.concat(langString), vocab.sdo.alternateName, literals(["countryName1", "countryName2"], new vocab.LanguageTag(langString))),
            mwTester(),
        ]).run();
    });
    it("should work with mixed key/static", () => {
        return getEtlForTestingNoExtractor([
            fromJson({ countryName: "Nederland" }),
            triple(prefix.concat(langString), vocab.sdo.name, str("Koninkrijk der Nederlanden")),
            triple(prefix.concat(langString), vocab.sdo.alternateName, literals(["countryName", str("Holland")], new vocab.LanguageTag(langString))),
            mwTester(),
        ]).run();
    });
    it("should fix issue https://git.triply.cc/triply/etl/-/issues/274", () => {
        const etl = new Etl();
        etl.use(fromJson([{ Record: [{ keywords: { Keyword: ["a"] } }] }, { Record: [{ keywords: { Keyword: ["b"] } }] }]), addIri({ content: "$recordId", key: "S" }), forEach("Record", triple("$parent.S", vocab.sdo.keywords, literals("keywords.Keyword", vocab.xsd.string)), async (ctx, next) => {
            const keywords = ctx.getArray("keywords.Keyword", "string");
            const literals = ctx.store.getObjects(null, vocab.sdo.keywords, null);
            assert.equal(literals.length, keywords.length);
            assert.isTrue(literals[0].equals(getFactory().literal(keywords[0])));
            return next();
        }));
        return etl.run();
    }),
        it("should work with a keys holding literals", () => {
            return getEtlForTesting([
                addLiteral({ key: "countryName1", content: str("Nederland"), language: vocab.language.en }),
                addLiteral({ key: "countryName2", content: str("Holland"), language: vocab.language.en }),
                triple(prefix.concat(langString), vocab.sdo.name, str("Koninkrijk der Nederlanden")),
                triple(prefix.concat(langString), vocab.sdo.alternateName, literals(["countryName1", "countryName2"], new vocab.LanguageTag(langString))),
                mwTester(),
            ]).run();
        });
});
function mwTester() {
    return async (ctx, next) => {
        const alternateNames = ctx.store.getQuads({ predicate: vocab.sdo.alternateName });
        const mappedObj = alternateNames.map((o) => o.object.id);
        assert.equal(2, new Set(mappedObj).size);
        mappedObj.forEach((o) => assert.isTrue(['"Holland"@nl', '"Nederland"@nl'].includes(o)));
        return next();
    };
}
//# sourceMappingURL=literals.test.js.map