import path from "path";
import chai, { assert } from "chai";
import { getValFromTermGetter } from "../getter.js";
import { getFactory } from "@triplydb/data-factory";
import { Etl, toRdf, fromJson, Destination, Iri } from "../../../../../generic/index.js";
import { triple } from "../../statement/index.js";
import iri from "../iri.js";
import { expectNoBlankNodesMw } from "../../../../../__tests__/util.js";
import literal from "../literal.js";
import { a, language, sdo, languageTag, xsd } from "@triplyetl/vocabularies";
import { isLiteral } from "../../../../../utils/asserts.js";
import str from "../str.js";
import { addTag, addValue } from "../../../transformations/index.js";
import { getEtlForTestingNoExtractor } from "../../../../__tests__/getEtlForTesting.js";
import { EtlError } from "../../../../../utils/Error.js";
const DataFactory = getFactory();
const expect = chai.expect;
const testDestinationPath = path.resolve("tmp/out.nt");
const testDestination = Destination.file(testDestinationPath);
describe("literal", () => {
    it("Referencing nullable literal in object pos to throw", async function () {
        const app = new Etl({ defaultGraph: "https://default.com/" });
        app.use(fromJson([{ a: "a:a", b: "b:b" }]));
        app.use(triple(iri("a"), iri("b"), "does-not-exist"));
        app.use(expectNoBlankNodesMw);
        app.use(toRdf(testDestination));
        expect(() => app.run()).to.throw;
        expect(app["_runtimeStats"]["#Statements"]).to.be.undefined;
    });
    it("should use the runtime type", async function () {
        const pipeline = new Etl({});
        let stringLiteral;
        let numberLiteral;
        let booleanLiteral;
        pipeline.use(fromJson({ String: "1", Number: 1, Boolean: false }), async (ctx, next) => {
            stringLiteral = getValFromTermGetter(ctx, literal("String", xsd.string))[0];
            numberLiteral = getValFromTermGetter(ctx, literal("Number", xsd.integer))[0];
            booleanLiteral = getValFromTermGetter(ctx, literal("Boolean", xsd.boolean))[0];
            await next();
        });
        await pipeline.run();
        expect(stringLiteral).to.not.be.undefined;
        expect(isLiteral(stringLiteral)).true;
        expect(stringLiteral.datatype.equals(xsd.string)).true;
        expect(numberLiteral).to.not.be.undefined;
        expect(isLiteral(numberLiteral)).true;
        expect(numberLiteral.datatype.equals(xsd.integer)).true;
        expect(booleanLiteral).to.not.be.undefined;
        expect(isLiteral(booleanLiteral)).true;
        expect(booleanLiteral.datatype.equals(xsd.boolean)).true;
    });
    it("Should create a rdf:langString", async () => {
        const app = new Etl({});
        app.use(fromJson([
            {
                S: "http://ex.com/subj",
                en: "http://ex.com/en",
                fr: "http://ex.com/fr",
                es: "http://ex.com/es",
                nl: "http://ex.com/nl",
                O: "Hello",
            },
        ]), triple(iri("S"), iri("en"), literal("O", str("en"))), triple(iri("S"), iri("fr"), literal(str("Bonjour"), str("fr"))), triple(iri("S"), iri("es"), literal(str("Ola"), language.es)), triple(iri("S"), iri("nl"), literal(str("Hallo"), language.nl)), async (ctx, next) => {
            expect(ctx.store.getQuads(null, null, null, null).length).to.equal(4);
            const languages = ["en", "fr", "es", "nl"];
            languages.forEach((lang) => {
                expect(ctx.store.getObjects(null, ctx.getIri(lang), null).length).to.equal(1);
                expect(ctx.store.getObjects(null, ctx.getIri(lang), null)[0].termType).to.equal("Literal");
                expect(ctx.store.getObjects(null, ctx.getIri(lang), null)[0].language).to.equal(lang);
            });
            return next();
        });
        await app.run();
    });
    it("Should create a xsd:String", async () => {
        const app = new Etl({});
        app.use(addValue({ key: "foo", content: "foo1" }), triple(sdo.Thing, sdo.name, "foo"), triple(sdo.Thing, sdo.name, str("foo2")), async (ctx, next) => {
            expect(ctx.store.getQuads(sdo.Thing, sdo.name, null, null).length).to.equal(2);
            // return next()
            for (let i = 1; i <= 2; i++) {
                const lit = DataFactory.literal(`foo${i}`, xsd.string);
                expect(ctx.store.getQuads(sdo.Thing, sdo.name, lit, null).length).to.equal(1);
            }
            return next();
        });
        await app.run();
    });
    it("should work with and without datatypes", () => {
        const app = new Etl({});
        const subject = DataFactory.namedNode("http://ex.com/id/1");
        const pred = Iri("http://ex.com/pred/");
        app.use([
            fromJson({ name: "Jane Doe", lang: "en", sex: "female" }),
            addTag({ key: "es", content: str("es") }),
            addValue({ content: languageTag("fr"), key: "fr" }),
            triple(subject, sdo.name, "name"),
            triple(subject, sdo.name, str("J. Doe")),
            triple(subject, iri(pred, str("age")), literal(str("52"), xsd.integer)),
            triple(subject, iri(pred, str("kilometers")), literal(str("10"), DataFactory.namedNode("http://ex.com/unit/km"))),
            triple(subject, iri(pred, str("miles")), literal(str("6.25"), str("http://ex.com/unit/miles"))),
            triple(subject, sdo.gender, literal("sex", "lang")),
            triple(subject, sdo.gender, literal(str("Ehefrau"), str("de"))),
            triple(subject, sdo.gender, literal(str("Vrouw"), languageTag("nl"))),
            triple(subject, sdo.gender, literal(str("Femme"), "fr")),
            triple(subject, sdo.gender, literal(str("Esposa"), "es")),
            async (ctx, next) => {
                expect(ctx.store.getQuads({}).length).equal(10);
                ctx.store.getObjects(subject, sdo.name, null).forEach((lit) => {
                    expect(lit.termType).equal("Literal");
                    expect(isLiteral(lit)).true;
                    expect(lit.datatype.equals(xsd.string)).true;
                });
                const kilometers = ctx.store.getObjects(subject, pred.concat("kilometers"), null);
                expect(kilometers.length).equal(1);
                expect(kilometers[0].termType).equal("Literal");
                expect(isLiteral(kilometers[0])).true;
                expect(kilometers[0].datatype.equals(DataFactory.namedNode("http://ex.com/unit/km"))).true;
                expect(kilometers[0].value).equal("10");
                const miles = ctx.store.getObjects(subject, pred.concat("miles"), null);
                expect(miles.length).equal(1);
                expect(miles[0].termType).equal("Literal");
                expect(isLiteral(miles[0])).true;
                expect(miles[0].datatype.equals(DataFactory.namedNode("http://ex.com/unit/miles"))).true;
                expect(miles[0].value).equal("6.25");
                const gender = ctx.store.getObjects(subject, sdo.gender, null);
                expect(gender.length).equal(5);
                gender.forEach((gender) => {
                    expect(gender.termType).equal("Literal");
                    expect(isLiteral(gender)).true;
                    expect(gender.datatype.equals(DataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#langString"))).true;
                    expect(gender.language).oneOf(["en", "de", "nl", "fr", "es"]);
                });
                return next();
            },
        ]);
        return app.run();
    });
    it("should work with misc. datatypes", () => {
        const S = DataFactory.namedNode("http://ex.com/thing");
        const P = Iri("http://ex.com/p/");
        const data = {
            bool: true,
            int: 1,
            float: 2.13,
            negativeInt: -1,
            zero: 0,
            negativeFloat: -2.13,
            bigint: BigInt(456),
            date: new Date(),
            string: str("foo"),
            x: 1.0e8,
            decimal: literal("x", xsd.decimal),
            z: BigInt(1.7976931348623157e308),
        };
        const etl = getEtlForTestingNoExtractor(fromJson(data));
        Object.entries(data).forEach(([k, v]) => etl.use(triple(S, P.concat(k), v)));
        etl.use(async (ctx, next) => {
            const types = {
                bool: xsd.boolean,
                int: xsd.integer,
                zero: xsd.integer,
                negativeInt: xsd.negativeInteger,
                float: xsd.float,
                negativeFloat: xsd.float,
                bigint: xsd.double,
                date: xsd.dateTime,
                decimal: xsd.decimal,
                z: xsd.double,
            };
            Object.entries(types).forEach(([k, v]) => {
                const O = ctx.store.getObjects(S, P.concat(k), null);
                expect(O.length).equal(1);
                expect(O[0].termType).equal("Literal");
                expect(O[0].language).equal("");
                expect(O[0].datatype.equals(v)).true;
            });
            return next();
        });
        return etl.run();
    });
    it("should not work with non coerced datatypes", () => {
        const S = DataFactory.namedNode("http://ex.com/thing");
        const P = Iri("http://ex.com/p/");
        const data = {
            yearMonth: 1564 - 10,
            double: 223642938472398,
            decimal: 12.345,
            year: 2001,
            base64binary: 0o1101,
        };
        const etl = getEtlForTestingNoExtractor(fromJson(data));
        Object.entries(data).forEach(([k, v]) => etl.use(triple(S, P.concat(k), v)));
        etl.use(async (ctx, next) => {
            const types = {
                yearMonth: xsd.gYearMonth,
                double: xsd.double,
                decimal: xsd.decimal,
                year: xsd.gYear,
                base64binary: xsd.base64Binary,
            };
            Object.entries(types).forEach(([k, v]) => {
                const O = ctx.store.getObjects(S, P.concat(k), null);
                expect(O.length).equal(1);
                expect(O[0].termType).equal("Literal");
                expect(O[0].language).equal("");
                expect(O[0].datatype.equals(v)).true;
            });
            return next();
        });
        return expect(etl.run()).to.eventually.rejectedWith("expected false to be true");
    });
    it("Should have the same datatypes for triple coerced key and literal middleware given datatype", async () => {
        const etlA = new Etl();
        const etlB = new Etl();
        let resultsA;
        let resultsB;
        etlA.use(fromJson({ String: "s", Number: 1, Boolean: false }), triple(a, a, literal("Boolean", xsd.boolean)), triple(a, a, literal("Number", xsd.integer)), triple(a, a, literal("String", xsd.string)), async (ctx) => {
            resultsA = ctx.store.getQuads({});
        });
        etlB.use(fromJson({ String: "s", Number: 1, Boolean: false }), triple(a, a, "Boolean"), triple(a, a, "Number"), triple(a, a, "String"), async (ctx) => {
            resultsB = ctx.store.getQuads({});
        });
        await expect(etlA.run()).to.eventually.fulfilled;
        await expect(etlB.run()).to.eventually.fulfilled;
        assert.deepEqual(resultsA, resultsB);
    });
    it("Should throw on wrong literal datatype given with estimated coercion datatype", async () => {
        const etl = new Etl();
        etl.use(fromJson({ String: "s", Number: 1, Boolean: false }), triple(a, a, literal("Boolean", xsd.integer)), triple(a, a, literal("Number", xsd.integer)), triple(a, a, literal("String", xsd.string)));
        await expect(etl.run())
            .to.eventually.rejectedWith(/Unable to parse value 'false'/)
            .and.be.an.instanceOf(EtlError);
    });
});
//# sourceMappingURL=literal.test.js.map