import chai from "chai";
import { getFactory } from "@triplydb/data-factory";
import chaiAsPromised from "chai-as-promised";
import { Etl, fromJson, Iri } from "../../../../../generic/index.js";
import { getEtlForTesting, getEtlForTestingNoExtractor } from "../../../../__tests__/getEtlForTesting.js";
import { addIri, addValue, iri, str, triple } from "../../../../index.js";
import { a } from "@triplyetl/vocabularies";
chai.use(chaiAsPromised);
const DataFactory = getFactory();
const expect = chai.expect;
const S = DataFactory.namedNode("http://ex.com/JohnDoe");
const P = DataFactory.namedNode("http://ex.com/type");
const O = DataFactory.namedNode("http://ex.com/Person");
const prefix = Iri("http://ex.com/");
describe("iri TermGetter", () => {
    it("should work with static URL's", () => {
        return getEtlForTesting([triple(iri(str(S.value)), iri(str(P.value)), iri(str(O.value))), validate()]).run();
    });
    it("should fail with strings that are invalid URL's", () => {
        return expect(getEtlForTesting([triple(iri(str("err")), iri(str("P")), iri(str("O"))), validate()]).run()).eventually.rejectedWith(/Invalid Iri/);
    });
    it("should work with prefix, no value", () => {
        return getEtlForTesting([triple(iri(Iri(S.value)), iri(Iri(P.value)), iri(Iri(O.value))), validate()]).run();
    });
    it("should work with URL strings from keys, no value", () => {
        return getEtlForTestingNoExtractor([
            fromJson({ S: S.value, P: P.value, O: O.value }),
            triple(iri("S"), iri("P"), iri("O")),
            validate(),
        ]).run();
    });
    it("should fail with invalid URL strings from keys, no value", () => {
        return expect(getEtlForTestingNoExtractor([
            fromJson({ S: "S", P: "P", O: "O" }),
            triple(iri(str("S")), iri(str("P")), iri(str("O"))),
            validate(),
        ]).run()).eventually.rejectedWith(/Invalid Iri/);
    });
    it("should work with IRI's from keys, no value", () => {
        return getEtlForTesting([
            addValue({ content: S, key: "S" }),
            addValue({ content: P, key: "P" }),
            addValue({ content: O, key: "O" }),
            triple(iri("S"), iri("P"), iri("O")),
            validate(),
        ]).run();
    });
    it("should work with Iri's added with `addIri()` middleware, no value (bad practice!)", () => {
        return getEtlForTesting([
            addIri({ key: "S", content: str(S.value) }),
            addIri({ key: "P", content: str(P.value) }),
            addIri({ key: "O", content: str(O.value) }),
            triple(iri("S"), iri("P"), iri("O")),
            validate(),
        ]).run();
    });
    it("should work with prefixes and static strings", () => {
        return getEtlForTesting([
            triple(iri(prefix, str("JohnDoe")), iri(prefix, str("type")), iri(prefix, str("Person"))),
            validate(),
        ]).run();
    });
    it("should work with prefixes and strings from keys", () => {
        return getEtlForTestingNoExtractor([
            fromJson({ S: "JohnDoe", P: "type", O: "Person" }),
            triple(iri(prefix, "S"), iri(prefix, "P"), iri(prefix, "O")),
            validate(),
        ]).run();
    });
    it("should work with prefixes and numbers from keys", () => {
        return getEtlForTestingNoExtractor([
            fromJson({ S: 1, P: 2, O: 3 }),
            triple(iri(prefix, "S"), iri(prefix, "P"), iri(prefix, "O")),
            async (ctx, next) => {
                const quads = ctx.store.getQuads({});
                expect(quads.length).equal(1);
                expect(quads[0].subject.equals(prefix.concat("1"))).true;
                expect(quads[0].predicate.equals(prefix.concat("2"))).true;
                expect(quads[0].object.equals(prefix.concat("3"))).true;
                return next();
            },
        ]).run();
    });
    describe("Invalid Iris should throw", function () {
        it("should throw with prefix", async () => {
            const etl = new Etl();
            etl.use(triple(a, a, iri(str("•http://ex.com/Person"))));
            await expect(etl.run()).to.eventually.rejectedWith(/invalid iri/gi);
        });
        it("should throw with key", async () => {
            const etl = new Etl();
            etl.use(fromJson({ foo: "•http://ex.com/Person" }));
            etl.use(triple(a, a, iri("foo")));
            await expect(etl.run()).to.eventually.rejectedWith(/invalid iri/gi);
        });
    });
});
function validate() {
    return async (ctx, next) => {
        const quads = ctx.store.getQuads({});
        expect(quads.length).equal(1);
        expect(quads[0].subject.equals(S)).true;
        expect(quads[0].predicate.equals(P)).true;
        expect(quads[0].object.equals(O)).true;
        return next();
    };
}
//# sourceMappingURL=iri.test.js.map