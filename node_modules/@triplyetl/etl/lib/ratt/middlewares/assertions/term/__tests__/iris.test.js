import chai from "chai";
import { getFactory } from "@triplydb/data-factory";
import chaiAsPromised from "chai-as-promised";
import { fromJson, Iri } from "../../../../../generic/index.js";
import { getEtlForTesting, getEtlForTestingNoExtractor } from "../../../../__tests__/getEtlForTesting.js";
import { triple } from "../../statement/index.js";
import iris from "../iris.js";
import str from "../str.js";
import { owl } from "@triplyetl/vocabularies";
chai.use(chaiAsPromised);
const DataFactory = getFactory();
const expect = chai.expect;
const S1 = DataFactory.namedNode("http://ex.com/JohnDoe");
const S2 = DataFactory.namedNode("http://ex.com/JaneDoe");
const P = DataFactory.namedNode("http://ex.com/type");
const O = DataFactory.namedNode("http://ex.com/Person");
const prefix = Iri("http://ex.com/");
describe("iris TermGetter", () => {
    it("should fail on a prefix with empty content", () => {
        return expect(getEtlForTesting([triple(iris(prefix, []), P, O)]).run()).eventually.rejectedWith("Can not create Iri's using a prefix function with no local values.");
    });
    it("should fail on a prefix with non-existing key", () => {
        return expect(getEtlForTestingNoExtractor([
            fromJson({ names: ["JohnDoe", "JaneDoe"] }),
            triple(iris(prefix, ["names", "non-existing-key"]), P, O),
        ]).run()).eventually.rejectedWith("The key 'non-existing-key' is missing, unable to get a Iri values.");
    });
    it("should work on a prefix with some static values", () => {
        return getEtlForTesting([triple(iris(prefix, [str("JohnDoe"), str("JaneDoe")]), P, O), validate()]).run();
    });
    it("should work with static URL strings", () => {
        return getEtlForTestingNoExtractor([
            fromJson({ iris: [] }),
            triple(iris([str(S1.value), str(S2.value)]), P, O),
            validate(),
        ]).run();
    });
    it("should work on a prefix with some values from keys", () => {
        return getEtlForTestingNoExtractor([
            fromJson({ names: ["JohnDoe", "JaneDoe"] }),
            triple(iris(prefix, "names"), P, O),
            validate(),
        ]).run();
    });
    it("should work on a prefix with some values from keys (subject and object)", () => {
        // this is weird?
        return getEtlForTestingNoExtractor([
            fromJson({ names: ["JohnDoe", "JaneDoe"], altNames: ["DoeJohn", ["DoeJane"]] }),
            triple(iris(prefix, "names"), owl.sameAs, iris(prefix, "names")),
            async (ctx, next) => {
                const quads = ctx.store.getQuads({});
                expect(quads.length).equal(4);
                return next();
            },
        ]).run();
    });
    it("should work on a prefix with some values from multiple keys", () => {
        return getEtlForTestingNoExtractor([
            fromJson({ name1: ["JohnDoe"], name2: ["JaneDoe"] }),
            triple(iris(prefix, ["name1", "name2"]), P, O),
            validate(),
        ]).run();
    });
    it("should work on a prefix with some numbers from keys", () => {
        return getEtlForTestingNoExtractor([
            fromJson({ ids: ["1", "2"] }),
            triple(iris(prefix, "ids"), P, O),
            async (ctx, next) => {
                const quads = ctx.store.getQuads({});
                expect(quads.length).equal(2);
                expect(quads[0].subject.equals(DataFactory.namedNode("http://ex.com/1"))).true;
                expect(quads[1].subject.equals(DataFactory.namedNode("http://ex.com/2"))).true;
                return next();
            },
        ]).run();
    });
});
function validate() {
    return async (ctx, next) => {
        const quads = ctx.store.getQuads({});
        expect(quads.length).equal(2);
        expect(quads[0].subject.equals(S1)).true;
        expect(quads[1].subject.equals(S2)).true;
        return next();
    };
}
//# sourceMappingURL=iris.test.js.map