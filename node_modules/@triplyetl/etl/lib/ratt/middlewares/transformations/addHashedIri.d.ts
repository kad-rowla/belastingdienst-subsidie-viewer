import { Key, Middleware } from "../../../generic/index.js";
import { PossibleIri } from "../../../utils/index.js";
import { StaticString } from "../assertions/term/str.js";
/**
 * Creates an IRI based on the specified IRI prefix and the hash calculated
 * over the input content string(s).
 *
 * @remarks
 * This function is used under the following circumstances:
 * 1. You want to identify something with an IRI.
 * 2. The thing that you want to identify does not have a readily available
 *    identifier.
 * 3. The thing that you want to identify has one or more properties that
 *    together allow the thing to be uniquely identified.
 *
 * A benefit of this middleware is that the created IRIs are the same across
 * different ETL runs over the same source data.
 *
 * A downside of this middleware is that specifying the hashed content takes
 * may take a lot of time, especially when the properties that make a thing
 * unique are not straightforward to determine.  Having to adjust the hashed
 * content later may pose a maintenance burden.
 *
 * @param args.prefix - An IRI, or a key that contains an IRI value.
 *
 * @param args.content - A key that contains a string value, or a string value
 * specified with {@link str}.
 *
 * @param args.key - A new key where the created hashed IRI is stored.
 *
 * @example
 * The following snippet uses the first and last name of a person to create a
 * hashed-based IRI.  This assumes that every person in the dataset has a
 * unique first/last name combination.
 *
 * ```ts
 * fromJson([{ firstName: 'John', lastName: 'Doe' }]),
 * addHashedIri({
 *   prefix: prefix.person,
 *   content: ['firstName', 'lastName'],
 *   key: '_person',
 * }),
 * pairs('_person',
 *   [a, sdo.Person],
 *   [sdo.givenName, 'firstName'],
 *   [sdo.familyName, 'lastName'],
 * ),
 * ```
 *
 * This results in the following linked data assertions:
 *
 * ```ttl
 * person:70020947bea6c39cccea20d27e30fbdf
 *   a sdo:Person;
 *   sdo:givenName 'John';
 *   familyName 'Doe'.
 * ```
 *
 * @example
 * The following snippet uses `addHashedIri` to create a reified triple:
 *
 * ```ts
 * fromJson([{ id: '1', name: 'John Doe' }]),
 * addIri({
 *   prefix: prefix.person,
 *   content: 'id',
 *   key: 'subject',
 * }),
 * addIri({
 *   prefix: prefix.def,
 *   content: str('name'),
 *   key: 'predicate',
 * }),
 * addLiteral({
 *   content: 'name',
 *   key: 'object',
 * }),
 * addHashedIri({
 *   prefix: prefix.statement,
 *   content: ['subject', 'predicate', 'object'],
 *   key: 'statement',
 * }),
 * triple('subject', 'predicate', 'object'),
 * pairs('statement',
 *   [a, rdf.Statement],
 *   [rdf.subject, 'subject'],
 *   [rdf.predicate, 'predicate'],
 *   [rdf.object, 'object'],
 * ),
 * ```
 *
 * This results in the following linked data assertions:
 *
 * ```ttl
 * person:1 def:name 'John Doe'.
 * statement:549decc4c44204a907aa32b4cc9bfaba
 *   a rdf:Statement;
 *   rdf:subject person:1;
 *   rdf:predicate def:name;
 *   rdf:object 'John Doe'.
 * ```
 */
export default function <R = unknown>(args: {
    prefix: PossibleIri;
    content: StaticString | Key | Array<Key | StaticString>;
    key: string;
}): Middleware<R>;
//# sourceMappingURL=addHashedIri.d.ts.map