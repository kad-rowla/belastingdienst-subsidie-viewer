/**
 * Makes a plain copy of the input content value and stores it in a new key.
 *
 * This is specifically useful if a downstream user can use either A or B,
 * but prefers to use A in case both A and B are present.
 *
 * Plain copy allows a potential value for A to be stored in key `'A'` and
 * allows a potential value for B to be stored in key `'B'`.
 * The downstream user check whether key `'A'` is present, and can otherwise
 * check whether key `'B'` is present.
 *
 * @param args.content A static value of any type, or a key containing a dynamic
 *                     value of any type.
 * @param args.key     A new key where the plain copy is stored.
 */
import { Middleware } from "../../../../../generic/index.js";
import { TypeForName, TypeName } from "../../../../../generic/Context.js";
/**
 * This is a custom transformation that uses one value and stores a
 * transformed version of it in a new key.
 *
 * This transformation is used in case none of the standard transformations
 * does the job.
 *
 * Use of this transformation is considered typical.
 *
 * @param args.content  A key that contains a dynamic value of the type denoted
 *                      by `type`.
 * @param args.type     Optionally, a Etl Type Name.
 *                      When absent, Etl Type Name `'string'` is used.
 * @param args.function A function that takes a value as input and returns a
 *                      transformed variant of that value.
 * @param args.key      A new key where the result of the transformation is
 *                      stored.
 */
export default function <R = unknown, T extends TypeName = "unknown">(args: {
    /**
     * Key to copy from
     */
    content: string | String | String[];
    /**
     * Key to copy to
     */
    key: string;
    /**
     * Optionally modify the value when copying
     */
    change?: (val: TypeForName<T>) => unknown;
    /**
     * Ensure the value is of this type
     */
    type?: T;
}): Middleware<R>;
//# sourceMappingURL=value.d.ts.map