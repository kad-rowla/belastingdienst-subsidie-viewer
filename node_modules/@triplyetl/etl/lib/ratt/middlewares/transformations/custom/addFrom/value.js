/**
 * Makes a plain copy of the input content value and stores it in a new key.
 *
 * This is specifically useful if a downstream user can use either A or B,
 * but prefers to use A in case both A and B are present.
 *
 * Plain copy allows a potential value for A to be stored in key `'A'` and
 * allows a potential value for B to be stored in key `'B'`.
 * The downstream user check whether key `'A'` is present, and can otherwise
 * check whether key `'B'` is present.
 *
 * @param args.content A static value of any type, or a key containing a dynamic
 *                     value of any type.
 * @param args.key     A new key where the plain copy is stored.
 */
// export default function (args: {
//   content: String
//   key: string
//   type?: TypeName
// }): Middleware {
//   return copy({
//     fromKey: args.content.toString(),
//     toKey: args.key,
//     type: args.type ?? 'unknown',
//     change: (val) => {
//       if (!args.content.typeOfKey) {
//         // Type guard: if content is not a key, users should use the add() function
//         throw new Error(`key '${args.content.toString()}' is not a key, use '${args.content.toString()}.key' or '${args.content.toString()}.askey()'`)
//       }
//       return val
//     }
//   })
// }
import { has, isArray, isObject, set } from "lodash-es";
import { addMwCallSiteToError } from "../../../../../utils/index.js";
import { isStatic } from "../../../assertions/term/str.js";
import { copy } from "../copy.js";
/**
 * This is a custom transformation that uses one value and stores a
 * transformed version of it in a new key.
 *
 * This transformation is used in case none of the standard transformations
 * does the job.
 *
 * Use of this transformation is considered typical.
 *
 * @param args.content  A key that contains a dynamic value of the type denoted
 *                      by `type`.
 * @param args.type     Optionally, a Etl Type Name.
 *                      When absent, Etl Type Name `'string'` is used.
 * @param args.function A function that takes a value as input and returns a
 *                      transformed variant of that value.
 * @param args.key      A new key where the result of the transformation is
 *                      stored.
 */
export default function (args) {
    if (isArray(args.content)) {
        return addMwCallSiteToError(async (ctx, next) => {
            if (has(ctx.record, args.key)) {
                throw new Error(`Record already contains key '${args.key}'. Use the 'replace' middleware`);
            }
            set(ctx.record, args.key, args.content.map((str) => str.toString()));
            return next();
        }, { sourceFuncName: "_value" });
    }
    if (isObject(args.content) && isStatic(args.content)) {
        return addMwCallSiteToError(async (ctx, next) => {
            if (has(ctx.record, args.key)) {
                throw new Error(`Record already contains key '${args.key}'. Use the 'replace' middleware`);
            }
            set(ctx.record, args.key, args.content.toString());
            return next();
        }, { sourceFuncName: "_value" });
    }
    else {
        return addMwCallSiteToError(copy({
            fromKey: args.content.toString(),
            type: args.type ?? "unkown",
            change: args.change,
            toKey: args.key,
        }), { sourceFuncName: "_value" });
    }
}
//# sourceMappingURL=value.js.map