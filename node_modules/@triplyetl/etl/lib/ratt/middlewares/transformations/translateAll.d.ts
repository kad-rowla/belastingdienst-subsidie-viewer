import { Middleware } from "../../../generic/index.js";
import { StaticString } from "../assertions/term/str.js";
import { Vocabulary } from "@triplyetl/vocabularies";
/**
 * Translates all dynamic strings from a specific key to new values of an
 * arbitrary type `To`, according to a specified translation table.
 *
 * @remarks
 * Since this function translates *all* values, the mapped values can have any
 * type `T`; they do not need to be strings.  For example, this allows strings
 * to be translated to IRIs or to literals.
 *
 * @param args.content - A key that contains a string value.
 *
 * @param args.table - A translation table from strings to values of some
 * arbitrary type `T`.
 *
 * @param args.nulls - Optionally, a list of string values that are considered
 * denote NULL values in the source data.  When a NULL value is encountered,
 * the special value `undefined` is added for the target `key`.
 *
 * @param args.default - Optionally, a default value or a default
 * value-determining function that is used for string values that are neither
 * in the translation table (`table`) nor in the NULL values list (`nulls`).
 * The function must return a value of type `T`.
 * Use of a default value `value` is equivalent to using the following
 * value-determining function: `_ => value`.
 *
 * @param args.key - A new key where the results of the translation are
 * stored.
 *
 * @example
 * Suppose that source data contains country names.  In RDF we want to use
 * IRIs to denote countries, so that we can link additional information.
 * Since the list of countries that appear in the source data is not that
 * long, we can specify a translation table from names to IRIs by hand:
 *
 * ```ts
 * change.translateAll({
 *   content: 'country',
 *   table: {
 *     'Belgium': country.be,
 *     'Germany': country.de,
 *     'England': country.gb,
 *     ...,
 *   },
 *   nulls: ['Unknown'],
 *   key: '_country',
 * }),
 * when('country', [
 *   triple('_country', a, sdo.Country),
 * ]),
 * ```
 *
 * @example
 * When we relate a creative work to its creator, we sometimes know whether
 * the creator was the actor, architect, author, etc. of the creative work.
 * But in other cases we only know that there is a generic creator
 * relationship.  The [Library of Congress Relators
 * vocabulary](https://triplydb.com/loc/relators) allows us to express
 * specific and generic predicates of this kind.
 *
 * ```ts
 * transform.translateAll({
 *   table: {
 *     'actor': rel.act,
 *     'architect': rel.arc,
 *     'author': rel.aut,
 *     ...,
 *   },
 *   default: rel.oth, // generic relator
 *   key: '_relator',
 * }),
 * triple('_creativeWork', '_relator', '_creator'),
 * ```
 */
export default function translateAll<To = unknown, R = unknown>(args: {
    content: StaticString | string;
    table: {
        [key: string]: To;
    } | string | Vocabulary;
    nulls?: string[];
    default?: To | ((value: string) => To);
    key: string;
}): Middleware<R>;
export declare function vocabularyToTable<To = unknown>(vocab: Vocabulary): {
    [key: string]: To;
};
//# sourceMappingURL=translateAll.d.ts.map