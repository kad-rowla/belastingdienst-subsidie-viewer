import { get, has } from "lodash-es";
import { addMwCallSiteToError } from "../../../utils/index.js";
import { add } from "./custom/add.js";
import { Vocabulary } from "@triplyetl/vocabularies";
/**
 * Translates all dynamic strings from a specific key to new values of an
 * arbitrary type `To`, according to a specified translation table.
 *
 * @remarks
 * Since this function translates *all* values, the mapped values can have any
 * type `T`; they do not need to be strings.  For example, this allows strings
 * to be translated to IRIs or to literals.
 *
 * @param args.content - A key that contains a string value.
 *
 * @param args.table - A translation table from strings to values of some
 * arbitrary type `T`.
 *
 * @param args.nulls - Optionally, a list of string values that are considered
 * denote NULL values in the source data.  When a NULL value is encountered,
 * the special value `undefined` is added for the target `key`.
 *
 * @param args.default - Optionally, a default value or a default
 * value-determining function that is used for string values that are neither
 * in the translation table (`table`) nor in the NULL values list (`nulls`).
 * The function must return a value of type `T`.
 * Use of a default value `value` is equivalent to using the following
 * value-determining function: `_ => value`.
 *
 * @param args.key - A new key where the results of the translation are
 * stored.
 *
 * @example
 * Suppose that source data contains country names.  In RDF we want to use
 * IRIs to denote countries, so that we can link additional information.
 * Since the list of countries that appear in the source data is not that
 * long, we can specify a translation table from names to IRIs by hand:
 *
 * ```ts
 * change.translateAll({
 *   content: 'country',
 *   table: {
 *     'Belgium': country.be,
 *     'Germany': country.de,
 *     'England': country.gb,
 *     ...,
 *   },
 *   nulls: ['Unknown'],
 *   key: '_country',
 * }),
 * when('country', [
 *   triple('_country', a, sdo.Country),
 * ]),
 * ```
 *
 * @example
 * When we relate a creative work to its creator, we sometimes know whether
 * the creator was the actor, architect, author, etc. of the creative work.
 * But in other cases we only know that there is a generic creator
 * relationship.  The [Library of Congress Relators
 * vocabulary](https://triplydb.com/loc/relators) allows us to express
 * specific and generic predicates of this kind.
 *
 * ```ts
 * transform.translateAll({
 *   table: {
 *     'actor': rel.act,
 *     'architect': rel.arc,
 *     'author': rel.aut,
 *     ...,
 *   },
 *   default: rel.oth, // generic relator
 *   key: '_relator',
 * }),
 * triple('_creativeWork', '_relator', '_creator'),
 * ```
 */
export default function translateAll(args) {
    return addMwCallSiteToError(add({
        value: (context) => _translateAll({ context, ...args }),
        key: args.key,
    }), { sourceFuncName: "_translateAll" });
}
async function _translateAll(args) {
    const keyFromContent = args.context.getString(args.content).toString();
    if (args.nulls?.includes(keyFromContent) ?? false) {
        return undefined;
    }
    const table = typeof args.table === "string"
        ? args.context.getTable(args.table)
        : Vocabulary.isVocabulary(args.table)
            ? vocabularyToTable(args.table)
            : args.table;
    /**
     * process args.table as key in record.
     */
    if (has(table, keyFromContent)) {
        /**
         * process args.table as JS object.
         */
        return get(table, keyFromContent);
    }
    else if (args.default !== undefined) {
        if (typeof args.default === "function") {
            // Function.
            return args.default(keyFromContent);
        }
        else {
            // Constant.
            return args.default;
        }
    }
    else {
        throw Error(`Unanticipated string value for key '${args.key}': '${keyFromContent}'`);
    }
}
export function vocabularyToTable(vocab) {
    return vocab.toRecord();
}
//# sourceMappingURL=translateAll.js.map