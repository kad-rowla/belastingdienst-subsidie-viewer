import chai from "chai";
import chaiAsPromised from "chai-as-promised";
import { addHashedIri, addIri, addLiteral, geojsonToWkt } from "../index.js";
import wkx from "wkx";
import { getEtlForTesting, getEtlForTestingNoExtractor } from "../../../__tests__/getEtlForTesting.js";
import { pairs } from "../../assertions/statement/index.js";
import { a, epsg, geo } from "@triplyetl/vocabularies";
import { getFactory } from "@triplydb/data-factory";
import { Iri, fromJson } from "../../../../generic/index.js";
import { str } from "../../../index.js";
import { literal } from "../../assertions/term/index.js";
chai.use(chaiAsPromised);
const assert = chai.assert;
const expect = chai.expect;
const point = { type: "Point", coordinates: [1, 2] };
const wkt = wkx.Geometry.parseGeoJSON(point).toWkt();
const key = "geojsonToWkt";
const dataIssue16 = {
    type: "Feature",
    properties: {
        ID: "19940",
    },
    geometry: {
        type: "LineString",
        coordinates: [[2775441.366799999, 8444748.913500004]],
    },
};
describe("Transform.geojsonToWkt ", () => {
    it("should work with a Point, no crs", () => {
        const etl = getEtlForTestingNoExtractor([
            geojsonToWkt({
                content: point,
                key,
            }),
            async (ctx, next) => {
                assert.equal(wkx.Geometry.parseGeoJSON(point).toWkt(), ctx.getString("geojsonToWkt"));
                return next();
            },
        ]);
        return etl.run();
    });
    it("should work with a key, no crs", () => {
        const etl = getEtlForTestingNoExtractor([
            fromJson(dataIssue16),
            geojsonToWkt({
                content: "geometry",
                key,
            }),
            async (ctx, next) => {
                assert.equal(wkx.Geometry.parseGeoJSON(dataIssue16.geometry).toWkt(), ctx.getString("geojsonToWkt"));
                return next();
            },
        ]);
        return etl.run();
    });
    it("should work with a Point, with static crs", () => {
        const crs = str("http://ex.com/");
        const etl = getEtlForTesting([
            geojsonToWkt({ content: point, key, crs }),
            async (ctx, next) => {
                const result = ctx.getString(key);
                assert.isTrue(result.endsWith(wkt));
                assert.isTrue(result.startsWith(`<${crs.toString()}>`));
                return next();
            },
        ]);
        return etl.run();
    });
    it("should work with a Point, with Etl.Prefix crs", () => {
        const crs = Iri("http://ex.com/");
        const etl = getEtlForTesting([
            geojsonToWkt({ content: point, key, crs }),
            async (ctx, next) => {
                const result = ctx.getString(key);
                assert.isTrue(result.endsWith(wkt));
                assert.isTrue(result.startsWith(`<${crs.value}>`));
                return next();
            },
        ]);
        return etl.run();
    });
    it("should work with a Point, with a static crs from a key", () => {
        const crs = str("http://ex.com/");
        const etl = getEtlForTesting([
            addLiteral({ key: "crs", content: crs }),
            geojsonToWkt({ content: point, key, crs }),
            async (ctx, next) => {
                const result = ctx.getString(key);
                assert.isTrue(result.endsWith(wkt));
                assert.isTrue(result.startsWith(`<${crs.toString()}>`));
                return next();
            },
        ]);
        return etl.run();
    });
    it("Should fail on a static string with invalid Json data", () => {
        const etl = getEtlForTesting([geojsonToWkt({ key: "crs", content: str("Invalid JSON data") })]);
        return expect(etl.run()).to.eventually.rejected;
    });
    it("Should succeed on a static string with valid Json data", () => {
        const etl = getEtlForTesting([geojsonToWkt({ key: "crs", content: str(JSON.stringify(point)) })]);
        return expect(etl.run()).to.eventually.fulfilled;
    });
    it("Should run documentation example", () => {
        const prefix = {
            feature: Iri("http://ex.com/feature/"),
            geometry: Iri("http://ex.com/geometry/"),
        };
        const def = {
            TrafficLight: prefix.feature.concat("TrafficLight"),
        };
        const data = {
            id: "123",
            geometry: {
                type: "Point",
                coordinates: [6.256, 48.48],
            },
        };
        return getEtlForTestingNoExtractor([
            fromJson(data),
            addIri({
                prefix: prefix.feature,
                content: "id",
                key: "_feature",
            }),
            geojsonToWkt({
                content: "geometry",
                crs: epsg[3857],
                key: "_wkt",
            }),
            addHashedIri({
                prefix: prefix.geometry,
                content: "_wkt",
                key: "_geometry",
            }),
            pairs("_feature", [a, def.TrafficLight], [geo.hasGeometry, "_geometry"]),
            pairs("_geometry", [a, geo.Geometry], [geo.asWKT, literal("_wkt", geo.wktLiteral)]),
            async (ctx, next) => {
                expect(ctx.store.getQuads(prefix.feature.concat(data.id), a, def.TrafficLight, null).length).equal(1);
                const hasGeometry = ctx.store.getQuads(prefix.feature.concat(data.id), geo.hasGeometry, null, null);
                expect(hasGeometry.length).equal(1);
                const bn = hasGeometry[0].object;
                expect(bn.value).match(/^http:\/\/ex.com\/geometry\/([a-z0-9]{32})$/);
                expect(ctx.store.getQuads(bn, a, geo.Geometry, null).length).equal(1);
                const wkt = ctx.store.getObjects(bn, geo.asWKT, null);
                expect(wkt.length).equal(1);
                expect(wkt[0].termType).equal("Literal");
                expect(wkt[0].value.replace(/.+ Point /, "POINT")).equal(wkx.Geometry.parseGeoJSON(data.geometry).toWkt());
                expect(wkt[0].datatype.equals(getFactory().namedNode("http://www.opengis.net/ont/geosparql#wktLiteral"))).true;
                return next();
            },
        ]).run();
    });
});
//# sourceMappingURL=geojsonToWkt.test.js.map