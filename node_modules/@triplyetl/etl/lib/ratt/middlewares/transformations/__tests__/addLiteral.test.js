import chai from "chai";
import chaiAsPromised from "chai-as-promised";
import { getEtlForTesting } from "../../../__tests__/getEtlForTesting.js";
import literals from "../../../../utils/__tests__/literals.js";
import { str } from "../../../index.js";
import { getFactory } from "@triplydb/data-factory";
import { LanguageTag, language, region, xsd } from "@triplyetl/vocabularies";
import { addIri, addLiteral, addValue, translateAll } from "../index.js";
import { Iri } from "../../../../generic/index.js";
chai.use(chaiAsPromised);
const assert = chai.assert;
async function getEtlForLiteral(content, datatype, forValid = true) {
    return getEtlForTesting([
        addLiteral({
            content: str(content),
            key: "obj",
            datatype: datatype,
        }),
        addIri({ prefix: str("http://ex.com/"), content: str("Subject"), key: "subj" }),
        addIri({ prefix: str("http://ex.com/"), content: str("predicate"), key: "pred" }),
        async (ctx, next) => {
            ctx.store.addQuad(ctx.getIri("subj"), ctx.getIri("pred"), ctx.getLiteral("obj"));
            return next();
        },
        async (ctx, next) => {
            if (!forValid)
                return next();
            assert.equal(ctx.store.getQuads({}).length, 1);
            assert.equal(ctx.store.getQuads({ subject: ctx.getIri("subj") }).length, 1);
            assert.equal(ctx.store.getQuads({
                subject: ctx.getIri("subj"),
                predicate: ctx.getIri("pred"),
            }).length, 1);
            assert.equal(ctx.store.getQuads({
                subject: ctx.getIri("subj"),
                predicate: ctx.getIri("pred"),
                object: ctx.getLiteral("obj"),
            }).length, 1, "expected result on subj/pred/obj");
            return next();
        },
    ]).run();
}
describe("Transforming.addLiteral ", () => {
    literals.forEach((lit) => {
        describe(lit.datatype.value, () => {
            describe("- valid values", () => {
                lit.valid.forEach((validLiteral) => {
                    for (const l in validLiteral) {
                        const desc = validLiteral[l] === "" ? "" : ` (${validLiteral[l]})`;
                        it(`${l}${desc}`, () => {
                            return chai.expect(getEtlForLiteral(l.toString(), lit.datatype)).to.eventually.be.fulfilled;
                        });
                    }
                });
            });
            describe("- invalid values", () => {
                lit.invalid?.forEach((invalidLiteral) => {
                    for (const l in invalidLiteral) {
                        const desc = invalidLiteral[l] === "" ? "" : ` (${invalidLiteral[l]})`;
                        it(`${l}${desc}`, () => {
                            return chai.expect(getEtlForLiteral(l.toString(), lit.datatype, false)).to.eventually.be.rejected;
                        });
                    }
                });
            });
        });
    });
    it("Should create xsd:String with minimal arguments", async () => {
        return getEtlForTesting([
            addLiteral({ content: str("Title"), key: "Title" }),
            async (ctx, _) => {
                assert.isTrue(ctx.getLiteral("Title").equals(getFactory().literal("Title")));
                assert.isTrue(ctx.getLiteral("Title").datatype.equals(xsd.string));
            },
        ]).run();
    });
    it("Should work with unrecognized datatype argument", async () => {
        const km = getFactory().namedNode("http://ex.com/units/km");
        return getEtlForTesting([
            addIri({ prefix: Iri("http://ex.com/units/"), content: str("km"), key: "unit" }),
            addLiteral({ content: str(10), key: "distance1", datatype: str("http://ex.com/units/km") }),
            addLiteral({ content: str(10), key: "distance2", datatype: "unit" }),
            addLiteral({ content: str(10), key: "distance3", datatype: xsd.integer }),
            async (ctx, _) => {
                assert.doesNotThrow(() => ctx.getLiteral("distance1"));
                assert.equal(ctx.getLiteral("distance1").validationStatus, "unrecognized");
                assert.isTrue(ctx.getLiteral("distance1").equals(getFactory().literal("10", km)));
                assert.isTrue(ctx.getLiteral("distance1").datatype.equals(km));
                assert.doesNotThrow(() => ctx.getLiteral("distance2"));
                assert.equal(ctx.getLiteral("distance2").validationStatus, "unrecognized");
                assert.isTrue(ctx.getLiteral("distance2").equals(getFactory().literal("10", km)));
                assert.isTrue(ctx.getLiteral("distance2").datatype.equals(km));
            },
        ]).run();
    });
    it("Use cases from https://git.triply.cc/etl/ratt-helpers/-/issues/35", () => {
        const desc = "Een beschrijving";
        return getEtlForTesting([
            addValue({ content: str("Dutch"), key: "language" }),
            addValue({ content: str(desc), key: "description" }),
            // Case 1. I want to add a string:
            addLiteral({
                content: str("from"),
                key: "case1",
            }),
            // Case 2. I want to add a language-tagged string:
            addLiteral({
                content: str("from"),
                language: language.en,
                key: "case2",
            }),
            // logR
            // Case 3. I want to add a language-tagged string with a language tag from the source data:
            translateAll({
                content: "language",
                table: {
                    English: language.en,
                    Dutch: language.nl,
                },
                key: "_ltag",
            }),
            addLiteral({
                content: "description",
                language: "_ltag",
                key: "case3",
            }),
            // Case 4. I want to add a typed literal:
            addValue({ key: "created", content: str("1970") }),
            addLiteral({
                content: "created",
                datatype: xsd.gYear,
                key: "case4",
            }),
            // Case 5. I want to add a typed literal with a datatype from the source data:
            addIri({ prefix: xsd.gYear, content: str(""), key: "_datatype" }),
            addLiteral({
                content: "created",
                datatype: "_datatype",
                key: "case5",
            }),
            async (ctx, _) => {
                assert.doesNotThrow(() => ctx.getLiteral("case1"));
                assert.isTrue(ctx.getLiteral("case1").equals(getFactory().literal("from", xsd.string)));
                assert.doesNotThrow(() => ctx.getLiteral("case2"));
                assert.isTrue(ctx.getLiteral("case2").equals(getFactory().literal("from", "en")));
                assert.doesNotThrow(() => ctx.getLiteral("case3"));
                assert.isTrue(ctx.getLiteral("case3").equals(getFactory().literal("Een beschrijving", "nl")));
                assert.doesNotThrow(() => ctx.getLiteral("case4"));
                assert.isTrue(ctx.getLiteral("case4").equals(getFactory().literal("1970", xsd.gYear)));
                assert.doesNotThrow(() => ctx.getLiteral("case5"));
                assert.isTrue(ctx.getLiteral("case5").equals(getFactory().literal("1970", xsd.gYear)));
            },
        ]).run();
    });
    it("Literals where datatype is language string or Tag", () => {
        const etl = getEtlForTesting([
            addLiteral({ content: str("Title"), language: new LanguageTag("nl"), key: "langString@nl" }),
            addLiteral({ content: str("Title"), language: language.nl, key: "langString@nl-from-vocab" }),
            addLiteral({
                content: str("Title"),
                language: language.nl.addRegion(region.NL),
                key: "langString@nl-NL-from-vocab",
            }),
            addLiteral({ content: str("Title"), language: new LanguageTag("nl-BE"), key: "langString@nl-BE" }),
            addLiteral({ content: str("Title"), language: new LanguageTag("en"), key: "langString@en" }),
            addLiteral({ content: str("Title"), language: new LanguageTag("en-GB"), key: "langString@en-GB" }),
            async (ctx, next) => {
                assert.doesNotThrow(() => ctx.getLiteral("langString@nl"));
                assert.doesNotThrow(() => ctx.getLiteral("langString@nl-from-vocab"));
                assert.doesNotThrow(() => ctx.getLiteral("langString@nl-NL-from-vocab"));
                assert.doesNotThrow(() => ctx.getLiteral("langString@en"));
                assert.doesNotThrow(() => ctx.getLiteral("langString@en-GB"));
                assert.doesNotThrow(() => ctx.getLiteral("langString@nl-BE"));
                assert.equal(ctx.getLiteral("langString@nl").language, "nl");
                assert.equal(ctx.getLiteral("langString@nl-from-vocab").language, "nl");
                assert.equal(ctx.getLiteral("langString@nl-NL-from-vocab").language.toLowerCase(), "nl-nl");
                assert.equal(ctx.getLiteral("langString@en").language, "en");
                assert.equal(ctx.getLiteral("langString@en-GB").language.toLowerCase(), "en-gb");
                assert.equal(ctx.getLiteral("langString@nl-BE").language.toLowerCase(), "nl-be");
                return next();
            },
        ]);
        return etl.run();
    });
});
//# sourceMappingURL=addLiteral.test.js.map