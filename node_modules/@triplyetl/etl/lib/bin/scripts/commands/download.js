import chalk from "chalk";
import { Etl } from "../../../generic/index.js";
import App from "@triply/triplydb/App.js";
import { existsSync, mkdirSync, rename, writeFileSync } from "fs";
import inquirer from "inquirer";
import path from "path";
import mime from "mime";
import { skip } from "./report.js";
import { Remarkable } from "remarkable";
const cmd = {
    command: "download",
    describe: "Download information from the currently configured TriplyDB instance, if any",
    builder: {
        out: {
            alias: "o",
            demandOption: true,
            type: "string",
            describe: "Output directory",
            requiresArg: true,
        },
        zip: {
            alias: "z",
            type: "boolean",
            describe: "Create a zip archive",
        },
        token: {
            alias: "t",
            type: "string",
            describe: "Provide a TriplyDB Token",
            requiresArg: true,
        },
        account: {
            alias: "a",
            type: "string",
            describe: "Limit downloads to this account",
            requiresArg: true,
        },
        "skip-orgs": {
            type: "boolean",
            describe: "Do not download organisations",
        },
        "skip-users": {
            type: "boolean",
            describe: "Do not download users",
        },
        "skip-datasets": {
            type: "boolean",
            describe: "Do not download datasets",
        },
        "skip-graphs": {
            type: "boolean",
            describe: "Do not download graphs",
        },
        "skip-queries": {
            type: "boolean",
            describe: "Do not download queries",
        },
        "skip-stories": {
            type: "boolean",
            describe: "Do not download stories",
        },
        "skip-stories-html": {
            type: "boolean",
            describe: "Do not create HTML for stories",
        },
        interactive: {
            type: "boolean",
            alias: "i",
            describe: "Enter interactive mode",
        },
    },
    handler: async (_argv) => {
        if (!_argv.token && !Etl.token) {
            console.error(chalk.yellow("No token found, you might want to create one with the 'create-token' command."));
            process.exit(2);
        }
        if (_argv.interactive) {
            const choices = [
                { checked: true, value: "queries", name: "Stored SPARQL Queries" },
                { checked: true, value: "datasets", name: "Datasets" },
                { checked: true, value: "assets", name: "Assets (only when Datasets are included)" },
                { checked: true, value: "stories", name: "Stories" },
                { checked: true, value: "graphs", name: "Graphs (only when Datasets are included)" },
                { checked: true, value: "users", name: "Users" },
                { checked: true, value: "orgs", name: "Organisations" },
            ];
            const answers = await inquirer.prompt({
                name: "report",
                type: "checkbox",
                message: "Select the options for your report:",
                choices,
            });
            for (const choice of choices) {
                if (!answers.report.includes(choice.value)) {
                    _argv[`skip-${choice.value}`] = true;
                }
            }
        }
        const app = App.get(_argv.token ?? Etl.token);
        Promise.all([
            downloadInstance(_argv, app),
            downloadAccounts(_argv, app),
            downloadQueries(_argv, app),
            downloadStories(_argv, app),
            downloadDatasets(_argv, app),
        ]).catch((e) => logError(e.message));
    },
};
const logInfo = (info) => console.info(chalk.cyan(info));
const logError = (info) => console.error(chalk.red(info));
const logWarn = (info) => console.warn(chalk.yellow(info));
const getPath = (_argv, ...components) => {
    const p = path.join(_argv.out, ...components);
    if (!existsSync(p)) {
        try {
            mkdirSync(p, { recursive: true });
        }
        catch (e) {
            console.error(`Failed to create target folder '${p}'.`);
            process.exit();
        }
    }
    return p;
};
let accounts;
const getAccounts = async (_argv, app) => {
    if (accounts && accounts.length)
        return accounts;
    accounts = [];
    if (_argv.account) {
        accounts.push(await app.getAccount(_argv.account));
    }
    else {
        accounts = await app.getAccounts().toArray();
    }
    return accounts;
};
const writeJson = (dirname, object, filename) => writeFileSync(path.join(dirname, filename ? `${filename}.json` : "info.json"), JSON.stringify(object, null, 2));
const downloadInstance = (_argv, app) => {
    const outDir = getPath(_argv);
    app
        .getInfo()
        .then((info) => {
        writeJson(outDir, info);
        if (info.branding.banner)
            downloadFile(info.branding.banner, outDir);
        if (info.branding.logo)
            downloadFile(info.branding.logo, outDir);
        if (info.branding.logoLg)
            downloadFile(info.branding.logoLg, outDir);
    })
        .then((_) => logInfo(`saved instance info ${outDir}`))
        .catch((e) => logError(e.message));
};
const downloadAccounts = async (_argv, app) => {
    (await getAccounts(_argv, app)).forEach(async (account) => {
        const info = await account.getInfo();
        if (info.type === "org" && skip(_argv, "orgs") && info.accountName !== _argv.account)
            return;
        if (info.type === "user" && skip(_argv, "users") && info.accountName !== _argv.account)
            return;
        const accountDir = getPath(_argv, "accounts", `${info.type}s`, info.accountName);
        writeJson(accountDir, info);
        if (info.avatarUrl)
            downloadFile(info.avatarUrl, path.join(accountDir), info.accountName);
        logInfo(`saved account ${accountDir}`);
    });
};
const downloadStories = async (_argv, app) => {
    if (!skip(_argv, "stories")) {
        (await getAccounts(_argv, app)).forEach(async (account) => {
            const accountInfo = await account.getInfo();
            for await (const story of account.getStories()) {
                const info = await story.getInfo();
                const storyDir = getPath(_argv, "stories", `${accountInfo.type}s`, accountInfo.accountName, info.name);
                writeJson(storyDir, info);
                if (info.bannerUrl)
                    downloadFile(info.bannerUrl, storyDir);
                let markdown = "";
                markdown += `# ${info.displayName ?? info.name}\n`;
                for (const i in info.content) {
                    if (info.content[i].type === "paragraph") {
                        markdown += `\n${info.content[i].paragraph ?? ""}\n`;
                    }
                    else {
                        const rq = `../../../../queries/${accountInfo.type}s/${accountInfo.accountName}/${info.content[i].query?.name}.rq`;
                        markdown += `\n*SPARQL query* [${info.content[i].query?.name}](${rq})\n`;
                    }
                }
                const html = `
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>${info.displayName ?? info.name}</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-KK94CHFLLe+nY2dmCWGMq91rCGa5gtU4mk92HdvYe+M/SXH301p5ILy+dN9+nJOZ" crossorigin="anonymous">
  </head>
  <body>
    <div class="container">${new Remarkable({ html: true }).render(markdown)}</div>
  </body>
</html>`;
                const paths = {
                    markdown: path.join(storyDir, `${info.name}.md`),
                    html: path.join(storyDir, `${info.name}.html`),
                    pdf: path.join(storyDir, `${info.name}.pdf`),
                };
                writeFileSync(paths.markdown, markdown, { encoding: "utf-8" });
                if (!skip(_argv, "stories-html"))
                    writeFileSync(paths.html, html, { encoding: "utf-8" });
                logInfo(`saved story ${storyDir}`);
            }
        });
    }
};
const downloadQueries = async (_argv, app) => {
    if (!skip(_argv, "queries")) {
        (await getAccounts(_argv, app)).forEach(async (account) => {
            const accountInfo = await account.getInfo();
            for await (const query of account.getQueries()) {
                const info = await query.getInfo();
                const queryDir = getPath(_argv, "queries", `${accountInfo.type}s`, accountInfo.accountName);
                writeJson(queryDir, info, info.name);
                if (info.numberOfVersions > 0) {
                    let variables;
                    if (info.variables) {
                        variables = {};
                        info.variables.forEach((variable) => {
                            let value;
                            if (variable.allowedValues?.length ?? 0 > 0) {
                                value = variable.allowedValues[0];
                            }
                            else if (variable.defaultValue) {
                                value = variable.defaultValue;
                            }
                            else if (variable.termType === "Literal") {
                                value = variable.name;
                            }
                            else {
                                value = `http://ex.com/variable/${variable.name}`;
                            }
                            variables[variable.name] = value;
                        });
                    }
                    await query
                        .getString(variables)
                        .then((rq) => writeFileSync(path.join(queryDir, `${info.name}.rq`), rq, "utf-8"))
                        .then((_) => logInfo(`saved query ${queryDir}/${info.name}.rq`))
                        .catch((e) => {
                        logWarn(`query '${info.link}': ${e.message}`);
                    });
                }
            }
        });
    }
};
const downloadDatasets = async (_argv, app) => {
    if (skip(_argv, "datasets"))
        return;
    (await getAccounts(_argv, app)).forEach(async (account) => {
        const datasets = account.getDatasets();
        for await (const dataset of datasets) {
            const info = await dataset.getInfo();
            const datasetDir = getPath(_argv, "datasets", `${info.owner.type}s`, info.owner.accountName, info.name);
            writeJson(datasetDir, info);
            if (!skip(_argv, "assets")) {
                const assets = dataset.getAssets();
                const ps = [];
                for await (const asset of assets) {
                    const assetDir = getPath(_argv, datasetDir, "assets");
                    const info = asset.getInfo();
                    const targetFile = path.join(assetDir, info.assetName);
                    ps.push(asset.toFile(targetFile));
                    writeJson(assetDir, info, path.basename(info.assetName, path.extname(info.assetName)));
                }
                await Promise.all(ps);
            }
            if (!skip(_argv, "graphs") && (await dataset.getGraphs().toArray()).length > 0) {
                await dataset
                    .graphsToFile(path.join(datasetDir, `${info.name}.trig`))
                    .catch((_) => logError(`failed to save graphs for dataset ${info.name}`));
            }
            logInfo(`saved dataset ${datasetDir}`);
        }
    });
};
const downloadFile = (url, targetDir, basename) => {
    const filename = basename ?? path.basename(new URL(url).pathname);
    const targetFile = path.join(targetDir, filename);
    let to = targetFile;
    let headers;
    fetch(url, { headers: { Authorization: `Bearer + ${Etl.token}` } })
        .then((res) => {
        headers = res.headers;
        return res.arrayBuffer();
    })
        .then((buf) => writeFileSync(targetFile, Buffer.from(buf)))
        .then((_) => {
        const ext = path.extname(targetFile);
        if (!ext) {
            const contentType = headers.get("content-type");
            if (contentType) {
                to = path.join(targetDir, `${filename}.${mime.getExtension(contentType) ?? "data"}`);
                rename(targetFile, to, (err) => {
                    if (err)
                        logWarn(`failed to rename '${targetFile}' => '${to}'`);
                });
            }
        }
    })
        // .then(_ => logInfo(`saved ${to}`))
        .catch((_) => {
        logError(`failed to download ${url}`);
    });
};
export default cmd;
//# sourceMappingURL=download.js.map