import { Store, getFactory, parse } from "@triplydb/data-factory";
import { Etl } from "../../generic/index.js";
import { addMwCallSiteToError } from "../../utils/index.js";
import { castArray } from "lodash-es";
import { createHash } from "crypto";
import Validator from "@triplyetl/shacl/lib/Validator.js";
import getCurrentLine from "get-current-line";
const factory = { ...getFactory({ skipValidation: Etl.skipValidation }), dataset: (quads) => new Store(quads) };
// generate a hash for the sources so we know which models have been validated with ShSh
const getFingerPrint = async (info) => {
    const hash = createHash("md5");
    for (const i of info)
        hash.update(await i.id());
    return hash.digest("hex");
};
// Singleton patterns to prevent loading common used data more than once:
class Once {
    constructor() { }
    static async getValidator(ctx, oneOrMoreModelSources) {
        const sources = await ctx["_registerSources"](castArray(oneOrMoreModelSources), "statements");
        const hash = await getFingerPrint(sources);
        if (!Once.validators.has(hash)) {
            let sourceData = "";
            for (const source of sources) {
                sourceData += await source.getString();
            }
            const model = new Store(parse(sourceData), { factory });
            await Validator.validateModel(model);
            Once.validators.set(hash, new Validator(model, { skipShaclShaclValidaton: true }));
        }
        return Once.validators.get(hash);
    }
}
Once.validators = new Map();
// TODO @DocumentationTeam: add TS doc comment here
export default function (oneOrMoreModelSources, opts) {
    const callSite = getCurrentLine({ frames: 2 });
    return addMwCallSiteToError(async (ctx, next) => {
        const validator = await Once.getValidator(ctx, oneOrMoreModelSources);
        opts = opts ?? { terminateOn: "Violation" };
        // next step is to validate the Context's store:
        const prefixers = { ...ctx.app.standardPrefixes, ...ctx.app.prefix };
        const prefixes = {};
        let alias;
        for (alias in prefixers) {
            prefixes[alias] = prefixers[alias].value;
        }
        const report = await validator.validate({ dataset: ctx.store });
        if (!report.conforms) {
            const writer = report.addPrefixes(prefixes).writer;
            ctx.app["_messageCounts"].ShaclViolation = ctx.app["_messageCounts"].ShaclViolation ?? 0;
            ctx.app["_messageCounts"].ShaclWarning = ctx.app["_messageCounts"].ShaclWarning ?? 0;
            ctx.app["_messageCounts"].ShaclInfo = ctx.app["_messageCounts"].ShaclInfo ?? 0;
            ctx.app["_messageCounts"].ShaclViolation += report.countViolations();
            ctx.app["_messageCounts"].ShaclWarning += report.countWarnings();
            ctx.app["_messageCounts"].ShaclInfo += report.countInfos();
            const message = `The instance data of record ${ctx.recordId} does not conform to the model${report.severityMessage ? ` (${report.severityMessage}).` : "."}`;
            if (opts.terminateOn !== "Never") {
                let terminate = true;
                switch (opts.terminateOn) {
                    case "Info":
                        terminate = report.countInfos() + report.countWarnings() + report.countViolations() > 0;
                        break;
                    case "Warning":
                        terminate = report.countWarnings() + report.countViolations() > 0;
                        break;
                    case "Violation":
                        terminate = report.countViolations() > 0;
                        break;
                }
                if (terminate === true) {
                    ctx.app.info("A copy of the SHACL Validation report is saved in the file `etl.validation-report.trig`.");
                    await writer.saveRdf("etl.validation-report.trig");
                    ctx.app.info("These are the validation results:\n" + (await writer.toString()));
                    throw new Error(message);
                }
            }
            if (report.countViolations())
                ctx.app.error(message);
            else if (report.countWarnings())
                ctx.app.warn(message, "Shacl");
            else if (report.countInfos())
                ctx.app.info(message, "Shacl");
            const graph = opts?.graph
                ? typeof opts.graph === "string"
                    ? factory.namedNode(opts.graph)
                    : opts.graph
                : ctx.app.standardGraphs.report;
            report.dataset.getQuads({}).forEach((q) => {
                const { subject, predicate, object } = q;
                ctx.store.addQuad(factory.quad(subject, predicate, object, graph));
            });
        }
        return next();
    }, { reportTouched: true, callSite, sourceFuncName: "_validate" });
}
//# sourceMappingURL=validate.js.map