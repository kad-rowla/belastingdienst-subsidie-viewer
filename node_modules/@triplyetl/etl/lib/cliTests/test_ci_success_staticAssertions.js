import { Store, parse } from "@triplydb/data-factory";
import { Destination, Etl, fromJson, toRdf } from "@triplyetl/etl/generic";
import { iri, literal, pairs, str, triple } from "@triplyetl/etl/ratt";
import { a, dcat, dct, lang, sdo, skos, xsd } from "@triplyetl/etl/vocab";
import { readFileSync } from "fs";
export default async function () {
    const etl = new Etl();
    await etl.staticAssertions(pairs(iri(etl.standardGraphs.default), [a, dcat.Dataset], [skos.prefLabel, literal(str("Family Doe"), lang.en)], [dct.created, literal(str(new Date().toISOString()), xsd.dateTime)]));
    await etl.staticAssertions(pairs(iri(etl.standardGraphs.default), [skos.prefLabel, literal(str("Familie Doe"), lang.nl)]));
    etl.use(fromJson([{ name: "John Doe" }, { name: "Jane Doe" }]), triple(iri(etl.standardPrefixes.id, "$recordId"), sdo.name, "name"), toRdf(Destination.file("data/out.nt")));
    etl.after(() => {
        const store = new Store(parse(readFileSync("data/out.nt", "utf-8")));
        if (store.getQuads({ predicate: sdo.name }).length !== 2) {
            throw new Error("wrong triple patterns");
        }
        if (store.getQuads({ predicate: skos.prefLabel }).length !== 2) {
            throw new Error("wrong triple patterns");
        }
    });
    return etl;
}
//# sourceMappingURL=test_ci_success_staticAssertions.js.map