//external dependencies
import chai from "chai";
import chaiAsPromised from "chai-as-promised";
import { toJSON as toJsonFlatted } from "flatted";
import fs from "fs-extra";
const { open, rm } = fs;
import Etl from "../generic/Etl.js";
import { mapValues } from "lodash-es";
import { Destination, fromJson } from "../generic/index.js";
import { forEach, when } from "../generic/middlewares/conditional/index.js";
import { getFactory } from "@triplydb/data-factory";
const dataFactory = getFactory();
chai.use(chaiAsPromised);
const expect = chai.expect;
const { quad } = dataFactory;
describe("Etl", function () {
    afterEach(function () {
        Etl.CliContext = undefined;
    });
    describe("Using 'use' without middlewares", async function () {
        it("With empty array", async function () {
            const app = new Etl({ defaultGraph: "https://bla" });
            app.use([]);
            await app.run();
        });
        it("Without arguments", async function () {
            const app = new Etl({ defaultGraph: "https://bla" });
            app.use();
            await app.run();
        });
    });
    it("should stop at head, even if `next` isn't called", async function () {
        Etl.CliContext = { limit: 3 };
        const app = new Etl({
            defaultGraph: "https://bla",
        });
        app.use(fromJson([{ a: "a" }, { b: "b" }, { c: "c" }, { d: "d" }]));
        app.use(async (ctx) => {
            if ("d" in ctx.record)
                throw new Error("should've stopped at head");
        });
        let postProcessed = false;
        app.after(() => {
            postProcessed = true;
        });
        await app.run();
        expect(postProcessed).to.be.true;
    });
    it("should skip the first few records with fromRecordId", async function () {
        let nRecords = 0;
        Etl.CliContext = { offset: 3 };
        const app = new Etl({
            defaultGraph: "https://bla",
        });
        app.use(fromJson([{ a: "a" }, { b: "b" }, { c: "c" }, { d: "d" }]));
        app.use(async (ctx) => {
            if ("a" in ctx.record)
                throw new Error("should've skipped a");
            if ("b" in ctx.record)
                throw new Error("should've skipped b");
            nRecords++;
        });
        await app.run();
        expect(nRecords).to.equal(2);
    });
    it("should combine fromRecordId and head", async function () {
        let nRecords = 0;
        Etl.CliContext = { offset: 3, limit: 2 };
        const app = new Etl({
            defaultGraph: "https://bla",
        });
        app.use(fromJson([{ a: "a" }, { b: "b" }, { c: "c" }, { d: "d" }, { e: "e" }]));
        app.use(async (ctx) => {
            if ("a" in ctx.record)
                throw new Error("should've skipped a");
            if ("b" in ctx.record)
                throw new Error("should've skipped b");
            if ("e" in ctx.record)
                throw new Error("should've stopped after d");
            nRecords++;
        });
        await app.run();
        expect(nRecords).to.equal(2);
    });
    it("should stop at head, not doing any work after the last record", async function () {
        Etl.CliContext = { limit: 3 };
        const app = new Etl({
            defaultGraph: "https://bla",
        });
        let didThree = false;
        let postProcessed = false;
        app.use(async (_ctx, next) => {
            await next();
            await next();
            didThree = true;
            await next();
            throw new Error("Didn't stop in time!");
        });
        app.after(() => {
            postProcessed = true;
        });
        await app.run();
        expect(postProcessed).to.be.true;
        expect(didThree).to.be.true;
    });
    describe("Using 'useWhen' without middlewares", async function () {
        it("With empty array", async function () {
            const app = new Etl({ defaultGraph: "https://bla" });
            app.useWhen(() => true, []);
            await app.run();
        });
        it("Without arguments", async function () {
            const app = new Etl({ defaultGraph: "https://bla" });
            app.useWhen(() => true);
            await app.run();
        });
    });
    it("Should have correct $parent and $root", async function () {
        const app = new Etl({ defaultGraph: "https://bla" });
        app.use(fromJson({
            name: "parent",
            children: [
                { name: "child-1" },
                { name: "child-2" },
                { name: "child-3", children: [{ name: "grandchild-1" }, { name: "grandchild-2" }, { name: "grandchild-3" }] },
            ],
        }));
        app.use(forEach("children", async (ctx, next) => {
            expect(ctx.getAny("$parent.name")).to.equal("parent");
            expect(ctx.getAny("$root.name")).to.equal("parent");
            await next();
        }, when("children", forEach("children", async (ctx) => {
            expect(ctx.getAny("$parent.name")).to.equal("child-3");
            expect(ctx.getAny("$root.name")).to.equal("parent");
        }))));
        await app.run();
    });
    describe("Should track the correct current middleware index", function () {
        function throwWhenTouched() {
            return async () => {
                throw new Error("This middleware should not be reached");
            };
        }
        const traceRecord = { num: 0 };
        it("With foreach", async function () {
            Etl.CliContext = {
                debugTrace: {
                    fromMwIndex: [2, 2, 1],
                    quadsAtStart: "<a:a> <a:a> <a:a> <a:a> .",
                    recordAtStart: toJsonFlatted(traceRecord),
                    isTraceDebug: true,
                    isTraceError: false,
                },
            };
            const app = new Etl({
                defaultGraph: "https://bla",
            });
            let touched = false;
            app.use(throwWhenTouched(), throwWhenTouched(), forEach("array", [
                throwWhenTouched(),
                when("subArray", forEach("subArray", [
                    throwWhenTouched(),
                    async (ctx, next) => {
                        touched = true;
                        expect(ctx.record.num).to.equal(0);
                        return next();
                    },
                ])),
            ]), 
            // going to a lower scope of the trace should not be possible: we dont have a record for that
            throwWhenTouched());
            await app.run();
            expect(touched).to.be.true;
        });
        it("Simple", async function () {
            Etl.CliContext = {
                debugTrace: {
                    fromMwIndex: [2],
                    quadsAtStart: "<a:a> <a:a> <a:a> <a:a> .",
                    recordAtStart: toJsonFlatted(traceRecord),
                    isTraceDebug: true,
                    isTraceError: false,
                },
            };
            const app = new Etl({
                defaultGraph: "https://bla",
            });
            let touched = false;
            app.use(throwWhenTouched(), throwWhenTouched(), async (ctx, next) => {
                touched = true;
                expect(ctx.record.num).to.equal(0);
                return next();
            });
            await app.run();
            expect(touched).to.be.true;
        });
    });
    it("Should resume correctly using a trace", async function () {
        const app = new Etl({ defaultGraph: "https://bla" });
        app.use(fromJson([
            { num: 0, array: [{ sub: 0 }, { sub: 1, subArray: [{ subsub: 0 }, { subsub: 1 }] }] },
            { num: 1, array: [{ sub: 0 }, { sub: 1 }, { sub: 2, subArray: [{ subsub: 0 }] }] },
        ]));
        function checkIndexMw(expectedIndex) {
            return async function _checkIndexMw(ctx, next) {
                expect(ctx.app["currentMwIndices"]).to.deep.equal(expectedIndex);
                return next();
            };
        }
        app.use(checkIndexMw([1]), checkIndexMw([2]), forEach("array", [
            checkIndexMw([3, 0]),
            checkIndexMw([3, 1]),
            when("subArray", forEach("subArray", [checkIndexMw([3, 3, 0]), checkIndexMw([3, 3, 1])])),
        ]), checkIndexMw([4]));
        await app.run();
    });
    it("Should correctly count the ctx.recordId when using a forEach mw", async () => {
        const jsonRecord = [
            { a: [{ b: 1 }, { b: 2 }] },
            { a: [{ b: 3 }, { b: 4 }] },
            { a: [{ b: 5 }, { b: 6 }] },
            { a: [{ b: 7 }, { b: 8 }] },
            { a: [{ b: 9 }, { b: 10 }] },
        ];
        let record = 0;
        const app = new Etl({
            defaultGraph: "",
        });
        app.use(fromJson(jsonRecord), (_, next) => next(), (_, next) => next(), forEach("a", (_, next) => next()), (ctx, next) => {
            record = ctx.recordId;
            return next();
        });
        await app.run();
        expect(record).to.equal(jsonRecord.length);
    });
    describe("After hooks", async function () {
        it("should run sequentially", async function () {
            const app = new Etl({ defaultGraph: "https://bla" });
            let hasRun = false;
            app.after(async () => {
                await new Promise((res) => setTimeout(res, 10));
                hasRun = true;
            });
            app.after(async () => {
                expect(hasRun).to.be.true;
            });
            await app.run();
        });
        it("should run destination post-processing first", async function () {
            const tmpFile = "./data/blahblah.trig";
            after(() => {
                rm(tmpFile).catch(() => { });
            });
            const app = new Etl({ defaultGraph: "https://bla" });
            const fileDest = Destination.file(tmpFile);
            app.use((ctx) => ctx.writeQuads([quad(dataFactory.namedNode("a:a"), dataFactory.namedNode("b:b"), dataFactory.namedNode("c:c"))], fileDest));
            app.after(async () => {
                await expect(open(tmpFile, "r")).to.eventually.be.fulfilled;
            });
            await app.run();
        });
        it("with `always` flag should run correctly", async function () {
            const app = new Etl({ defaultGraph: "https://bla" });
            let hasRun = false;
            app.use(async () => {
                throw new Error("An error.");
            });
            app.after(async () => {
                hasRun = true;
            }, { always: true });
            await expect(app.run()).to.eventually.be.rejectedWith("An error.");
            expect(hasRun).to.be.true;
        });
        it("should run `always` sequentially", async function () {
            const app = new Etl({ defaultGraph: "https://bla" });
            let counter = 0;
            app.after(() => {
                counter = 1;
            });
            app.after(() => {
                counter = 2;
            }, { always: true });
            await app.run();
            expect(counter).to.equal(2);
        });
    });
    describe("Timing logs", function () {
        function bigintToRoundedMs(val) {
            if (val === undefined)
                throw new Error("Expected bigint, got undefined");
            return Math.round(Number(val) / 1000000);
        }
        // @ts-ignore utility that we can use for debugging tests
        function prettyRuntimes(runtimes) {
            function bigintToPrettyMs(val) {
                if (!val)
                    return undefined;
                return bigintToRoundedMs(val).toFixed(2) + "ms";
            }
            return mapValues(runtimes, (runtime) => {
                return {
                    ...runtime,
                    timerStart: bigintToPrettyMs(runtime.timerStart),
                    runtime: bigintToPrettyMs(runtime.runtime),
                    trailingMwDuration: bigintToPrettyMs(runtime.trailingMwDuration),
                };
            });
        }
        it("Should report first and last middlewares correctly", async function () {
            const app = new Etl();
            app.use(async (_, next) => {
                for (let count = 0; count < 2; count++) {
                    await new Promise((resolve) => setTimeout(resolve, 11));
                    await next({ i: 2 });
                }
            });
            app.use(async (_, next) => next());
            app.use(async (_, next) => next());
            await app.run();
            const runtimes = app["mwRuntimesObj"];
            expect(bigintToRoundedMs(runtimes["0"].runtime)).to.be.greaterThanOrEqual(20); // at least 20 ms, we use timeouts here
            expect(bigintToRoundedMs(runtimes["2"].runtime)).to.be.lessThanOrEqual(2); // the last mw is a no-op, should not take long
        });
        it("With timeouts in several middlewares", async function () {
            const app = new Etl();
            app.use(async (_, next) => {
                await new Promise((resolve) => setTimeout(resolve, 5));
                await next();
                await new Promise((resolve) => setTimeout(resolve, 100));
                await next();
            });
            app.use(async () => {
                await new Promise((resolve) => setTimeout(resolve, 50));
            });
            await app.run();
            const runtimes = app["mwRuntimesObj"];
            expect(bigintToRoundedMs(runtimes["0"].runtime)).to.be.greaterThanOrEqual(105); // at least 105 ms, we use timeouts here
            expect(bigintToRoundedMs(runtimes["1"].runtime)).to.be.greaterThanOrEqual(100); // We're calling the last middleware twice, with 50ms timeouts eacg
        });
        it("Should report foreach middleware correctly", async function () {
            const app = new Etl();
            app.use((_, next) => {
                return next({ someArray: [{ a: 1 }, { a: 2 }] });
            });
            app.use(forEach("someArray", async (_, next) => {
                await new Promise((resolve) => setTimeout(resolve, 10));
                return next();
            }));
            app.use(async () => { });
            await app.run();
            const runtimes = app["mwRuntimesObj"];
            expect(bigintToRoundedMs(runtimes["1"].runtime)).to.be.greaterThanOrEqual(20); // A foreach child has a timeout of 10ms, and its called twice
            expect(bigintToRoundedMs(runtimes["1,0"].runtime)).to.be.greaterThanOrEqual(20); // The child itself has a timeout of 10ms, and its called twice
            expect(bigintToRoundedMs(runtimes["2"].runtime)).to.be.lessThanOrEqual(2); // no-op
            expect(bigintToRoundedMs(runtimes["0"].runtime)).to.be.lessThanOrEqual(2); // no-op
        });
    });
});
//# sourceMappingURL=Ratt.test.js.map