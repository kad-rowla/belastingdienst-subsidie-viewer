import { Etl, fromJson } from "../../generic/index.js";
import logMemory from "../logMemory.js";
import path from "path";
import fs from "fs-extra";
import { expect } from "chai";
function getLogFilePath(appId, dirPath) {
    return path.resolve(dirPath, appId + "-memory-usage.jsonl");
}
describe("logRecord destination", () => {
    const data = Array.from({ length: 10 }, () => ({ foo: "bar" }));
    const dirPath = "./tmp";
    const filesToRemove = [];
    after(async function () {
        // remove test log files
        for await (const file of filesToRemove) {
            await fs.unlink(file);
        }
    });
    it("Should work with no arguments", async function () {
        Etl.silent = true;
        const etl = new Etl();
        etl.use(fromJson(data));
        etl.use(logMemory());
        await etl.run();
        Etl.silent = false;
    });
    it("Should Write to disk at given destination", async function () {
        const etl = new Etl();
        const logFile = getLogFilePath(etl.id, dirPath);
        filesToRemove.push(logFile);
        etl.use(fromJson(data));
        etl.use(logMemory({ destination: dirPath }));
        await etl.run();
        expect(await fs.exists(logFile)).to.be.true;
        const file = fs.readFileSync(logFile).toString();
        const lines = file.split("\n").reduce((lines, line) => {
            line.length && lines.push(JSON.parse(line));
            return lines;
        }, []);
        const lastLine = lines.at(-1);
        expect(lastLine.recordId).to.equal(10);
        Object.values(lastLine).forEach((value) => expect(typeof value).to.equal("number"));
    });
    it("Should write on every N number of records", async function () {
        const etl = new Etl();
        const logFile = getLogFilePath(etl.id, dirPath);
        filesToRemove.push(logFile);
        etl.use(fromJson(data));
        etl.use(logMemory({ destination: dirPath, logOnRecord: 2 }));
        await etl.run();
        expect(await fs.exists(logFile)).to.be.true;
        const file = fs.readFileSync(logFile).toString();
        const lines = file.split("\n").reduce((lines, line) => {
            line.length && lines.push(JSON.parse(line));
            return lines;
        }, []);
        expect(lines.length).to.equal(5);
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            expect(line.recordId).to.equal((1 + i) * 2);
            Object.values(line).forEach((value) => expect(typeof value).to.equal("number"));
        }
    });
    it("Should use '.jsonl' file format", async function () {
        const etl = new Etl();
        const logFile = getLogFilePath(etl.id, dirPath);
        filesToRemove.push(logFile);
        etl.use(fromJson(data));
        etl.use(logMemory({ destination: dirPath, logOnRecord: 2 }));
        await etl.run();
        expect(await fs.exists(logFile)).to.be.true;
        expect(logFile.endsWith(".jsonl")).to.be.true;
    });
    it("Should throw when an empty string is passed as a 'destination'", async function () {
        const etl = new Etl();
        etl.use(fromJson(data));
        etl.use(logMemory({ destination: "" }));
        await expect(etl.run()).to.eventually.rejectedWith(/Empty string is not a valid argument for 'directory'/);
    });
});
//# sourceMappingURL=logMemory.test.js.map