import * as diff from "diff";
import { toJSON as toJsonFlatted } from "flatted";
import { getErr } from "../utils/Error.js";
import { addMwCallSiteToError, safeStringify } from "../utils/index.js";
// TODO @DocumentationTeam: add TS doc comment here
export default function traceEnd() {
    return addMwCallSiteToError(async function _traceEnd(ctx) {
        if (!ctx["traceInfo"]) {
            throw new Error("No trace info found. Did you call traceEnd() without calling traceStart() first?");
        }
        if (ctx["traceInfo"].recordId !== ctx.recordId) {
            throw new Error("The trace information seems to cover more than 1 record. Make sure you call traceStart and traceEnd for the same record");
        }
        if (ctx.app["currentMwIndices"].length !== ctx["traceInfo"].fromMwIndex.length) {
            throw new Error("It seems you use the 'traceStart' middleware at a different level than the 'traceEnd' middleware. This is not supported.");
        }
        throw getErr().setMessage("TraceDebug").setTraceInfo(getTraceInfo(ctx, "debug"));
    }, { sourceFuncName: "_traceEnd" });
}
export function getTraceInfo(ctx, traceType) {
    const traceProperty = traceType === "debug" ? "traceInfo" : "traceError";
    // The traceErrorInfo only exists if we run the ETL. Not all errors come from running the ETL.
    if (traceType === "error" && !ctx[traceProperty])
        return undefined;
    const recordDiff = diff.diffJson(JSON.parse(safeStringify(ctx[traceProperty].record)), JSON.parse(safeStringify(ctx.record)));
    const storeDiff = diff.diffLines(ctx[traceProperty].quads, ctx.store.toNquadsString());
    return {
        recordDiff: recordDiff,
        quadsDiff: storeDiff,
        fromMwIndex: ctx[traceProperty].fromMwIndex,
        recordAtStart: toJsonFlatted(ctx[traceProperty].record),
        quadsAtStart: ctx[traceProperty].quads,
        isTraceDebug: traceType === "debug",
        isTraceError: traceType === "error",
    };
}
//# sourceMappingURL=traceEnd.js.map