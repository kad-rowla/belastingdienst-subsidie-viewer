import * as dataFactory from "@triplydb/data-factory";
import getCurrentLine from "get-current-line";
import { Etl } from "../../generic/index.js";
import { addMwCallSiteToError, coerceToIri, getQueryStrings } from "../../utils/index.js";
import * as speedy from "@triplydb/speedy-memory";
// TODO @DocumentationTeam: add TS doc comment here
export default function sparqlConstruct(query, opts) {
    const callSite = getCurrentLine({ frames: 2 });
    return addMwCallSiteToError(async function _construct(ctx, next) {
        const engine = speedy.newEngine(ctx.store);
        const queries = await getQueryStrings(ctx, query);
        const graph = coerceToIri(opts?.toGraph === undefined ? ctx.app.defaultGraph : opts.toGraph);
        const { quad, fromTerm } = dataFactory.getFactory({ skipValidation: Etl.skipValidation });
        for (const queryString of queries) {
            let queryResult;
            try {
                queryResult = await engine.construct(queryString);
            }
            catch (e) {
                if (e instanceof Error && e.message.startsWith("Parse error")) {
                    e.message = "Failed to parse query: " + e.message;
                }
                throw e;
            }
            const quads = (await queryResult.quads()).map((q) => {
                return quad(fromTerm(q.subject), fromTerm(q.predicate), fromTerm(q.object), fromTerm(graph));
            });
            ctx.store.addQuads(quads);
            if (quads.length)
                ctx.app["markMwTouched"](callSite);
        }
        return next();
    }, { reportTouched: false, callSite, sourceFuncName: "_sparql.construct" });
}
//# sourceMappingURL=construct.js.map