import { findUpSync } from "find-up";
import dotenv from "dotenv";
import { castArray, compact, flatten, once } from "lodash-es";
import path from "path";
import fs from "fs-extra";
import crypto from "crypto";
import getCurrentLine from "get-current-line";
import { getErr } from "./Error.js";
import { v4 as uuid } from "uuid";
export { default as quadsToString } from "./quadsToString.js";
import * as TriplyIri from "@triplydb/iri";
import { Etl, Store } from "../generic/index.js";
export { default as hashify } from "./hashify.js";
import { getFactory } from "@triplydb/data-factory";
import { termToString } from "rdf-string";
const dataFactory = once(() => getFactory({ skipValidation: Etl.skipValidation }));
export function coerceToIri(val) {
    if (typeof val === "function")
        return val;
    if (typeof val === "string")
        return dataFactory().namedNode(val);
    return val;
}
export function coerceToString(val) {
    if (typeof val === "object")
        return val.value;
    return val;
}
export function validateIri(term, quad) {
    switch (term.termType) {
        case "Quad":
            validateIri(term.subject, term);
            validateIri(term.predicate, term);
            validateIri(term.object, term);
            validateIri(term.graph, term);
            break;
        case "NamedNode":
            try {
                TriplyIri.validate(term.value);
            }
            catch (error) {
                console.error(error);
                let message;
                if (quad) {
                    const quadAsString = termToString(quad).slice(2, -2);
                    message = `An invalid IRI [1] was added to the store, as part of quad [2]:
  
  [1]: ${term.value}
  [2]: ${quadAsString}`;
                }
                else {
                    message = `An invalid IRI [1] was added to the store:
  [1]: ${term.value}`;
                }
                throw getErr(error).setMessage(message);
            }
    }
}
/**
 * The stream is modified in-place
 */
export function modifyStreamError(stream, modifyError) {
    stream._emit = stream.emit;
    stream.emit = function (event, error, ...args) {
        if (event === "error" && error instanceof Error) {
            error = modifyError(error);
        }
        return stream._emit(event, error, ...args);
    };
}
/**
 * Try to find a `.env` or `.etl` file. Merge it with the process.env
 * so we can use it in the ETL itself. Latest item in the array has highest priority
 */
export function includeEtlVariablesInEnv() {
    const etlFiles = compact([
        findUpSync([".etl"]),
        findUpSync([".env"]),
        findUpSync([`.env-${Etl.environment.toLowerCase()}`]),
        findUpSync([`.etl-${Etl.environment.toLowerCase()}`]),
    ]);
    if (etlFiles.length) {
        //Make sure that latest item in the array has highest priority
        const sortedEtlFilesByPrio = etlFiles.sort((a, b) => {
            return path.dirname(a).localeCompare(path.dirname(b));
        });
        for (const etlFile of sortedEtlFilesByPrio) {
            process.env = { ...process.env, ...dotenv.parse(fs.readFileSync(etlFile)) };
        }
    }
}
/**
 *  Use all the values in an array to create an md5 hash.
 */
export function md5OfArray(array) {
    const hash = crypto.createHash("md5");
    for (const value of array) {
        hash.update(value);
    }
    return hash.digest("hex");
}
/**
 * Prevent users from adding multiple extractors to an ETL.
 * Note this is a run-time only check!
 *
 * @see https://git.triply.cc/triply/etl/-/issues/301
 */
export function assertOneExtractorPerETL(app, extractorName) {
    if (app.extractorName !== undefined) {
        throw new Error(`Extractor '${extractorName}' can not be used: a ETL allows 1 extractor which currently is '${app.extractorName}'.`);
    }
    app.extractorName = extractorName;
}
export function addMwCallSiteToError(mw, opts) {
    const callSite = opts?.callSite || getCurrentLine({ frames: 3 });
    callSite.file = path.relative(process.cwd(), callSite.file);
    const reportTouched = opts?.reportTouched !== false;
    const _mw = async (ctx, next) => {
        if (reportTouched)
            ctx.app["markMwTouched"](callSite);
        let innerError = false;
        try {
            await mw(ctx, async (...args) => {
                try {
                    await next(...args);
                }
                catch (e) {
                    innerError = true;
                    throw e;
                }
            });
        }
        catch (e) {
            const err = getErr(e);
            if (!innerError && (opts?.callSite || !err.callSite))
                err.setCallSite(callSite);
            throw err;
        }
    };
    _mw.callSite = callSite;
    _mw.sourceFuncName = opts?.sourceFuncName ? opts?.sourceFuncName : mw.name;
    return _mw;
}
export function safeStringify(record) {
    return JSON.stringify(record, cleanupJson(), 2);
}
/**
 * Avoid circular references, and avoid printing the whole store
 */
export function cleanupJson() {
    const seen = new WeakSet();
    return (_key, value) => {
        if (typeof value === "function") {
            return `${value.name}()`;
        }
        if (typeof value === "object" && value !== null) {
            if (value instanceof Store)
                return "__store__";
            if (seen.has(value)) {
                return "__circular__";
            }
            seen.add(value);
        }
        return value;
    };
}
export function removeCliArgument(cliArgs, opts) {
    const cliArgsClone = [...cliArgs]; // making a copy to avoid mutating the array. Probably superfluous, but doesnt hurt
    const fromRecordIdArgIndex = cliArgsClone.indexOf(opts.removeArg);
    if (fromRecordIdArgIndex >= 0) {
        const isPair = typeof opts.isPair === "boolean" ? opts.isPair : opts.isPair(cliArgsClone[fromRecordIdArgIndex + 1]);
        cliArgsClone.splice(fromRecordIdArgIndex, isPair ? 2 : 1); // when this is an argument pair, also remove the next argument
    }
    return cliArgsClone;
}
export function isNodejs() {
    return typeof process !== "undefined" && process.versions != null && process.versions.node != null;
}
export function getLogFilename(opts) {
    if (!opts.logDir)
        return compact([opts.filename, opts.logId]).join("-"); // e.g. `etl.log` or `.trace-1235215125612`
    // We're using a log dir. Assuming we want to make the filename unique.
    const etlScriptName = path.parse(opts.etlFile).name;
    return path.join(opts.logDir, `${etlScriptName}_${opts.logId}_${opts.filename}`); // e.g. logdir/main_13-02-22-123_etl.log
}
export async function getQueryStrings(ctx, query) {
    return flatten(await Promise.all(castArray(query).map(async (stringOrSourceGetter) => {
        if (typeof stringOrSourceGetter === "string") {
            return [stringOrSourceGetter];
        }
        else if (typeof stringOrSourceGetter === "function") {
            return castArray(stringOrSourceGetter(ctx));
        }
        else {
            const sourceInfos = await ctx["_registerSources"]([stringOrSourceGetter], "string");
            return Promise.all(sourceInfos.map((sourceInfo) => sourceInfo.getString()));
        }
    })));
}
/**
 * Utility function to add quads to a store, and track progress
 */
export function addQuadsToStore(store, quads) {
    for (const [s, p, o, graph] of quads) {
        for (const subject of s) {
            for (const predicate of p) {
                for (const object of o) {
                    store.addQuad(subject, predicate, object, graph);
                }
            }
        }
    }
}
export function iriCharacterCleaner(content) {
    return dataFactory().namedNode(
    // eslint-disable-next-line no-control-regex
    content.replace(/[ <>{}|\\^`"\u000B\b\n\t\f\r\u00A0]/g, (char) => encodeURI(char)));
}
/**
 * Creates a random MD5 style hash based on UUIDv4
 */
export function randomHash() {
    return uuid().replace(/-/g, "");
}
export function convertMwListToMiddleware(list, sourceFuncName) {
    return addMwCallSiteToError(async function (ctx, next) {
        let middlewaresToSkip = 0;
        for (let middlewares of list) {
            async function recursivelyResolve(mws) {
                if (Array.isArray(mws)) {
                    for (const mw of mws) {
                        if (middlewaresToSkip) {
                            /**
                             * if we skip inside a MiddlewareList, we are in a when/whenNot case.
                             * This number comes from the @see _whenMw, where if the when condition fails
                             * we pass in the amount of middlewares (middleware.length) we should skip.
                             * Here then we skip those middlewares 1-by-1.
                             */
                            middlewaresToSkip--;
                            continue;
                        }
                        await recursivelyResolve(mw);
                    }
                }
                else {
                    try {
                        await mws(ctx, async (record, _store, skip) => {
                            /**
                             * The skip count is used in the comes from the @see _whenMw function.
                             * if no skip is passed, we reset the skip number
                             */
                            ctx.record = { ...ctx.record, ...record };
                            middlewaresToSkip = skip ?? 0; //
                            return Promise.resolve();
                        });
                    }
                    catch (e) {
                        throw new Error(e.message);
                    }
                }
            }
            await recursivelyResolve(middlewares);
        }
        return next();
    }, { sourceFuncName, callSite: getCurrentLine({ frames: 3 }) });
}
//# sourceMappingURL=index.js.map