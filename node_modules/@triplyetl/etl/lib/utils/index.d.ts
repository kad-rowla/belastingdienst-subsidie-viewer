/// <reference types="node" resolution-mode="require"/>
import { Stream } from "stream";
import { Location } from "get-current-line";
import { SourceGetter, StringSourceInfo } from "../generic/locations/sources/index.js";
export { default as quadsToString } from "./quadsToString.js";
import { StaticString } from "../ratt/middlewares/assertions/term/str.js";
import { Context, Etl, Key, Middleware, MiddlewareList, Store } from "../generic/index.js";
import { BaseQuad, DefaultGraph, Literal, NamedNode, Term } from "@triplydb/data-factory/Terms.js";
export { default as hashify } from "./hashify.js";
export type NamedNodeCompatibleType = string | NamedNode;
export type PossibleIri = (<L extends string>(local: L) => NamedNode<string>) | NamedNode | StaticString | Key;
export declare function coerceToIri(val: NamedNodeCompatibleType): NamedNode<string>;
export declare function coerceToString(val: NamedNodeCompatibleType): string;
export declare function validateIri(term: Term, quad?: BaseQuad): void;
/**
 * The stream is modified in-place
 */
export declare function modifyStreamError(stream: Stream, modifyError: (error: Error) => Error): void;
/**
 * Try to find a `.env` or `.etl` file. Merge it with the process.env
 * so we can use it in the ETL itself. Latest item in the array has highest priority
 */
export declare function includeEtlVariablesInEnv(): void;
/**
 *  Use all the values in an array to create an md5 hash.
 */
export declare function md5OfArray(array: string[]): string;
/**
 * Prevent users from adding multiple extractors to an ETL.
 * Note this is a run-time only check!
 *
 * @see https://git.triply.cc/triply/etl/-/issues/301
 */
export declare function assertOneExtractorPerETL(app: Etl, extractorName: string): void;
export declare function addMwCallSiteToError<R = unknown>(mw: Middleware<R>, opts?: {
    /**
     * By default we're reporting this middleware as touched. If you want to control this yourself,
     * then set this value to false
     */
    reportTouched?: boolean;
    /**
     * We're storing the callsites by reference. I.e., to be able track the touched status,
     * we want to use 1 callsite object. That means when tracking the touched status externa to this function,
     * we want to use one and the same callsite reference
     */
    callSite?: Location;
    /**
     * Pass in the name of the function you are wrapping.
     * This is used for correctly identifying middlewares in the log file.
     */
    sourceFuncName: Middleware["name"];
}): Middleware<R>;
export declare function safeStringify(record?: Object): string;
/**
 * Avoid circular references, and avoid printing the whole store
 */
export declare function cleanupJson(): (_key: string, value: any) => any;
export declare function removeCliArgument(cliArgs: Array<string>, opts: {
    removeArg: string;
    isPair: boolean | ((nextArg: string | undefined) => boolean);
}): Array<string>;
export declare function isNodejs(): boolean;
export declare function getLogFilename(opts: {
    etlFile: string;
    filename: string;
    logDir: string | undefined;
    logId: string | undefined;
}): string;
export declare function getQueryStrings(ctx: Context, query: string | ((ctx: Context) => string | string[]) | SourceGetter<"string", StringSourceInfo> | Array<string | ((ctx: Context) => string | string[]) | SourceGetter<"string", StringSourceInfo>>): Promise<Array<string>>;
type Quad = [
    Array<NamedNode>,
    Array<NamedNode>,
    Array<NamedNode | Literal>,
    // object
    NamedNode | DefaultGraph
];
/**
 * Utility function to add quads to a store, and track progress
 */
export declare function addQuadsToStore(store: Store, quads: Quad[]): void;
export declare function iriCharacterCleaner(content: string): NamedNode<string>;
/**
 * Creates a random MD5 style hash based on UUIDv4
 */
export declare function randomHash(): string;
export declare function convertMwListToMiddleware(list: MiddlewareList, sourceFuncName: string): Middleware;
//# sourceMappingURL=index.d.ts.map