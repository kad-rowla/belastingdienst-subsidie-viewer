import { AssertionError } from "assert";
import { has, isEmpty, isEmpty as lodashIsEmpty, isPlainObject } from "lodash-es";
import chalk from "chalk";
import { isJPath } from "../ratt/middlewares/assertions/term/jpath.js";
import jp from "jsonpath";
//see https://stackoverflow.com/questions/61462867/missing-flow-in-type-narrowing-with-unknown-datatype-in-typescript
function toUnion(_x) { }
function assertTermIs(term, termType) {
    toUnion(term);
    const label = termType === "NamedNode" ? `an IRI` : `a ${termType}`;
    if (!term || typeof term !== "object")
        throw new AssertionError({ message: `Expected ${label}, but received ${term}` });
    if (!("termType" in term)) {
        throw new AssertionError({ message: `Expected ${label}, but we're missing a term type` });
    }
    if (term.termType !== termType) {
        throw new AssertionError({ message: `Expected ${label}, but received termtype ${term.termType}` });
    }
}
export const isEnvironment = (value) => typeof value === "string" && ["Development", "Testing", "Acceptance", "Production"].includes(value);
export function assertEnvironment(value) {
    if (!isEnvironment(value)) {
        throw new Error(`The environment is currently '${value}', but it can only be 'Development', 'Testing', 'Acceptance' or 'Production.
${chalk.cyan(`Here are some things you can try:
- create a file '.env' and make sure it hase a line 'ENV=Development' (or another valid environment)
- on Linux/Max/Unix systems, type 'export ENV=Development' (or another valid environment)
- run your ETL like this 'ENV=Development npx etl <lib/main.js>'
- contact Triply support (support@triply.cc)`)}`);
    }
}
export function assertHasToken(value) {
    if (value === undefined || typeof value !== "string")
        throw new Error(`Missing a TriplyDb Token.
${chalk.cyan(`Here are some things you can try:
- look at https://triply.cc/docs/triply-api#creating-an-api-token
- Run \`npx etl --help\` for more information on how to pass your TriplyDB credentials.
- generate a token using \`npx tool create-token\`
- contact Triply support (support@triply.cc)`)}
`);
}
export function isLiteral(term) {
    toUnion(term);
    return !!term && typeof term === "object" && "termType" in term && term.termType === "Literal";
}
export const isIri = (obj) => {
    return isNamedNode(obj) && Object.hasOwn(obj, "$IriClass");
};
export function isNamedNode(term) {
    toUnion(term);
    return !!term && typeof term === "object" && "termType" in term && term.termType === "NamedNode";
}
export function isBlankNode(term) {
    toUnion(term);
    return !!term && typeof term === "object" && "termType" in term && term.termType === "BlankNode";
}
export function isArray(val) {
    return Array.isArray(val);
}
export function isString(val) {
    return typeof val === "string";
}
export function isNumber(val) {
    return typeof val === "number";
}
export function isTable(val) {
    if (typeof val !== "object" || !isPlainObject(val) || val === null)
        return false;
    for (const key of Object.keys(val)) {
        if (typeof key !== "string")
            return false;
    }
    return true;
}
export function assertTable(val) {
    if (!isTable(val))
        throw new AssertionError({ message: `Expected a key => value table object` });
}
export function assertLiteral(term) {
    assertTermIs(term, "Literal");
}
export function assertNamedNode(term) {
    assertTermIs(term, "NamedNode");
}
export function assertBnode(term) {
    assertTermIs(term, "BlankNode");
}
export function assertIsDefined(val, msg) {
    if (val === undefined || val === null) {
        throw new AssertionError({ message: msg, expected: "defined", actual: val });
    }
}
export function assertIsObject(val, msg) {
    if (typeof val !== "object") {
        throw new AssertionError({ message: msg, expected: "object", actual: val });
    }
}
export class NullableOrEmptyString extends Error {
}
/**
 * Slightly different than assertIsDefined. It'll throw a different error in order for us to catch it properly.
 * It also checks for empty strings
 */
export function assertIsNotNullableOrEmptyString(val) {
    if (val === undefined || val === null) {
        throw new NullableOrEmptyString(`Expected value to be set. Instead, got value ${val}`);
    }
    else if (typeof val === "string" && val.trim().length === 0) {
        throw new NullableOrEmptyString(`Expected value to be set. Instead, got an empty string`);
    }
}
export function assertIsArray(val, msg) {
    if (val === undefined || val === null) {
        throw new NullableOrEmptyString(msg);
    }
    if (!Array.isArray(val)) {
        throw new AssertionError({ message: msg, expected: "array", actual: val });
    }
}
export function assertIsNonEmptyArray(val, msg) {
    assertIsArray(val, msg);
    if (val.length === 0)
        throw new NullableOrEmptyString(msg);
}
export function assertIsString(val, msg) {
    if (typeof val !== "string") {
        throw new AssertionError({ message: msg, expected: "string", actual: val });
    }
}
export function assertIsNonEmptyString(val, msg) {
    if (typeof val !== "string" || val.trim().length === 0) {
        throw new AssertionError({ message: msg, expected: "non-empty-string", actual: val });
    }
}
export function assertIsNumber(val, msg) {
    if (typeof val !== "number") {
        throw new AssertionError({ message: msg, expected: "number", actual: val });
    }
}
export function assertIsBoolean(val, msg) {
    if (typeof val !== "boolean") {
        throw new AssertionError({ message: msg, expected: "boolean", actual: val });
    }
}
/**
 * Find out whether something is considered empty and if so, why.
 *
 * Values considered empty are:
 * - Empty strings, or strings with only whitespace
 * - Empty arrays
 * - Empty objects
 * - undefined and null values
 */
export function getReasonWhysomethingIsEmpty(val, key) {
    let isEmpty = false;
    const keyMessage = key !== undefined ? `Key '${key}' has` : "Has";
    let reason = `${keyMessage} an empty value of type '${typeof val}'`;
    if (val === undefined)
        isEmpty = true;
    else if (val === null) {
        isEmpty = true;
        reason = `${keyMessage} an empty value of type 'null'`;
    }
    else if (typeof val === "string" && val.trim().length === 0)
        isEmpty = true;
    else if (Array.isArray(val) && lodashIsEmpty(val)) {
        reason = `${keyMessage} an empty value of type 'array'`;
        isEmpty = true;
    }
    else if (typeof val === "object" && lodashIsEmpty(val))
        isEmpty = true;
    if (isEmpty)
        return reason;
}
export function assertIsNotEmpty(val, key) {
    const reason = getReasonWhysomethingIsEmpty(val, key);
    if (reason)
        throw new AssertionError({ message: reason, expected: "value not to be empty", actual: val });
}
export function assertKeyExists(object, keyOrExpression) {
    const hasValue = isJPath(keyOrExpression)
        ? jp.query(object, keyOrExpression.toString()).length > 0
        : has(object, keyOrExpression);
    if (!isEmpty(keyOrExpression) && !hasValue) {
        throw new AssertionError({
            message: `Object does not have key '${keyOrExpression}'`,
            expected: `key '${keyOrExpression}' to exists`,
            actual: `key '${keyOrExpression}' does not exists`,
        });
    }
}
export function isDeeplyEmpty(val) {
    if (typeof val === "object") {
        if (val === null)
            return true;
        if (Array.isArray(val)) {
            return val.every(isDeeplyEmpty);
        }
        else {
            return isDeeplyEmpty(Object.values(val));
        }
    }
    else {
        return !!getReasonWhysomethingIsEmpty(val);
    }
}
export function assertIs(value, key, type) {
    const errMsg = `Assertion failed. Expected '${key}' to be '${type}'. Got '${typeof value}'.`;
    if (typeof type === "object") {
        const elementType = type.array;
        if (!Array.isArray(value))
            return;
        return value.map((v) => assertIs(v, key, elementType));
    }
    else {
        switch (type) {
            case "string":
                return assertIsString(value, errMsg);
            case "number":
                return assertIsNumber(value, errMsg);
            case "boolean":
                return assertIsBoolean(value, errMsg);
            case "literal":
                return assertLiteral(value);
            case "iri":
                return assertNamedNode(value);
            case "blankNode":
                return assertBnode(value);
            case "table":
                return assertTable(value);
            case "unknown":
                // Needed for type narrowing, but we don't need to do anything here.
                return;
            case "any":
                // Needed for type narrowing, but we don't need to do anything here.
                return;
        }
    }
    throw Error("This should really never happen. Please contact a developer. Assertion");
}
export function isSourceGetterArray(source) {
    return (source.length > 0 && typeof source[0] === "object" && "get" in source[0] && typeof source[0].get === "function");
}
export function isSourceGetter(source) {
    return typeof source === "object" && "get" in source && typeof source.get === "function";
}
//# sourceMappingURL=asserts.js.map