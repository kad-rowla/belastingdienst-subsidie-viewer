import { TriplyDbJsError } from "@triply/triplydb/utils/Error.js";
import path from "path";
export class EtlError extends Error {
    constructor(e) {
        super(e?.message);
        this.stoppedAtHead = false;
        this.timedout = false;
        if (e)
            this.setRootCause(e);
    }
    setMessage(msg) {
        this.message = msg;
        return this;
    }
    setRecord(record) {
        this.record = record;
        return this;
    }
    setRootCause(e) {
        this.rootCause = e;
        return this;
    }
    setTraceInfo(traceInfo) {
        this.trace = traceInfo;
        return this;
    }
    setRecordId(recordId) {
        this.recordId = recordId;
        return this;
    }
    setStoppedAtHead() {
        this.stoppedAtHead = true;
        return this;
    }
    setTimedout() {
        this.timedout = true;
        return this;
    }
    getTriplyDbJsErrorInfo() {
        if (this.rootCause instanceof TriplyDbJsError) {
            return { statusCode: this.rootCause.statusCode, context: this.rootCause.context };
        }
    }
    setCallSite(callSite) {
        this.callSite = callSite;
        if (this.callSite?.file) {
            this.callSite.file = path.relative(process.cwd(), this.callSite.file);
        }
        return this;
    }
    getErrForStacktrace() {
        // When printing this error, use the one at the lowest level to avoid stacktraces
        // where we recreate an error object and then rethrow
        return this.rootCause || this;
    }
}
export function getErr(e) {
    if (e && e instanceof EtlError) {
        return e;
    }
    const err = new EtlError(e);
    // CaptureStackTrace is node-specific, so lets check if the function exists
    Error.captureStackTrace?.(err, getErr);
    return err;
}
//# sourceMappingURL=Error.js.map