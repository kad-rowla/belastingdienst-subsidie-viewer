import { getErr } from "@triply/triplydb/utils/Error.js";
import { assertIsArray, assertIsDefined, assertIsString, isBlankNode, isNamedNode, isLiteral, isTable, } from "./asserts.js";
import { isArray, once } from "lodash-es";
import { coerceLiteral } from "../ratt/middlewares/assertions/statement/rdf/utils/coerceLiteral.js";
import { getFactory } from "@triplydb/data-factory";
import Etl from "../generic/Etl.js";
const dataFactory = once(() => getFactory({ skipValidation: Etl.skipValidation }));
function throwCoercionError(value, key, type) {
    let objectType;
    if (Array.isArray(value))
        objectType = "array";
    else if (isLiteral(value))
        objectType = "literal";
    else if (isNamedNode(value))
        objectType = "iri";
    else if (isBlankNode(value))
        objectType = "blankNode";
    else
        objectType = typeof value;
    throw getErr(`Could not coerce '${value}' of type '${objectType}' from key '${key}' to the desired type '${type}'`);
}
function ifPossibleCoerceToString(value, key) {
    if (typeof value === "string") {
        return value;
    }
    else if (typeof value === "number") {
        return value + "";
    }
    else if (typeof value === "boolean") {
        return `${value}`;
    }
    else if (isLiteral(value)) {
        return `${value.value}`;
    }
    else if (isNamedNode(value)) {
        throwCoercionError(value, key, "string");
    }
    else if (isBlankNode(value)) {
        throwCoercionError(value, key, "string");
    }
    else {
        throwCoercionError(value, key, "string");
    }
}
function ifPossibleCoerceToNumber(value, key) {
    if (typeof value === "number") {
        return value;
    }
    else if (typeof value === "string") {
        const anyNonDigit = /\D/g;
        if (!anyNonDigit.test(value))
            return Number(value);
        else {
            throwCoercionError(value, key, "number");
        }
    }
    else if (isLiteral(value)) {
        return ifPossibleCoerceToNumber(value.value, key);
    }
    else {
        throwCoercionError(value, key, "number");
    }
}
function ifPossibleCoerceToBoolean(value, key) {
    if (typeof value === "boolean") {
        return value;
    }
    else if (typeof value === "string") {
        const regExTrue = /^(true|1)$/i;
        const regExFalse = /^(false|0)$/i;
        if (regExTrue.test(value))
            return true;
        else if (regExFalse.test(value))
            return false;
        else {
            throwCoercionError(value, key, "boolean");
        }
    }
    else if (typeof value === "number") {
        if (value === 0 || value === 1) {
            return !!value;
        }
        else {
            throwCoercionError(value, key, "boolean");
        }
    }
    else if (isLiteral(value)) {
        return ifPossibleCoerceToBoolean(value.value, key);
    }
    else {
        throwCoercionError(value, key, "boolean");
    }
}
function ifPossibleCoerceToLiteral(value, key, languageTagOrDataType) {
    if (isLiteral(value)) {
        if (languageTagOrDataType)
            return unknownValToLiteral(value.value, key, languageTagOrDataType);
        return value;
    }
    else if (typeof value === "string") {
        return unknownValToLiteral(value, key, languageTagOrDataType);
    }
    else if (typeof value === "number") {
        return unknownValToLiteral(String(value), key, languageTagOrDataType);
    }
    else if (typeof value === "boolean") {
        return unknownValToLiteral(value.toString(), key, languageTagOrDataType);
    }
    else {
        throwCoercionError(value, key, "literal");
    }
}
function ifPossibleCoerceToIri(value, key) {
    if (isNamedNode(value)) {
        return value;
    }
    else if (typeof value === "string") {
        return unknownValToIri(value);
    }
    else {
        throwCoercionError(value, key, "iri");
    }
}
function ifPossibleCoerceToBlankNode(value, key) {
    if (isBlankNode(value)) {
        return value;
    }
    else if (typeof value === "string") {
        return dataFactory().blankNode(value);
    }
    else {
        throwCoercionError(value, key, "blankNode");
    }
}
function ifPossibleCoerceToTable(value, key) {
    if (isTable(value)) {
        return value;
    }
    else {
        throwCoercionError(value, key, "table");
    }
}
export function ifPossibleCoerce(value, key, type, languageTagOrDataType) {
    if (typeof type === "object") {
        const elementType = type.array;
        assertIsArray(value, `Expected key '${key}' to reference an array value. Got '${typeof value}'`);
        return value.map((v) => ifPossibleCoerce(v, key, elementType));
    }
    else {
        switch (type) {
            case "string":
                return ifPossibleCoerceToString(value, key);
            case "number":
                return ifPossibleCoerceToNumber(value, key);
            case "boolean":
                return ifPossibleCoerceToBoolean(value, key);
            case "literal":
                return ifPossibleCoerceToLiteral(value, key, languageTagOrDataType);
            case "iri":
                return ifPossibleCoerceToIri(value, key);
            case "blankNode":
                return ifPossibleCoerceToBlankNode(value, key);
            case "table":
                return ifPossibleCoerceToTable(value, key);
            case "unknown":
                return value;
            case "any":
                return value;
        }
    }
    throw Error("This should really never happen. Please contact a developer.");
}
export function unknownValToIri(val, keyLabel, opts) {
    assertIsDefined(val, "undefined value can not be used to coerce an Iri");
    if (isNamedNode(val)) {
        return val;
    }
    // We want to support passing numbers when creating IRI. This is a typical usecase, e.g. when using numerical identifier as local-name
    if (typeof val === "number")
        val = val.toString();
    // The type can still be anything other than a string (e.g. an object, array or whatever)
    assertIsString(val, `Cannot create IRI: ${keyLabel
        ? `Expected key '${keyLabel}' to reference a string or a number.`
        : "Expected value to be a string or a number."} Instead, got value of type ${isArray(val) ? "array" : typeof val}.`);
    return opts?.prefix ? opts.prefix.concat(val) : dataFactory().namedNode(val);
}
export function unknownValToLiteral(val, keyLabel, datatypeOrLanguageTag) {
    return coerceLiteral(val, datatypeOrLanguageTag, keyLabel);
}
//# sourceMappingURL=coercions.js.map