// async-saxophone test roughly changed to a mocha supported version, seem to take longer than 2 sec - will skip for now.
import { makeAsyncXMLParser } from "../Saxophone.js";
import { assert, expect } from "chai";
function delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
const allNodes = `
<?xml version="1.0" encoding="UTF-8"?>
<!-- this is a comment -->
<title>XML Test File</title>
<selfclose />
<cdata-section><![CDATA[this is a c&data s<>ction]]></cdata-section>
<empty></empty>
<hasattrs first="one" second="two"  third="three " />
<textarea> this\nis\na\r\n\ttextual\ncontent  </textarea>
<other attr="value"></other>`;
const openAndClose = "<full></full><selfclose />";
/**
 * Verify that an XML text is parsed as the specified stream of events.
 *
 * @param assert Assertion function.
 * @param xml XML string or array of XML chunks.
 * @param events Sequence of events that must be emitted in order.
 */
const expectEvents = async (xml, events, options) => {
    if (!Array.isArray(xml)) {
        // By default, split data in chunks of size 10
        const chunks = [];
        for (let i = 0; i < xml.length; i += 10) {
            chunks.push(xml.slice(i, i + 10));
        }
        xml = chunks;
    }
    const parser = makeAsyncXMLParser(options)(xml);
    const results = [];
    for await (let node of parser) {
        results.push(node);
    }
    assert.deepEqual(results, events, "parsed data should be as expected");
};
describe("Async Saxophone tests", function () {
    it("should parse comments", async () => expectEvents("<!-- this is a comment -->", [["comment", " this is a comment "]]));
    it("should parse comments between two chunks", async () => expectEvents(["<", "!", "-", "-", " this is a comment -->"], [["comment", " this is a comment "]]));
    it("should not parse unclosed comments", async () => {
        await expect(expectEvents("<!-- this is a comment ->")).to.eventually.be.rejectedWith("Unclosed comment");
    });
    it("should not parse invalid comments", async () => {
        await expect(expectEvents("<!-- this is an -- invalid comment ->")).to.eventually.be.rejectedWith("Unexpected -- inside comment");
    });
    it("should parse CDATA sections", async () => expectEvents("<![CDATA[this is a c&data s<>ction]]>", [["cdata", "this is a c&data s<>ction"]]));
    it("should parse CDATA sections between two chunks", async () => expectEvents(["<", "!", "[", "C", "D", "A", "T", "A", "[", "contents]]>"], [["cdata", "contents"]]));
    it("should not parse invalid CDATA sections", async () => {
        await expect(expectEvents(["<![CDAthis is NOT a c&data s<>ction]]>"])).to.eventually.be.rejectedWith("Unrecognized sequence: <![");
    });
    it("should not parse unclosed CDATA sections", async () => {
        await expect(expectEvents(["<![CDATA[this is a c&data s<>ction]>"])).to.eventually.be.rejectedWith("Unclosed CDATA section");
    });
    it("should parse processing instructions", async () => expectEvents('<?xml version="1.0" encoding="UTF-8" ?>', [
        ["processinginstruction", 'xml version="1.0" encoding="UTF-8" '],
    ]));
    it("should not parse unclosed processing instructions", async () => {
        await expect(expectEvents('<?xml version="1.0" encoding="UTF-8">')).to.eventually.be.rejectedWith("Unclosed processing instruction");
    });
    it("should parse simple tags", async () => expectEvents("<tag></tag>", [
        ["tagopen", "tag", "", ""],
        ["tagclose", "tag"],
    ]));
    it("should not parse unclosed opening tags", async () => {
        await expect(expectEvents("<tag")).to.eventually.be.rejectedWith("Unclosed tag");
    });
    it("should not parse unclosed tags 2", async () => {
        await expect(expectEvents("<tag>")).to.eventually.be.rejectedWith("Unclosed tags: tag");
    });
    it("should not parse unclosed tags 3", async () => {
        await expect(expectEvents("<closed><unclosed></closed>")).to.eventually.be.rejectedWith("Unclosed tag: unclosed");
    });
    it("should not parse DOCTYPEs", async () => {
        await expect(expectEvents("<!DOCTYPE html>")).to.eventually.be.rejectedWith("Unrecognized sequence: <!D");
    });
    it("should not parse invalid tags", async () => {
        await expect(expectEvents("< invalid>")).to.eventually.be.rejectedWith("Tag names may not start with whitespace");
    });
    it("should parse self-closing tags", async () => expectEvents("<test />", [["tagopen", "test", "", "/"]]));
    it("should parse closing tags", async () => expectEvents("<closed></closed>", [
        ["tagopen", "closed", "", ""],
        ["tagclose", "closed"],
    ]));
    it("should not parse unclosed closing tags", async () => {
        await expect(expectEvents("</closed")).to.eventually.be.rejectedWith("Unclosed tag");
    });
    it("should parse tags containing attributes", async () => expectEvents('<tag first="one" second="two"  third="three " /><other attr="value"></other>', [
        ["tagopen", "tag", 'first="one" second="two"  third="three "', "/"],
        ["tagopen", "other", 'attr="value"', ""],
        ["tagclose", "other"],
    ]));
    it("should parse text nodes", async () => expectEvents("<textarea> this\nis\na\r\n\ttextual\ncontent  </textarea>", [
        ["tagopen", "textarea", "", ""],
        ["text", " this\nis\na\r\n\ttextual\ncontent  "],
        ["tagclose", "textarea"],
    ]));
    it("should parse text nodes outside of the root element", async () => expectEvents("before<root>inside</root>after", [
        ["text", "before"],
        ["tagopen", "root", "", ""],
        ["text", "inside"],
        ["tagclose", "root"],
        ["text", "after"],
    ]));
    it("should allow selecting only open tags", async () => expectEvents(allNodes, [
        ["tagopen", "title", "", ""],
        ["tagopen", "selfclose", "", "/"],
        ["tagopen", "cdata-section", "", ""],
        ["tagopen", "empty", "", ""],
        ["tagopen", "hasattrs", 'first="one" second="two"  third="three "', "/"],
        ["tagopen", "textarea", "", ""],
        ["tagopen", "other", 'attr="value"', ""],
    ], { include: "tagopen" }));
    it("should allow selecting only closing tags", async () => expectEvents(allNodes, [
        ["tagclose", "title"],
        ["tagclose", "cdata-section"],
        ["tagclose", "empty"],
        ["tagclose", "textarea"],
        ["tagclose", "other"],
    ], { include: "tagclose" }));
    it("should allow selecting only opening and closing tags and text", async () => expectEvents(allNodes, [
        ["tagopen", "title", "", ""],
        ["text", "XML Test File"],
        ["tagclose", "title"],
        ["tagopen", "selfclose", "", "/"],
        ["tagopen", "cdata-section", "", ""],
        ["tagclose", "cdata-section"],
        ["tagopen", "empty", "", ""],
        ["tagclose", "empty"],
        ["tagopen", "hasattrs", 'first="one" second="two"  third="three "', "/"],
        ["tagopen", "textarea", "", ""],
        ["text", " this\nis\na\r\n\ttextual\ncontent  "],
        ["tagclose", "textarea"],
        ["tagopen", "other", 'attr="value"', ""],
        ["tagclose", "other"],
    ], { include: ["tagopen", "tagclose", "text"], noEmptyText: true }));
    it("should allow selecting only comments", async () => expectEvents(allNodes, [["comment", " this is a comment "]], { include: "comment" }));
    it("should allow selecting only cdata", async () => expectEvents(allNodes, [["cdata", "this is a c&data s<>ction"]], { include: "cdata" }));
    it("should allow selecting only processing instructions", async () => expectEvents(allNodes, [["processinginstruction", 'xml version="1.0" encoding="UTF-8"']], {
        include: "processinginstruction",
    }));
    it("should allow outputting tagclose for self-closing tags", async () => expectEvents(openAndClose, [
        ["tagopen", "full", "", ""],
        ["tagclose", "full"],
        ["tagopen", "selfclose", "", "/"],
        ["tagclose", "selfclose"],
    ], { alwaysTagClose: true }));
    it("should not add a tagclose for self-closing tags if no closeTagOnSelfClose option", async () => expectEvents(openAndClose, [
        ["tagopen", "full", "", ""],
        ["tagclose", "full"],
        ["tagopen", "selfclose", "", "/"],
    ], { alwaysTagClose: false }));
    it("should include text that is only whitespace by default", async () => expectEvents(`<full>something</full>
        <selfclose />`, [
        ["tagopen", "full", "", ""],
        ["text", "something"],
        ["tagclose", "full"],
        ["text", "\n        "],
        ["tagopen", "selfclose", "", "/"],
    ]));
    it("should allow filtering out whitespace text", async () => expectEvents(`<full>something</full>
        <selfclose />`, [
        ["tagopen", "full", "", ""],
        ["text", "something"],
        ["tagclose", "full"],
        ["tagopen", "selfclose", "", "/"],
    ], { noEmptyText: true }));
    it("inputs should wait on outputs and outputs wait on inputs", () => {
        async function* genxml() {
            yield `<a ${Date.now()} />`;
            await delay(500);
            yield `<b ${Date.now()} />`;
        }
        async function main() {
            const parser = makeAsyncXMLParser();
            let prev = 0;
            for await (let node of parser(genxml())) {
                if (prev) {
                    // expect at least 500 ms input and 500 ms output delay
                    assert(node[2] >= prev + 1000);
                }
                else {
                    prev = node[2];
                }
                await delay(500);
            }
        }
        main().then(assert).catch(assert);
    });
    it("should accept a string as input", (assert) => {
        async function main() {
            const parser = makeAsyncXMLParser();
            let accum = [];
            for await (let node of parser("<a />")) {
                accum.push(node);
            }
            expect(accum).to.deep.equal([["tagopen", "a", "", "/"]]);
        }
        main().then(assert).catch(assert);
    });
    it("should fail if a generator is used as an iterator without calling it first", () => {
        async function main() {
            async function* gen() {
                yield "<a";
                yield " />";
            }
            const parser = makeAsyncXMLParser();
            let accum = [];
            try {
                for await (let node of parser(gen)) {
                    accum.push(node);
                }
            }
            catch (e) {
                expect(e.toString()).equal("TypeError: sourceIterator is not async iterable");
            }
        }
        main().then(assert).catch(assert);
    });
    it("should take input from a generator", () => {
        async function main() {
            async function* gen() {
                yield "<a";
                yield " />";
            }
            const parser = makeAsyncXMLParser();
            let accum = [];
            for await (let node of parser(gen())) {
                // note `gen()`, rather than `gen` in the error test above
                accum.push(node);
            }
            expect(accum).to.deep.equal([["tagopen", "a", "", "/"]]);
        }
        main().then(assert).catch(assert);
    });
    it("should err on unclosed CDATA", async () => {
        await expect(expectEvents("<cdata-section><![CDATA[this is a c&data s<>ction")).to.eventually.be.rejectedWith(/Unclosed CDATA section/);
    });
    it("should err on unclosed comment", async () => {
        await expect(expectEvents("<!-- this is an unclosed comment")).to.eventually.be.rejectedWith(/Unclosed comment/);
    });
    it("should err on unclosed processing instruction", async () => {
        await expect(expectEvents('<?xml version="1.0" encoding="UTF-8"?')).to.eventually.be.rejectedWith(/Unclosed processing instruction/);
    });
    it("should err on unclosed tag", async () => {
        await expect(expectEvents('<xml version="1.0" encoding="UTF-8"')).to.eventually.be.rejectedWith(/Unclosed tag/);
    });
    it("should err on unclosed tag", async () => {
        await expect(expectEvents("<a><b></b>")).to.eventually.be.rejectedWith(/Unclosed tag/);
    });
    it("should parse text at end of the XML", async () => expectEvents("<test />Extra text", [
        ["tagopen", "test", "", "/"],
        ["text", "Extra text"],
    ]));
});
//# sourceMappingURL=Saxophone.test.js.map