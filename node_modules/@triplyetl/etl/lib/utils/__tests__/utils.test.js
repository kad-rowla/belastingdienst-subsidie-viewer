import { expect } from "chai";
import { getFactory } from "@triplydb/data-factory";
import { convertMwListToMiddleware, validateIri } from "../index.js";
import { when, Etl, ifElse, _switch, fromJson, fromCsv, Source, loadRecords, } from "../../generic/index.js";
import { addValue, triple } from "../../ratt/index.js";
import { a } from "@triplyetl/vocabularies";
const dataFactory = getFactory();
describe("validateIri", function () {
    it("should not throw on valid IRIs", function () {
        validateIri(dataFactory.namedNode("urn:li:person:123"));
        validateIri(dataFactory.namedNode("https://hallo.com"));
        validateIri(dataFactory.namedNode("ssh://hallo.com"));
        validateIri(dataFactory.namedNode("http://hallo.com"));
    });
    it("Should throw, ratt issue #82 - invalid Iri", function () {
        expect(() => {
            validateIri(dataFactory.namedNode("â€¢http://ex.com"));
        }).to.throw();
    });
});
describe("convertMwListToMiddleware", function () {
    const getWhenMwList = (trueOrFalse) => [
        when((_) => trueOrFalse, triple(a, a, a)),
        addValue({ key: "newKey", content: "added" }),
    ];
    it("Should respect 'when' middleware conditions, when false", async function () {
        const etlSkipTriple = new Etl();
        etlSkipTriple.use(convertMwListToMiddleware(getWhenMwList(false), "SkipWhenMwList"));
        etlSkipTriple.use((ctx, next) => {
            expect(ctx.getAny("newKey")).to.equal("added");
            expect(ctx.store.size).to.equal(0);
            return next();
        });
        await etlSkipTriple.run();
    });
    it("Should respect 'when' middleware conditions, when true", async function () {
        const etlAddTriple = new Etl();
        etlAddTriple.use(convertMwListToMiddleware(getWhenMwList(true), "AddWhenMwList"));
        etlAddTriple.use((ctx, next) => {
            expect(ctx.getAny("newKey")).to.equal("added");
            expect(ctx.store.size).to.equal(1);
            return next();
        });
        await etlAddTriple.run();
    });
    it("Should respect 'when' middleware conditions in an ifElse, when false", async function () {
        const etlSkipTriple = new Etl();
        etlSkipTriple.use(ifElse({ if: (_) => true, then: getWhenMwList(false) }));
        etlSkipTriple.use((ctx, next) => {
            expect(ctx.getAny("newKey")).to.equal("added");
            expect(ctx.store.size).to.equal(0);
            return next();
        });
        await etlSkipTriple.run();
    });
    it("Should respect 'when' middleware conditions in an ifElse, when true", async function () {
        const etlAddTriple = new Etl();
        etlAddTriple.use(ifElse({
            if: (_) => true,
            then: getWhenMwList(true),
        }));
        etlAddTriple.use((ctx, next) => {
            expect(ctx.getAny("newKey")).to.equal("added");
            expect(ctx.store.size).to.equal(1);
            return next();
        });
        await etlAddTriple.run();
    });
    it("Should respect 'when' middleware conditions in an 'switch', when false", async function () {
        const etlSkipTriple = new Etl();
        etlSkipTriple.use(fromJson([{ foo: "bar" }]), _switch("foo", ["bar", getWhenMwList(false)]));
        etlSkipTriple.use((ctx, next) => {
            expect(ctx.getAny("newKey")).to.equal("added");
            expect(ctx.store.size).to.equal(0);
            return next();
        });
        await etlSkipTriple.run();
    });
    it("Should respect 'when' middleware conditions in an 'switch', when true", async function () {
        const etlAddTriple = new Etl();
        etlAddTriple.use(fromJson([{ foo: "bar" }]), _switch("foo", ["bar", getWhenMwList(true)]));
        etlAddTriple.use((ctx, next) => {
            expect(ctx.getAny("newKey")).to.equal("added");
            expect(ctx.store.size).to.equal(1);
            return next();
        });
        await etlAddTriple.run();
    });
});
describe("One extractor per ETL", () => {
    it("should fail on 2 extractors of the same type", async () => {
        const app = new Etl();
        app.use(fromJson({ a: 1 }), fromJson({ a: 2 }));
        await expect(app.run()).to.eventually.be.rejectedWith("Extractor 'fromJson' can not be used: a ETL allows 1 extractor which currently is 'fromJson'.");
    });
    it("should fail on 2 extractors of a different type", async () => {
        const app = new Etl();
        app.use(fromCsv(Source.file("./src/__tests__/resources/csvFiles/people.csv")), fromJson({ a: 3 }));
        await expect(app.run()).to.eventually.be.rejectedWith("Extractor 'fromJson' can not be used: a ETL allows 1 extractor which currently is 'fromCsv'.");
    });
    it("should not fail with loadRecords() mw", async () => {
        const app = new Etl();
        app.use(loadRecords(fromJson({ foo: "bar" }), "foo"), fromCsv(Source.file("./src/__tests__/resources/csvFiles/people.csv")));
        await expect(app.run()).to.eventually.be.fulfilled;
    });
});
//# sourceMappingURL=utils.test.js.map