import { BlankNode, Literal, NamedNode, Quad } from "@triplydb/data-factory/Terms.js";
import { Record } from "./Record.js";
import { DestinationGetter } from "./locations/destinations/index.js";
import { SourceInfo } from "./locations/sources/index.js";
import { PossibleIri } from "../utils/index.js";
import { LanguageTagOrDataType } from "../ratt/middlewares/assertions/term/literal.js";
import Store from "./Store.js";
import { Etl } from "./index.js";
import { StaticString } from "../ratt/middlewares/assertions/term/str.js";
import { JPath } from "../ratt/middlewares/assertions/term/jpath.js";
export type Key = string | JPath;
export declare function isKey(value: any): value is Key;
interface PrimitiveTypeMapping {
    string: string;
    number: number;
    boolean: boolean;
    literal: Literal;
    iri: NamedNode;
    blankNode: BlankNode;
    unknown: unknown;
    any: any;
    table: {
        [key: string]: any;
    };
}
type PrimitiveTypeName = keyof PrimitiveTypeMapping;
type ArrayTypeName = {
    array: TypeName;
};
export type TypeName = PrimitiveTypeName | ArrayTypeName;
export type TypeForName<T extends TypeName> = T extends ArrayTypeName ? Array<TypeForName<T["array"]>> : T extends PrimitiveTypeName ? PrimitiveTypeMapping[T] : never;
export declare function getTypedValFromRecord(ctx: Context, key: string, type: TypeName): any;
type LiteralOptions<T> = T extends "literal" ? LanguageTagOrDataType : never;
export declare function getType<T extends TypeName = "unknown">(object: unknown, keyOrPathExpression: Key, type: T, opts?: LiteralOptions<T>): TypeForName<T>;
export default class Context<R = unknown> {
    private traceInfo;
    private traceError;
    recordId: number;
    readonly app: Etl;
    record: R & Record;
    store: Store;
    source?: SourceInfo;
    constructor(app: Etl);
    private _registerSources;
    hasParent(): boolean;
    getParent(): (R & Record) | undefined;
    getRoot(): R & Record;
    getAny(key: Key | StaticString): any;
    getUnknown(key: Key): unknown;
    getString(key: StaticString | Key): string;
    getArray<T extends TypeName>(key: Key, elementType: T): TypeForName<T>[];
    getTable<To = unknown>(key: Key): {
        [key: string]: To;
    };
    getNumber(key: Key | StaticString): number;
    getBoolean(key: Key): boolean;
    getLiteral(key: Key | StaticString, languageOrDatatype?: LanguageTagOrDataType): Literal;
    getIri(iriCandidate: PossibleIri): NamedNode;
    getBnode(key: string): BlankNode;
    hasKey(key: Key): boolean;
    /**
     * Check whether this key has a non empty value.
     * False is returned for:
     * - Empty strings, or strings with only whitespace
     * - Empty arrays
     * - Empty objects
     * - Values undefined and null
     */
    isNotEmpty(key: Key): boolean;
    /**
     * Check whether this key has a non empty value.
     * True is returned for:
     * - Empty strings, or strings with only whitespace
     * - Empty arrays
     * - Empty objects
     * - Values undefined and null
     */
    isEmpty(key: Key): boolean;
    isLiteral(key: string): boolean;
    isIri(key: string): boolean;
    isNumber(key: Key): boolean;
    isString(key: Key): boolean;
    isArray(key: Key): boolean;
    writeQuads(quads: Quad[], destinationGetter: DestinationGetter, opts?: Parameters<Etl["getDestinationStream"]>[1]): Promise<void>;
}
export {};
//# sourceMappingURL=Context.d.ts.map