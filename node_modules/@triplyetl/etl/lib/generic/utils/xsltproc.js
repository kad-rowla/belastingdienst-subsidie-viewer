import { Source } from "../index.js";
import SaxonJS from "saxon-js";
import crypto from "crypto";
import path from "path";
import { execSync } from "node:child_process";
import { existsSync, mkdirSync, writeFileSync } from "fs";
import { has } from "lodash-es";
const isStringSource = (i) => !has(i, "getLocalPath");
const isCorrectSourceGetter = (i, f) => f && typeof i === "object";
export default async (app, oneOreMoreSources, stylesheet) => {
    if (!existsSync(app.getTmpDir()))
        mkdirSync(app.getTmpDir(), { recursive: true });
    const filenameMap = new Map();
    if (typeof oneOreMoreSources === "string") {
        const tmpFileName = path.join(app.getTmpDir(), `${crypto.randomUUID()}.xml`);
        writeFileSync(tmpFileName, oneOreMoreSources, "utf-8");
        filenameMap.set(tmpFileName, undefined);
        oneOreMoreSources = Source.file(tmpFileName);
    }
    if (!Array.isArray(oneOreMoreSources)) {
        oneOreMoreSources = [oneOreMoreSources];
    }
    const processedSources = [];
    const onlyFileSources = [];
    for (const source of oneOreMoreSources) {
        // @ts-ignore
        const info = await source.get(app);
        let sourceIsStringSource = false;
        for (let i of info) {
            // if we have a StringSourceInfo, we need to save it to file first:
            if (isStringSource(i)) {
                sourceIsStringSource = true;
                const content = await i.getString();
                const stringSourceToFileFileName = path.join(app.getTmpDir(), `${crypto.generateKeySync("hmac", { length: 10 })}.txt`);
                writeFileSync(stringSourceToFileFileName, content, "utf-8");
                onlyFileSources.push(Source.file(stringSourceToFileFileName));
                filenameMap.set(stringSourceToFileFileName, undefined);
                //@ts-ignore
            }
        }
        // @ts-ignore
        if (!isCorrectSourceGetter(source, sourceIsStringSource))
            onlyFileSources.push(source);
    }
    // @ts-ignore
    const xslFile = await (await stylesheet.get(app))[0].getLocalPath();
    const sefFile = path.join(app.getTmpDir(), `${path.basename(xslFile, path.extname(xslFile))}.json`);
    //create SEF from XSL:
    const DevNull = process.platform === "win32" ? "NUL" : "/dev/null";
    const cmd = `npx xslt3 -xsl:"${xslFile}" -export:"${sefFile}" -nogo 2>${DevNull}`;
    try {
        execSync(cmd, { windowsHide: true });
    }
    catch (e) {
        throw new Error(`Failed to compile your stylesheet '${xslFile}'.\ndebug info:\n${e.message}`);
    }
    for (const source of onlyFileSources) {
        //@ts-ignore
        const info = await source.get(app);
        for (let i of info) {
            const hash = crypto.createHash("md5");
            const sourceFileName = await i.getLocalPath();
            hash.update(sourceFileName);
            const tmpFileName = `${hash.digest("hex")}.xml`;
            const tmpFilePath = path.join(app.getTmpDir(), tmpFileName);
            if (!filenameMap.has(tmpFilePath))
                filenameMap.set(tmpFilePath, filenameMap.get(sourceFileName) ?? sourceFileName);
            try {
                const output = await SaxonJS.transform({
                    stylesheetFileName: sefFile,
                    sourceFileName,
                    destination: "serialized",
                }, "async");
                writeFileSync(tmpFilePath, output.principalResult, "utf-8");
            }
            catch (e) {
                throw new Error(`Failed to apply the stylesheet '${xslFile}' to the XML.`);
            }
            //@ts-ignore
            processedSources.push(Source.file(tmpFilePath));
        }
    }
    filenameMap.forEach((value, key) => {
        if (value !== undefined && value.startsWith(app.getTmpDir())) {
            filenameMap.set(key, undefined);
        }
    });
    return { sources: processedSources, filenameMap };
};
//# sourceMappingURL=xsltproc.js.map