import { getFactory, Store as TriplyStore } from "@triplydb/data-factory";
import { flatMap, once } from "lodash-es";
import { Writer } from "n3";
import Etl from "./Etl.js";
import crypto from "crypto";
import { unknownValToIri, unknownValToLiteral } from "../utils/coercions.js";
const dataFactory = once(() => getFactory({ skipValidation: Etl.skipValidation }));
export default class Store extends TriplyStore {
    constructor(app) {
        super();
        this._app = app;
    }
    addQuad(subjectOrQuad, predicate, object, graph, done) {
        if ("graph" in subjectOrQuad) {
            // this is a quad
            let quad = subjectOrQuad;
            if (subjectOrQuad.graph.termType === "DefaultGraph") {
                quad = dataFactory().quad(quad.subject, quad.predicate, quad.object, this._app.defaultGraph);
            }
            super.addQuad(this.blankNodesToIris(subjectOrQuad));
        }
        else {
            if (!graph || graph.termType === "DefaultGraph") {
                graph = this._app.defaultGraph;
            }
            const subject = this.blankNodesToIris(subjectOrQuad);
            predicate = this.blankNodesToIris(predicate);
            object = this.blankNodesToIris(object);
            graph = this.blankNodesToIris(graph);
            super.addQuad(subject, predicate, object, graph, done);
        }
    }
    addQuads(quads) {
        const modifiedQuads = quads.map((q) => {
            if (q.graph.termType === "DefaultGraph") {
                return dataFactory().quad(q.subject, q.predicate, q.object, this._app.defaultGraph);
            }
            return q;
        });
        super.addQuads(this.blankNodesToIris(modifiedQuads));
    }
    map(mapper, pattern) {
        const quads = this.getQuads(pattern || {});
        const newQuads = flatMap(quads, mapper).filter((q) => !!q);
        this.removeQuads(quads);
        this.addQuads(newQuads);
        return newQuads;
    }
    containsBnode(quad) {
        for (const position of ["subject", "predicate", "object", "graph"]) {
            if (quad[position].termType === "BlankNode")
                return true;
        }
        return false;
    }
    blankNodesToIris(zeroOneOrMoreTerms) {
        if (zeroOneOrMoreTerms === undefined) {
            return undefined;
        }
        else if (Array.isArray(zeroOneOrMoreTerms)) {
            return zeroOneOrMoreTerms.map((quad) => this.blankNodesToIris(quad));
        }
        else if (zeroOneOrMoreTerms.termType === "Quad") {
            if (this.containsBnode(zeroOneOrMoreTerms)) {
                return dataFactory().quad(this.blankNodesToIris(zeroOneOrMoreTerms.subject), this.blankNodesToIris(zeroOneOrMoreTerms.predicate), this.blankNodesToIris(zeroOneOrMoreTerms.object), this.blankNodesToIris(zeroOneOrMoreTerms.graph));
            }
            else {
                return zeroOneOrMoreTerms;
            }
        }
        else if (zeroOneOrMoreTerms.termType === "BlankNode") {
            return this.wellKnownForBnode(zeroOneOrMoreTerms);
        }
        else {
            return zeroOneOrMoreTerms;
        }
    }
    wellKnownForBnode(blankNode) {
        return this.blankNodeIri(blankNode.value);
    }
    createBlankNode(_suggestedName) {
        throw new Error("Please use the `blankNodeIri` method of this store.");
    }
    blankNodeIri(val) {
        const content = val !== undefined ? this._app.id + val : crypto.randomBytes(16).toString("hex");
        return this._app.wellKnownIri.concat(content);
    }
    iri(val, opts) {
        const node = unknownValToIri(val, undefined, opts);
        return node;
    }
    literal(val, languageTagOrDataType) {
        return unknownValToLiteral(val, undefined, languageTagOrDataType);
    }
    copy() {
        const newStore = this._app.getNewStore();
        if (this.size === 0)
            return newStore;
        newStore.addQuads(this.getQuads(null, null, null, null));
        return newStore;
    }
    toNquadsString() {
        const writer = new Writer({ format: "nquads" });
        return writer.quadsToString(this.getQuads({})).split("\n").sort().join("\n") + "\n";
    }
}
//# sourceMappingURL=Store.js.map