import TriplyDb from "@triply/triplydb/App.js";
import chalk from "chalk";
import { format, formatDuration, intervalToDuration } from "date-fns";
import { EventEmitter } from "events";
import filenamify from "filenamify";
import { fromJSON as fromJsonFlatted } from "flatted";
import fs from "fs-extra";
import prettyMilliseconds from "pretty-ms";
import getCurrentLine from "get-current-line";
import { compact, flatMap, flattenDeep, get } from "lodash-es";
import { parse } from "@triplydb/data-factory";
import path from "path";
import Pumpify from "pumpify";
import * as zlib from "zlib";
import { Store } from "./index.js";
import Context from "./Context.js";
import { addMwCallSiteToError, coerceToIri, includeEtlVariablesInEnv, isNodejs, md5OfArray, randomHash, } from "../utils/index.js";
import { assertEnvironment, assertHasToken, assertIsDefined } from "../utils/asserts.js";
import { getErr } from "../utils/Error.js";
import { ldExtensionToN3Format } from "../utils/files.js";
import { randomUUID } from "crypto";
import { str } from "../ratt/index.js";
import { getFactory } from "@triplydb/data-factory";
import { getStreamWriter } from "@triplydb/data-factory/serialize.js";
import * as TriplyIri from "@triplydb/iri";
import { getTraceInfo } from "../debug/traceEnd.js";
import { setTraceErrorInfo } from "../debug/traceStart.js";
import { Iri } from "@triplyetl/vocabularies";
import { readFileSync } from "fs";
import { fileURLToPath } from "node:url";
export const DEFAULT_BASE_IRI = "https://triplydb.com";
export const DEFAULT_GRAPH_IRI = `${DEFAULT_BASE_IRI.replace(/\/+$/, "")}/graph/default`;
class Etl extends EventEmitter {
    constructor(conf) {
        super();
        this._runtimeStats = {};
        this._reportStats = {};
        this._after = [];
        // @ts-ignore Marked private to keep the interface clean. Used externaly though
        this._afterDurations = [];
        this._before = [];
        this._destinationPostProcess = [];
        this.createErrorTrace = false;
        this.status = "idle";
        // keep track of number of extractors, we allow only 1 per ETL:
        this.extractorName = undefined;
        /**
         * The baseIri used for all other Iri's. Trailing slashes will always be removed!
         */
        this.baseIri = new Iri(DEFAULT_BASE_IRI.replace(/\/+$/, ""));
        this.verbosity = 0;
        this.middlewares = [];
        this._dataDir = "./data";
        // Keep track of which middlewares were executed
        this.touchedMiddlewares = new Map();
        // @ts-ignore Marked private to keep the interface clean. Used externaly though
        this.currentMwIndices = [0];
        this.afterMiddlewaresFromConfig = [];
        this._runId = randomUUID();
        this._messageCounts = {};
        this.registeredDestinations = {};
        includeEtlVariablesInEnv();
        this.id = Date.now().toString(); // epoch in milliseconds
        if (conf?.baseIri)
            this.baseIri = this.getBaseIri(conf.baseIri);
        if (conf?.wellKnownIriPrefix) {
            this.wellKnownIri =
                typeof conf.wellKnownIriPrefix === "string"
                    ? new Iri(this.getBaseIri(conf.wellKnownIriPrefix).toString() + "/")
                    : conf.wellKnownIriPrefix;
        }
        else
            this.wellKnownIri = new Iri(new URL("/.well-known/genid/", this.baseUrl).toString());
        this.prefix = {
            ...DEFAULT_PREFIXES,
            ...conf?.prefixes,
        };
        this.defaultGraph = conf?.defaultGraph
            ? coerceToIri(conf.defaultGraph)
            : this.baseIri
                ? this.standardGraphs.default
                : this.dataFactory.namedNode(DEFAULT_GRAPH_IRI);
        this._triplyDb = Etl.CliContext?.triplydb;
        this._defaultAccount = Etl.CliContext?.account;
        this.offset = Etl.CliContext?.offset ?? 1;
        if (this.offset < 1) {
            throw new Error("fromRecordId must be strictly greater than 0");
        }
        this.limit = Etl.CliContext?.limit;
        this._timeout = Etl.CliContext?.timeout;
        this.debugTrace = Etl.CliContext?.debugTrace;
        this.errorTrace = Etl.CliContext?.errorTrace;
        this.createErrorTrace = Etl.CliContext?.createErrorTrace ?? false;
        this._fromCli = !!Etl.CliContext;
        if (Etl.CliContext?.dataDir)
            this._dataDir = Etl.CliContext.dataDir;
        if (Etl.CliContext?.verbosity) {
            this.verbosity = Etl.CliContext.verbosity;
        }
        this.sources = conf?.sources || {};
        this.destinations = conf?.destinations || {};
        for (const destinationName in this.destinations) {
            const destination = this.destinations[destinationName];
            if (typeof destination !== "function") {
                destination.name = `destination.${destinationName}`;
            }
        }
        this.mwRuntimesObj = {};
    }
    get dataFactory() {
        return getFactory({ skipValidation: Etl.skipValidation });
    }
    getBaseIri(possibleIri) {
        let iriAsString = "";
        if (typeof possibleIri === "string")
            iriAsString = possibleIri;
        else
            iriAsString = possibleIri.value;
        try {
            TriplyIri.validate(iriAsString);
            return new Iri(this.dataFactory.namedNode(iriAsString.replace(/\/+$/, "")));
        }
        catch (e) {
            throw new Error(`Could not make '${iriAsString}' into a valid URL`);
        }
    }
    get baseUrl() {
        return new URL(this.baseIri.value);
    }
    _setStatus(status) {
        this.status = status;
        this.emit("status", status);
    }
    toMessageObject(message, level, type) {
        const messageObject = typeof message === "string"
            ? {
                label: level,
                level: level,
                message: message,
                type: type,
            }
            : { ...message, level: level, type: type };
        if (this._messageCounts[messageObject.type + messageObject.label] === undefined) {
            this._messageCounts[messageObject.type + messageObject.label] = 0;
        }
        this._messageCounts[messageObject.type + messageObject.label]++;
        return {
            ...messageObject,
            count: this._messageCounts[messageObject.type + messageObject.label],
        };
    }
    // @ts-ignore Marked private to keep the interface clean. Used externaly though
    setMwIndices(mwIndex) {
        const last = this.currentMwIndices.length - 1;
        this.currentMwIndices[last] = mwIndex;
    }
    startMwTimer(opts) {
        // Only track time when we're in node
        if (!isNodejs())
            return;
        // when 'this.currentMwIndices' is later updated we don't want the 'mwIndicesPosition' to change.
        const mwIndicesPosition = [...this.currentMwIndices];
        let functionName = "unnamed middleware";
        if (opts.mwName) {
            /**
             * all middlewares in Etl are wrapped with addMwCallSiteToError
             * when wrapped the function.name property is prepended with an underscore "_"
             * here we are removing it for logging purposes.
             */
            if (opts.mwName.startsWith("_"))
                functionName = opts.mwName.substring(1);
            else
                functionName = opts.mwName;
        }
        if (this.mwRuntimesObj[opts.timerLabel]) {
            this.mwRuntimesObj[opts.timerLabel].timerStart = process.hrtime.bigint();
            this.mwRuntimesObj[opts.timerLabel].numOfRecords = opts.recordId;
            this.mwRuntimesObj[opts.timerLabel].timesCalled++;
        }
        else {
            const startTimerObj = {
                timerStart: process.hrtime.bigint(),
                mwIndicesPosition,
                functionName,
                callSite: opts.callSite,
                runtime: BigInt(0),
                trailingMwDuration: BigInt(0),
                numOfRecords: opts.recordId ? opts.recordId : 1,
                timesCalled: 1,
                whenMwDepth: opts.whenMwDepth,
            };
            this.mwRuntimesObj[opts.timerLabel] = startTimerObj;
        }
    }
    addToMwTimerTrailingDuration(timerLabel, duration) {
        if (!this.mwRuntimesObj[timerLabel]) {
            throw new Error(`Failed to find runtime info for middleware ${timerLabel}. Please contact a developer.`);
        }
        this.mwRuntimesObj[timerLabel].trailingMwDuration += duration;
    }
    endMwTimer(timerLabel) {
        // Only track time when we're in node
        if (!isNodejs())
            return;
        if (!this.mwRuntimesObj[timerLabel]) {
            throw new Error(`Failed to find runtime info for middleware ${timerLabel}. Please contact a developer.`);
        }
        const { timerStart, trailingMwDuration } = this.mwRuntimesObj[timerLabel];
        if (timerStart) {
            const endTime = process.hrtime.bigint();
            const timeDifference = endTime - timerStart - trailingMwDuration;
            this.mwRuntimesObj[timerLabel].runtime += timeDifference;
            this.mwRuntimesObj[timerLabel].timerStart = undefined;
            this.mwRuntimesObj[timerLabel].trailingMwDuration = BigInt(0);
        }
    }
    debugTraceToDispatchOpts() {
        assertIsDefined(this.debugTrace, "Expected debug trace to be defined");
        let store;
        let record;
        if (this.debugTrace.fromMwIndex.length > 1) {
            // we have a middleware stack (i.e. a foreach or something) to dive into
            // i.e., the record we have in the debugTrace wont apply to the current level anyway
            // So, use an empty store and record
            store = this.getNewStore();
            record = {};
        }
        else {
            store = this.getNewStore();
            store.addQuads(parse(this.debugTrace.quadsAtStart));
            record = fromJsonFlatted(this.debugTrace.recordAtStart);
        }
        return {
            mwIndex: this.debugTrace.fromMwIndex.shift(),
            record,
            store,
        };
    }
    logMessage(status) {
        if (Etl.silent)
            return;
        if (status.level === "Error") {
            console.error(`${chalk.red(status.label)} ${status.message}`);
        }
        else if (status.level === "Violation") {
            console.error(`${chalk.red(status.label)} ${status.message}`);
        }
        else if (status.level === "Warning") {
            console.warn(`${chalk.yellow(status.label)} ${status.message}`);
        }
        else {
            console.info(`${chalk.blue(status.label)} ${status.message}`);
        }
    }
    async copySource(source, destination) {
        switch (this.status) {
            case "beforeHook":
            case "idle":
            case "running":
                break;
            default:
                throw new Error(`Can only copy a source when the app hasn't finished running yet. Currently, the app is in the ${this.status} state.`);
        }
        const sources = await source.get(this, "statements");
        const extraFiles = await Promise.all(
        // for each source we register the information given the destination function's registerSource function (rdf.ts, terminal.ts, file.ts, or TriplyDB.ts)
        sources.map((sourceInfo) => destination.registerSource(sourceInfo, this.getTmpDir(destination.type))));
        // Register the files with the destination.
        // NB: `destinationInfo` is a mutable reference to an item of `this.registeredDestinations`
        // getDestinationInfo retrieves the file destinations using the destination's unique fingerprint, this fingerprint is a key in the dictionairy object (this.registeredDestinations) that is created in the destination functions (rdf.ts, terminal.ts, file.ts, or TriplyDB.ts)
        const destinationInfo = await this.getDestinationInfo(destination, { alwaysPostProcess: false });
        destinationInfo.files.push(...extraFiles);
    }
    async getDestinationInfo(destination, opts) {
        let info = this.registeredDestinations[destination.fingerprint];
        if (!info) {
            // Register a destination for the first time
            await destination.init(this);
            this._destinationPostProcess.push(this.postProcessFactory(destination));
            info = this.registeredDestinations[destination.fingerprint] = {
                alwaysInfo: { files: [] },
                onSuccessInfo: { files: [] },
            };
        }
        return opts.alwaysPostProcess ? info.alwaysInfo : info.onSuccessInfo;
    }
    // @ts-ignore used in `Context.writeQuads` but private to keep the API clean
    async getDestinationStream(destination, opts) {
        const alwaysPostProcess = opts?.alwaysPostProcess ?? false;
        const info = await this.getDestinationInfo(destination, { alwaysPostProcess });
        if (info.writeableRdfStream)
            return info.writeableRdfStream;
        const extension = `.${destination.fileInfo.extension}${destination.fileInfo.compression === "gz" ? ".gz" : ""}`;
        const tmpFile = path.join(this.getTmpDir(destination.type), md5OfArray([destination.fingerprint, `${alwaysPostProcess}`])) +
            extension;
        info.files.push({ filename: tmpFile, remove: true });
        await fs.ensureFile(tmpFile);
        const fileStream = fs.createWriteStream(tmpFile);
        const prefixes = {};
        const etlPrefixes = { ...this.prefix, ...opts?.extraPrefixes };
        for (const prefix in etlPrefixes) {
            prefixes[prefix] = etlPrefixes[prefix];
        }
        const triplyStreamWriter = getStreamWriter({
            format: ldExtensionToN3Format(destination.fileInfo.extension),
            prefixes: { ...this.prefix, ...opts?.extraPrefixes },
        });
        const stream = (info.writeableRdfStream =
            destination.fileInfo.compression === "gz"
                ? new Pumpify.obj(triplyStreamWriter, zlib.createGzip(), fileStream)
                : new Pumpify.obj(triplyStreamWriter, fileStream));
        return stream;
    }
    async flushWriters() {
        // wait for any write processes to finish
        await Promise.all(flatMap(Object.values(this.registeredDestinations), (info) => [
            info.alwaysInfo.writeableRdfStream,
            info.onSuccessInfo.writeableRdfStream,
        ]).map((writeableRdfStream) => new Promise((resolve) => (writeableRdfStream ? writeableRdfStream.end(resolve) : resolve()))));
    }
    postProcessFactory(destination) {
        return {
            fn: async (etlFinishedSuccessfully) => {
                const info = this.registeredDestinations[destination.fingerprint];
                if (!info)
                    return;
                delete this.registeredDestinations[destination.fingerprint];
                const files = info.alwaysInfo.files.concat(etlFinishedSuccessfully ? info.onSuccessInfo.files : []);
                const filesWithMetadata = compact(await Promise.all(files.map(async (f) => {
                    if (await fs.pathExists(f.filename))
                        return f;
                })));
                // Each postProcess function of the given destination function is executed
                // This check is necessary as postProcess expects filesWithMetadata to have at least one element.
                if (filesWithMetadata.length)
                    return destination.postProcess(this, filesWithMetadata);
            },
            name: destination.name || destination.fingerprint,
        };
    }
    // @ts-ignore Marked private to keep the interface clean. Used externaly though
    getUntouchedMiddlewares() {
        return [...this.touchedMiddlewares].filter(([, val]) => !val).map(([key]) => key);
    }
    // @ts-ignore Marked private to keep the interface clean. Used externaly though
    markMwTouched(location) {
        this.touchedMiddlewares.set(location, true);
    }
    async removeTmpDir() {
        return fs.remove(this.getTmpDir());
    }
    //////////////////////////////////////////////
    /////// Public methods ///////////////////////
    //////////////////////////////////////////////
    static get token() {
        includeEtlVariablesInEnv();
        return get(process.env, "TRIPLYDB_TOKEN");
    }
    get triplyDb() {
        if (!this._triplyDb) {
            if (this._fromCli) {
                throw new Error(`No TriplyDB token or API URL set. Run \`npx etl --help\` for more information on how to pass your TriplyDB credentials.
If you do not have a TriplyDB token yet, you can run \`npx tools create-token\` to have on created for you.`);
            }
            const token = Etl.token;
            assertHasToken(get(process.env, "TRIPLYDB_TOKEN"));
            return TriplyDb.get({
                token,
                url: get(process.env, "TRIPLYDB_API"),
            });
        }
        return this._triplyDb;
    }
    get skolemIri() {
        return this.standardPrefixes.skolem.concat(randomHash());
    }
    static get environment() {
        const env = str(get(process.env, "ENV") ?? get(process.env, "NODE_ENV") ?? "Development").capitalize();
        if (env === "")
            return "Development";
        assertEnvironment(env);
        return env;
    }
    getNewStore() {
        const store = new Store(this);
        store["_app"] = this;
        return store;
    }
    /**
     * Set expected total progress of this Etl run. Can be any number (e.g. byte-size, array length).
     */
    setTotalProgress(size) {
        this._totalToProcess = size;
    }
    /**
     * Add to the current progress of the Etl run. Can be any number (e.g.
     * bytes processed, number of processed array elements). This function is
     * typically used in the first Etl middleware
     */
    incrementProgress(processed) {
        // see issue #313: if a user defines a custom Record creator, the progressbar will explode
        this._processedAbsolute = processed + (this._processedAbsolute ?? 0);
        if ((this._processedAbsolute ?? 0) + processed > (this._totalToProcess ?? 0)) {
            this.setTotalProgress((this._processedAbsolute ?? 0) + processed);
        }
        if (this._totalToProcess) {
            this.showProgress();
        }
        return this._processedAbsolute;
    }
    showProgress() {
        let percentage;
        if (this._totalToProcess && this._processedAbsolute) {
            percentage = Math.round((this._processedAbsolute / this._totalToProcess) * 100);
        }
        else {
            percentage = 0;
        }
        if (percentage !== this._processedPercentage) {
            this._processedPercentage = percentage;
            this.emit("progress", this._processedPercentage);
        }
    }
    /**
     * Print and emit error message
     */
    error(message) {
        const statusObj = this.toMessageObject(message, "Error", "Etl");
        this.logMessage(statusObj);
        this.emit("message", statusObj);
    }
    /**
     * Print and emit violation message
     */
    violation(message, type = "Shacl") {
        const statusObj = this.toMessageObject(message, "Violation", type);
        this.logMessage(statusObj);
        this.emit("message", statusObj);
    }
    /**
     * Print and emit warning message
     * @param type type of warning message (SHACL validation severity or ETL warning)
     */
    warn(message, type = "Etl") {
        const statusObj = this.toMessageObject(message, "Warning", type);
        this.emit("message", statusObj);
        this.logMessage(statusObj);
    }
    /**
     * Print and emit info message
     * @param type type of warning message (SHACL validation severity or ETL warning)
     */
    info(message, type = "Etl") {
        const statusObj = this.toMessageObject(message, "Info", type);
        this.logMessage(statusObj);
        this.emit("message", statusObj);
    }
    /**
     * Update Etl run statistics. These can be displayed at runtime, or only in the final report
     */
    updateStats(label, value, opts) {
        const runtimeStat = opts?.display !== "finalReport";
        const stats = runtimeStat ? this._runtimeStats : this._reportStats;
        const newValue = typeof value === "function" ? value(stats[label]) : value;
        const changed = newValue !== stats[label];
        if (newValue === undefined) {
            delete stats[label];
        }
        else {
            stats[label] = newValue;
        }
        if (runtimeStat && changed) {
            //Only emitting the stats when we want runtime feedback.
            this.emit("stats", stats);
        }
    }
    getStats(type) {
        if (type === "runtime")
            return this._runtimeStats;
        return this._reportStats;
    }
    after(fn, options = { always: false }) {
        const callsite = getCurrentLine({ frames: 2 });
        if (options.always) {
            this._after.push({ fn, always: true, callsite });
        }
        else {
            this._after.push({ fn, callsite });
        }
    }
    before(fn) {
        this._before.push(fn);
    }
    setDataDir(dataDir) {
        this._dataDir = dataDir;
    }
    getDataDir(...subpaths) {
        return path.resolve(this._dataDir, ...subpaths.map((p) => filenamify(p, {
            replacement: "-",
            maxLength: 255,
        })));
    }
    getCacheDir(...subpaths) {
        return this.getDataDir("cache", ...subpaths);
    }
    getTmpDir(...subpaths) {
        return this.getDataDir("tmp", `run-id-${this._runId}`, ...subpaths);
    }
    setTriplyDb(triplyDb) {
        if (triplyDb instanceof TriplyDb) {
            this._triplyDb = triplyDb;
        }
        else {
            this._triplyDb = TriplyDb.get(triplyDb);
        }
        return this._triplyDb;
    }
    get standardPrefixes() {
        if (this.baseIri === undefined) {
            throw new Error("To use the standard prefixes, a 'baseIri' must be set when you create an Etl instance.");
        }
        const base = this.baseUrl;
        const port = base.port === "80" || base.port === "443" || base.port === "" ? "" : `:${base.port}`;
        const skolem = new Iri(`${base.protocol}//${base.hostname}${port}/.well-known/genid/`);
        return {
            /**
             * The IRI prefix for blank node-replacing well-known IRIs.
             */
            skolem,
            /**
             * The IRI prefix for graph names.
             */
            graph: this.baseIri.concat("/graph/"),
            /**
             * The IRI prefix for SKOS concepts.
             */
            con: this.baseIri.concat("/model/con/"),
            /**
             * The IRI prefix for definitions, i.e. OWL classes and OWL properties.
             */
            def: this.baseIri.concat("/model/def/"),
            /**
             * The IRI prefix for instances.
             */
            id: this.baseIri.concat("/id/"),
            /**
             * The IRI prefix for SKOS concept schemes.
             */
            scheme: this.baseIri.concat("/model/scheme/"),
            /**
             * The IRI prefix for SHACL shapes.
             */
            shp: this.baseIri.concat("/model/shp/"),
        };
    }
    /**
     * Function for creating graph names that follow [the Triply IRI
     * Strategy](https://triplydb.com/how-to-model/-/stories/how-to-model-iris).
     *
     * Many datasets have a repeating core set of graph names, e.g. 'metadata',
     * 'report', 'model', and 'instances'.  This function makes such common graph
     * names available within the given prefix/namespace.
     */
    get standardGraphs() {
        if (this.baseIri === undefined) {
            throw new Error("To use the standard graphnames, a 'baseIri' must be set when you create an Etl instance.");
        }
        return {
            /**
             * The name of the default graph.
             *
             * In TriplyDB the default graph is a named graph with this name.
             */
            default: this.baseIri.concat("/graph/default"),
            /**
             * The name of the graph that contains instance data.
             */
            instances: this.baseIri.concat("/graph/instances"),
            /**
             * The graph that contains the metadata that described this dataset.
             */
            metadata: this.baseIri.concat("/graph/metadata"),
            /**
             * The name of the graph that contains the meta-model.
             *
             * The meta-model is used to verify the correctness of the data model
             * and/or dataset metadata.
             */
            metamodel: this.baseIri.concat("/graph/metamodel"),
            /**
             * The name of the graph that contains the data model.
             */
            model: this.baseIri.concat("/graph/model"),
            /**
             * The name of the graph that contains the SHACL validation report.
             */
            report: this.baseIri.concat("/graph/report"),
        };
    }
    /**
     * Register one or more middlewares
     */
    use(...middlewaresArray) {
        if (this._startTime)
            throw new Error("Cannot register a new middleware when the Etl app already started");
        const middlewares = flattenDeep(middlewaresArray).filter((m) => !!m);
        for (const mw of middlewares) {
            if (mw.callSite)
                this.touchedMiddlewares.set(mw.callSite, false);
        }
        this.middlewares.push(...middlewares);
        return this;
    }
    /**
     * Conditionally register one er more middlewares
     */
    useWhen(when, ...middlewaresArray) {
        if (this._startTime)
            throw new Error("Cannot register a new middleware when the Etl app already started");
        const mw = whenMw(when, ...middlewaresArray);
        this.middlewares.push(...mw);
    }
    /**
     * Run the Etl app
     */
    async run() {
        if (this._startTime)
            throw new Error("Cannot call `run()` on a Etl app that is already running");
        this.middlewares.push(...this.afterMiddlewaresFromConfig);
        this._startTime = new Date();
        const context = new Context(this);
        if (this._before.length) {
            this._setStatus("beforeHook");
            const beforeTime = process.hrtime.bigint();
            await Promise.all(this._before.map((p) => p()));
            this._beforeDuration = process.hrtime.bigint() - beforeTime;
        }
        try {
            this._setStatus("running");
            const dispatch = composeMiddlewares({
                middlewares: this.middlewares,
                context,
                onEnd: (context) => {
                    if (this.limit && context.recordId - (this.offset - 1) === this.limit) {
                        throw getErr().setStoppedAtHead();
                    }
                    // Track the exact number for the final report
                    this.updateStats("#Statements", (val) => +(val || 0) + context.store.size, { display: "finalReport" });
                    // Track a human readable (less exact) string for the runtime stats
                    const currentNumQuads = +this.getStats("finalReport")["#Statements"];
                    this.updateStats("#Statements", isNaN(currentNumQuads) ? 0 : currentNumQuads, { display: "runtime" });
                    this.updateStats("#Records", context.recordId, { display: "finalReport" });
                },
                onNextRecord: (context) => {
                    context.recordId++;
                    if (context.recordId < this.offset) {
                        return "skipRecord";
                    }
                    // If flag --timeout is set and (runtime < timeout) - otherwise exit gracefully
                    if (this._startTime && this._timeout) {
                        let timeoutRunCondition;
                        timeoutRunCondition = Date.now() - this._startTime.valueOf() < this._timeout;
                        if (!timeoutRunCondition) {
                            this.error(`The runtime has exceeded the timeout of ${prettyMilliseconds(this._timeout)}!\nTimedout at recordID: ${context.recordId.valueOf()}\n`);
                            throw getErr().setTimedout();
                        }
                    }
                    // If the last middleware isn't nice and doesn't call `next`, we can't
                    // rely on the above stoppedAtHead-error to fire, as it only fires
                    // after `next` is called by the last middleware. Therefore,
                    // to make sure that we _always_ stop at least during the first
                    // record we shouldn't be processing, this catch is here.
                    if (this.limit && context.recordId - (this.offset - 1) > this.limit) {
                        throw getErr().setStoppedAtHead();
                    }
                },
            });
            if (this.debugTrace) {
                await dispatch(this.debugTraceToDispatchOpts());
            }
            else {
                await dispatch();
            }
        }
        catch (_e) {
            const e = getErr(_e);
            /**
             * The 'context.traceError' only exists if we run the ETL over at least one record.
             * Not all errors come from running the ETL. Those we need to just pass on.
             * We also want to not modify TraceErrors set from the traceMiddleware
             */
            if (this.createErrorTrace) {
                const traceErrorInfo = getTraceInfo(context, "error");
                if (!e.trace?.isTraceDebug && traceErrorInfo)
                    e.setTraceInfo(traceErrorInfo);
            }
            /**
             * (1) We ran the etl with a `--head` argument. We want to exit gracefully, so not throwing things,
             * and (considering we have partial results) not calling the after hooks
             * (2) We ran the etl with a `--timeout` argument.
             */
            if (!e.stoppedAtHead && !e.timedout) {
                // Clean up writers before throwing errors
                await this.flushWriters();
                /**
                 * We received an error. We still want to call the after-always hooks so we e.g.
                 * still upload the validation report when the validation threw
                 * That being said, we dont want to call the after hooks when we only have partial results, such as
                 * - When we only execute a traced record (via `--trace <file>`)
                 * - When we exit early due to creating a trace (via traceStart() and traceEnd())
                 */
                const afterAlwaysHooks = [...this._destinationPostProcess, ...this._after.filter((x) => x.always === true)];
                if (afterAlwaysHooks.length && !e.trace?.isTraceDebug && !this.debugTrace) {
                    this._setStatus("afterHook");
                    for (const afterAlwaysHook of afterAlwaysHooks) {
                        const start = process.hrtime.bigint();
                        await afterAlwaysHook.fn(false);
                        const name = "name" in afterAlwaysHook ? afterAlwaysHook.name : undefined;
                        this._afterDurations.push({
                            name: name || afterAlwaysHook.fn.name || "unnamed function",
                            duration: process.hrtime.bigint() - start,
                            callsite: "callsite" in afterAlwaysHook ? afterAlwaysHook.callsite : undefined,
                        });
                    }
                }
                await this.removeTmpDir();
                this._setStatus("error");
                if (!e.stoppedAtHead && !e.timedout) {
                    // Manipulate error so we have more actionable information
                    throw e.setRecordId(context.recordId).setRecord(context.record);
                }
            }
        }
        await this.flushWriters();
        const afterHooks = [...this._destinationPostProcess, ...this._after];
        if (afterHooks.length) {
            this._setStatus("afterHook");
            for (const afterHook of afterHooks) {
                const start = process.hrtime.bigint();
                await afterHook.fn(true);
                const name = "name" in afterHook ? afterHook.name : undefined;
                this._afterDurations.push({
                    name: name || afterHook.fn.name || "unnamed function",
                    duration: process.hrtime.bigint() - start,
                    callsite: "callsite" in afterHook ? afterHook.callsite : undefined,
                });
            }
        }
        this._setStatus("done");
        const packageJsonPath = path.join(path.dirname(fileURLToPath(import.meta.url)), "..", "..", "package.json");
        this._reportStats["Version"] =
            "TriplyETL " + JSON.parse(readFileSync(packageJsonPath, "utf-8")).version + "; Node.js " + process.version;
        this._reportStats["Environment"] = Etl.environment;
        this._reportStats["Started at"] = format(this._startTime, "yyyy-LL-dd kk:mm:ss");
        this._reportStats["Ended at"] = format(Date.now(), "yyyy-LL-dd kk:mm:ss");
        this._reportStats["Runtime"] =
            formatDuration(intervalToDuration({ start: this._startTime, end: Date.now() })) || "0 sec";
        this.emit("finished", { ...this._runtimeStats, ...this._reportStats });
        await this.removeTmpDir();
        return { ...this._runtimeStats, ...this._reportStats };
    }
    async staticAssertions(...mws) {
        const ctx = new Context(this);
        for (const mw of mws) {
            await mw(ctx, () => Promise.resolve());
        }
        if (this.staticStore === undefined)
            this.staticStore = ctx.store;
        else
            this.staticStore.addQuads(ctx.store.getQuads({}));
        const currentNumQuads = +ctx.app.getStats("finalReport")["#Statements"];
        ctx.app.getStats("finalReport")["#Statements"] = (isNaN(currentNumQuads) ? 0 : currentNumQuads) + ctx.store.size;
        return this;
    }
}
// utility key to precvent messages being print, useful in tests:
Etl.silent = false;
Etl.skipValidation = false;
export default Etl;
// This is the only middleware that's part of Etl core, considering Etl depends on this
// for the `useWhen` functionality
/**
 * Run one or more middlewares when some condition is met.
 *
 * @param when - The condition under which the middlewares are run.  This is
 * either a key or a function that takes the Etl Context and returns a
 * Boolean value.
 *
 * If the condition is a key, the middlewares are run if (i) the key exists
 * and (ii) has a value that is non-empty.  The value for a key is considered
 * empty if it is `undefined`, `null`, the empty string (`''`), the empty
 * array (`[]`), or the empty object (`{}`).
 *
 * If the condition is a function, its signature is `ctx => boolean`.
 *
 * @param middleware - An array with zero or more middlewares.
 *
 * @example
 * The following snippet always asserts the last name of a person, and
 * optionally asserts the first name if it is present:
 *
 * ```ts
 * fromJson([
 *   { id: '123', first: 'John', last: 'Doe' },
 *   { id: '456', last: 'Smith' },
 * ]),
 * addIri({
 *   prefix: prefix.person,
 *   content: 'id',
 *   key: '_person',
 * }),
 * triple('_person', foaf.lastName, 'last'),
 * when('first', [
 *   triple('_person', foaf.firstName, 'first'),
 * ]),
 * ```
 *
 * This results in the following linked data assertions:
 *
 * ```ttl
 * person:123
 *   foaf:firstName 'John';
 *   foaf:lastName 'Doe'.
 * person:456 lastName 'Smith'.
 * ```
 *
 * @example
 * The following snippet shows assertions that are only made if two keys are
 * present in the Etl Record:
 *
 * ```ts
 * fromJson([
 *   { id: '123', first: 'John', last: 'Doe' },
 *   { id: '456', last: 'Smith' },
 * ]),
 * when(ctx => ctx.hasString('first') && ctx.hasString('last'), [
 *   couples(iri(prefix.person, 'id'), [
 *     [foaf.firstName, 'first'],
 *     [foaf.lastName, 'last'],
 *   ]),
 * ]),
 * ```
 */
export function whenMw(when, ...middlewaresArray) {
    const middlewares = flattenDeep(middlewaresArray).filter((m) => !!m);
    const whenFn = typeof when === "function" ? when : (ctx) => ctx.isNotEmpty(when);
    let registeredTouchedMiddlewares = false;
    // Setting whenMwDepth value for logging indentation
    for (let mw of middlewares) {
        if (!mw.whenMwDepth)
            mw.whenMwDepth = 0;
        mw.whenMwDepth++;
    }
    let sourceFuncName = "_when";
    if (whenFn.sourceFuncName)
        sourceFuncName = whenFn.sourceFuncName;
    return [
        addMwCallSiteToError(async function _whenMw(ctx, next) {
            if (!registeredTouchedMiddlewares) {
                for (const mw of middlewares) {
                    if (mw.callSite)
                        ctx.app["touchedMiddlewares"].set(mw.callSite, false);
                }
                registeredTouchedMiddlewares = true;
            }
            if (await whenFn(ctx))
                return next();
            return next(ctx.record, ctx.store, middlewares.length);
        }, { sourceFuncName, callSite: whenFn.callsite }),
        ...middlewares,
    ];
}
const DEFAULT_PREFIXES = {
    rdf: new Iri("http://www.w3.org/1999/02/22-rdf-syntax-ns#"),
    rdfs: new Iri("http://www.w3.org/2000/01/rdf-schema#"),
};
export function composeMiddlewares(opts) {
    // dispatch a next middleware. Information needed to dispatch is the middleware index, and a record+store
    async function dispatch(dispatchOpts) {
        const mwIndex = dispatchOpts?.mwIndex || 0;
        const app = opts.context.app;
        const mw = opts.middlewares[mwIndex];
        // There is no next middleware to run for this record. This happens when our last middleware calls `next()`
        if (!mw) {
            opts.onEnd?.(opts.context);
            return BigInt(0);
        }
        const beginDispatch = process.hrtime.bigint();
        app["setMwIndices"](mwIndex);
        const timerLabel = app["currentMwIndices"].join(",");
        app["startMwTimer"]({
            timerLabel: timerLabel,
            recordId: opts.context.recordId,
            callSite: mw.callSite,
            mwName: mw.sourceFuncName ? mw.sourceFuncName : mw.name,
            whenMwDepth: mw.whenMwDepth,
        });
        if (dispatchOpts?.record) {
            opts.context.record = dispatchOpts.record;
        }
        if (dispatchOpts?.store) {
            opts.context.store = dispatchOpts.store;
        }
        /**
         * We want to set the traceErrorInfo when each new record is being processed,
         * not each time we call a middleware. Otherwise there is a massive performance hit.
         */
        if (app["createErrorTrace"]) {
            if (opts.context["traceError"] === undefined || opts.context["traceError"].recordId !== opts.context.recordId) {
                setTraceErrorInfo(opts.context);
            }
        }
        await mw(opts.context, async (record, store, skip) => {
            if (mwIndex === 0) {
                if (opts.onNextRecord?.(opts.context) === "skipRecord") {
                    return; // stop processing this record
                }
            }
            const nextMiddlewareIndex = mwIndex + 1 + (skip ?? 0);
            const duration = await dispatch({ mwIndex: nextMiddlewareIndex, record, store });
            app["addToMwTimerTrailingDuration"](timerLabel, duration);
        }).finally(() => {
            app["endMwTimer"](timerLabel);
        });
        return process.hrtime.bigint() - beginDispatch;
    }
    return dispatch;
}
//# sourceMappingURL=Etl.js.map