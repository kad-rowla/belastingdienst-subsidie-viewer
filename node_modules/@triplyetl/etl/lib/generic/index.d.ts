import Context from "./Context.js";
import Store from "./Store.js";
import { Location } from "get-current-line";
export { default as Context, Key } from "./Context.js";
export { Record, key } from "./Record.js";
export { default as Source } from "./locations/sources/index.js";
export { default as Destination } from "./locations/destinations/index.js";
export { default as Store } from "./Store.js";
export { default as Etl } from "./Etl.js";
export { default as Iri } from "./Iri.js";
export * from "./middlewares/index.js";
export { default as declarePrefix } from "./utils/declarePrefix.js";
export type NextFn = <R = unknown>(record?: R, store?: Store, skip?: number) => Promise<void>;
export type Middleware<R = unknown> = ((context: Context<R>, next: NextFn) => Promise<void>) & {
    callSite?: Location;
    sourceFuncName?: string;
    whenMwDepth?: number;
};
export type MiddlewareList<R = unknown> = Array<MiddlewareList<R> | Middleware<R>>;
export type Environment = "Development" | "Testing" | "Acceptance" | "Production";
export declare const environments: {
    [key in Environment]: Environment;
};
/**
 * Returns a randomly created key name.
 *
 * This can be used to store intermedate results in between two middlewares.
 */
export declare function randomKey(): string;
//# sourceMappingURL=index.d.ts.map