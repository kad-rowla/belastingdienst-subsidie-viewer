import { expect } from "chai";
import fs from "fs-extra";
import { default as validateShacl } from "../../../../shacl/middleware/validate.js";
import { createReadStreamSafe } from "../../../../utils/files.js";
import { toRdf, Etl, Destination, Source } from "../../../index.js";
import { getStreamParser } from "@triplydb/data-factory";
function getTestReportLocation(fileName) {
    return `./src/__tests__/resources/validationFiles/report_shacl_${fileName}`;
}
function getTestReportDestination(fileName) {
    return Destination.file(getTestReportLocation(fileName));
}
function fromTtl(fileLocation) {
    return async function (ctx, next) {
        const dataFileStream = await createReadStreamSafe(fileLocation);
        const triplyParser = getStreamParser();
        await new Promise((resolve, reject) => {
            ctx.store.import(dataFileStream.pipe(triplyParser)).on("finish", resolve).on("error", reject);
        });
        await next();
    };
}
describe("Copying to a file destination", function () {
    it("a single file", async function () {
        const sourceFile = "./src/__tests__/resources/shapeFiles/places.shp";
        const destinationFile = "tmp/" + Math.random() + ".trig";
        expect(await fs.pathExists(destinationFile)).to.be.false;
        const app = new Etl({ defaultGraph: "https://default.com/" });
        await app.copySource(Source.file(sourceFile), Destination.file(destinationFile));
        await app.run();
        expect(await fs.pathExists(destinationFile)).to.be.true;
        expect((await fs.stat(destinationFile)).isFile()).to.be.true;
        // it shouldn't have touched the source file
        expect(await fs.pathExists(sourceFile)).to.be.true;
        expect((await fs.stat(sourceFile)).isFile()).to.be.true;
    });
    it("multiple files", async function () {
        const sourceFiles = [
            "./src/__tests__/resources/shapeFiles/places.shp",
            "./src/__tests__/resources/shapeFiles/railways.shp",
        ];
        const destinationFile = "tmp/" + Math.random() + ".trig";
        expect(await fs.pathExists(destinationFile)).to.be.false;
        const app = new Etl({ defaultGraph: "https://default.com/" });
        for (const sourceFile of sourceFiles) {
            await app.copySource(Source.file(sourceFile), Destination.file(destinationFile));
        }
        await app.run();
        expect(await fs.pathExists(destinationFile)).to.be.true;
        expect((await fs.stat(destinationFile)).isDirectory()).to.be.true;
        expect(await fs.pathExists(sourceFiles[0])).to.be.true;
        expect((await fs.stat(sourceFiles[0])).isFile()).to.be.true;
        expect(await fs.pathExists(sourceFiles[1])).to.be.true;
        expect((await fs.stat(sourceFiles[1])).isFile()).to.be.true;
    });
    it("to a dynamic destination", async function () {
        const app = new Etl({ defaultGraph: "https://default.com/" });
        // @ts-expect-error
        const failedCopy = app.copySource(Source.file("./src/__tests__/resources/shapeFiles/places.shp"), (ctx) => Destination.file(ctx.getString("hallo")));
        await expect(failedCopy).to.be.rejected;
    });
    describe("when an error occurs", async function () {
        const reportName = "default.ttl";
        afterEach(async function () {
            // Cleanup leftover reports.
            await fs.rm(getTestReportLocation(reportName)).catch(() => { });
            Etl.silent = false;
        });
        it("with distinct destinations, only the `always` destination should be written to", async function () {
            const tmpDestinationFile = "tmp/" + Math.random() + ".trig";
            Etl.silent = true;
            const app = new Etl({
                defaultGraph: "https://default.com/",
                destinations: {
                    destination1: getTestReportDestination(reportName),
                    destination2: Destination.file(tmpDestinationFile),
                },
            });
            app.use(fromTtl("./src/__tests__/resources/validationFiles/data.ttl"));
            app.use(toRdf(app.destinations.destination2));
            app.use(validateShacl(Source.file("./src/__tests__/resources/validationFiles/shapes.ttl")));
            await expect(app.run()).to.eventually.rejectedWith(/The instance data of record 1 does not conform to the model./);
            await expect(fs.pathExists("etl.validation-report.trig")).to.eventually.be.true;
            await expect(fs.pathExists(tmpDestinationFile)).to.eventually.be.false;
        });
    });
});
//# sourceMappingURL=file.test.js.map