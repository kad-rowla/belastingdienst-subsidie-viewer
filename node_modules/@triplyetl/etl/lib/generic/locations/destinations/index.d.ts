import { Etl, Context } from "../../index.js";
import { Options as FileInfo, LdExtensions } from "../../../utils/files.js";
import { FileSourceInfo } from "../sources/index.js";
import file from "./file.js";
import rdf from "./rdf.js";
import terminal from "./terminal.js";
declare const destinations: {
    TriplyDb: {
        rdf: typeof rdf;
    };
    /**
     * This is a simplified version of Destination.TriplyDb.rdf(...)
     */
    triplyDb: (args: import("../../middlewares/destinations/toTriplyDb.js").ToTriplyDbOptions) => Destination;
    file: typeof file;
    terminal: typeof terminal;
};
export type TempFileInfo = {
    filename: string;
    remove: boolean;
};
export default destinations;
export type DestinationType = "file" | "rdf" | "terminal";
export interface Destination {
    type: DestinationType;
    /** Name for presenting to humans */
    name?: string;
    fileInfo: FileInfo<LdExtensions>;
    /**
     *  Two destinations are considered to be "the same" if they have the same
     *  fingerprint.
     */
    fingerprint: `${DestinationType}://${string}`;
    /**
     *  Initialise this destination.
     *
     *  The app guarantees this function is only called once per destination.
     */
    init: (app: Etl) => Promise<void>;
    /** Allows the destination to decide how to handle a source file */
    registerSource: (source: FileSourceInfo, tmpDir: string) => Promise<TempFileInfo>;
    /**
     *  Post-process a bunch of (possibly temporary) files.
     *
     *  The app guarantees this function is only called once per destination.
     */
    postProcess: (app: Etl, filesWithMetadata: Array<TempFileInfo>) => Promise<void>;
}
export type DestinationGetter = Destination | ((ctx: Context) => Destination | Promise<Destination>);
//# sourceMappingURL=index.d.ts.map