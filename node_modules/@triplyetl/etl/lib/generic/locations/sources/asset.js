import fs from "fs-extra";
import { getTriplyDb } from "../index.js";
import { last } from "lodash-es";
import mime from "mime";
import { assertIsDefined } from "../../../utils/asserts.js";
import path from "path";
import { parsePath, streamToString } from "../../../utils/files.js";
import { randomUUID } from "crypto";
function getLastVersionInfo(asset) {
    const versionInfo = last(asset.getInfo().versions);
    //This should never happen. An asset always has a version
    if (!versionInfo)
        throw new Error("Asset does not have any versions");
    return versionInfo;
}
function getCacheFile(cacheDir, assetObject) {
    const versionInfo = getLastVersionInfo(assetObject);
    return path.resolve(cacheDir, `${versionInfo.id}_${assetObject.getInfo().assetName}`);
}
async function fetchToCacheWhenNeeded(cacheDir, tmpDir, asset) {
    const cacheFile = getCacheFile(cacheDir, asset);
    if (!(await fs.pathExists(cacheFile))) {
        const tmpFile = path.resolve(tmpDir, randomUUID());
        await asset.toFile(tmpFile);
        // Make sure we only set the actual file after a full download
        await fs.rename(tmpFile, cacheFile);
    }
    return cacheFile;
}
export default function asset(accountNameOrDatasetName, datasetNameOrOpts, opts) {
    return {
        get: async (app) => {
            let accountName = app["_defaultAccount"];
            let datasetName;
            let assetName;
            let assetFilter;
            let version;
            if (typeof datasetNameOrOpts === "string") {
                accountName = accountNameOrDatasetName;
                datasetName = datasetNameOrOpts;
            }
            else {
                opts = datasetNameOrOpts;
                datasetName = accountNameOrDatasetName;
            }
            if (opts?.name) {
                assetName = opts?.name;
            }
            if (opts?.filter) {
                assetFilter = opts.filter;
            }
            if (opts?.version) {
                version = opts.version;
            }
            let triplydbConfig = opts?.triplyDb;
            const cacheDir = app.getCacheDir("source-asset");
            const tmpDir = app.getTmpDir("source-asset");
            await fs.ensureDir(cacheDir);
            await fs.ensureDir(tmpDir);
            const triplyDb = getTriplyDb(app, triplydbConfig);
            let assets;
            const account = await triplyDb.getAccount(accountName);
            const dataset = await account.getDataset(datasetName);
            if (assetName) {
                assets = [await dataset.getAsset(assetName, version)];
            }
            else {
                //We want to complete list
                const allAssets = await dataset.getAssets().toArray();
                if (assetFilter) {
                    assets = allAssets.filter((asset) => {
                        assertIsDefined(assetFilter, "");
                        return assetFilter(asset.getInfo().assetName, asset);
                    });
                }
                else {
                    assets = allAssets;
                }
            }
            const apiUrl = (await triplyDb.getInfo()).apiUrl;
            return assets.map((asset) => {
                async function getStream() {
                    return fs.createReadStream(await fetchToCacheWhenNeeded(cacheDir, tmpDir, asset));
                }
                const name = asset.getInfo().assetName;
                const parsedFilename = parsePath(name);
                return {
                    name: name,
                    id: async () => `asset://${apiUrl}/${account}/${dataset}/${name}/${getLastVersionInfo(asset).id}`,
                    compression: async () => parsedFilename.compression,
                    mediaType: async () => mime.getType(parsedFilename.extension) || undefined,
                    extension: async () => parsedFilename.extension,
                    getStream,
                    getString: async () => streamToString(await getStream(), parsedFilename.compression),
                    getSize: async () => {
                        const versionInfo = getLastVersionInfo(asset);
                        return versionInfo.fileSize;
                    },
                    getLocalPath: async () => fetchToCacheWhenNeeded(cacheDir, tmpDir, asset),
                };
            });
        },
    };
}
//# sourceMappingURL=asset.js.map