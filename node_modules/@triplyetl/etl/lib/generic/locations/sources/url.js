import fs from "fs-extra";
import fetch from "cross-fetch";
import { assertIsDefined, isNamedNode } from "../../../utils/asserts.js";
import { parsePath, resolveAndFilenamify, streamToString } from "../../../utils/files.js";
import { randomUUID } from "crypto";
import path from "path";
export default function url(url, request) {
    return {
        get: async (app) => {
            let $url;
            if (isNamedNode(url)) {
                $url = url.value;
            }
            else if (typeof url !== "string") {
                $url = url.toString();
            }
            else {
                $url = url;
            }
            const cacheDir = app.getCacheDir("source-url");
            await fs.ensureDir(cacheDir);
            const tmpDir = app.getTmpDir("source-url");
            await fs.ensureDir(tmpDir);
            const uncachedFile = resolveAndFilenamify(tmpDir, $url + "-" + Math.random());
            async function getFingerPrintArray() {
                const lastModified = headResponse.headers.get("Last-Modified");
                const etag = headResponse.headers.get("ETag");
                return [$url, (lastModified || "").replace(/ /g, ""), etag || ""];
            }
            async function fetchWhenNeeded() {
                let localFile;
                const fingerPrintArray = await getFingerPrintArray();
                const canCache = !!fingerPrintArray[1] || !!fingerPrintArray[2];
                if (canCache) {
                    localFile = resolveAndFilenamify(cacheDir, fingerPrintArray.join("-"));
                }
                else {
                    localFile = uncachedFile;
                }
                if (!(await fs.pathExists(localFile))) {
                    const tmpFile = path.resolve(tmpDir, randomUUID());
                    const response = await fetch($url, { ...request, redirect: "follow" });
                    if (!response.body)
                        throw new Error(`Response of ${$url} did not return a valid body`);
                    if (!response.ok)
                        throw new Error(`${response.status} - ${response.statusText}`);
                    const fileStream = fs.createWriteStream(tmpFile);
                    await new Promise((resolve, reject) => {
                        try {
                            assertIsDefined(response.body, "");
                            response.body.pipe(fileStream).on("error", reject);
                            response.body.on("error", reject);
                            fileStream.on("finish", resolve);
                        }
                        catch (e) {
                            reject(e);
                        }
                    });
                    // Make sure we only set the actual file after a full download
                    await fs.rename(tmpFile, localFile);
                }
                return localFile;
            }
            const headResponse = await fetch($url, { ...request, redirect: "follow", method: "HEAD", body: null });
            const parsedUrl = new URL($url);
            const parsedPath = parsePath(parsedUrl.pathname);
            let compression;
            if (parsedPath.compression) {
                compression = parsedPath.compression;
            }
            else if (headResponse.headers.get("Content-Encoding") === "application/gzip") {
                compression = "gz";
            }
            async function getStream() {
                const cacheFile = await fetchWhenNeeded();
                return fs.createReadStream(cacheFile);
            }
            return [
                {
                    name: $url,
                    id: async () => "url://" + (await getFingerPrintArray()).reverse().join("/"),
                    compression: async () => compression,
                    mediaType: async () => headResponse.headers.get("Content-Type") || undefined,
                    extension: async () => parsedPath.extension || undefined,
                    getStream,
                    getString: async () => streamToString(await getStream(), compression),
                    getSize: async () => {
                        const cacheFile = await fetchWhenNeeded();
                        const stat = await fs.stat(cacheFile);
                        return stat.size;
                    },
                    getLocalPath: async () => fetchWhenNeeded(),
                },
            ];
        },
    };
}
//# sourceMappingURL=url.js.map