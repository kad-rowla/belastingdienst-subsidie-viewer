import { requestConfigToFetchConfig } from "@triply/triplydb/RequestHandler.js";
import fs from "fs-extra";
import { getTriplyDb } from "../index.js";
import { resolveAndFilenamify, streamToString } from "../../../utils/files.js";
import { Readable } from "stream";
import fetch from "cross-fetch";
import md5 from "md5";
import { fileCache } from "@triply/triplydb/utils/cache.js";
export const isQuerySourceGetter = (val) => {
    return typeof val === "object" && Object.hasOwn(val, "$id") && val.$id == "QuerySourceGetter";
};
export default function (accountOrQueryName, queryNameOrOpts, optionalOpts) {
    const getQueryInfo = async (app) => {
        let accountName = app["_defaultAccount"];
        let queryName;
        let opts = optionalOpts;
        if (typeof queryNameOrOpts === "string") {
            queryName = queryNameOrOpts;
            accountName = accountOrQueryName;
        }
        else {
            queryName = accountOrQueryName;
            if (queryNameOrOpts) {
                opts = queryNameOrOpts;
            }
        }
        const triplyDb = getTriplyDb(app, opts?.triplyDb);
        const account = await triplyDb.getAccount(accountName);
        const query = await account.getQuery(queryName);
        if (typeof opts?.version === "number")
            await query.useVersion(opts.version);
        const info = await query.getInfo();
        if (info.requestConfig === undefined) {
            throw new Error("No versions found for this saved query: " + info.link);
        }
        return { triplyDb, account, query, info, opts, accountName, queryName, cacheDir: "unknown" };
    };
    const getQueryType = async (app) => {
        const queryInfo = await getQueryInfo(app);
        const cacheDir = app.getCacheDir(`source-query-string`);
        await fs.ensureDir(cacheDir);
        const queryString = await getString({ ...queryInfo, cacheDir });
        const parser = new sparqljs.Parser();
        const parsed = parser.parse(await queryString.getString());
        if (parsed.type !== "query") {
            throw new Error(`Unsupported query type '${parsed.type}'.`);
        }
        return parsed.queryType;
    };
    return {
        $id: "QuerySourceGetter",
        getQueryInfo,
        get: async function (app, requestedContentType) {
            const queryInfo = await getQueryInfo(app);
            queryInfo.cacheDir = app.getCacheDir(`source-query-${requestedContentType}`);
            await fs.ensureDir(queryInfo.cacheDir);
            let partialSourceInfo;
            switch (requestedContentType) {
                case "string":
                    partialSourceInfo = await getString(queryInfo);
                    break;
                case "statements":
                    partialSourceInfo = await getStatements(queryInfo);
                    break;
                case "boolean":
                    partialSourceInfo = await getBoolean(queryInfo);
                    break;
                case "records":
                    const queryType = await getQueryType(app);
                    if (queryType === "ASK") {
                        partialSourceInfo = await getBoolean(queryInfo);
                    }
                    else {
                        partialSourceInfo = await getBindings(queryInfo);
                    }
                    break;
            }
            const apiUrl = (await queryInfo.triplyDb.getInfo()).apiUrl;
            const sharedSourceInfo = {
                name: `${requestedContentType} of ${queryInfo.info.link}`,
                id: async () => `TriplyDb-query-${requestedContentType}://${apiUrl}/${queryInfo.accountName}/${queryInfo.queryName}/${queryInfo.info.version}`,
            };
            let sourceInfo = {
                ...sharedSourceInfo,
                ...partialSourceInfo,
            };
            return [sourceInfo];
        },
    };
}
import sparqljs from "sparqljs";
async function getString(queryInfo) {
    const { query, info, cacheDir } = queryInfo;
    // Doesn't make an additional request, as we have already made a request
    // to "info" and the query string is in that response
    const queryString = await query.getString(queryInfo.opts?.variables);
    const fingerprint = `${info.id}_${new Date(info.updatedAt).getTime()}`;
    return {
        compression: async () => undefined,
        mediaType: async () => "application/sparql-query",
        extension: async () => "rq",
        getStream: async () => Readable.from(queryString),
        getString: async () => queryString,
        getSize: async () => Buffer.from(queryString).byteLength,
        getLocalPath: async () => {
            await fs.ensureDir(cacheDir);
            const cacheFile = resolveAndFilenamify(cacheDir, fingerprint + `.rq`);
            if (!(await fs.pathExists(cacheFile))) {
                await fs.writeFile(cacheFile, queryString);
            }
            return cacheFile;
        },
    };
}
async function getBindings(queryInfo) {
    const { query, cacheDir } = queryInfo;
    return {
        getAsyncIterable: async () => query
            .results(queryInfo.opts?.variables, { cache: fileCache({ cacheDir: cacheDir, compression: "gz" }) })
            .bindings(),
        mediaType: async () => "application/json",
    };
}
async function getBoolean(queryInfo) {
    const { query, cacheDir, opts } = queryInfo;
    return {
        getBoolean: async () => {
            return query
                .results(opts?.variables, { cache: fileCache({ cacheDir: cacheDir, compression: "gz" }) })
                .boolean()
                .toArray()
                .then((askResult) => {
                if (askResult.length === 0) {
                    throw new Error("Unexpected empty ASK response.");
                }
                return askResult.pop() ?? false;
            });
        },
        mediaType: async () => "application/json",
    };
}
async function getFingerprint(url, triplyDb, variables) {
    const headResponse = await fetch(url + "/run", requestConfigToFetchConfig("HEAD", { app: triplyDb }));
    const etag = headResponse.headers.get("etag");
    // Older versions may not return the etag. In that case, fall back to a random string, i.e. we're never properly caching the result
    return etag ? `${etag}_${md5(JSON.stringify(variables || ""))}` : String(Math.random());
}
async function getStatements(queryInfo) {
    const { triplyDb, cacheDir, query, opts } = queryInfo;
    const compression = "gz";
    const extension = "nt";
    let fingerprint;
    async function fetchToCacheWhenNeeded() {
        await fs.ensureDir(cacheDir);
        if (fingerprint === undefined) {
            fingerprint = await getFingerprint(await query.getApiUrl(), triplyDb, opts?.variables);
        }
        const cacheFile = resolveAndFilenamify(cacheDir, `${fingerprint}.${extension}.${compression}`);
        if (!(await fs.pathExists(cacheFile))) {
            // create a temporary file to make sure we don't create an illegal cache
            // when something goes wrong
            const tempCacheFile = cacheFile + ".part";
            await query
                .results(opts?.variables)
                .statements()
                .toFile(tempCacheFile, { compressed: true });
            await fs.rename(tempCacheFile, cacheFile);
        }
        return cacheFile;
    }
    async function getStream() {
        const cacheFile = await fetchToCacheWhenNeeded();
        return fs.createReadStream(cacheFile);
    }
    return {
        compression: async () => compression,
        mediaType: async () => "application/n-triples",
        extension: async () => extension,
        getStream: getStream,
        getString: async () => streamToString(await getStream(), compression),
        getSize: async () => {
            const file = await fetchToCacheWhenNeeded();
            const stat = await fs.stat(file);
            return stat.size;
        },
        getLocalPath: async () => fetchToCacheWhenNeeded(),
    };
}
//# sourceMappingURL=savedQuery.js.map