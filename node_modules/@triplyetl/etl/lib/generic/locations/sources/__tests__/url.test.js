//external dependencies
import Etl from "../../../Etl.js";
import fs from "fs-extra";
import chai from "chai";
import chaiAsPromised from "chai-as-promised";
import Source from "../index.js";
import { fromCsv, fromJson } from "../../../index.js";
chai.use(chaiAsPromised);
const expect = chai.expect;
async function getLocationInfo(app, url, opts) {
    const location = Source.url(url, opts);
    const locationInfo = await location.get(app, "records");
    return locationInfo[0];
}
const ASSET_URL = "https://nightly.triplydb.com/Triply/ratt-test-assets/assets/60bf6e43d93e8d038a1df031";
let app;
const getApp = () => {
    if (app)
        return app;
    app = new Etl({ defaultGraph: "https://default.com/" });
    return app;
};
describe("Read from url", function () {
    this.timeout(4000);
    this.afterEach(async () => {
        await getApp()["removeTmpDir"]();
        app = new Etl({ defaultGraph: "https://default.com/" });
    });
    it("with invalid url", async function () {
        await expect(getLocationInfo(getApp(), "bla")).to.eventually.rejectedWith("Only absolute URLs are supported");
    });
    it("with asset url", async function () {
        const expectedFile = "./src/__tests__/resources/xmlFiles/1.xml";
        const expectedStat = await fs.stat(expectedFile);
        const location = await getLocationInfo(getApp(), ASSET_URL);
        const localPath = await location.getLocalPath();
        expect(await location.compression()).to.equal(undefined);
        expect(await location.extension()).to.be.undefined;
        expect((await fs.readFile(localPath, "utf-8")).replace(/(?:\r\n|\r|\n)/g, "")).to.equal((await fs.readFile(expectedFile, "utf-8")).replace(/(?:\r\n|\r|\n)/g, ""));
        expect(await location.getSize()).to.approximately(expectedStat.size, 100);
        expect(localPath).to.match(/(\\|\/)cache(\\|\/)/); //should not be a tmp dir. Assets have a last modified and etag header
    });
    it("downloading url twice (cached)", async function () {
        const app1 = new Etl({ defaultGraph: "https://default.com/" });
        const location1 = await getLocationInfo(app1, ASSET_URL);
        await location1.getLocalPath(); //triggers a download
        await app1["removeTmpDir"]();
        const app2 = new Etl({ defaultGraph: "https://default.com/" });
        const location2 = await getLocationInfo(app2, ASSET_URL);
        await location2.getLocalPath(); //triggers a download
        await app2["removeTmpDir"]();
    });
    it("Should throw error code with bad url", async function () {
        const etl = new Etl();
        etl.use(fromCsv(Source.url("https://aap.nl/does/not/exist")));
        await expect(etl.run()).to.eventually.rejectedWith(/404 - Not Found/);
    });
    describe("Workaround for ASK queries as a Source", function () {
        // https://git.triply.cc/triply/etl/-/issues/127
        it("Should return results a SPARQL endpoint", async function () {
            const queryString = `PREFIX%20vocab%3A%20%3Chttps%3A%2F%2Ftriplydb.com%2Facademy%2Fpokemon%2Fvocab%2F%3E%0AASK%20%7B%0A%20%20%3Fs%20vocab%3Aname%20%3Fname.%0A%20%20filter%20REGEX(str(%3Fname)%2C%20%22pika%22%2C%20%22i%22)%0A%7D`;
            const sparqlEndpoint = "https://api.nightly.triplydb.com/datasets/Triply/Pokemon/services/Pokemon/sparql";
            // Not using URL web API as it turns out it incorrectly parses the "(" found in the 'queryString'
            const manualUrl = sparqlEndpoint + "?" + "query=" + queryString;
            const askSourceGetter = Source.url(manualUrl);
            const etl = new Etl();
            etl.use(fromJson(askSourceGetter));
            etl.use((ctx, next) => {
                expect(ctx.getBoolean("boolean")).to.be.true;
                expect(ctx.store.size).to.equal(0);
                return next();
            });
            await etl.run();
        });
        // skipped awaiting resolve of https://issues.triply.cc/issues/8117
        it.skip("Should return results from a 'SavedQuery' endpoint", async function () {
            const savedQueryEndpoint = "https://api.nightly.triplydb.com/queries/Triply/ratt-ask-query-test/run?";
            const getRequest = new URL(savedQueryEndpoint);
            getRequest.searchParams.append("pokemonName", "pikachu");
            const askSourceGetter = Source.url(getRequest.toString());
            const etl = new Etl();
            etl.use(fromJson(askSourceGetter));
            etl.use((ctx, next) => {
                expect(ctx.getBoolean("boolean")).to.be.true;
                expect(ctx.store.size).to.equal(0);
                return next();
            });
            await etl.run();
        });
    });
});
//# sourceMappingURL=url.test.js.map