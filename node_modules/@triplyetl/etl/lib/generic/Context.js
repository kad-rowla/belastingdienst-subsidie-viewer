import jp from "jsonpath";
import { flatten, get as lodashGet, isString as _isString, toNumber, has, unset, once } from "lodash-es";
import { getTotalSize } from "./locations/sources/index.js";
import { assertIs, assertIsNotEmpty, assertKeyExists, getReasonWhysomethingIsEmpty, isArray, isNamedNode, isLiteral, isNumber, isString, } from "../utils/asserts.js";
import { ifPossibleCoerce } from "../utils/coercions.js";
import { Etl } from "./index.js";
import { isStatic } from "../ratt/middlewares/assertions/term/str.js";
import { coerceLiteral } from "../ratt/middlewares/assertions/statement/rdf/utils/coerceLiteral.js";
import { isJPath } from "../ratt/middlewares/assertions/term/jpath.js";
import { getFactory } from "@triplydb/data-factory";
import * as TriplyIri from "@triplydb/iri";
import { isIri } from "@triplyetl/vocabularies/lib/Classes/Iri.js";
const dataFactory = once(() => getFactory({ skipValidation: Etl.skipValidation }));
export function isKey(value) {
    return (typeof value === "string" || isJPath(value)) && !isStatic(value);
}
export function getTypedValFromRecord(ctx, key, type) {
    if (typeof type === "string") {
        switch (type) {
            case "any":
                return ctx.getAny(key);
            case "unknown":
                return ctx.getUnknown(key);
            case "string":
                return ctx.getString(key);
            case "number":
                return ctx.getNumber(key);
            case "boolean":
                return ctx.getBoolean(key);
            case "iri":
                return ctx.getIri(key);
            case "literal":
                return ctx.getLiteral(key);
        }
    }
    else if ("array" in type) {
        return ctx.getArray(key, type.array);
    }
    else {
        throw new Error(`Unexpected type ${type} requested`);
    }
}
export function getType(object, keyOrPathExpression, type, opts) {
    let value, key;
    assertKeyExists(object, keyOrPathExpression);
    if (isJPath(keyOrPathExpression)) {
        value = jp.value(object, keyOrPathExpression.toString());
        key = keyOrPathExpression.toString();
    }
    else {
        value = lodashGet(object, keyOrPathExpression);
        key = keyOrPathExpression;
    }
    if (type === "any" || type === "unknown")
        return value;
    assertIsNotEmpty(value, key);
    const coercedValue = ifPossibleCoerce(value, key, type, opts);
    assertIs(coercedValue, key, type);
    return coercedValue;
}
export default class Context {
    constructor(app) {
        this.recordId = 0;
        this.record = {};
        this.app = app;
        this.store = app.getNewStore();
    }
    //@ts-ignore Private to keep a clean interface. It's used somewhere else though
    async _registerSources(sourceGetters, requestedContentType, opts) {
        const sources = flatten(await Promise.all(sourceGetters.map(async (location) => location.get(this.app, requestedContentType))));
        if (opts?.registerTotalProgress && this.app["_totalToProcess"] === undefined) {
            this.app.setTotalProgress(await getTotalSize(sources.filter((s) => "getSize" in s)));
        }
        return sources;
    }
    hasParent() {
        return this.hasKey("$parent");
    }
    getParent() {
        if (this.hasKey("$parent")) {
            const parent = { ...this.getAny("$parent") };
            unset(parent, "$index");
            unset(parent, "$parent");
            unset(parent, "$root");
            return parent;
        }
    }
    getRoot() {
        return this.hasKey("$root") ? this.getAny("$root") : this.record;
    }
    getAny(key) {
        return isStatic(key) ? key.toString() : getType(this.record, key, "any");
    }
    getUnknown(key) {
        return getType(this.record, key, "unknown");
    }
    getString(key) {
        // currently fetching a value from a Record that is empty ('') this will throw an error.
        // We have to reconcider if this is correct. For now, we can overrule with allowEmptyString = true.
        if (isStatic(key)) {
            // to make this consistant, Etl should throw on empty static strings as well, which is a bit weird ...
            // if (key.toString() === '' && !allowEmptyString) throw new AssertionError({ message: 'static value not to be empty' })
            return key.toString();
        }
        return getType(this.record, key, "string");
    }
    getArray(key, elementType) {
        return getType(this.record, key, { array: elementType });
    }
    getTable(key) {
        return getType(this.record, key, "table");
    }
    getNumber(key) {
        return isStatic(key) ? toNumber(key.toString()) : getType(this.record, key, "number");
    }
    getBoolean(key) {
        return getType(this.record, key, "boolean");
    }
    getLiteral(key, languageOrDatatype) {
        return coerceLiteral(isStatic(key) ? key : this.getAny(key), languageOrDatatype, isStatic(key) ? `str('${key}')` : isJPath(key) ? `jsonpath('${key}')` : key, languageOrDatatype?.toString());
    }
    getIri(iriCandidate) {
        if (isIri(iriCandidate)) {
            return iriCandidate;
        }
        else if (_isString(iriCandidate)) {
            if (isStatic(iriCandidate)) {
                try {
                    return dataFactory().namedNode(new URL(iriCandidate.toString()).toString());
                }
                catch (e) {
                    throw new Error(`'${iriCandidate}': ${e.message}`);
                }
            }
            else {
                try {
                    // If this is already an Iri, we can return it
                    return getType(this.record, iriCandidate, "iri");
                }
                catch (e) {
                    // Otherwise we need a string and  cast that as an Iri
                    let iriString = "";
                    let value = this.getAny(iriCandidate.toString());
                    if (isNamedNode(value))
                        return value;
                    if (typeof value === "function") {
                        const valueFromFunction = value("");
                        if (isNamedNode(valueFromFunction))
                            return valueFromFunction;
                        if (typeof valueFromFunction !== "string") {
                            throw new Error(`Expected the key '${iriCandidate}' to contain a function that returns either an Iri or a URL string, got type '${typeof valueFromFunction}'`);
                        }
                        iriString = valueFromFunction;
                    }
                    else if (typeof value === "string") {
                        iriString = value;
                    }
                    else if (typeof value === "number") {
                        iriString = value.toString();
                    }
                    else if (typeof value === "object") {
                        throw new Error(`Key '${iriCandidate.toString()}' points to an object the Etl record, I can not process that type.`);
                    }
                    else {
                        throw new Error(`Expected a function (): Iri or IRI string for key '${iriCandidate.toString()}' in the Etl record.`);
                    }
                    try {
                        TriplyIri.validate(iriString);
                    }
                    catch (e) {
                        throw new Error(`Can not make value '${iriString}' into a valid URL.`);
                    }
                    return dataFactory().namedNode(iriString);
                }
            }
        }
        else if (typeof iriCandidate === "function") {
            return iriCandidate("");
        }
        else {
            return iriCandidate;
        }
    }
    getBnode(key) {
        return getType(this.record, key, "blankNode");
    }
    hasKey(key) {
        if (isJPath(key))
            return jp.query(this.record, key.toString()).length > 0;
        else
            return has(this.record, key);
    }
    /**
     * Check whether this key has a non empty value.
     * False is returned for:
     * - Empty strings, or strings with only whitespace
     * - Empty arrays
     * - Empty objects
     * - Values undefined and null
     */
    isNotEmpty(key) {
        if (isJPath(key))
            return jp.value(this.record, key.toString()).length > 0;
        else
            return !this.isEmpty(key);
    }
    /**
     * Check whether this key has a non empty value.
     * True is returned for:
     * - Empty strings, or strings with only whitespace
     * - Empty arrays
     * - Empty objects
     * - Values undefined and null
     */
    isEmpty(key) {
        const value = isJPath(key) ? jp.value(this.record, key.toString()) : lodashGet(this.record, key);
        return !!getReasonWhysomethingIsEmpty(value);
    }
    isLiteral(key) {
        return isLiteral(this.getAny(key));
    }
    isIri(key) {
        return isNamedNode(this.getAny(key));
    }
    isNumber(key) {
        return isNumber(this.getAny(key));
    }
    isString(key) {
        return isString(this.getAny(key));
    }
    isArray(key) {
        return isArray(this.getAny(key));
    }
    async writeQuads(quads, destinationGetter, opts) {
        const destination = typeof destinationGetter === "function" ? await destinationGetter(this) : destinationGetter;
        if (destination.fileInfo.extension === "nt" || destination.fileInfo.extension === "ttl") {
            // We're removing the graph manually now.
            // See https://github.com/rdfjs/N3.js/issues/165
            const defaultGraph = dataFactory().defaultGraph();
            quads = quads.map((q) => dataFactory().quad(q.subject, q.predicate, q.object, defaultGraph));
        }
        const stream = await this.app["getDestinationStream"](destination, opts);
        for (const quad of quads) {
            // Handling backpressure
            await new Promise((resolve, reject) => {
                try {
                    if (stream.write(quad))
                        return resolve();
                    stream.once("drain", () => resolve());
                }
                catch (e) {
                    reject(e);
                }
            });
        }
    }
}
//# sourceMappingURL=Context.js.map