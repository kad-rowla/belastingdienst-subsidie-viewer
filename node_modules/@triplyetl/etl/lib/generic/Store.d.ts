import { Store as TriplyStore } from "@triplydb/data-factory";
import { Literal, NamedNode, Quad, Term } from "@triplydb/data-factory/Terms.js";
import { Pattern } from "@triplydb/data-factory/Store.js";
import Etl from "./Etl.js";
import { LanguageTagOrDataType } from "../ratt/middlewares/assertions/term/literal.js";
import { Iri } from "@triplyetl/vocabularies";
export type OTerm = Term | string | null;
export default class Store extends TriplyStore {
    private _app;
    constructor(app: Etl);
    addQuad(quad: Quad): void;
    addQuad(subject: Quad["subject"], predicate: Quad["predicate"], object: Quad["object"] | Array<Quad["object"]>, graph?: Quad["graph"], done?: () => void): void;
    addQuads(quads: Quad[]): void;
    map(mapper: (quad: Readonly<Quad>) => undefined | Quad | Quad[], pattern?: Pattern): Quad[];
    private containsBnode;
    private blankNodesToIris;
    private wellKnownForBnode;
    createBlankNode(_suggestedName?: string): never;
    blankNodeIri(val?: string): NamedNode;
    iri(val: unknown, opts?: {
        prefix?: Iri;
    }): NamedNode;
    literal(val: unknown, languageTagOrDataType?: LanguageTagOrDataType): Literal;
    copy(): Store;
    toNquadsString(): string;
}
//# sourceMappingURL=Store.d.ts.map