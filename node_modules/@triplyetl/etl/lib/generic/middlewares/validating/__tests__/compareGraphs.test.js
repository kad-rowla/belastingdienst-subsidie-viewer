import { Etl, fromJson, when, Source, Iri, loadRdf } from "../../../index.js";
import chai, { assert } from "chai";
import chaiAsPromised from "chai-as-promised";
import { addSkolemIri, iri, pairs, str, triple } from "../../../../ratt/index.js";
import compareGraphs, { isIsomorphicReport } from "../compareGraphs.js";
import { a, sdo } from "@triplyetl/vocabularies";
import { set } from "lodash-es";
chai.use(chaiAsPromised);
const expect = chai.expect;
const John = Source.file("src/__tests__/resources/rdfFiles/john-doe.trig");
const Jane = Source.file("src/__tests__/resources/rdfFiles/jane-doe.trig");
const sources = {
    doe: Source.file("src/__tests__/resources/jsonFiles/family-doe.json"),
};
const defaultGraph = "http://ex.com/graph";
const prefixes = {
    ex: Iri("http://ex.com/"),
};
export const assertDoeFamily = () => {
    return async (ctx, next) => {
        assert.doesNotThrow(() => ctx.getNumber("$recordId"));
        assert.doesNotThrow(() => ctx.getNumber("id"));
        assert.doesNotThrow(() => ctx.getString("firstName"));
        assert.doesNotThrow(() => ctx.getString("familyName"));
        assert.equal("Doe", ctx.getString("familyName"));
        assert.equal(ctx.getNumber("id"), ctx.getNumber("$recordId"));
        ctx.app.updateStats("#Records", (val) => +(val || 0) + 1, { display: "finalReport" });
        return next();
    };
};
export const writeDoeFamily = [
    async (ctx, next) => {
        set(ctx.record, "iri", prefixes.ex.concat(ctx.getString("id")));
        return next();
    },
    pairs("iri", [a, sdo.Person], [sdo.givenName, "firstName"], [sdo.familyName, "familyName"]),
];
const getApp = () => {
    const app = new Etl({ defaultGraph, prefixes, sources });
    app.use(fromJson(sources.doe), writeDoeFamily, assertDoeFamily());
    return app;
};
const isomorphicCheck = [
    when((ctx) => ctx.getString("firstName") === "John", compareGraphs(John, { terminate: false, key: "isomorphic" })),
    when((ctx) => ctx.getString("firstName") === "Jane", compareGraphs(Jane, { terminate: false, key: "isomorphic" })),
];
describe("Testing isomorphic between graphs", () => {
    before(() => (Etl.silent = true));
    after(() => (Etl.silent = false));
    it("Should assert 2 graphs are isomorphic", async () => {
        const app = getApp();
        app.use(isomorphicCheck, async (ctx, _) => {
            expect(() => ctx.getAny("isomorphic")).to.not.throw;
            expect(isIsomorphicReport(ctx.getAny("isomorphic"))).to.be.true;
            const report = ctx.getAny("isomorphic");
            expect(report.isomorphic).to.be.true;
        });
        await app.run();
    });
    it("Should assert 2 graphs are not isomorphic", () => {
        const app = getApp();
        app.use(triple(iri(prefixes.ex, "id"), sdo.alternateName, str("J.")), isomorphicCheck, async (ctx, _) => {
            expect(() => ctx.getAny("isomorphic")).to.not.throw;
            expect(isIsomorphicReport(ctx.getAny("isomorphic"))).to.be.true;
            const report = ctx.getAny("isomorphic");
            expect(report.isomorphic).to.be.false;
        });
        return app.run();
    });
    it("Should throw when 2 graphs are not isomorphic", async () => {
        const app = getApp();
        app.use(triple(iri(prefixes.ex, "id"), sdo.alternateName, str("J.")), when((ctx) => ctx.getString("firstName") === "John", compareGraphs(Jane, { terminate: false, throw: true })), when((ctx) => ctx.getString("firstName") === "Jane", compareGraphs(John, { terminate: false, throw: true })));
        return expect(app.run()).to.eventually.be.rejectedWith(/Graphs .+ are not isomorphic/);
    });
    it("Should work with skolem iri's", async () => {
        const prefix = Iri("http://ex.com/");
        const wellKnownIriPrefix = prefix.concat(".well-known/genid/");
        const defaultGraph = prefix.concat("graph");
        const app = new Etl({ wellKnownIriPrefix, defaultGraph, prefixes: { ex: prefix } });
        app.use(addSkolemIri({ prefix, key: "bn" }), pairs(iri(prefix, str("1")), [a, sdo.Person], [sdo.givenName, str("John")], [sdo.familyName, str("Doe")], [sdo.spouse, "bn"]), pairs("bn", [a, sdo.Person], [sdo.givenName, str("Jane")]), compareGraphs(Source.file("src/__tests__/resources/rdfFiles/john-doe-with-blanknodes.trig")));
        return expect(app.run()).to.eventually.be.fulfilled;
    });
    describe("Blanknodes that share predicate and object", function () {
        // See issue: https://git.triply.cc/triply/etl/-/issues/64
        it("Should report missing bnodes", async function () {
            const etl = new Etl();
            etl.use(loadRdf(Source.file("src/generic/middlewares/validating/__tests__/resources/Bnodes-1-a.trig")), compareGraphs(Source.file("src/generic/middlewares/validating/__tests__/resources/Bnodes-1-b.trig"), {
                terminate: false,
                key: "isomorphic",
            }));
            etl.use((ctx, next) => {
                const report = ctx.getAny("isomorphic");
                if (!report.blanknodes.missing)
                    throw new Error("Should be some missing blanknodes");
                expect(Object.keys(report.blanknodes.missing).length).to.equal(1);
                expect(report.blanknodes.additional).to.be.undefined;
                return next();
            }),
                await etl.run();
        });
        it("Should report additional bnodes", async function () {
            const etl = new Etl();
            etl.use(loadRdf(Source.file("src/generic/middlewares/validating/__tests__/resources/Bnodes-2-a.trig")), compareGraphs(Source.file("src/generic/middlewares/validating/__tests__/resources/Bnodes-2-b.trig"), {
                terminate: false,
                key: "isomorphic",
            }));
            etl.use((ctx, next) => {
                const report = ctx.getAny("isomorphic");
                if (!report.blanknodes.additional)
                    throw new Error("Should be some additional blanknodes");
                expect(Object.keys(report.blanknodes.additional).length).to.equal(1);
                expect(report.blanknodes.missing).to.be.undefined;
                return next();
            }),
                await etl.run();
        });
        it("Should report missing and additional bnodes, symetrical", async function () {
            const etl = new Etl();
            etl.use(loadRdf(Source.file("src/generic/middlewares/validating/__tests__/resources/Bnodes-3-a.trig")), compareGraphs(Source.file("src/generic/middlewares/validating/__tests__/resources/Bnodes-3-b.trig"), {
                terminate: false,
                key: "isomorphic",
            }));
            etl.use((ctx, next) => {
                const report = ctx.getAny("isomorphic");
                if (!report.blanknodes.missing)
                    throw new Error("Should be some missing blanknodes");
                expect(Object.keys(report.blanknodes.missing).length).to.equal(1);
                if (!report.blanknodes.additional)
                    throw new Error("Should be some additional blanknodes");
                expect(Object.keys(report.blanknodes.additional).length).to.equal(1);
                return next();
            }),
                await etl.run();
        });
        it("Should report missing and additional bnodes, asymetrical", async function () {
            const etl = new Etl();
            etl.use(loadRdf(Source.file("src/generic/middlewares/validating/__tests__/resources/Bnodes-4-a.trig")), compareGraphs(Source.file("src/generic/middlewares/validating/__tests__/resources/Bnodes-4-b.trig"), {
                terminate: false,
                key: "isomorphic",
            }));
            etl.use((ctx, next) => {
                const report = ctx.getAny("isomorphic");
                if (!report.blanknodes.missing)
                    throw new Error("Should be some missing blanknodes");
                expect(Object.keys(report.blanknodes.missing).length).to.equal(3);
                if (!report.blanknodes.additional)
                    throw new Error("Should be some additional blanknodes");
                expect(Object.keys(report.blanknodes.additional).length).to.equal(2);
                return next();
            }),
                await etl.run();
        });
    });
});
//# sourceMappingURL=compareGraphs.test.js.map