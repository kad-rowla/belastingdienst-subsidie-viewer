import { Middleware } from "../../index.js";
export type FromOaiOptions<T extends FromOaiOptionsListRecord | FromOaiOptionsGetRecord> = T extends FromOaiOptionsListRecord ? FromOaiOptionsBase & FromOaiOptionsListRecord & CacheOverride : FromOaiOptionsBase & FromOaiOptionsGetRecord;
export interface FromOaiOptionsBase extends OaiOptions {
    /** Only include records since this date. DANGEROUS WHEN USED IN COMBINATION WITH CACHING.*/
    since?: Date;
    skipTrim?: boolean;
    skipEnrich?: boolean;
    /**
     * Choose what keys we want to get the records for.
     * Each match will produce a new record.
     * Nested keys should use dot notation:
     *
     * eg: { selectors: "header.subHeader.anotherSubheader" }
     * returns { header: { subHeader: { anotherSubheader: { key: value }}}}
     */
    selectors?: string | string[];
}
type CacheOverride = {
    /** Manually override whether the data should be cached. */
    cacheOverride?: "use cache" | "do not cache";
    /** How old the oldest record in the cache is allowed to be before the cache is fully cleared. */
    maxCacheAgeDays?: number;
};
export interface FromOaiOptionsListRecord {
    set?: ListRecordsOptions["set"];
    metadataPrefix?: ListRecordsOptions["metadataPrefix"];
    identifier?: never;
}
export interface FromOaiOptionsGetRecord {
    metadataPrefix?: GetRecordOptions["metadataPrefix"];
    identifier: GetRecordOptions["identifier"];
    set?: never;
    cacheOverride?: never;
    maxCacheAgeDays?: never;
}
/**
 * Read records from an open archive initiative API.
 *
 * See http://www.openarchives.org/OAI/openarchivesprotocol.html
 */
export default function fromOai<T extends FromOaiOptionsListRecord | FromOaiOptionsGetRecord>(opts: FromOaiOptions<T>): Middleware;
type Verb = keyof VerbOptions;
interface VerbOptions {
    Identify: {};
    ListRecords: ListRecordsOptions | {
        resumptionToken: string;
    };
    ListIdentifiers: ListRecordsOptions | {
        resumptionToken: string;
    };
    ListSets: {
        resumptionToken?: string;
    };
    ListMetadataFormats: {
        /** http://www.openarchives.org/OAI/openarchivesprotocol.html#UniqueIdentifier */
        identifier?: string;
    };
    GetRecord: GetRecordOptions;
}
type GetRecordOptions = {
    identifier: string;
    metadataPrefix: string;
};
type ListRecordsOptions = {
    metadataPrefix: string;
    set?: string;
    /** must be ISO date(time) format */
    from?: string;
    /** must be ISO date(time) format */
    until?: string;
};
/** http://www.openarchives.org/OAI/openarchivesprotocol.html#Identify */
type IdentifyResponse = {
    repositoryName: string;
    baseURL: string;
    protocolVersion: string;
    earliestDatestamp: string;
    deletedRecord: "no" | "transient" | "persistent";
    granularity: string;
    adminEmail: string | string[];
    compression?: string | string[];
    description?: {
        [key: string]: any;
    } | {
        [key: string]: any;
    }[];
};
/** http://www.openarchives.org/OAI/openarchivesprotocol.html#Record */
export type OaiRecordHeader = {
    fromCache: boolean;
    identifier: string;
    datestamp: string;
    setSpec?: string | string[];
    status?: "deleted";
};
export type OaiRecord = {
    header: OaiRecordHeader;
    metadata: any;
    about?: any[];
};
type ResumptionInfo = {
    "@completeListSize": number;
    "@cursor": number;
    /** the resumption token */
    $text?: string;
};
type SetInfo = {
    setSpec: string;
    setName: string;
};
export interface OaiOptions {
    /** URL of the OAI api, excluding the `?` and anything that follows it. */
    url: string;
    verb?: "ListRecords" | "ListIdentifiers";
    verbosity?: number;
    /** Timeout of the request to the OAI-PMH server in **minutes** (not (milli)seconds!) */
    timeout?: number;
}
export declare class Oai {
    url: string;
    verbosity: number;
    timeout: number;
    verb?: "ListRecords" | "ListIdentifiers";
    constructor(opts: OaiOptions);
    fetch<V extends Verb>(verb: V, options: VerbOptions[V]): Promise<any>;
    identify(): Promise<IdentifyResponse>;
    listMetadataFormats(): Promise<Array<{
        metadataPrefix: string;
        schema: string;
        metadataNamespace: string;
    }>>;
    GetRecord(opts: {
        identifier: VerbOptions["GetRecord"]["identifier"];
        metadataPrefix?: VerbOptions["GetRecord"]["metadataPrefix"];
    }): Promise<OaiRecord>;
    listRecordsPage(opts: VerbOptions["ListRecords"]): Promise<{
        record: OaiRecord[];
        resumptionToken?: ResumptionInfo;
    }>;
    listIdentifierPage(opts: VerbOptions["ListRecords"]): Promise<{
        record: OaiRecord[];
        resumptionToken?: ResumptionInfo;
    }>;
    listSetsPage(opts: VerbOptions["ListSets"]): Promise<{
        set: SetInfo[];
        resumptionToken?: ResumptionInfo;
    }>;
    getMetadataPrefix(metadataPrefix: string | undefined): Promise<string>;
    listSets(): Promise<SetInfo[]>;
    setsIterator(): OaiSetsIterator;
    recordsIterator(opts: RecordsIteratorOptions): OaiRecordsIterator;
}
interface RecordsIteratorOptions extends ListRecordsOptions {
    firstResponseCallback?: OaiRecordsIterator["firstResponseCallback"];
    responseCallback?: OaiRecordsIterator["responseCallback"];
}
declare class OaiRecordsIterator implements AsyncIterator<OaiRecord[]>, AsyncIterable<OaiRecord[]> {
    readonly oai: Oai;
    started: boolean;
    resumptionToken: string | undefined;
    readonly firstResponseCallback: (amount: number) => Promise<void>;
    readonly responseCallback: (completeListSize: number, cursor: number, elapsed: number) => Promise<void>;
    readonly listRecordsOptions: ListRecordsOptions;
    constructor(oai: Oai, opts: RecordsIteratorOptions);
    next(): Promise<{
        readonly done: true;
        readonly value: undefined;
    } | {
        value: OaiRecord[];
        done: boolean;
    }>;
    [Symbol.asyncIterator](): this;
}
declare class OaiSetsIterator implements AsyncIterator<SetInfo>, AsyncIterable<SetInfo> {
    oai: Oai;
    started: boolean;
    resumptionToken: string | undefined;
    /** last element of the array is next up */
    buffer: SetInfo[];
    constructor(oai: Oai);
    next(): Promise<{
        readonly done: true;
        readonly value: undefined;
    } | {
        value: SetInfo;
        done: boolean;
    }>;
    [Symbol.asyncIterator](): this;
}
export declare class OaiCache {
    readonly directory: string;
    readonly prefixSize: number;
    private constructor();
    static new(cacheDir: string): Promise<OaiCache>;
    private getCacheIdPath;
    getCacheIndentifier(): Promise<number>;
    setCacheIdentifier(cacheId: number): Promise<void>;
    readDate(name: "lastUpdated"): Promise<Date | undefined>;
    readDate(name: "cacheCreated"): Promise<Date>;
    /** Write a date (with day-precision) to the cache metadata. */
    writeDate(name: "lastUpdated" | "cacheCreated"): Promise<void>;
    /**
     *  Clear the cache.
     *  The inner promise can safely be executed while writing new entries.
     */
    clear(): Promise<{
        promise: Promise<void>;
    }>;
    /** Get a filesystem-safe unique ID for a record */
    static id(record: OaiRecord): string;
    filesystemInfo(record: OaiRecord): {
        dir: string;
        fullPath: string;
    };
    /**
     *  Iterate over all the cached records, in arbitrary order.
     *
     *  @param cutOffTimeForFilesToInclude
     *           If the last modified date of the file on disc is after
     *           `cutOffTimeForFilesToInclude` the record will be excluded.
     */
    iterate(cutOffTimeForFilesToInclude?: Date): AsyncGenerator<OaiRecord, void, unknown>;
    /**
     *  Write a record to cache. Overwrites existing entry with the same ID.
     *
     *  @returns Whether the entry already existed in the cache.
     */
    add(record: OaiRecord): Promise<boolean>;
    /**
     *  Remove a record from the cache.
     */
    remove(record: OaiRecord): Promise<void>;
    /**
     *  Count the number of entries in the cache.
     */
    countRecords(): Promise<number>;
}
export {};
//# sourceMappingURL=fromOai.d.ts.map