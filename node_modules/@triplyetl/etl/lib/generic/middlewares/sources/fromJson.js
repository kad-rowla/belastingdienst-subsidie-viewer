import { castArray, has, get, isPlainObject } from "lodash-es";
import fs from "fs-extra";
const { readFile } = fs;
import { addMwCallSiteToError, assertOneExtractorPerETL } from "../../../utils/index.js";
import trimRecordFromSource from "./util/trimRecordFromSource.js";
import { validatePaths } from "./fromXml.js";
import { isSourceGetterArray } from "../../../utils/asserts.js";
import { Etl } from "../../index.js";
// TODO @DocumentationTeam: add TS doc comment here
export default function fromJson(oneOrMoreInputs, opts) {
    const inputs = castArray(oneOrMoreInputs);
    if (inputs.length === 0)
        return async function () { };
    return addMwCallSiteToError(async function _fromJson(ctx, next) {
        assertOneExtractorPerETL(ctx.app, "fromJson");
        for await (const record of getRecords(ctx, inputs, opts)) {
            await next(opts?.skipTrim ? record : trimRecordFromSource(record), ctx.app.getNewStore());
        }
    }, { sourceFuncName: "_fromJson" });
}
async function* getRecords(ctx, inputs, opts) {
    ctx.app.setTotalProgress(inputs.length);
    const selectors = opts?.selectors ? castArray(opts.selectors) : [];
    validatePaths(selectors);
    if (isSourceGetterArray(inputs)) {
        const sources = await ctx["_registerSources"](inputs, "records");
        let records;
        for (const source of sources) {
            ctx.source = source;
            if ("getAsyncIterable" in source) {
                records = await source.getAsyncIterable();
            }
            else if ("getBoolean" in source) {
                records = [{ boolean: await source.getBoolean() }];
            }
            else {
                const jsonString = "getString" in source ? await source.getString() : await readFile(await source.getLocalPath(), "utf8");
                try {
                    records = JSON.parse(jsonString);
                }
                catch (e) {
                    if (e instanceof Error) {
                        e.message = `Failed to parse JSON ${source.name}: ${e.message}`;
                    }
                    throw e;
                }
                if (opts?.toRecords) {
                    // an array is an async iterable, even though typescript disagrees
                    records = opts.toRecords(records);
                }
                else {
                    records = castArray(records);
                }
            }
            for await (let record of records) {
                // casting because of ASK results:
                record = record;
                // one element of `inputs` per source
                ctx.app.incrementProgress(1);
                const possiblyEnrichRecord = configureEnrichment({
                    ctx,
                    fileName: source.name,
                    skipEnrich: opts?.skipEnrich,
                });
                if (selectors.length) {
                    for (const recordFound of processRecordBySelectors({ record, selectors })) {
                        possiblyEnrichRecord(recordFound);
                        yield recordFound;
                    }
                }
                else {
                    /**
                     * Return all record values
                     */
                    possiblyEnrichRecord(record);
                    yield record;
                }
            }
        }
    }
    else {
        for await (let record of inputs) {
            const possiblyEnrichRecord = configureEnrichment({
                ctx,
                skipEnrich: opts?.skipEnrich,
            });
            if (selectors.length) {
                for (const recordFound of processRecordBySelectors({ selectors, record })) {
                    possiblyEnrichRecord(recordFound);
                    yield recordFound;
                }
            }
            else {
                possiblyEnrichRecord(record);
                yield record;
            }
            // one element of `inputs` per record
            ctx.app.incrementProgress(1);
        }
    }
}
function configureEnrichment({ ctx, fileName, skipEnrich, }) {
    return function possiblyEnrichRecord(record) {
        if (skipEnrich)
            return;
        record.$recordId = ctx.recordId + 1;
        record.$environment = Etl.environment;
        if (fileName)
            record.$fileName = fileName;
    };
}
export function matchFromRecord(record, selector) {
    if (has(record, selector)) {
        // Casting here as we want any match to be a new 'Record'
        const value = get(record, selector);
        // Check to make sure its not an array or primative
        if (isPlainObject(value)) {
            value.$tagName = selector.split(".").pop();
            value.$selector = selector;
            return value;
        }
        throw new Error(`Only plain objects can be returned as records. Selector '${selector}' returned type: '${typeof value}'`);
    }
}
function processRecordBySelectors({ record, selectors }) {
    const matchesFound = [];
    for (const selector of selectors) {
        const matchFound = matchFromRecord(record, selector);
        if (!matchFound)
            continue;
        matchesFound.push(matchFound);
    }
    return matchesFound;
}
//# sourceMappingURL=fromJson.js.map