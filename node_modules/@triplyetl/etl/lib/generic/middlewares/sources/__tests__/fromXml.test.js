import { expect, assert } from "chai";
import { get, has } from "lodash-es";
import fromXml from "../fromXml.js";
import Etl from "../../../Etl.js";
import fs from "fs-extra";
import Source from "../../../locations/sources/index.js";
import { addIri, iri, literal, pairs } from "../../../../ratt/index.js";
import { a, sdo, xsd } from "@triplyetl/vocabularies";
import { getFactory } from "@triplydb/data-factory";
describe("Read xml documents", function () {
    it("Should correctly read a single XML document with Array<string> selectors", async function () {
        const app = new Etl({ defaultGraph: "https://default.com/" });
        app.use(fromXml([Source.file("./src/__tests__/resources/xmlFiles/1.xml")], {
            selectors: ["Result.ResultInfo", "Result.Performer"],
            skipEnrich: true,
        }));
        const records = [];
        app.use(async (ctx, next) => {
            records.push(ctx.record);
            await next();
        });
        await app.run();
        const expected = await fs.readJson("./src/__tests__/resources/validationFiles/1.xml.json");
        expect(records).to.deep.equal(expected);
    });
    it("Should correctly read a single XML document with 'single' string selector", async function () {
        const app = new Etl({ defaultGraph: "https://default.com/" });
        app.use(fromXml([Source.file("./src/__tests__/resources/xmlFiles/1.xml")], {
            selectors: "Result.ResultInfo",
            skipEnrich: true,
        }));
        const records = [];
        app.use(async (ctx, next) => {
            records.push(ctx.record);
            await next();
        });
        await app.run();
        const expected = await fs.readJson("./src/__tests__/resources/validationFiles/2.xml.json");
        expect(records).to.deep.equal(expected);
    });
    it("Should correctly read CDATA", async function () {
        const records = [];
        const app = new Etl({ defaultGraph: "https://default.com/" });
        app.use(fromXml(Source.file("./src/__tests__/resources/xmlFiles/cdata.xml"), {
            selectors: "employee",
            trim: false,
            skipEnrich: true,
        }));
        app.use(async (ctx, next) => {
            records.push(ctx.record);
            await next();
        });
        await app.run();
        const expected = await fs.readJson("./src/__tests__/resources/validationFiles/cdata.xml.json");
        // Fix Windows newline issue:
        const sExpected = JSON.stringify(expected).replace(/(?:\\r\\n|\\r|\\n)/g, "");
        const sActual = JSON.stringify(records).replace(/(?:\\r\\n|\\r|\\n)/g, "");
        expect(sExpected).to.deep.equal(sActual);
    });
    it("Should correctly read two XML documents", async function () {
        const app = new Etl({ defaultGraph: "https://default.com/" });
        app.use(fromXml([
            Source.file("./src/__tests__/resources/xmlFiles/1.xml"),
            Source.file("./src/__tests__/resources/xmlFiles/2.xml"),
        ], {
            selectors: ["Result.ResultInfo", "Result.Performer"],
            trim: false,
            skipEnrich: true,
        }));
        const records = [];
        app.use(async (ctx, next) => {
            records.push(ctx.record);
            await next();
        });
        await app.run();
        expect(records).to.have.lengthOf(4);
        expect(get(records[2], "RequestedPerformerLink[0].$text")).to.equal("M00000090238");
    });
    it("Should reject attempts to use overlapping selectors #1", async function () {
        const app = new Etl({ defaultGraph: "https://default.com/" });
        app.use(fromXml(Source.file("./src/__tests__/resources/xmlFiles/1.xml"), {
            selectors: ["Result.Performer", "Result"],
            trim: false,
            skipEnrich: true,
        }));
        return expect(app.run()).to.eventually.be.rejectedWith(/A pattern starts with another pattern\./);
    });
    it("Should reject attempts to use overlapping selectors #2", async function () {
        const app = new Etl({ defaultGraph: "https://default.com/" });
        app.use(fromXml(Source.file("./src/__tests__/resources/xmlFiles/1.xml"), {
            selectors: ["Result.Performer", "Result"].reverse(),
            trim: false,
            skipEnrich: true,
        }));
        return expect(app.run()).to.eventually.be.rejectedWith(/A pattern starts with another pattern\./);
    });
    it.skip("Should parse variety of files", async function () {
        const app = new Etl({ defaultGraph: "https://default.com/" });
        app.use(fromXml(
        // These files can be obtained from https://nightly.triplydb.com/Triply/ratt-test-assets/assets
        [
            // this is better, but currently we do not support access to TriplyDB without a token:
            Source.TriplyDb.asset("Triply", "ratt-test-assets", { name: "547fdedb372e32e77e431e8c39671.xml" }),
            Source.file("./547fdedb372e32e77e431e8c39671.xml"),
            Source.file("./d50070488e0e4e2c9b08baa395cdf.xml"),
            Source.file("./f59d220b06ff0b75d2f90a9592b6d.xml"),
            Source.file("./NEN-2767-4-2-v1.5-org.xml"),
        ], {
            selectors: ["Result", "nen_product"],
            trim: false,
            skipEnrich: true,
        }));
        await app.run();
    });
    it.skip("Should parse large xml file", async function () {
        this.timeout(1000 * 60 * 60 * 99999); // 99999 hours
        // this test is for running manually whenever we want to check
        // - if we've got a performance drop
        // - if we're accidentally using memory
        // 2020.12.15 :
        // ~10k records per second, memory usage is non-increasing.
        const app = new Etl({ defaultGraph: "https://default.com/" });
        const initTime = new Date().getTime();
        let recordCount = 0;
        app.use(fromXml(
        // this file can be obtained from https://data.labs.kadaster.nl/kadaster/bgt/assets/5f21f4a3b536eb0383db5e9d
        // size 2.92 gb
        Source.file("./bgt_onbegroeidterreindeel.gml.gz"), {
            selectors: ["CityModel.cityObjectMember"],
            trim: false,
            skipEnrich: true,
        }));
        app.use(async (_ctx, next) => {
            // uncomment the wait to check if backpressure is properly handled
            // await new Promise((resolve) => setTimeout(resolve,10))
            if (++recordCount % 10000 === 0) {
                console.info(Math.round(recordCount / ((new Date().getTime() - initTime) / 1000)), "records per second");
            }
            return next();
        });
        await app.run();
    });
    it("Report problematic document", async function () {
        const app = new Etl({ defaultGraph: "https://default.com/" });
        app.use(fromXml("<tag", {
            selectors: ["random.selector"],
            trim: false,
            skipEnrich: true,
        }));
        return expect(app.run()).to.eventually.be.rejectedWith(/Unclosed tag/);
    });
    it("should fix issue https://issues.triply.cc/issues/5631", async () => {
        const app = new Etl();
        app.use(fromXml(Source.file("./src/__tests__/resources/xmlFiles/issue-redmine-5631.xml"), {
            selectors: "a",
            skipEnrich: true,
        }), async (ctx, next) => {
            assert.isTrue(has(ctx.record, ""));
            assert.deepStrictEqual(ctx.getArray("", "any"), [{}]);
            const keys = ["header", "header-after"];
            keys.forEach((key) => ctx.getArray(key, "any").forEach((entry) => assert.equal(entry.$text, entry.$text.trim())));
            return next();
        });
        await app.run();
    });
    it("should parse a string containing XML", async () => {
        const app = new Etl();
        app.use(fromXml("<root><name>John Doe</name></root>", { selectors: "root", skipEnrich: true }), async (ctx, next) => {
            assert.equal(ctx.getString("name[0].$text"), "John Doe");
            return next();
        });
        await app.run();
    });
    it("should skip trimming values by default", async () => {
        const app = new Etl();
        app.use(fromXml(Source.file("./src/__tests__/resources/xmlFiles/issue-redmine-5631.xml"), {
            selectors: "a",
            trim: false,
            skipEnrich: true,
        }), async (ctx, next) => {
            assert.isTrue(has(ctx.record, ""));
            assert.deepStrictEqual(ctx.getArray("", "any"), [{}]);
            const keys = ["header", "header-after"];
            keys.forEach((key) => ctx.getArray(key, "any").forEach((entry) => {
                if (entry.$text !== "value inside")
                    assert.notEqual(entry.$text, entry.$text.trim());
            }));
            return next();
        });
        await app.run();
    });
    it("should apply a stylesheet (XSL)", async () => {
        const etl = new Etl();
        const xml = "src/__tests__/resources/xslt/family-doe.xml";
        const stylesheet = "src/__tests__/resources/xslt/stylesheet.xsl";
        etl.use(
        // load
        fromXml(Source.file(xml), {
            selectors: "rdf:RDF.sdo:Person",
            stylesheet: Source.file(stylesheet),
        }), addIri({ content: 'sdo:birthDate[0]["@rdf:datatype"]', key: "dataType" }), pairs(iri("@rdf:about"), [a, sdo.Person], [sdo.givenName, "sdo:givenName[0].$text"], [sdo.familyName, "sdo:familyName[0].$text"], [sdo.birthDate, literal("sdo:birthDate[0].$text", "dataType")]), async (ctx, next) => {
            assert.equal(ctx.store.size, 4);
            const subject = getFactory().namedNode(`https://ex.com/${ctx.recordId}`);
            assert.equal(ctx.store.getQuads({
                subject,
                predicate: sdo.givenName,
                object: getFactory().literal(ctx.recordId === 1 ? "John" : "Jane"),
            }).length, 1);
            assert.equal(ctx.store.getQuads({ subject, predicate: sdo.familyName, object: getFactory().literal("Doe") }).length, 1);
            const birthDate = ctx.store.getQuads({ subject, predicate: sdo.birthDate });
            assert.equal(birthDate.length, 1);
            assert.equal(birthDate[0].object.termType, "Literal");
            if (birthDate[0].object.termType === "Literal") {
                assert.isTrue(birthDate[0].object.datatype.equals(xsd.date));
            }
            return next();
        });
        await etl.run();
    });
    it("should fail when an incorrect stylesheet is used", async () => {
        const etl = new Etl();
        const xml = "src/__tests__/resources/xslt/family-doe.xml";
        etl.use(
        // load
        fromXml(Source.file(xml), {
            selectors: "rdf:RDF.sdo:Person",
            stylesheet: Source.file(xml),
        }));
        return expect(etl.run()).to.eventually.be.rejectedWith(/^Failed to compile your stylesheet/);
    });
    it("should read SELECT results from https://triplydb.com/academy/-/queries/3-1", async () => {
        const select = Source.TriplyDb.query("academy", "3-1", { triplyDb: { url: "https://api.triplydb.com" } });
        const app = new Etl();
        let c = 0;
        app.use(fromXml(select, { skipEnrich: true, selectors: "sparql.results.result" }));
        app.use((_, next) => {
            c++;
            return next();
        });
        await app.run();
        assert.equal(c, 2958, "Expected 2.958 pokemons from query (make sure the query actually returns this number!)");
    });
    it("should fail on XSLT with saved query", async () => {
        const select = Source.TriplyDb.query("academy", "3-1", { triplyDb: { url: "https://api.triplydb.com" } });
        const app = new Etl();
        app.use(fromXml(select, {
            skipEnrich: true,
            selectors: "sparql.results.result",
            stylesheet: Source.file("src/__tests__/resources/xslt/stylesheet.xsl"),
        }));
        return expect(app.run()).to.eventually.be.rejectedWith(/^We currently do not allow saved TriplyDB queries to be processed with XSLT.$/);
    });
    it("should read ASK results from https://triplydb.com/academy/-/queries/ask-1", async () => {
        const ask = Source.TriplyDb.query("academy", "ask-1", { triplyDb: { url: "https://api.triplydb.com" } });
        const app = new Etl();
        let c = 0;
        app.use(fromXml(ask, { skipEnrich: true, selectors: "sparql.boolean" }));
        app.use((ctx, next) => {
            c++;
            assert.isTrue(ctx.getBoolean("$text"));
            return next();
        });
        await app.run();
        assert.equal(c, 1, "Expected 1 result from query (make sure the query actually returns this number!)");
    });
});
//# sourceMappingURL=fromXml.test.js.map