import * as zlib from "zlib";
import pumpify from "pumpify";
import { Etl } from "../../index.js";
import { castArray, mapKeys, unset } from "lodash-es";
import { Readable } from "stream";
import saxophone from "saxophone";
const parseAttrs = saxophone.parseAttrs;
import through2 from "through2";
import { addMwCallSiteToError, assertOneExtractorPerETL } from "../../../utils/index.js";
import { makeAsyncXMLParser } from "../../../utils/Saxophone.js";
import xsltproc from "../../utils/xsltproc.js";
import { isQuerySourceGetter } from "../../locations/sources/savedQuery.js";
import { SparqlResultsXmlIterator } from "../utils/SparqlResultsXmlIterator.js";
async function iterateOverXml(selectors, onRecordClose, inputStream, trim = true) {
    // `currentPath` is the full path to the current tag in the xml tree, irrespective of the selectors.
    const currentPath = [];
    // `stack` is a stack with a JsonXmlNode matching a selector at the bottom (left).
    // at any time, each following node is a child of the node to the left.
    // the left-most element is what we eventually pass to the next mw.
    const stack = [];
    // Not catching errors as part of #5041, as its implementation would be too
    // complicated for this AsyncIterable
    for await (const data of makeAsyncXMLParser({ noEmptyText: true, alwaysTagClose: true })(inputStream)) {
        const [nodeType, tagName, attributes] = data;
        const currentNode = stack[stack.length - 1];
        if (nodeType === "tagopen") {
            currentPath.push(tagName);
            if (!selectors.some((selectorPath) => currentPath.join(".").startsWith(selectorPath)))
                continue;
            const node = mapKeys(parseAttrs(attributes), (_, key) => `@${key}`);
            if (currentNode) {
                // add the node as a child of its parent.
                if (!currentNode[tagName])
                    currentNode[tagName] = [];
                currentNode[tagName].push(node);
            }
            stack.push(node);
        }
        else if (nodeType === "tagclose") {
            if (stack.length === 1) {
                await onRecordClose({ ...currentNode, $selector: currentPath.join(".") });
            }
            stack.pop();
            currentPath.pop();
        }
        else if (nodeType === "text" || nodeType === "cdata") {
            // trailing data after the root-level element closing leads to a text node
            //  outside any tag. A common example of this is a trailing new-line after
            //  an xml tree. we ignore this data.
            if (!stack.length)
                continue;
            let [, text] = data;
            if (currentNode["$text"]) {
                text += currentNode["$text"];
                unset(currentNode, "$text");
            }
            // this will happen in this case: <i>Id="Code"</i><br/>(required)<br/>
            // throw new Error("The input data contains legal but unsupported XML-syntax. Please contact a developer.");
            currentNode["$text"] = trim ? text.trim() : text;
        }
    }
}
/**
 * We check to make sure none of the selector paths match
 * @param paths array of selector paths
 */
export function validatePaths(paths) {
    if (!paths.length)
        return;
    let checkingIndex = 0;
    let keepChecking = true;
    while (keepChecking) {
        for (const [i, path] of paths.entries()) {
            if (checkingIndex === i)
                continue;
            if (paths[checkingIndex].startsWith(path)) {
                throw new Error(`A pattern starts with another pattern. Conflict between:\n - ${path}\n - ${paths[checkingIndex]}`);
            }
        }
        checkingIndex++;
        if (checkingIndex === paths.length)
            keepChecking = false;
    }
}
/**
 * Read from an XML file and convert elements at paths matching a `selector` to JSON.
 * `selectors` is an array of string-arrays indicating which XML paths should be stored as a record.
 *  Example [ [ 'root', 'a' ], [ 'root', 'x', 'y' ] ] matches the `y` and `a` tag in
 *  <root><a>...</a><x><y>...</y></x></root>
 */
export default function fromXml(oneOrMoreSources, opts) {
    return addMwCallSiteToError(async function _fromXml(ctx, next) {
        assertOneExtractorPerETL(ctx.app, "fromXml");
        const selectors = castArray(opts.selectors);
        validatePaths(selectors);
        let filenameMap = new Map();
        let nonQuerySources = castArray(oneOrMoreSources).filter((src) => !isQuerySourceGetter(src));
        const querySources = castArray(oneOrMoreSources).filter((src) => isQuerySourceGetter(src));
        if (opts.stylesheet !== undefined) {
            if (typeof oneOrMoreSources === "string") {
                throw new Error("We currently do not allow static strings to be processed with XSLT.");
            }
            if (querySources.length) {
                throw new Error("We currently do not allow saved TriplyDB queries to be processed with XSLT.");
            }
            const proc = await xsltproc(ctx.app, nonQuerySources, opts.stylesheet);
            nonQuerySources = proc.sources;
            filenameMap = proc.filenameMap;
        }
        if (typeof oneOrMoreSources === "string") {
            const streamFromStatic = new Readable();
            streamFromStatic.push(oneOrMoreSources);
            streamFromStatic.push(null);
            streamFromStatic.on("data", (d) => {
                ctx.app.incrementProgress(d.length);
            });
            const stream = new pumpify.obj(streamFromStatic, through2());
            await iterateOverXml(selectors, (record) => {
                const $tagName = record.$selector === undefined ? undefined : record.$selector.split(".").pop();
                const enriched = !opts.skipEnrich
                    ? {
                        $recordId: ctx.recordId + 1,
                        $environment: Etl.environment,
                        $tagName,
                    }
                    : {};
                return next({ ...enriched, ...record }, ctx.app.getNewStore());
            }, stream, opts.trim);
        }
        else {
            for (const query of querySources) {
                for await (const xml of new SparqlResultsXmlIterator(ctx.app, query)) {
                    const rs = new Readable();
                    rs.on("data", (d) => {
                        ctx.app.incrementProgress(d.length);
                    });
                    rs.push(xml);
                    rs.push(null);
                    const stream = new pumpify.obj(rs, through2());
                    await iterateOverXml(selectors, (record) => {
                        const $tagName = record.$selector === undefined ? undefined : record.$selector.split(".").pop();
                        const enrichement = opts.skipEnrich
                            ? {}
                            : {
                                $recordId: ctx.recordId + 1,
                                $environment: Etl.environment,
                                $tagName,
                            };
                        return next({ ...enrichement, ...record }, ctx.app.getNewStore());
                    }, stream, opts.trim);
                }
            }
            const sources = await ctx["_registerSources"](nonQuerySources, "records", {
                registerTotalProgress: true,
            });
            for (const source of sources) {
                ctx.source = source;
                const rs = await source.getStream();
                rs.on("data", (d) => {
                    ctx.app.incrementProgress(d.length);
                });
                const stream = new pumpify.obj(rs, (await source.compression()) === "gz" ? zlib.createGunzip() : through2());
                await iterateOverXml(selectors, (record) => {
                    const $tagName = record.$selector === undefined ? undefined : record.$selector.split(".").pop();
                    const enrichement = {
                        $recordId: ctx.recordId + 1,
                        $environment: Etl.environment,
                        $tagName,
                    };
                    if (filenameMap.has(source.name)) {
                        if (filenameMap.get(source.name) !== undefined) {
                            enrichement.$fileName = filenameMap.get(source.name);
                        }
                    }
                    else {
                        enrichement.$fileName = source.name;
                    }
                    const enriched = !opts.skipEnrich ? enrichement : {};
                    return next({ ...enriched, ...record }, ctx.app.getNewStore());
                }, stream, opts.trim);
            }
        }
    }, { sourceFuncName: "_fromXml" });
}
//# sourceMappingURL=fromXml.js.map