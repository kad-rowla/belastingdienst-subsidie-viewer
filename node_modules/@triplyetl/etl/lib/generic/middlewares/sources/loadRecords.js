import { Etl } from "../../index.js";
import { addMwCallSiteToError } from "../../../utils/index.js";
class OnlyOnce {
    constructor() { }
}
OnlyOnce.instance = new Map();
/**
 * Runs a sub ETL and stores the records that are created to a single key of the main ETL.
 * Make sure to call this Middleware after you load your source data with one of the `from...()` mw's!
 *
 * @param fromSrc - The Source to load the data from, use one of the `from...` middlewares, but any middleware can be used.
 * @param key - A new key where the loaded Records are stored.
 *
 * @example
 *
 * ```ts
 * const content = Ratt.Source.TriplyDb.asset("Triply", "ratt-test-assets", {
 *   name: "tableMap.json",
 *   triplyDb: { url: "https://api.nightly.triplydb.com" },
 * });
 *
 * const etl = new Ratt()
 * etl.use(
 *   loadRecords(fromJson(content), 'countries.table'}),
 *   fromJson({country: 'be'}),
 *    translateAll({
 *       content: "country",
 *       table: "countries.table[0]",
 *       key: "countryAsIri",
 *     }),
 *   triple(iri("countryAsIri"), a, sdo.Country)
 * )
 * ```
 *
 * This results in the following linked data assertions:
 *
 * ```ttl
 * <http://ex.com/Belgium> a sdo.Country .
 * ```
 */
export default function loadRecords(fromSrc, key) {
    return addMwCallSiteToError(async function _loadRecords(ctx, next) {
        if (ctx.hasKey(key)) {
            throw new Error(`key '${key}' already exists`);
        }
        let records = [];
        if (OnlyOnce.instance.has(ctx.app.id)) {
            records = OnlyOnce.instance.get(ctx.app.id);
        }
        else {
            const etl = new Etl();
            etl.use(fromSrc, async (ctx, next) => {
                records.push(ctx.record);
                return next();
            });
            await etl.run();
        }
        ctx.record[key] = records;
        OnlyOnce.instance.set(ctx.app.id, records);
        return next();
    }, { sourceFuncName: "_loadRecords" });
}
//# sourceMappingURL=loadRecords.js.map