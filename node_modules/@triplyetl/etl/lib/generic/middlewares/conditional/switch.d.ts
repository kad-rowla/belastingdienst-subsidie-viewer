import { Context, Middleware, MiddlewareList, Key } from "../../index.js";
type CaseWhen = [string | ((context: Context) => boolean), Middleware | MiddlewareList];
type ArrayofAtLeatsOne<T> = [T, ...T[]];
/**
 * using a double underscore here as we are wrapping this function here:
 * @see _switch
 * by our own convention, single underscores are reserved for function names in
 * @see addMwCallSiteToError
 */
export declare function __switch(key: Key, ...cases: ArrayofAtLeatsOne<CaseWhen | Middleware | MiddlewareList>): MiddlewareList<unknown>;
/**
 * Switch between different cases, based on the value of a specified key.
 *
 * @param key The key whose value is compared against the specified values.
 * @param cases One or more cases.  Each case is represented by a pair.
 *        The first element of the pair is the value that is checked for
 *        equivalence with the value in `key`.  The second element is either
 *        one middleware or a list of middlewares.
 *        Whenever the value in `key` is equal to the value in one of the
 *        cases, the corresponding middleware(s) are run.
 *
 * Notice that we must write `conditional.switch()` because `switch` is a
 * reserved keyword.
 *
 * @throws An error is emitted if the value for `key` does not match any of the
 *         cases.
 *
 * @example
 * When an ETL uses multiple data sources, we can use a `switch()` to run a
 * dedicated sub-ETL for each data source.
 *
 * Suppose we have two tabular data sources: `file.episodes` and `file.people`.
 * We can use the following `switch()` statement to run different sub-ETLs:
 *
 * ```ts
 * conditional.switch(key.fileName,
 *   [file.episodes, etl_episodes],
 *   [file.people, etl_people],
 * ),
 * ```
 *
 * @example
 * When ETLs transform different kinds of entities, it can be useful
 * run a sub-ETL based on the type of entity.
 *
 * For example, if the current Etl Record represents a person we want to
 * assert their age.  But if the current Etl Record represents a location we
 * want to assert its latitude and longitude,
 *
 * This is a great use case for `switch()`:
 *
 * ```ts
 * const etl_location = [
 *   triple('iri', sdo.latitude, literal('lat', xsd.double)),
 *   triple('iri', sdo.longitude, literal('long', xsd.double)),
 * ]
 *
 * const etl_person = [
 *   triple('iri', sdo.age, literal('age', xsd.nonNegativeInteger)),
 * ]
 *
 * etl.run(
 *   conditional.switch('type',
 *     ['location', etl_location],
 *     ['person', etl_person],
 *   ),
 * )
 */
export default function _switch(key: string, ...cases: ArrayofAtLeatsOne<CaseWhen | Middleware | MiddlewareList>): MiddlewareList;
export {};
//# sourceMappingURL=switch.d.ts.map