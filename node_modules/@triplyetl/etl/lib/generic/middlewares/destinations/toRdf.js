import { unknownValToIri } from "../../../utils/coercions.js";
import { flatten } from "lodash-es";
function asPattern(graphOrPattern) {
    if (typeof graphOrPattern === "string") {
        return { graph: unknownValToIri(graphOrPattern) };
    }
    else if ("graph" in graphOrPattern) {
        return graphOrPattern;
    }
    else {
        return { graph: graphOrPattern };
    }
}
export default function (destination, opts) {
    const includePatterns = opts?.includeGraphs ? opts.includeGraphs.map((include) => asPattern(include)) : undefined;
    return async function _toRdf(ctx, next) {
        let quads = [];
        if (includePatterns) {
            if (ctx.app.staticStore) {
                quads.push(...flatten(includePatterns.map((pattern) => ctx.app.staticStore.getQuads(pattern))));
            }
            quads.push(...flatten(includePatterns.map((pattern) => ctx.store.getQuads(pattern))));
        }
        else {
            if (ctx.app.staticStore) {
                quads.push(...ctx.app.staticStore.getQuads({}));
            }
            quads.push(...ctx.store.getQuads({}));
        }
        ctx.app.staticStore = undefined;
        if (opts?.excludeGraphs) {
            const graphsToExclude = opts.excludeGraphs.map((g) => unknownValToIri(g));
            quads = ctx.store.getQuads({}).filter((quad) => {
                const shouldExclude = graphsToExclude.some((excludeGraph) => quad.graph.equals(excludeGraph));
                return !shouldExclude;
            });
        }
        if (quads.length) {
            // Track the exact number for the final report
            // Track a human readable (less exact) string for the runtime stats
            const currentNumQuads = +ctx.app.getStats("finalReport")["#Statements"];
            ctx.app.updateStats("#Statements", currentNumQuads, { display: "runtime" });
            await ctx.writeQuads(quads, destination);
        }
        return next();
    };
}
//# sourceMappingURL=toRdf.js.map