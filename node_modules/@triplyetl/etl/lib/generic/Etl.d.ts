/// <reference types="node" resolution-mode="require"/>
import TriplyDb, { AppConfig as TriplyDbConfig } from "@triply/triplydb/App.js";
import { EventEmitter } from "events";
import { Location } from "get-current-line";
import { Environment, Middleware, MiddlewareList, Store } from "./index.js";
import { Record } from "./Record.js";
import Context, { Key } from "./Context.js";
import { Destination, DestinationGetter } from "./locations/destinations/index.js";
import { FileSourceInfo, SourceGetter, SourceInfo } from "./locations/sources/index.js";
import { NamedNodeCompatibleType } from "../utils/index.js";
import { SerializedTraceInfo } from "../utils/Error.js";
import { NamedNode } from "@triplydb/data-factory/Terms.js";
import { Iri } from "@triplyetl/vocabularies";
export declare const DEFAULT_BASE_IRI = "https://triplydb.com";
export declare const DEFAULT_GRAPH_IRI: string;
export interface Iris {
    [key: string]: Iri;
}
export interface Config<P extends Iris, S extends {
    [key: string]: SourceGetter<any, SourceInfo>;
}, D extends {
    [key: string]: DestinationGetter;
}> {
    /**
     * List of prefixes. To access these later on, use `app.prefix.<prefix>`
     */
    prefixes: P;
    /**
     * Default graph when writing quads
     */
    defaultGraph: NamedNodeCompatibleType;
    /**
     * Base iri for generating skolem iri's and default prefixes/graphnames.
     * NOTE: This configuration property does not yet support IRIs that are not URIs.
     */
    baseIri: string | NamedNode;
    /**
     * Prefix for well-known IRIs (skolemised blank-nodes). If not provided it will use the `baseIri` setting.
     */
    wellKnownIriPrefix: Iri | string;
    /**
     * Sources that you can use in your ETL. To access these, use `app.sources.<source-name>`
     */
    sources: S;
    /**
     * Destinations that you can use in your ETL. To access these, use `app.destinations.<source-name>`
     */
    destinations: D;
}
type ConfigArg<P extends Iris, S extends {
    [key: string]: SourceGetter<any, SourceInfo>;
}, D extends {
    [key: string]: DestinationGetter;
}> = Partial<Config<P, S, D>>;
/**
 * Stats are statistics we track for a complete Etl run
 * These are used by the CLI to draw the final report, and optionally shown at real-time
 */
export interface Stats {
    [label: string]: string | number;
}
type AfterHookFn = (etlFinishedSuccessfully: boolean) => void | Promise<void>;
type BeforeHookFn = () => void | Promise<void>;
export interface CliContext {
    triplydb?: TriplyDb;
    wellKnownIriPrefix?: Iri;
    offset?: number;
    limit?: number;
    timeout?: number;
    dataDir?: string;
    account?: string;
    verbosity?: number;
    debugTrace?: SerializedTraceInfo;
    errorTrace?: boolean;
    createErrorTrace?: boolean;
}
export type InitEtl = () => Etl | Promise<Etl>;
/**
 * Messages are logged by default. They are also shown (as a counter) in the final report and real-time
 */
export type MessageLevel = "Error" | "Violation" | "Warning" | "Info";
export interface Message {
    type: "Shacl" | "Etl";
    level: MessageLevel;
    label: string;
    message: string;
    count: number;
}
export type Status = "idle" | "running" | "afterHook" | "beforeHook" | "done" | "error";
export interface AfterHookDuration {
    name: string;
    duration: bigint;
    callsite?: Location;
}
export type MwRuntimeInfo = {
    timerStart?: bigint;
    trailingMwDuration: bigint;
    runtime: bigint;
    /**
     * nested position of middlewares using an array of index values.
     * when calling a middleware inside a forEach, the array length increases,
     * and a new mw index value is created.
     */
    mwIndicesPosition: Array<number>;
    functionName: string;
    callSite: Location | undefined;
    numOfRecords: number;
    timesCalled: number;
    whenMwDepth: number | undefined;
};
interface Etl<P extends Iris, S extends {
    [key: string]: SourceGetter<any, SourceInfo>;
}, D extends {
    [key: string]: DestinationGetter;
}> {
    on(event: "progress", listener: (progress: number) => void): this;
    off(event: "progress", listener: (progress: number) => void): this;
    emit(event: "progress", progress: number): boolean;
    on(event: "finished", listener: (stats: Stats) => void): this;
    off(event: "finished", listener: (stats: Stats) => void): this;
    emit(event: "finished", stats: Stats): boolean;
    on(event: "message", listener: (statusMessage: Message) => void): this;
    off(event: "message", listener: (statusMessage: Message) => void): this;
    emit(event: "message", statusMessage: Message): boolean;
    on(event: "stats", listener: (stats: Stats) => void): this;
    off(event: "stats", listener: (stats: Stats) => void): this;
    emit(event: "stats", stats: Stats): boolean;
    on(event: "status", listener: (status: Status) => void): this;
    off(event: "status", listener: (status: Status) => void): this;
    emit(event: "status", status: Status): boolean;
}
declare class Etl<P extends Iris = {}, S extends {
    [key: string]: SourceGetter<any, SourceInfo>;
} = {}, D extends {
    [key: string]: DestinationGetter;
} = {}> extends EventEmitter {
    private _totalToProcess;
    private _processedAbsolute;
    private _processedPercentage;
    private _runtimeStats;
    private _reportStats;
    private _startTime?;
    private _beforeDuration?;
    private _after;
    private _afterDurations;
    private _before;
    private _destinationPostProcess;
    private readonly offset;
    private readonly limit?;
    private readonly createErrorTrace;
    private readonly _timeout?;
    status: Status;
    static silent: boolean;
    extractorName?: string;
    static skipValidation: boolean;
    prefix: Iris;
    /**
     * String that is different for every app
     */
    readonly id: string;
    readonly defaultGraph: NamedNode;
    readonly wellKnownIri: Iri;
    /**
     * The baseIri used for all other Iri's. Trailing slashes will always be removed!
     */
    readonly baseIri: Iri;
    readonly verbosity: number;
    private middlewares;
    private _dataDir;
    private _fromCli;
    private touchedMiddlewares;
    sources: S;
    destinations: D;
    private _triplyDb?;
    private currentMwIndices;
    private _defaultAccount?;
    private debugTrace;
    private errorTrace;
    private mwRuntimesObj;
    private afterMiddlewaresFromConfig;
    private readonly _runId;
    constructor(conf?: ConfigArg<P, S, D>);
    get dataFactory(): {
        fromTerm: <T extends import("rdf-js").Term>(term: T, opts?: {
            validationStatus?: import("@triplydb/data-factory/Terms.js").ValidationStatus | undefined;
        } | undefined) => import("@triplydb/data-factory/Terms.js").TermTypeToTerm[T["termType"]];
        fromQuad: (term: import("rdf-js").Quad) => import("@triplydb/data-factory/Terms.js").Quad<{
            subject: NamedNode<string> | import("@triplydb/data-factory/Terms.js").Quad<import("@triplydb/data-factory/Terms.js").BaseQuad> | import("@triplydb/data-factory/Terms.js").BlankNode | import("@triplydb/data-factory/Terms.js").Variable;
            predicate: NamedNode<string> | import("@triplydb/data-factory/Terms.js").Variable;
            object: NamedNode<string> | import("@triplydb/data-factory/Terms.js").Literal<string> | import("@triplydb/data-factory/Terms.js").Quad<import("@triplydb/data-factory/Terms.js").BaseQuad> | import("@triplydb/data-factory/Terms.js").BlankNode | import("@triplydb/data-factory/Terms.js").Variable;
            graph: NamedNode<string> | import("@triplydb/data-factory/Terms.js").DefaultGraph | import("@triplydb/data-factory/Terms.js").BlankNode | import("@triplydb/data-factory/Terms.js").Variable;
        }>;
        resetBnodeCounter: () => void;
        prefixer: <Prefix extends string>(base: Prefix | NamedNode<Prefix>) => <Suffix extends string>(local: Suffix) => NamedNode<`${Prefix}${Suffix}`>;
        isValidSubject: (term: import("@triplydb/data-factory/Terms.js").Term) => term is NamedNode<string> | import("@triplydb/data-factory/Terms.js").Quad<import("@triplydb/data-factory/Terms.js").BaseQuad> | import("@triplydb/data-factory/Terms.js").BlankNode | import("@triplydb/data-factory/Terms.js").Variable;
        isValidPredicate: (term: import("@triplydb/data-factory/Terms.js").Term) => term is NamedNode<string> | import("@triplydb/data-factory/Terms.js").Variable;
        isValidObject: (term: import("@triplydb/data-factory/Terms.js").Term) => term is NamedNode<string> | import("@triplydb/data-factory/Terms.js").Literal<string> | import("@triplydb/data-factory/Terms.js").Quad<import("@triplydb/data-factory/Terms.js").BaseQuad> | import("@triplydb/data-factory/Terms.js").BlankNode | import("@triplydb/data-factory/Terms.js").Variable;
        isValidGraph: (term: import("@triplydb/data-factory/Terms.js").Term) => term is NamedNode<string> | import("@triplydb/data-factory/Terms.js").DefaultGraph | import("@triplydb/data-factory/Terms.js").BlankNode | import("@triplydb/data-factory/Terms.js").Variable;
        literal: {
            (value: string, languageOrDataType?: string | import("rdf-js").NamedNode<string> | undefined, opts?: {
                validationStatus?: import("@triplydb/data-factory/Terms.js").ValidationStatus | undefined;
            } | undefined): import("@triplydb/data-factory/Terms.js").Literal<string>;
            (value: number | boolean, languageTagOrDatatype: string | import("rdf-js").NamedNode<string>, opts?: {
                validationStatus?: import("@triplydb/data-factory/Terms.js").ValidationStatus | undefined; /**
                 * Sources that you can use in your ETL. To access these, use `app.sources.<source-name>`
                 */
            } | undefined): import("@triplydb/data-factory/Terms.js").Literal<string>;
        };
        namedNode: (<Iri_1 extends string = string>(iri: Iri_1, opts?: {
            validationStatus?: import("@triplydb/data-factory/Terms.js").ValidationStatus | undefined;
        } | undefined) => NamedNode<Iri_1>) & import("lodash").MemoizedFunction;
        blankNode: (name?: string | undefined) => import("@triplydb/data-factory/Terms.js").BlankNode;
        defaultGraph: () => import("@triplydb/data-factory/Terms.js").DefaultGraph;
        quad: (subject: NamedNode<string> | import("@triplydb/data-factory/Terms.js").Quad<import("@triplydb/data-factory/Terms.js").BaseQuad> | import("@triplydb/data-factory/Terms.js").BlankNode | import("@triplydb/data-factory/Terms.js").Variable, predicate: NamedNode<string> | import("@triplydb/data-factory/Terms.js").Variable, object: NamedNode<string> | import("@triplydb/data-factory/Terms.js").Literal<string> | import("@triplydb/data-factory/Terms.js").Quad<import("@triplydb/data-factory/Terms.js").BaseQuad> | import("@triplydb/data-factory/Terms.js").BlankNode | import("@triplydb/data-factory/Terms.js").Variable, graph?: NamedNode<string> | import("@triplydb/data-factory/Terms.js").DefaultGraph | import("@triplydb/data-factory/Terms.js").BlankNode | import("@triplydb/data-factory/Terms.js").Variable | undefined) => import("@triplydb/data-factory/Terms.js").Quad<{
            subject: NamedNode<string> | import("@triplydb/data-factory/Terms.js").Quad<import("@triplydb/data-factory/Terms.js").BaseQuad> | import("@triplydb/data-factory/Terms.js").BlankNode | import("@triplydb/data-factory/Terms.js").Variable;
            predicate: NamedNode<string> | import("@triplydb/data-factory/Terms.js").Variable;
            object: NamedNode<string> | import("@triplydb/data-factory/Terms.js").Literal<string> | import("@triplydb/data-factory/Terms.js").Quad<import("@triplydb/data-factory/Terms.js").BaseQuad> | import("@triplydb/data-factory/Terms.js").BlankNode | import("@triplydb/data-factory/Terms.js").Variable;
            graph: NamedNode<string> | import("@triplydb/data-factory/Terms.js").DefaultGraph | import("@triplydb/data-factory/Terms.js").BlankNode | import("@triplydb/data-factory/Terms.js").Variable;
        }>;
        variable: (name: string) => import("@triplydb/data-factory/Terms.js").Variable;
    };
    private getBaseIri;
    get baseUrl(): URL;
    private _setStatus;
    private _messageCounts;
    private toMessageObject;
    private setMwIndices;
    private startMwTimer;
    private addToMwTimerTrailingDuration;
    private endMwTimer;
    private debugTraceToDispatchOpts;
    private logMessage;
    private registeredDestinations;
    copySource(source: SourceGetter<"statements", FileSourceInfo>, destination: Destination): Promise<void>;
    private getDestinationInfo;
    private getDestinationStream;
    private flushWriters;
    private postProcessFactory;
    private getUntouchedMiddlewares;
    private markMwTouched;
    private removeTmpDir;
    static get token(): string | undefined;
    get triplyDb(): TriplyDb;
    get skolemIri(): NamedNode;
    static get environment(): Environment;
    getNewStore(): Store;
    /**
     * Set expected total progress of this Etl run. Can be any number (e.g. byte-size, array length).
     */
    setTotalProgress(size: number): void;
    /**
     * Add to the current progress of the Etl run. Can be any number (e.g.
     * bytes processed, number of processed array elements). This function is
     * typically used in the first Etl middleware
     */
    incrementProgress(processed: number): number;
    showProgress(): void;
    /**
     * Print and emit error message
     */
    error(message: string | Pick<Message, "message" | "label">): void;
    /**
     * Print and emit violation message
     */
    violation(message: string | Pick<Message, "message" | "label">, type?: "Shacl" | "Etl"): void;
    /**
     * Print and emit warning message
     * @param type type of warning message (SHACL validation severity or ETL warning)
     */
    warn(message: string | Pick<Message, "message" | "label">, type?: "Shacl" | "Etl"): void;
    /**
     * Print and emit info message
     * @param type type of warning message (SHACL validation severity or ETL warning)
     */
    info(message: string | Pick<Message, "message" | "label">, type?: "Shacl" | "Etl"): void;
    /**
     * Update Etl run statistics. These can be displayed at runtime, or only in the final report
     */
    updateStats(label: string, value: number | string | undefined | ((v: number | string | undefined) => number | string | undefined), opts?: {
        display: "runtime" | "finalReport";
    }): void;
    getStats(type: "runtime" | "finalReport"): Stats;
    after(fn: AfterHookFn, options?: {
        always: boolean;
    }): void;
    before(fn: BeforeHookFn): void;
    setDataDir(dataDir: string): void;
    getDataDir(...subpaths: string[]): string;
    getCacheDir(...subpaths: string[]): string;
    getTmpDir(...subpaths: string[]): string;
    setTriplyDb(triplyDb: TriplyDb | TriplyDbConfig): TriplyDb;
    get standardPrefixes(): {
        /**
         * The IRI prefix for blank node-replacing well-known IRIs.
         */
        skolem: Iri<`${string}//${string}${string}/.well-known/genid/`>;
        /**
         * The IRI prefix for graph names.
         */
        graph: Iri<`${string}/graph/`>;
        /**
         * The IRI prefix for SKOS concepts.
         */
        con: Iri<`${string}/model/con/`>;
        /**
         * The IRI prefix for definitions, i.e. OWL classes and OWL properties.
         */
        def: Iri<`${string}/model/def/`>;
        /**
         * The IRI prefix for instances.
         */
        id: Iri<`${string}/id/`>;
        /**
         * The IRI prefix for SKOS concept schemes.
         */
        scheme: Iri<`${string}/model/scheme/`>;
        /**
         * The IRI prefix for SHACL shapes.
         */
        shp: Iri<`${string}/model/shp/`>;
    };
    /**
     * Function for creating graph names that follow [the Triply IRI
     * Strategy](https://triplydb.com/how-to-model/-/stories/how-to-model-iris).
     *
     * Many datasets have a repeating core set of graph names, e.g. 'metadata',
     * 'report', 'model', and 'instances'.  This function makes such common graph
     * names available within the given prefix/namespace.
     */
    get standardGraphs(): {
        /**
         * The name of the default graph.
         *
         * In TriplyDB the default graph is a named graph with this name.
         */
        default: Iri<`${string}/graph/default`>;
        /**
         * The name of the graph that contains instance data.
         */
        instances: Iri<`${string}/graph/instances`>;
        /**
         * The graph that contains the metadata that described this dataset.
         */
        metadata: Iri<`${string}/graph/metadata`>;
        /**
         * The name of the graph that contains the meta-model.
         *
         * The meta-model is used to verify the correctness of the data model
         * and/or dataset metadata.
         */
        metamodel: Iri<`${string}/graph/metamodel`>;
        /**
         * The name of the graph that contains the data model.
         */
        model: Iri<`${string}/graph/model`>;
        /**
         * The name of the graph that contains the SHACL validation report.
         */
        report: Iri<`${string}/graph/report`>;
    };
    /**
     * Register one or more middlewares
     */
    use<R = unknown>(...middlewaresArray: MiddlewareList<R>): Etl;
    /**
     * Conditionally register one er more middlewares
     */
    useWhen<R = unknown>(when: string | UseWhenCb<R>, ...middlewaresArray: MiddlewareList<R>): void;
    /**
     * Run the Etl app
     */
    run(): Promise<{
        [x: string]: string | number;
    }>;
    staticStore?: Store;
    staticAssertions(...mws: Middleware[]): Promise<this>;
    /**
     * Statics
     */
    static CliContext: CliContext | undefined;
}
export default Etl;
export type UseWhenCb<R> = ((context: Context<R>) => boolean | Promise<boolean>) & {
    sourceFuncName?: string;
    callsite?: Location;
};
/**
 * Run one or more middlewares when some condition is met.
 *
 * @param when - The condition under which the middlewares are run.  This is
 * either a key or a function that takes the Etl Context and returns a
 * Boolean value.
 *
 * If the condition is a key, the middlewares are run if (i) the key exists
 * and (ii) has a value that is non-empty.  The value for a key is considered
 * empty if it is `undefined`, `null`, the empty string (`''`), the empty
 * array (`[]`), or the empty object (`{}`).
 *
 * If the condition is a function, its signature is `ctx => boolean`.
 *
 * @param middleware - An array with zero or more middlewares.
 *
 * @example
 * The following snippet always asserts the last name of a person, and
 * optionally asserts the first name if it is present:
 *
 * ```ts
 * fromJson([
 *   { id: '123', first: 'John', last: 'Doe' },
 *   { id: '456', last: 'Smith' },
 * ]),
 * addIri({
 *   prefix: prefix.person,
 *   content: 'id',
 *   key: '_person',
 * }),
 * triple('_person', foaf.lastName, 'last'),
 * when('first', [
 *   triple('_person', foaf.firstName, 'first'),
 * ]),
 * ```
 *
 * This results in the following linked data assertions:
 *
 * ```ttl
 * person:123
 *   foaf:firstName 'John';
 *   foaf:lastName 'Doe'.
 * person:456 lastName 'Smith'.
 * ```
 *
 * @example
 * The following snippet shows assertions that are only made if two keys are
 * present in the Etl Record:
 *
 * ```ts
 * fromJson([
 *   { id: '123', first: 'John', last: 'Doe' },
 *   { id: '456', last: 'Smith' },
 * ]),
 * when(ctx => ctx.hasString('first') && ctx.hasString('last'), [
 *   couples(iri(prefix.person, 'id'), [
 *     [foaf.firstName, 'first'],
 *     [foaf.lastName, 'last'],
 *   ]),
 * ]),
 * ```
 */
export declare function whenMw<R = unknown>(when: Key | UseWhenCb<R>, ...middlewaresArray: MiddlewareList<R>): Array<Middleware<R>>;
export interface DispatchOpts {
    mwIndex?: number;
    record?: unknown;
    store?: Store;
}
export type DispatchFn = (dispatchOpts?: DispatchOpts) => Promise<bigint>;
export declare function composeMiddlewares(opts: {
    middlewares: Middleware[];
    context: Context;
    onNextRecord?: (context: Context) => "skipRecord" | void;
    onEnd?: (context: Context) => void;
    store?: Store;
    record?: Record;
}): DispatchFn;
//# sourceMappingURL=Etl.d.ts.map