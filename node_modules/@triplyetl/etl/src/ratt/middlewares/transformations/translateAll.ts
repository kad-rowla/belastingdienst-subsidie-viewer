import { get, has } from "lodash-es";
import { Context, Key, Middleware } from "../../../generic/index.js";
import { addMwCallSiteToError } from "../../../utils/index.js";
import { StaticString } from "../assertions/term/str.js";
import { add } from "./custom/add.js";
import { Vocabulary } from "@triplyetl/vocabularies";

/**
 * Translates all dynamic strings from a specific key to new values of an
 * arbitrary type `To`, according to a specified translation table.
 *
 * @remarks
 * Since this function translates *all* values, the mapped values can have any
 * type `T`; they do not need to be strings.  For example, this allows strings
 * to be translated to IRIs or to literals.
 *
 * @param args.content - A key that contains a string value.
 *
 * @param args.table - A translation table from strings to values of some
 * arbitrary type `T`.
 *
 * @param args.nulls - Optionally, a list of string values that are considered
 * denote NULL values in the source data.  When a NULL value is encountered,
 * the special value `undefined` is added for the target `key`.
 *
 * @param args.default - Optionally, a default value or a default
 * value-determining function that is used for string values that are neither
 * in the translation table (`table`) nor in the NULL values list (`nulls`).
 * The function must return a value of type `T`.
 * Use of a default value `value` is equivalent to using the following
 * value-determining function: `_ => value`.
 *
 * @param args.key - A new key where the results of the translation are
 * stored.
 *
 * @example
 * Suppose that source data contains country names.  In RDF we want to use
 * IRIs to denote countries, so that we can link additional information.
 * Since the list of countries that appear in the source data is not that
 * long, we can specify a translation table from names to IRIs by hand:
 *
 * ```ts
 * change.translateAll({
 *   content: 'country',
 *   table: {
 *     'Belgium': country.be,
 *     'Germany': country.de,
 *     'England': country.gb,
 *     ...,
 *   },
 *   nulls: ['Unknown'],
 *   key: '_country',
 * }),
 * when('country', [
 *   triple('_country', a, sdo.Country),
 * ]),
 * ```
 *
 * @example
 * When we relate a creative work to its creator, we sometimes know whether
 * the creator was the actor, architect, author, etc. of the creative work.
 * But in other cases we only know that there is a generic creator
 * relationship.  The [Library of Congress Relators
 * vocabulary](https://triplydb.com/loc/relators) allows us to express
 * specific and generic predicates of this kind.
 *
 * ```ts
 * transform.translateAll({
 *   table: {
 *     'actor': rel.act,
 *     'architect': rel.arc,
 *     'author': rel.aut,
 *     ...,
 *   },
 *   default: rel.oth, // generic relator
 *   key: '_relator',
 * }),
 * triple('_creativeWork', '_relator', '_creator'),
 * ```
 */
export default function translateAll<To = unknown, R = unknown>(args: {
  content: StaticString | string;
  table: { [key: string]: To } | string | Vocabulary;
  nulls?: string[];
  default?: To | ((value: string) => To);
  key: string;
}): Middleware<R> {
  return addMwCallSiteToError<R>(
    add({
      value: (context) => _translateAll<To>({ context, ...args }),
      key: args.key,
    }),
    { sourceFuncName: "_translateAll" },
  );
}

async function _translateAll<To = unknown>(args: {
  context: Context;
  content: StaticString | Key;
  table: { [key: string]: To } | string | Vocabulary;
  nulls?: string[];
  default?: To | ((value: string) => To);
  key: string;
}): Promise<To | undefined> {
  const keyFromContent = args.context.getString(args.content).toString();
  if (args.nulls?.includes(keyFromContent) ?? false) {
    return undefined;
  }
  const table: { [key: string]: To } =
    typeof args.table === "string"
      ? args.context.getTable<To>(args.table)
      : Vocabulary.isVocabulary(args.table)
      ? vocabularyToTable<To>(args.table)
      : args.table;
  /**
   * process args.table as key in record.
   */
  if (has(table, keyFromContent)) {
    /**
     * process args.table as JS object.
     */
    return get(table, keyFromContent);
  } else if (args.default !== undefined) {
    if (typeof args.default === "function") {
      // Function.
      return (args.default as (value: string) => To)(keyFromContent);
    } else {
      // Constant.
      return args.default;
    }
  } else {
    throw Error(`Unanticipated string value for key '${args.key}': '${keyFromContent}'`);
  }
}

export function vocabularyToTable<To = unknown>(vocab: Vocabulary): { [key: string]: To } {
  return vocab.toRecord() as { [key: string]: To };
}
