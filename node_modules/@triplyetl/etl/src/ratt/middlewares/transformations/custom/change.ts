import { castArray, has, set as lodashSet } from "lodash-es";
import { Middleware } from "../../../../generic/index.js";
import { getTypedValFromRecord, TypeForName, TypeName } from "../../../../generic/Context.js";
import { addMwCallSiteToError } from "../../../../utils/index.js";

interface Opts<T extends TypeName = "unknown"> {
  /**
   * Key (or keys) to change
   */
  key: string | string[];
  /**
   * Modify the value
   */
  change: (val: TypeForName<T>) => unknown;
  /**
   * Ensure the value is of this type
   */
  type: T;
}

export function change<R = unknown, T extends TypeName = "unknown">(opts: Opts<T>): Middleware<R> {
  return async (ctx, next) => {
    const keys = castArray(opts.key);
    const keysThatDoNotExist = keys.filter((k) => !has(ctx.record, k));
    if (keysThatDoNotExist.length === 1) {
      throw new Error(`Could not find key '${keysThatDoNotExist[0]}' in the record`);
    } else if (keysThatDoNotExist.length) {
      throw new Error(`Could not find the following keys in the record: '${keysThatDoNotExist.join(", ")}'`);
    }
    await Promise.all(
      keys.map(async (key) => {
        lodashSet(ctx.record, key, await opts.change(getTypedValFromRecord(ctx, key, opts.type)));
      })
    );

    return next();
  };
}

export default <R = unknown, T extends TypeName = "unknown">(opts: Opts<T>) =>
  addMwCallSiteToError<R>(change(opts), { sourceFuncName: "_change" });
