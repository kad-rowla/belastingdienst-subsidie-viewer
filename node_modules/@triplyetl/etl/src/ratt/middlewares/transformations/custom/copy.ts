import { has, set as lodashSet } from "lodash-es";
import { Middleware } from "../../../../generic/index.js";
import { getTypedValFromRecord, TypeForName, TypeName } from "../../../../generic/Context.js";
import { addMwCallSiteToError } from "../../../../utils/index.js";

interface Opts<T extends TypeName = "unknown"> {
  /**
   * Key to copy from
   */
  fromKey: string;
  /**
   * Key to copy to
   */
  toKey: string;
  /**
   * Optionally modify the value when copying
   */
  change?: (val: TypeForName<T>) => unknown;
  /**
   * Ensure the value is of this type
   */
  type: T;
}

export function copy<R = unknown, T extends TypeName = "unknown">(opts: Opts<T>): Middleware<R> {
  return async (ctx, next) => {
    if (opts.fromKey === opts.toKey)
      throw new Error(`"fromKey" and "toKey" are both '${opts.fromKey}'. Use the 'change' middleware`);
    if (!has(ctx.record, opts.fromKey)) throw new Error(`Could not find key '${opts.fromKey}' in the record`);
    if (ctx.isNotEmpty(opts.toKey))
      throw new Error(`Record already contains key '${opts.toKey}'. Use the 'replace' middleware`);
    const val = getTypedValFromRecord(ctx, opts.fromKey, opts.type);
    if (opts.change) {
      lodashSet(ctx.record, opts.toKey, await opts.change(val));
    } else {
      lodashSet(ctx.record, opts.toKey, val);
    }
    return next();
  };
}

export default <R = unknown, T extends TypeName = "unknown">(opts: Opts<T>) =>
  addMwCallSiteToError<R>(copy(opts), { sourceFuncName: "_copy" });
