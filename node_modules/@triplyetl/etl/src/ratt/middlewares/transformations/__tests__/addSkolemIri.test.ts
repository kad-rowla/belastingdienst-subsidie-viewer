import chai from "chai";
import chaiAsPromised from "chai-as-promised";
import { NamedNode } from "@triplydb/data-factory/Terms.js";
import * as transform from "../index.js";
import { Context, NextFn, Iri } from "../../../../generic/index.js";
import { getEtlForTesting } from "../../../__tests__/getEtlForTesting.js";

chai.use(chaiAsPromised);
const expect = chai.expect;
const assert = chai.assert;

const prefix = Iri("http://ex.com/");

const skolemIriChecker = async (ctx: Context<unknown>, next: NextFn): Promise<void> => {
  const iri = ctx.getIri("skolemIri");
  const skolemizedPrefix = prefix.concat(".well-known/genid/");
  assert.isDefined(iri, "Key `skolemIri` is undefined.");
  assert.instanceOf(iri, NamedNode);
  assert.isTrue(iri.value.startsWith(skolemizedPrefix.value));
  assert.isTrue(/^[a-f0-9]{32}$/.test(iri.value.replace(skolemizedPrefix.value, "")), "expected a UUID without `-`");
  return next();
};

describe("Transform.addSkolemIri ", () => {
  it("should generate a randomized Skolem IRI", () => {
    return getEtlForTesting([transform.addSkolemIri({ prefix, key: "skolemIri" }), skolemIriChecker]).run();
  });

  it("should work without prefix, using default Triply.cc prefix", async () => {
    return getEtlForTesting([
      transform.addSkolemIri({ key: "skolem" }),
      async (ctx, next) => {
        assert.doesNotThrow(() => ctx.getIri("skolem"));
        assert.isTrue(ctx.getIri("skolem").value.startsWith("https://triplydb.com/.well-known/genid/"));
        return next();
      },
    ]).run();
  });

  it("should fail when URL value does not match standard defined pattern for Skolem IRI's", () => {
    const etl = getEtlForTesting([
      transform.addSkolemIri({ prefix: prefix.concat("/extra/path/components"), key: "skolemIri" }),
      skolemIriChecker,
    ]);
    const promise = etl.run();
    return expect(promise).to.eventually.be.rejectedWith(
      /^Skolem IRI must start with '\/.well-known\/genid\/', either provide it or just use a base url./,
    );
  });
});
