import chai from "chai";
import chaiAsPromised from "chai-as-promised";
import * as transform from "../index.js";
import { getEtlForTesting } from "../../../__tests__/getEtlForTesting.js";
import { add } from "../custom/add.js";
import { getFactory } from "@triplydb/data-factory";
import { str } from "../../../index.js";
import { addIri } from "../index.js";
import { Etl, Iri, fromJson } from "../../../../generic/index.js";
const dataFactory = getFactory();

chai.use(chaiAsPromised);
const assert = chai.assert;

describe("Transform.iri ", () => {
  it("should create an iri from strings, no prefix", () => {
    const content = str("http://ex.com/path");
    return getEtlForTesting([
      addIri({ key: "iri", content }),
      async (ctx, next) => {
        assert.isTrue(ctx.getIri("iri").equals(getFactory().namedNode(content.toString())));
        return next();
      },
    ]).run();
  });

  it("should work with the scenario's from https://git.triply.cc/etl/ratt-helpers/-/issues/38", () => {
    const app = new Etl();
    const JohnDoe = getFactory().namedNode("https://example.com/id/person/johndoe");
    const prefix = Iri("https://example.com/id/person/");
    app.use(
      fromJson({ name: "johndoe", url: "https://example.com/id/person/johndoe" }),
      // Case 1. Key containing an IRI or a string that can be cast to IRI:
      addIri({ content: "url", key: "case1" }),

      // Case 2. Static IRI or static string that can be cast to IRI:
      addIri({ content: str("https://example.com/id/person/johndoe"), key: "case2" }),

      // Case 3. Prefix + key containing a local name
      addIri({ prefix, content: "name", key: "case3" }),

      // Case 4. Prefix + static local name:
      addIri({ prefix, content: str("johndoe"), key: "case4" }),

      async (ctx, next) => {
        for (let i = 1; i <= 4; i++) {
          assert.doesNotThrow(() => ctx.getIri(`case${i}`));
          assert.isTrue(ctx.getIri(`case${i}`).equals(JohnDoe));
        }
        return next();
      },
    );
    return app.run();
  });

  it("should create an iri from static string(s), no prefix", () => {
    const content = str("http://ex.com/path");
    return getEtlForTesting([
      transform.addIri({ key: "iri", content }),
      async (ctx, next) => {
        assert.isTrue(ctx.getIri("iri").equals(dataFactory.namedNode(content.toString())));
        return next();
      },
    ]).run();
  });

  it("should create an iri from static string(s), with NamedNode prefix", () => {
    const content = str("path");
    const prefix = dataFactory.namedNode("http://ex.com/");
    return getEtlForTesting([
      transform.addIri({ prefix, key: "iri", content }),
      async (ctx, next) => {
        assert.isTrue(ctx.getIri("iri").equals(dataFactory.namedNode(`${prefix.value}path`)));
        return next();
      },
    ]).run();
  });

  it("It should work when the prefix is a key which hold an Iri object", () => {
    return getEtlForTesting([
      add({ key: "prefix", value: (_) => Iri("http://ex.com/building/") }),
      add({ key: "id", value: (_) => "123" }),
      transform.addIri({ prefix: "prefix", content: "id", key: "iri" }),
      async (ctx, next) => {
        assert.isTrue(ctx.getIri("iri").equals(Iri("http://ex.com/building/").concat("123")));
        return next();
      },
    ]).run();
  });
});
