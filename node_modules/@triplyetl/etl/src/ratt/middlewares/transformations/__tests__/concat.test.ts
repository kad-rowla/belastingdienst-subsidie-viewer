import chai from "chai";
import chaiAsPromised from "chai-as-promised";
import { addValue, concat } from "../index.js";
import { str } from "../../../index.js";
import { getEtlForTesting } from "../../../__tests__/getEtlForTesting.js";

chai.use(chaiAsPromised);
const assert = chai.assert;
const expect = chai.expect;

const separator = "|";

describe("Transform.concat ", () => {
  it("should use String.static with 2 elements, no seperator", () => {
    const content = [str("bar1"), str("bar2")];
    return getEtlForTesting([
      concat({ content, key: "Foo" }),
      async (ctx, next) => {
        const Foo = ctx.getAny("Foo");
        assert.equal(Foo, "bar1bar2");
        return next();
      },
    ]).run();
  });

  it("should use String.static with 1 element, no seperator", () => {
    const content = [str("bar1")];
    return getEtlForTesting([
      concat({ content, key: "Foo" }),
      async (ctx, next) => {
        const Foo = ctx.getAny("Foo");
        assert.equal(Foo, "bar1");
        return next();
      },
    ]).run();
  });

  it("should use String.static with 2 elements, with seperator", () => {
    const content = [str("bar1"), str("bar2")];
    return getEtlForTesting([
      concat({ content, key: "Foo", separator }),
      async (ctx, next) => {
        const Foo = ctx.getAny("Foo");
        assert.equal(Foo, "bar1|bar2");
        return next();
      },
    ]).run();
  });

  it("should use String.static with 3 elements (incl 1 empty string), with seperator", () => {
    const content = [str("bar1"), str(""), str("bar2")];
    return getEtlForTesting([
      concat({ content, key: "Foo", separator }),
      async (ctx, next) => {
        const Foo = ctx.getAny("Foo");
        assert.equal(Foo, "bar1||bar2");
        return next();
      },
    ]).run();
  });

  it("should use String.key with empty values, override fails", () => {
    const content = ["start", "", "", "end"];
    const etl = getEtlForTesting();
    const keys: string[] = [];
    for (const i in content) {
      keys.push(`key${i}`);
      etl.use(addValue({ key: keys[i], content: str(content[i]) }));
    }
    etl.use(concat({ content: keys, key: "Foo", separator }), async (ctx, next) => {
      const Foo = ctx.getAny("Foo");
      assert.equal(Foo, "start|||end");
      return next();
    });
    return expect(etl.run()).to.eventually.rejectedWith("Key 'key1' has an empty value of type 'string'");
  });

  it("should use String.static with 1 element, with seperator", () => {
    const content = [str("bar1")];
    return getEtlForTesting([
      concat({ content, key: "Foo", separator }),
      async (ctx, next) => {
        const Foo = ctx.getAny("Foo");
        assert.equal(Foo, "bar1");
        return next();
      },
    ]).run();
  });

  it("should use keys to concatenate, with seperator", () => {
    const keys = ["foo", "foo2"];
    return getEtlForTesting([
      addValue({ key: "foo2", content: str("bar2") }),
      concat({ content: keys, key: "Foo", separator }),
      async (ctx, next) => {
        assert.equal(ctx.getString("Foo"), `${ctx.getString("foo")}${separator}${ctx.getString("foo2")}`);
        return next();
      },
    ]).run();
  });

  it("should use keys to concatenate, no seperator", () => {
    const keys = ["foo", "foo2"];
    return getEtlForTesting([
      addValue({ key: "foo2", content: str("bar2") }),
      concat({ content: keys, key: "Foo" }),
      async (ctx, next) => {
        assert.equal(ctx.getString("Foo"), `${ctx.getString("foo")}${ctx.getString("foo2")}`);
        return next();
      },
    ]).run();
  });

  it("should use a key and a static to concatenate, with seperator", () => {
    const keys = ["foo", str("foo2")];
    return getEtlForTesting([
      concat({ content: keys, key: "Foo", separator }),
      async (ctx, next) => {
        assert.equal(ctx.getString("Foo"), `${ctx.getString("foo")}${separator}foo2`);
        return next();
      },
    ]).run();
  });

  it("should create 'Letterhead' example", () => {
    const content = [str("Dear "), "firstName", str(" "), "lastName", str(",")];
    const key = "_letterHead";
    return getEtlForTesting([
      addValue({ key: "firstName", content: str("John") }),
      addValue({ key: "lastName", content: str("Doe") }),
      concat({ content, key }),
      async (ctx, next) => {
        assert.equal(ctx.getString("_letterHead"), "Dear John Doe,");
        assert.equal(ctx.getString("_letterHead"), `Dear ${ctx.getString("firstName")} ${ctx.getString("lastName")},`);
        return next();
      },
    ]).run();
  });
});
