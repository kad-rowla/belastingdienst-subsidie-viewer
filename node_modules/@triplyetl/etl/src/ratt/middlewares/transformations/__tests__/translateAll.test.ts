import chai from "chai";
import chaiAsPromised from "chai-as-promised";
import { addIri, addValue, translateAll } from "../index.js";
import { NamedNode } from "@triplydb/data-factory/Terms.js";
import { getEtlForTesting, getEtlForTestingNoExtractor } from "../../../__tests__/getEtlForTesting.js";
import { triple } from "../../assertions/statement/index.js";
import { add } from "../custom/add.js";
import { iri, str } from "../../assertions/term/index.js";
import * as vocab from "@triplyetl/vocabularies";
import { Etl, Iri, fromJson } from "../../../../generic/index.js";
import { getFactory } from "@triplydb/data-factory";
const dataFactory = getFactory();

chai.use(chaiAsPromised);
const expect = chai.expect;
const assert = chai.assert;

const table: { [key: string]: NamedNode } = {
  be: dataFactory.namedNode("http://ex.com/Belgium"),
  nl: dataFactory.namedNode("http://ex.com/Netherlands"),
  de: dataFactory.namedNode("http://ex.com/Germany"),
  en: dataFactory.namedNode("http://ex.com/England"),
};

const world = dataFactory.namedNode("http://ex.com/World");

describe("Transform.translateAll ", () => {
  it("should work on static strings", () =>
    getEtlForTesting([
      translateAll({
        content: str("nl"),
        table,
        nulls: ["Unknown"],
        key: "countryAsIri",
      }),
      triple(iri("countryAsIri"), vocab.rdf.type, vocab.sdo.Country),
      async (ctx, next) => {
        assert.equal(table.nl, ctx.getIri("countryAsIri"));
        assert.equal(1, ctx.store.getQuads({}).length);
        assert.equal(1, ctx.store.getQuads({ subject: table.nl }).length);
        return next();
      },
    ]).run());

  it("should work using default values", () =>
    getEtlForTesting([
      translateAll({
        content: str("cz"),
        table,
        default: world,
        key: "countryAsIri",
      }),
      triple(iri("countryAsIri"), vocab.rdf.type, vocab.sdo.Country),
      async (ctx, next) => {
        assert.equal(world, ctx.getIri("countryAsIri"));
        assert.equal(1, ctx.store.getQuads({}).length);
        assert.equal(1, ctx.store.getQuads({ subject: world }).length);
        return next();
      },
    ]).run());

  it("should return undefined where content is a null value", () =>
    getEtlForTesting([
      translateAll({
        content: str("Unknown"),
        table,
        nulls: ["Unknown"],
        key: "countryAsIri",
      }),
      async (ctx, _) => {
        assert.throw(() => ctx.getString("countryAsIri"));
        assert.doesNotThrow(() => ctx.getAny("countryAsIri"));
        assert.isUndefined(ctx.getAny("countryAsIri"));
      },
    ]).run());

  it("should throw Error on static strings when value is not in table", () =>
    expect(
      getEtlForTesting([
        translateAll({
          content: str("??"),
          table,
          nulls: ["Unknown"],
          key: "countryAsIri",
        }),
      ]).run(),
    ).to.eventually.rejected);

  it("should work on keys", () =>
    getEtlForTesting([
      addValue({ key: "country", content: "nl" }),
      translateAll({
        content: "country",
        table,
        nulls: ["Unknown"],
        key: "countryAsIri",
      }),
      triple(iri("countryAsIri"), vocab.rdf.type, vocab.sdo.Country),
      async (ctx, next) => {
        assert.equal(table.nl, ctx.getIri("countryAsIri"));
        assert.equal(1, ctx.store.getQuads({}).length);
        assert.equal(1, ctx.store.getQuads({ subject: table.nl }).length);
        return next();
      },
    ]).run());

  it("should work with functions that return IRI's", () =>
    getEtlForTesting([
      add({ key: "type", value: (_) => "building" }),
      add({ key: "id", value: (_) => "123" }),
      translateAll({
        content: "type",
        table: {
          building: Iri("http://ex.com/building/"),
        },
        key: "prefix",
      }),
      addIri({ prefix: "prefix", content: "id", key: "iri" }),
      async (ctx, next) => {
        assert.isTrue(ctx.getIri("iri").equals(Iri("http://ex.com/building/").concat("123")));
        return next();
      },
    ]).run());

  it("should work with a Vocabulary", async () => {
    const etl = new Etl();
    etl.use(
      fromJson({ gemeenteNaam: "Heiloo", type: "City" }),
      translateAll({
        content: "gemeenteNaam",
        table: vocab.owms.gemeente,
        nulls: ["Bergen"], // TODO: We do not know which 'Bergen' this is.
        key: "gemeente",
      }),
      translateAll({
        content: "type",
        table: vocab.sdo,
        key: "$type",
      }),
      async (ctx, next) => {
        assert.isTrue(ctx.hasKey("gemeente"));
        assert.isTrue(
          ctx
            .getIri("gemeente")
            .equals(getFactory().namedNode("http://standaarden.overheid.nl/owms/terms/Heiloo_(gemeente)")),
        );
        assert.isTrue(ctx.hasKey("$type"));
        assert.isTrue(ctx.getIri("$type").equals(vocab.sdo.City));
        return next();
      },
    );
    await etl.run();
  });

  it("Should accept a record key for table param", async () => {
    const namedNode = dataFactory.namedNode("http://ex.com/Belgium");
    const jsonData = {
      countries: {
        table: {
          be: "http://ex.com/Belgium",
          nl: "http://ex.com/Netherlands",
          de: "http://ex.com/Germany",
          en: "http://ex.com/England",
        },
      },
    };
    return getEtlForTestingNoExtractor([
      fromJson(jsonData),
      addValue({ key: "country", content: "be" }),
      translateAll({
        content: "country",
        table: "countries.table",
        nulls: ["Unknown"],
        key: "countryAsIri",
      }),
      triple(iri("countryAsIri"), vocab.rdf.type, vocab.sdo.Country),
      async (ctx, next) => {
        assert.deepEqual(namedNode, ctx.getIri("countryAsIri"));
        assert.equal(1, ctx.store.getQuads({}).length);
        assert.equal(1, ctx.store.getQuads({ subject: namedNode }).length);
        return next();
      },
    ]).run();
  });
});
