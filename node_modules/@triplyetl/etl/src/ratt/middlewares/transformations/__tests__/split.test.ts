import chai from "chai";
import chaiAsPromised from "chai-as-promised";
import { str } from "../../../index.js";
import { getEtlForTesting } from "../../../__tests__/getEtlForTesting.js";
import addValue from "../addValue.js";
import split from "../split.js";

chai.use(chaiAsPromised);
const assert = chai.assert;

const theFox = "The quick brown fox jumps over the lazy dog";
const separator = "fox";
const separatorRegExp = / [a-z]/;

const phoneNumbers = "-99-7755";
const phoneSeparator = "-";

const checkvalueNoSeperatatorNoLimit = theFox.split(" ").map((val) => val.trim());
const checkvalueWithSeperatatorNoLimit = theFox.split(separator.toString()).map((val) => val.trim());
const checkvalueWithSeperatatorRegExpNoLimit = theFox.split(separatorRegExp).map((val) => val.trim());
const checkValueWithEmptyKeys = phoneNumbers
  .split(phoneSeparator)
  .map((val) => val.trim())
  .filter((value) => value !== "");
const keepEmptyValues = phoneNumbers.split(phoneSeparator).map((val) => val.trim());

describe("Transform.split ", () => {
  it("should work on single static string, with and/or without limit and/or separator", () =>
    getEtlForTesting([
      split({ content: str(theFox), key: "splittedNoSeperatatorNoLimit", separator: " " }),
      split({ content: str(theFox), key: "splittedWithSeperatatorNoLimit", separator }),
      split({ content: str(theFox), key: "splittedWithSeperatatorRegExpNoLimit", separator: separatorRegExp }),
      split({ content: str(theFox), key: "splittedWithSeperatatorRegExpWithLimit", separator: separatorRegExp }),

      async (ctx, next) => {
        assert.isTrue(
          checkvalueNoSeperatatorNoLimit.length === ctx.getArray("splittedNoSeperatatorNoLimit", "string").length
        );
        assert.deepEqual(checkvalueNoSeperatatorNoLimit, ctx.getArray("splittedNoSeperatatorNoLimit", "string"));

        assert.isTrue(
          checkvalueWithSeperatatorNoLimit.length === ctx.getArray("splittedWithSeperatatorNoLimit", "string").length
        );
        assert.deepEqual(checkvalueWithSeperatatorNoLimit, ctx.getArray("splittedWithSeperatatorNoLimit", "string"));

        assert.isTrue(
          checkvalueWithSeperatatorRegExpNoLimit.length ===
            ctx.getArray("splittedWithSeperatatorRegExpNoLimit", "string").length
        );
        assert.deepEqual(
          checkvalueWithSeperatatorRegExpNoLimit,
          ctx.getArray("splittedWithSeperatatorRegExpNoLimit", "string")
        );

        return next();
      },
    ]).run());
  it("should work on single key, with and/or without limit and/or separator", () =>
    getEtlForTesting([
      addValue({ key: "theFox", content: str(theFox) }),
      split({ content: "theFox", key: "splittedNoSeperatatorNoLimit", separator: " " }),
      split({ content: "theFox", key: "splittedWithSeperatatorNoLimit", separator }),
      split({ content: "theFox", key: "splittedWithSeperatatorRegExpNoLimit", separator: separatorRegExp }),

      async (ctx, next) => {
        assert.isTrue(
          checkvalueNoSeperatatorNoLimit.length === ctx.getArray("splittedNoSeperatatorNoLimit", "string").length
        );
        assert.deepEqual(checkvalueNoSeperatatorNoLimit, ctx.getArray("splittedNoSeperatatorNoLimit", "string"));

        assert.isTrue(
          checkvalueWithSeperatatorNoLimit.length === ctx.getArray("splittedWithSeperatatorNoLimit", "string").length
        );
        assert.deepEqual(checkvalueWithSeperatatorNoLimit, ctx.getArray("splittedWithSeperatatorNoLimit", "string"));

        assert.isTrue(
          checkvalueWithSeperatatorRegExpNoLimit.length ===
            ctx.getArray("splittedWithSeperatatorRegExpNoLimit", "string").length
        );
        assert.deepEqual(
          checkvalueWithSeperatatorRegExpNoLimit,
          ctx.getArray("splittedWithSeperatatorRegExpNoLimit", "string")
        );

        return next();
      },
    ]).run());

  it("should remove empty entities by default", () =>
    getEtlForTesting([
      split({ content: str(phoneNumbers), separator: phoneSeparator, key: "removeEmptyEntitiesByDefault" }),
      async (ctx, next) => {
        assert.isTrue(checkValueWithEmptyKeys.length == ctx.getArray("removeEmptyEntitiesByDefault", "any").length);
        assert.deepEqual(checkValueWithEmptyKeys, ctx.getArray("removeEmptyEntitiesByDefault", "any"));
        return next();
      },
    ]).run());

  it("should remove empty entities if specified", () =>
    getEtlForTesting([
      split({
        content: str(phoneNumbers),
        separator: phoneSeparator,
        key: "removeEmptyEntitiesByDefault",
        keepEmptyEntities: false,
      }),
      async (ctx, next) => {
        assert.isTrue(checkValueWithEmptyKeys.length == ctx.getArray("removeEmptyEntitiesByDefault", "any").length);
        assert.deepEqual(checkValueWithEmptyKeys, ctx.getArray("removeEmptyEntitiesByDefault", "any"));
        return next();
      },
    ]).run());

  it("should keep empty entities if parameter is set", () =>
    getEtlForTesting([
      split({
        content: str(phoneNumbers),
        separator: phoneSeparator,
        key: "keepEmptyEntities",
        keepEmptyEntities: true,
      }),
      async (ctx, next) => {
        assert.isTrue(keepEmptyValues.length == ctx.getArray("keepEmptyEntities", "any").length);
        assert.deepEqual(keepEmptyValues, ctx.getArray("keepEmptyEntities", "any"));
        return next();
      },
    ]).run());
});
