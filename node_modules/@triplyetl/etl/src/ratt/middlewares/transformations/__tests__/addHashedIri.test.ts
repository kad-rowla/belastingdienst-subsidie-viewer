import chai from "chai";
import chaiAsPromised from "chai-as-promised";
import { NamedNode } from "@triplydb/data-factory/Terms.js";
import * as transform from "../index.js";
import { str } from "../../../index.js";
import { Context, Iri, NextFn } from "../../../../generic/index.js";
import { hashify } from "../../../../utils/index.js";
import { getEtlForTesting } from "../../../__tests__/getEtlForTesting.js";
import { add } from "../custom/add.js";
import { getFactory } from "@triplydb/data-factory";

chai.use(chaiAsPromised);
const assert = chai.assert;
const prefix = Iri("http://ex.com/.well-known/genid/");

const hashedIriCheckerWithoutPrefix = async (ctx: Context<unknown>, next: NextFn): Promise<void> => {
  const iri = ctx.getAny("hashedIri");
  assert.isDefined(iri, "Key `hashedIri` is undefined.");
  assert.instanceOf(iri, NamedNode);
  assert.isTrue(/[a-f0-9]{32}$/.test(iri.value), "expected a UUID without `-`");
  return next();
};

const hashedIriChecker = async (ctx: Context<unknown>, next: NextFn): Promise<void> => {
  const iri = ctx.getAny("hashedIri");
  assert.isDefined(iri, "Key `hashedIri` is undefined.");
  assert.instanceOf(iri, NamedNode);
  assert.isTrue(iri.value.startsWith(prefix.value));
  assert.isTrue(/^[a-f0-9]{32}$/.test(iri.value.replace(prefix.value, "")), "expected a UUID without `-`");
  return next();
};

describe("Transform.hashedIri ", () => {
  it("should generate a randomized IRI", () => {
    const etl = getEtlForTesting([
      transform.addHashedIri({ prefix, key: "hashedIri", content: str("foo") }),
      hashedIriChecker,
    ]);
    return etl.run();
  });

  it("should generate an IRI using a md5 hash", () => {
    const etl = getEtlForTesting([
      transform.addValue({ key: "key1", content: str("bar1") }),
      transform.addValue({ key: "key2", content: str("bar2") }),
      transform.addHashedIri({ prefix, key: "hashedIri", content: ["key1", "key2"] }),
      hashedIriChecker,
      async (ctx, next) => {
        const hash = hashify(ctx, [str("bar1"), str("bar2")]);
        const iri = ctx.getIri("hashedIri");
        assert.equal(iri.value, prefix.concat(hash).value);
        return next();
      },
    ]);
    return etl.run();
  });

  it("should work with static strings as prefix", () => {
    const prefix = str("http://a.ex.com/.well-known/genid/");
    const etl = getEtlForTesting([
      transform.addHashedIri({ prefix, key: "hashedIri", content: "foo" }),
      // hashedIriCheckerWithoutPrefix,
      async (ctx, next) => {
        assert.isTrue(ctx.getIri("hashedIri").value.startsWith(prefix.toString()));
        return next();
      },
    ]);
    return etl.run();
  });

  it("should work with keys containing static strings as prefix", () => {
    const prefix = str("http://b.ex.com/.well-known/genid/");
    const etl = getEtlForTesting([
      transform.addValue({ key: "staticIriString", content: prefix }),
      transform.addHashedIri({ prefix: "staticIriString", key: "hashedIri", content: "foo" }),
      hashedIriCheckerWithoutPrefix,
      async (ctx, next) => {
        assert.isTrue(ctx.getIri("hashedIri").value.startsWith(prefix.toString()));
        return next();
      },
    ]);
    return etl.run();
  });

  it("should work with keys containing an Iri as prefix", () => {
    const prefix = str("http://c.ex.com/.well-known/genid/");
    const etl = getEtlForTesting([
      add({ key: "iri", value: (_) => getFactory().namedNode(prefix.toString()) }),
      transform.addHashedIri({ prefix: "iri", key: "hashedIri", content: "foo" }),
      hashedIriCheckerWithoutPrefix,
      async (ctx, next) => {
        assert.isTrue(ctx.getIri("hashedIri").value.startsWith(prefix.toString()));
        return next();
      },
    ]);
    return etl.run();
  });
});
