import { Middleware } from "../../../generic/index.js";
import { TypeName } from "../../../generic/Context.js";
import { addMwCallSiteToError } from "../../../utils/index.js";
import { copy } from "./custom/copy.js";

/**
 * Makes a plain copy from the value stored in the given key to a new key.
 *
 * @param args.content - A value of any type, or a key that contains a value
 * of any type.
 *
 * @param args.type - Optionally, the name of the TypeScript type of the value.
 * The default value is `'string'`.
 *
 * @param args.key - A new key where the plain copy is stored.
 *
 * @example
 * Plain copies can be used to abbreviate long keys, especially in tree-shaped
 * data like JSON or XML.  In the following example, values stored in a long
 * nested key are copies into a short and descriptive key.  This is even more
 * useful if the key is used many times in the script.
 *
 * ```ts
 * copy({
 *   content: 'record[0].family[0].children.child[0].id.$text',
 *   key: 'childId',
 * }),
 * ```
 *
 * @example
 * Since plain copies introduce a new name for an existing value, the new name
 * can be used to store extra information about the value.  The following
 * example stores an English name, if available; or a Dutch name, if
 * available; or no name at all.  This is a relatively complex example that
 * can only be accomplished by copying the names for the encountered languages
 * under descriptive key names.
 *
 * ```ts
 * fromJson([
 *   {
 *     id: '1',
 *     names: [
 *       { language: 'en', value: 'London' },
 *       { language: 'fr', value: 'Londres' },
 *       { language: 'nl', value: 'Londen' },
 *     ],
 *   },
 *   {
 *     id: '2',
 *     names: [
 *       { language: 'fr', value: 'Paris' },
 *       { language: 'nl', value: 'Parijs' },
 *     ],
 *   },
 * ]),
 * forEach('names', [
 *   _switch('language',
 *     // Plain copy of the English label, if available.
 *     ['en', copy({ content: 'value', key: '$parent.en' })],
 *     // Plain copy of the Dutch label, if available.
 *     ['nl', copy({ content: 'value', key: '$parent.nl' })],
 *   ),
 * ]),
 * ifElse({
 *   // Prefer an English label over a Dutch label.
 *   if: 'en',
 *   then: copy({ content: 'en', key: '_preferredName' }),
 * }, {
 *   // If there is no English label, a Dutch label is a second-best option.
 *   if: 'nl',
 *   then: copy({ content: 'nl', key: '_preferredName' }),
 * }),
 * // If there is either an English or a Dutch label, assert it.
 * when('_preferredName', [
 *   triple(iri(prefix.city, 'id'), rdfs.label, '_preferredName'),
 * ]),
 * ```
 *
 * This results in the following linked data assertions:
 *
 * ```ttl
 * city:1 rdfs:label 'London'.
 * city:2 rdfs:label 'Parijs'.
 * ```
 */
export default function <R = unknown>(args: { key: string; content: string; type?: TypeName }): Middleware<R> {
  return addMwCallSiteToError<R>(
    copy({
      fromKey: args.content,
      toKey: args.key,
      type: args.type ?? "string",
    }),
    { sourceFuncName: "_copy" }
  );
}
