import { Etl, Middleware } from "../../../generic/index.js";
import { PossibleIri, addMwCallSiteToError } from "../../../utils/index.js";
import { add } from "./custom/add.js";
import { LanguageTag, xsd } from "@triplyetl/vocabularies";
import { isStatic, StaticString } from "../assertions/term/str.js";
import { getFactory } from "@triplydb/data-factory";
import { NamedNode } from "@triplydb/data-factory/Terms.js";
import { coerceToLanguageTag } from "../assertions/statement/rdf/utils/coerceToLanguageTag.js";
import { once } from "lodash-es";
import { Validator, validate } from "../../validators/index.js";
const dataFactory = once(() => getFactory({ skipValidation: Etl.skipValidation }));
/**
 * Creates an new literal and adds it to the Etl Record under the specified
 * key.
 *
 * @see You can also immediately use a literal inside a {@link triple} or
 * {@link quad} assertion, without storing it under a new key in the Etl
 * Record.
 *
 * @remarks
 * This middleware is typically used when the same literal is used in two or
 * more statement assertion (i.e. {@link triple} or {@link quad}).  This
 * avoids having to specify the same literal multiple times using the term
 * assertion {@link literal}.
 *
 * If a language tag is given, a language-tagged string is created; otherwise
 * a typed literal is created.
 * If neither a language tag nor a datatype is specified, then a typed literal
 * with datatype `xsd:string` is created.
 *
 * @param args.content - A key that contains a string value, or a string
 * specified with {@link str}.
 *
 * @param args.datatype Optionally, an IRI or a key that stores an IRI.
 *
 * @param args.languageTag - Optionally, a language tag from the {@link lang}
 * object, or a key that stores such a language tag.
 *
 * @param args.key  A new key where the created literal is stored.
 *
 * @example
 * The following snippet asserts a triple with a typed literal with datatype
 * IRI `xsd:date`:
 *
 * ```ts
 * fromJson([{ id: '123', date: '2022-01-30' }]),
 * addLiteral({
 *  content: 'date',
 *  datatype: xsd.date,
 *  key: '_dateCreated',
 * }),
 * triple(iri(prefix.book, 'id'), sdo.dateCreated, '_dateCreated'),
 * ```
 *
 * This makes the following linked data assertion:
 *
 * ```ttl
 * book:123 sdo:dateCreated '2022-30-01'^^xsd:date.
 * ```
 *
 * Notice that the same linked data could have been asserted with the
 * following use the the {@link literal} assertion middleware:
 *
 * ```ts
 * fromJson([{ id: '123', date: '2022-01-30' }]),
 * triple(iri(prefix.book, 'id'), sdo.dateCreated, literal('date', xsd.date)),
 * ```
 *
 * @example
 * The following snippet asserts a triple with a string literal in the object
 * position:
 *
 * ```ts
 * fromJson([{name: 'London'}]),
 * addLiteral({
 *   content: 'name',
 *   key: '_name',
 * }),
 * triple(iri(prefix.city, '_name'), skos.prefLabel, '_name')
 * ```
 *
 * This makes the following assertion:
 *
 * ```ttl
 * city:London sdo:name 'London'.
 * ```
 *
 * The literal 'London' has type `xsd:string`.  This is the standard datatype
 * IRI for typed literals in Etl, and in many other linked data languages
 * such as Turtle, TriG, and SPARQL.
 *
 * Notice that the same linked data could have been asserted with the
 * following snippet, where the string value `'London'` is automatically
 * cast into a string literal:
 *
 * ```ts
 * fromJson([{ name: 'London' }]),
 * triple(iri(prefix.city, 'name'), skos.prefLabel, 'name'),
 * ```
 *
 * @example
 * The following snippet asserts a triple with a language-tagged string in
 * the object position:
 *
 * ```ts
 * fromJson([{ name: 'London' }]),
 * addLiteral({
 *   content: 'name',
 *   languageTag: lang['en-gb'],
 *   key: '_name',
 * }),
 * triple(iri(prefix.city, 'name'), skos.prefLabel, '_name'),
 * ```
 *
 * This results in the following linked data assertion:
 *
 * ```ttl
 * city:London skos:prefLabel 'London'@en-gb.
 * ```
 *
 * Notice that the same linked data could have been asserted with the
 * following use the the {@link literal} assertion middleware:
 *
 * ```ts
 * fromJson([{ name: 'London' }]),
 * triple(iri(prefix.city, 'name'), skos.prefLabel, literal('name', lang['en-gb'])),
 * ```
 */
function addLiteral<R = unknown>(args: ArgumentsWithLanguage): Middleware<R>;
function addLiteral<R = unknown>(args: ArgumentsWithDataType): Middleware<R>;
function addLiteral<R = unknown>(args: ArgumentsNoDatatypeOrLanguage): Middleware<R>;
function addLiteral<R = unknown>(
  args: ArgumentsNoDatatypeOrLanguage | ArgumentsWithLanguage | ArgumentsWithDataType,
): Middleware<R> {
  return addMwCallSiteToError<R>(
    add({
      value: (ctx) => {
        let languageOrDatatype: string | NamedNode = xsd.string;
        if (args.language !== undefined) {
          languageOrDatatype = coerceToLanguageTag(
            !LanguageTag.isLanguageTag(args.language) && !isStatic(args.language)
              ? ctx.getAny(args.language)
              : args.language,
          )
            .toString()
            .toLowerCase();
        } else if (args.datatype !== undefined) languageOrDatatype = ctx.getIri(args.datatype);
        const literal = ctx.getString(args.content);
        validate(literal, args.validate);
        return dataFactory().literal(literal, languageOrDatatype);
      },
      key: args.key,
    }),
    { sourceFuncName: "_addLiteral" },
  );
}

export default addLiteral;

interface ArgumentsWithDataType {
  content: StaticString | string;
  datatype: PossibleIri;
  language?: never;
  validate?: Validator | Validator[];
  key: string;
}
interface ArgumentsWithLanguage {
  content: StaticString | string;
  datatype?: never;
  language: string | LanguageTag;
  validate?: Validator | Validator[];
  key: string;
}

interface ArgumentsNoDatatypeOrLanguage {
  content: StaticString | string;
  datatype?: never;
  language?: never;
  validate?: Validator | Validator[];
  key: string;
}
