import { decode } from "html-entities";
import { Key, Middleware } from "../../../generic/index.js";
import { addMwCallSiteToError } from "../../../utils/index.js";
import { StaticString } from "../assertions/term/str.js";
import { add } from "./custom/add.js";

/**
 * This transformation decodes any HTML entities that appear in a given key.
 *
 * @remarks
 * The following HTML entities are common in source data:
 *
 * | HTML entity | Decoded |
 * |-------------+---------|
 * | &amp;       | &       |
 * | &gt;        | >       |
 * | &lt;        | <       |
 *
 * You do *not* need to use this transformation if you want to assert literals
 * with datatype IRI `rdf:HTML`.  HTML entities are meaningful in HTML, so
 * there they should be preserved.
 *
 * @param args.content - A key in the Etl Record that contains string values
 * with HTML entities.
 *
 * @param args.key - A new key where the decoded content is stored.
 *
 * @example
 * The following snippet takes HTML texts from the source data and asserts
 * them as regular text literals.  Since HTML entities are meaningless in
 * regular text, `decodeHtml` is used to denote these entities.
 *
 * ```ts
 * fromJson([
 *   { id: '1', label: 'A&amp;B' },
 *   { id: '2', label: '1 &lt; 2' },
 * ]),
 * decodeHtml({
 *   content: 'label',
 *   key: '_label',
 * }),
 * triple(iri(prefix.id, 'id'), rdfs.label, '_label'),
 * ```
 *
 * This results in the following linked data assertions:
 *
 * ```ttl
 * id:1 rdfs:label 'A&B'.
 * id:2 rdfs:label '1 < 2'.
 * ```
 */
export default function <R = unknown>(args: { content: StaticString | Key; key: string }): Middleware<R> {
  return addMwCallSiteToError<R>(
    add({
      key: args.key,
      value: (context) => decode(context.getString(args.content)),
    }),
    { sourceFuncName: "_decodeHtml" }
  );
}
