import { getFactory } from "@triplydb/data-factory";
import { Etl, Key, Middleware } from "../../../generic/index.js";
import { addMwCallSiteToError, PossibleIri } from "../../../utils/index.js";
import { StaticString } from "../assertions/term/str.js";
import { add } from "./custom/add.js";

/**
 * This transformation is used when string values must be mapped onto literals
 * with varying datatype IRIs.
 *
 * @remarks
 * The datatype IRIs that could apply are specified in a list.  The specified
 * datatype IRIs are tried out from left to right.  The first datatype IRI
 * that results in a valid literal is chosen.
 *
 * You do *not* need to use this transformation if the datatype IRI of the
 * literal is stable.  Use the {@link literal} assertion instead.
 *
 * @param args.content - A key that contains a string value, or a string
 * value specified with {@link str}.
 *
 * @param args.datatypes - An array of two or more datatype IRIs.
 *
 * @param args.key - A new key where the created literal is stored.
 *
 * @example
 * A literal is valid if the given string value appears in the lexical space
 * of a specific datatype IRI.  This is best explained with an example:
 *
 * ```ts
 * tryLiteral({
 *   content: 'date',
 *   datatypes: [xsd.date, xsd.gYearMonth, xsd.gYear],
 *   key: '_publicationDate',
 * }),
 * ```
 *
 * | Source data in key `'date'` | Result in key `'_date'` |
 * | --------------------------- | ----------------------- |
 * | '1900-01-02'                | '1900-01-02'^^xsd:date  |
 * | '1900'                      | '1900'^^xsd:gYear       |
 * | '02-01-1900'                | ERROR                   |
 *
 * If we do not want to emit errors for string values that cannot be satisfy
 * any of the specified datatype IRIs, we may choose to include `xsd.string`
 * as the last datatype IRI in the list.  Do notice however that this will
 * result in dates that cannot be compared on a timeline, since they were
 * not transformed to an XSD date/time datatype.
 *
 * @throws An exception if a string value does not belong to the lexical space
 * of any of the specified datatype IRIs.
 */
export default function <R = unknown>(args: {
  content: StaticString | Key;
  datatypes: [PossibleIri, PossibleIri, ...PossibleIri[]];
  key: string;
}): Middleware<R> {
  const factory = getFactory({ skipValidation: Etl.skipValidation });
  return addMwCallSiteToError<R>(
    add({
      value: (context) => {
        const lexicalForm = context.getString(args.content);
        for (const datatype of args.datatypes) {
          try {
            return factory.literal(lexicalForm, context.getIri(datatype));
          } catch (e) {}
        }
        throw new Error(`Unabled to parse lexical form '${lexicalForm}' as one of the provided datatypes`);
      },
      key: args.key,
    }),
    { sourceFuncName: "_tryLiteral" },
  );
}
