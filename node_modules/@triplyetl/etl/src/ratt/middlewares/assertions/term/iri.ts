import { NamedNode } from "@triplydb/data-factory/Terms.js";
import { TermGetter } from "./getter.js";
import { get } from "lodash-es";
import { isStatic, StaticString } from "./str.js";
import { Context, Key } from "../../../../generic/index.js";
import { assertIsString, isIri } from "../../../../utils/asserts.js";
import { unknownValToIri } from "../../../../utils/coercions.js";
import { Iri } from "@triplyetl/vocabularies";

/**
 * Creates an IRI based on a dynamic key:
 * - `iri(KEY)` if key has a IRI value.
 * - `iri(PREFIX, KEY)` if key has a string value that acts as the local name
 *   of an IRI.
 *
 * How to use
 * ----------
 *
 * To create an IRI from a prefix and a key that has a string:
 *
 *   1. Choose the `PREFIX` for the IRI that you want to create.
 *   2. Choose the `KEY` that contains the local name (i.e., the part of an
 *      IRI that occurs after the last forward slash).
 *   3. Make the following call: `iri(PREFIX, KEY)`
 *
 * To create an IRI from a key that has an IRI:
 *
 *   1. Make the following call: `iri(KEY)`
 *
 * Examples
 * --------
 *
 * To create an IRI from `prefix.a` and `someKey`:
 *
 * ```ts
 * triple(iri(prefix.a, 'someKey'), a, owl.NamedIndividual),
 * ```
 *
 * To use an IRI stored in `someKey`:
 *
 * ```ts
 * triple(iri('someKey'), a, owl.NamedIndividual),
 * ```
 */
export function iri(key: Key | StaticString): TermGetter<NamedNode>;
export function iri(prefix: Iri, key?: Key | StaticString): TermGetter<NamedNode>;
export function iri(keyOrPrefix: Key | StaticString | Iri, possibleKey?: Key | StaticString): TermGetter<NamedNode> {
  const prefix = isIri(keyOrPrefix) ? keyOrPrefix : undefined;
  const key = typeof keyOrPrefix === "string" ? keyOrPrefix : possibleKey;

  return function _toIri(ctx: Context) {
    let iri: NamedNode<string>;
    if (possibleKey === undefined) {
      if (isIri(keyOrPrefix)) {
        return [keyOrPrefix];
      }
      // Using try/catch here as the Error message I was getting didn't fit the context of this function
      try {
        iri = ctx.getIri(keyOrPrefix);
      } catch (error) {
        let iriAny: any = ctx.getAny(keyOrPrefix);
        if (typeof iriAny === "boolean") iriAny = `${iriAny ? "TRUE" : "False"} [type: boolean]`;
        else if (typeof iriAny === "object") {
          try {
            iriAny = JSON.stringify(iriAny);
          } catch (e) {
            iriAny = `[${(e as Error).message}]`;
          }
        } else iriAny = `${iriAny.toString()} [type: ${typeof iriAny}]`;

        throw new Error(`Invalid Iri: '${iriAny}' at key: '${keyOrPrefix}' `);
      }
      return [iri];
    }

    if (!key && prefix) {
      iri = prefix;
      return [iri];
    }
    if (!isStatic(key)) {
      assertIsString(key, "Expected key to be a string");
      if (!ctx.hasKey(key)) throw Error(`Record does not have key '${key}'`);
    }

    iri = unknownValToIri(
      isStatic(key) ? key.toString() : get(ctx.record, key),
      isStatic(key) ? `str('${key}')` : key,
      {
        prefix,
      },
    );
    return [iri];
  };
}

export default iri;
