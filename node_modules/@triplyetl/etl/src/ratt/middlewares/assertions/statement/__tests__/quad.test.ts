import chai from "chai";
import { quad } from "../index.js";
import { addIri, addLiteral, addValue } from "../../../transformations/index.js";
import { getEtlForTesting } from "../../../../__tests__/getEtlForTesting.js";
import * as vocab from "@triplyetl/vocabularies";
import { str, literal } from "../../term/index.js";
import { getFactory } from "@triplydb/data-factory";
const dataFactory = getFactory();

const assert = chai.assert;
const graph = dataFactory.namedNode("http://ex.com/graph");
const anotherGraph = dataFactory.namedNode("http://ex.com/anotherGraph");

describe("writing.quad", () => {
  it("should create 5 triples in 2 quads", () => {
    return getEtlForTesting([
      addLiteral({ content: str("Heineken"), language: vocab.languageTag("nl"), key: "naam" }),
      addValue({ content: str("Heineken"), key: "naamPrimitive" }),
      addIri({ content: str("http://ex.com/Brewery"), key: "subject" }),
      addIri({ content: str("http://ex.com/name"), key: "predicate" }),
      addIri({ content: str("http://ex.com/Heineken"), key: "objectIri" }),
      quad(vocab.sdo.Brewery, vocab.rdf.type, vocab.sdo.FoodEstablishment, graph),
      quad(vocab.sdo.Brewery, vocab.sdo.name, literal(str("Naam"), vocab.languageTag("nl")), graph),
      quad(vocab.sdo.Brewery, vocab.sdo.name, "objectIri", graph),
      quad(vocab.sdo.Brewery, vocab.sdo.name, "naam", anotherGraph),
      quad(vocab.sdo.Brewery, vocab.sdo.name, str("Heineken Brouwerij"), anotherGraph),
      quad(vocab.sdo.Brewery, vocab.sdo.name, "naamPrimitive", anotherGraph),
      async (ctx, next) => {
        assert.equal(6, ctx.store.getQuads({}).length);
        assert.equal(3, ctx.store.getQuads({ graph }).length, "Incorrect quads count for 1st graph");
        assert.equal(3, ctx.store.getQuads({ graph: anotherGraph }).length, "Incorrect quads count for 2nd graph");
        return next();
      },
    ]).run();
  });

  it("should create a quad from static strings", () => {
    const subject = "http://ex.com/Brewery";
    const predicate = "http://ex.com/name";
    const object = str("Heineken");
    return getEtlForTesting([
      quad(str(subject), str(predicate), str(object), graph),
      async (ctx, next) => {
        assert.equal(1, ctx.store.getQuads({ graph }).length, "Incorrect quads count for 1st graph");
        assert.equal(
          1,
          ctx.store.getQuads({ graph, subject: dataFactory.namedNode(subject) }).length,
          "Incorrect quads count for 1st graph with S",
        );
        assert.equal(
          1,
          ctx.store.getQuads({
            graph,
            subject: dataFactory.namedNode(subject),
            predicate: dataFactory.namedNode(predicate),
          }).length,
          "Incorrect quads count for 1st graph with S,P",
        );
        assert.equal(
          1,
          ctx.store.getQuads({
            graph,
            subject: dataFactory.namedNode(subject),
            predicate: dataFactory.namedNode(predicate),
            object: dataFactory.literal(object.toString()),
          }).length,
          "Incorrect quads count for 1st graph with S,P,O",
        );
        return next();
      },
    ]).run();
  });

  it("should create a quad from strings stored in keys", () => {
    const subject = "http://ex.com/Brewery";
    const predicate = "http://ex.com/name";
    const object = "Heineken";
    return getEtlForTesting([
      addValue({ key: "graph", content: str(graph.value) }),
      addValue({ key: "subject", content: str(subject) }),
      addValue({ key: "predicate", content: str(predicate) }),
      addValue({ key: "object", content: str(object) }),
      quad("subject", "predicate", "object", "graph"),
      async (ctx, next) => {
        const subjectNode = dataFactory.namedNode(subject);
        const predicateNode = dataFactory.namedNode(predicate);
        const objectNode = dataFactory.literal(object);
        assert.equal(1, ctx.store.getQuads({ graph }).length);
        assert.equal(1, ctx.store.getQuads({ graph, subject: subjectNode }).length);
        assert.equal(1, ctx.store.getQuads({ graph, subject: subjectNode, predicate: predicateNode }).length);
        assert.equal(
          1,
          ctx.store.getQuads({ graph, subject: subjectNode, predicate: predicateNode, object: objectNode }).length,
        );
        return next();
      },
    ]).run();
  });

  it("should create a quad where object is a typed literal", () => {
    const subject = "http://ex.com/Brewery";
    const predicate = "http://ex.com/name";
    const object = "2022";
    return getEtlForTesting([
      addValue({ key: "graph", content: str(graph.value) }),
      addValue({ key: "subject", content: str(subject) }),
      addValue({ key: "predicate", content: str(predicate) }),
      addLiteral({ key: "object", content: str(object), datatype: vocab.xsd.gYear }),
      quad("subject", "predicate", "object", "graph"),
      async (ctx, next) => {
        const subjectNode = dataFactory.namedNode(subject);
        const predicateNode = dataFactory.namedNode(predicate);
        const objectNode = dataFactory.literal(object, vocab.xsd.gYear);
        assert.equal(1, ctx.store.getQuads({ graph }).length);
        assert.equal(1, ctx.store.getQuads({ graph, subject: subjectNode }).length);
        assert.equal(1, ctx.store.getQuads({ graph, subject: subjectNode, predicate: predicateNode }).length);
        assert.equal(
          1,
          ctx.store.getQuads({ graph, subject: subjectNode, predicate: predicateNode, object: objectNode }).length,
        );
        return next();
      },
    ]).run();
  });
});
