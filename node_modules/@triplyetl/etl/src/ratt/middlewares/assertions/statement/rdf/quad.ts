import getCurrentLine from "get-current-line";
import { isArray } from "lodash-es";
import { Literal, NamedNode } from "@triplydb/data-factory/Terms.js";
import { Middleware } from "../../../../../generic/index.js";
import { isKey, Key } from "../../../../../generic/Context.js";
import { addMwCallSiteToError, addQuadsToStore } from "../../../../../utils/index.js";
import { isNamedNode, NullableOrEmptyString } from "../../../../../utils/asserts.js";
import { TermGetter } from "../../term/getter.js";
import { isStatic, StaticString } from "../../term/str.js";
import { getNamedNodes } from "./utils/getNamedNodes.js";
import { getObjects } from "./utils/getObjects.js";

// results in a Subject, Predicate or Graph Iri after some fidling:
export type SPG = StaticString | Key | TermGetter<NamedNode>;
export type O = Key | StaticString | ObjectLiterals | ObjectLiterals[] | TermGetter<NamedNode | Literal>;
export type ObjectLiterals = boolean | Key | number | bigint | Date;
export type Pair = [SPG, O];
export type Triple = [SPG, SPG, O];
export type Quad = [SPG, SPG, O, SPG];

// Assertions:
export const isSPG = (value: any): value is SPG =>
  isStatic(value) || isTermGetterForNamednode(value) || isNamedNode(value) || isKey(value);

export const isO = (value: any): value is O =>
  isStatic(value) ||
  isObjectLiteral(value) ||
  isObjectLiterals(value) ||
  isNamedNode(value) ||
  isTermGetterForLiteral(value) ||
  isTermGetterForNamednode(value);

export const isOs = (value: any): value is O => {
  if (!isArray(value)) return false;
  let i = 0;
  value.forEach((val) => (i += isO(val) ? 1 : 0));
  return i === value.length;
};

export const isObjectLiteral = (value: any): value is ObjectLiterals =>
  typeof value === "string" ||
  typeof value === "boolean" ||
  typeof value === "number" ||
  typeof value === "bigint" ||
  value instanceof Date;

export const isObjectLiterals = (value: any[]): value is ObjectLiterals[] => {
  if (!isArray(value)) return false;
  let i = 0;
  value.forEach((val) => (i += isObjectLiteral(val) ? 1 : 0));
  return i === value.length;
};

export const isPair = (value: any): value is Pair =>
  isArray(value) && value.length === 2 && isSPG(value[0]) && isO(value[1]);

export const isPairs = (value: any): value is Pair[] => {
  if (!isArray(value)) return false;
  let i = 0;
  value.forEach((val) => (i += isPair(val) ? 1 : 0));
  return i === value.length;
};

export const isTriple = (value: any): value is Triple =>
  isArray(value) && value.length === 3 && isSPG(value[0]) && isSPG(value[1]) && isO(value[2]);

export const isQuad = (value: any): value is Quad =>
  isArray(value) && value.length === 4 && isSPG(value[0]) && isSPG(value[1]) && isSPG(value[2]) && isO(value[3]);

export const isTermGetterForNamednode = (value: any): value is TermGetter<NamedNode> =>
  typeof value === "function" &&
  !!value("") &&
  typeof value("") === "object" &&
  "termType" in value("") &&
  (value("") as NamedNode).termType === "NamedNode";

export const isTermGetterForLiteral = (value: any): value is TermGetter<Literal> =>
  typeof value === "function" &&
  !!value("") &&
  typeof value("") === "object" &&
  "termType" in value("") &&
  (value("") as Literal).termType === "Literal";

// TODO @DocumentationTeam: add TS doc comment here
export default function _quad(subject: SPG, predicate: SPG, object: O, graph?: SPG): Middleware {
  const callSite = getCurrentLine({ frames: 2 });
  return addMwCallSiteToError(
    async function _triple(ctx, next) {
      try {
        const s = getNamedNodes(ctx, subject);
        const p = getNamedNodes(ctx, predicate);
        const o = getObjects(ctx, object);
        const gs = graph === undefined ? [ctx.app.defaultGraph] : getNamedNodes(ctx, graph);
        for (const g of gs) {
          addQuadsToStore(ctx.store, [[s, p, o, g]]);
          if (s.length && p.length && o.length) {
            ctx.app["markMwTouched"](callSite);
          }
        }
      } catch (e: any) {
        //Skip this error. If a term is nullable or an empty string, we should simply not store that as a quad
        if (!(e instanceof NullableOrEmptyString)) {
          //adding information to error. Dont want to throw a new error to keep the stacktrace intact.
          e.addQuad = [subject, predicate, object, ctx.app.defaultGraph];
          throw e;
        }
      }
      await next();
    },
    { reportTouched: false, callSite, sourceFuncName: "_triple" },
  );
}
