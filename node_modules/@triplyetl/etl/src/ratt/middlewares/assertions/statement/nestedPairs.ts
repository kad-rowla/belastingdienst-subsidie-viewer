import { unset } from "lodash-es";
import { MiddlewareList, Middleware } from "../../../../generic/index.js";
import { convertMwListToMiddleware, randomHash } from "../../../../utils/index.js";
import addSkolemIri from "../../transformations/addSkolemIri.js";
import { isJPath } from "../term/jpath.js";
import quad, { isPair, isSPG, Pair, SPG } from "./rdf/quad.js";

function _nestedPairs(
  graphOrSubject: SPG,
  subjectOrPredicate: SPG,
  predicateOrObject: SPG | undefined,
  objectOrPair: SPG | Pair,
  ...pairs: Pair[]
): MiddlewareList {
  let S: SPG, P: SPG, O: SPG | undefined, G: SPG | undefined;
  if (isSPG(objectOrPair)) {
    G = graphOrSubject;
    S = subjectOrPredicate;
    P = predicateOrObject!;
    O = objectOrPair;
  } else {
    pairs = objectOrPair !== undefined ? [objectOrPair, ...pairs] : pairs;
    S = graphOrSubject;
    P = subjectOrPredicate;
    O = predicateOrObject;
  }

  if (isJPath(O)) {
    throw new Error("This must be a bug: a JSON Path expression can not make a good RDF Object");
  }

  const mws: MiddlewareList = [];
  const sentinalKey = "$nestedPairs-" + randomHash();
  if (O === undefined) {
    mws.push(addSkolemIri({ key: sentinalKey }));
  }
  mws.push(quad(S, P, O ?? sentinalKey, G), ...pairs.map((pair) => quad(O ?? sentinalKey, pair[0], pair[1], G)));
  if (O === undefined) {
    mws.push(async (ctx, next) => {
      unset(ctx.record, sentinalKey);
      return next();
    });
  }
  return mws;
}

/**
 * Makes one or more assertions about a nested node.
 *
 * @remarks
 * Since RDF is composed of triples, more complex n-ary information must often
 * be asserted using a nested node.  Such a nested node can be given a name
 * with {@link iri} or {@link addIri}.  In some cases, it is inconvenient to
 * come up with a naming scheme for such intermediate nodes.  In such cases a
 * content-based IRI can be generated with {@link addHashedIri}, or a random
 * IRI can be generated with {@link addRandomIri}.  Finally, a random Skolem
 * IRI can be generated with {@link addSkolemIri} to represent a nested node
 * that can be treated as a 'blank node' in RDF.
 *
 * @param subject - A subject term.  This must be either an {@link iri}.
 *
 * @param predicate - A predicate term.  This must be an {@link iri}.
 *
 * @param nestedNode - The nested node.  This must be an {@link iri}.
 *
 * @param pairs - One or more pairs that make assertions about the nested
 * node.  Every pair consists of a predicate term and an object term (in that
 * order).
 *
 * @example
 * The following example asserts a value together with a unit of measure.
 * A well-known Skolem IRI or 'blank node' is used to attach the value and
 * unit to:
 *
 * ```ts
 * fromJson([{ id: '1', height: 15 }]),
 * addSkolemIri({
 *   prefix: prefix.skolem,
 *   key: '_height',
 * }),
 * nestedPairs(iri(prefix.product, 'id'), sdo.height, '_height',
 *   [qudt.unit, unit.CentiM],
 *   [rdf.value, 'height'],
 * ),
 * ```
 *
 * This generates the following linked data assertyions:
 *
 * ```ttl
 * product:1 sdo:height
 *   [ qudt:unit unit:CentiM;
 *     rdf:value 15 ].
 * ```
 *
 * @example
 * The following example asserts a GeoSPARQL geometry. The geometry is created
 * as a separate node.
 *
 * ```ts
 * fromJson([{ id: '1', geometry: 'Point(1.1 2.2)' }]),
 * nestedpairs(iri(prefix.feature, 'id'), geo.hasGeometry, iri(prefix.geometry, 'id'),
 *   [a, geo.Geometry],
 *   [geo.asWKT, literal('geometry', geo.wktLiteral)],
 * ),
 * ```
 *
 * This generates the following RDF, where a well-known Skolem IRI is used for
 * the geometry 'blank node':
 *
 * ```ttl
 * feature:1 geo:hasGeometry geometry:1.
 * geometry:1
 *   a geo:Geometry;
 *   geo:asWKT 'Point(1.1 2.2)'^^geo:wktLiteral.
 * ```
 *
 * The `nestedpairs()` assertion is a shorter notation for the following
 * sequence of middlewares:
 *
 * ```ts
 * fromJson([{ id: '1', geometry: 'Point(1.1 2.2)' }]),
 * triple(iri(prefix.feature, 'id'), geo.hasGeometry, iri(prefix.geometry, 'id')),
 * pairs(iri(prefix.geometry, 'id'),
 *   [a, geo.Geometry],
 *   [geo.asWKT, literal('geometry', geo.wktLiteral)],
 * ),
 * ```
 */
function nestedPairs(subject: SPG, predicate: SPG, pair: Pair, ...pairs: Pair[]): Middleware;
function nestedPairs(subject: SPG, predicate: SPG, object: SPG, ...pairs: Pair[]): Middleware;
function nestedPairs(graph: SPG, subject: SPG, predicate: SPG, object: SPG, ...pairs: Pair[]): Middleware;
function nestedPairs(
  graphOrSubject: SPG,
  subjectOrPredicate: SPG,
  predicateOrObject: SPG | Pair,
  objectOrPair: SPG | Pair,
  ...pairs: Pair[]
): Middleware {
  // this will result in a Skolem Iri being used:
  let predicateOrObjectOrUndefined: SPG | undefined;
  if (isPair(predicateOrObject)) {
    if (isPair(objectOrPair)) {
      pairs.unshift(objectOrPair);
    }
    if (predicateOrObject !== undefined) pairs.unshift(predicateOrObject);
    predicateOrObjectOrUndefined = undefined;
  } else {
    predicateOrObjectOrUndefined = predicateOrObject as SPG;
  }
  return convertMwListToMiddleware(
    _nestedPairs(graphOrSubject, subjectOrPredicate, predicateOrObjectOrUndefined, objectOrPair, ...pairs),
    "_nestedPairs",
  );
}

export default nestedPairs;
