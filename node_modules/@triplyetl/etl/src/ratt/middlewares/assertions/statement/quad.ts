import { Literal, NamedNode } from "@triplydb/data-factory/Terms.js";
import { Key, Middleware } from "../../../../generic/index.js";
import { TermGetter } from "../term/getter.js";
import { StaticString } from "../term/str.js";
import quad, { ObjectLiterals } from "./rdf/quad.js";

/**
 * Assets a quadruple or 'quad', i.e. a statement that consists of a subject
 * term, a predicate term, an object term, and a graph name.
 *
 * @remarks
 * A quad is a {@link triple} with a graph name as its fourth parameter.
 *
 * @param subject - A subject term.  This must be either an {@link iri}.
 *
 * @param predicate - A predicate term.  This must be an {@link iri}.
 *
 * @param object - An object term.  This must be either an {@link iri} or a
 * {@link literal}.
 *
 * @param graph - A graph name.  This must be an {@link iri}.
 *
 * @example
 * An ETL may distinguish between data and metadata assertions.  Both may be
 * placed into distinct graphs.  The following snippet makes one assertion in
 * a metadata graph and one assertion in a data graph.
 *
 * ```ts
 * quad(iri(prefix.dataset, 'flowers'), a, dcat.Dataset, graph.metadata),
 * quad(iri(prefix.flower, '_id'), a, def.Flower, graph.data),
 * ```
 *
 * @see {@link quads} for making multiple quadruple assertions.
 */
export default (
  subject: StaticString | Key | TermGetter<NamedNode>,
  predicate: StaticString | Key | TermGetter<NamedNode>,
  object: StaticString | ObjectLiterals | ObjectLiterals[] | TermGetter<NamedNode | Literal>,
  graphName: StaticString | Key | TermGetter<NamedNode>
): Middleware => quad(subject, predicate, object, graphName);
