import { getFactory } from "@triplydb/data-factory";
import chai from "chai";
import * as vocab from "@triplyetl/vocabularies";
import { getEtlForTesting } from "../../../../__tests__/getEtlForTesting.js";
import { addLiteral, addValue, addIri } from "../../../transformations/index.js";
import { str, literal } from "../../term/index.js";
import pairs from "../pairs.js";

const DataFactory = getFactory();

const assert = chai.assert;

describe("writing.pairs", () => {
  it("should create 5 triples", () => {
    return getEtlForTesting([
      addLiteral({ content: str("Heineken"), language: vocab.languageTag("nl"), key: "naam" }),
      addValue({ content: "Heineken Brouwerij", key: "naamPrimitive" }),
      addIri({ content: str("http://ex.com/Brewery"), key: "subject" }),
      addIri({ content: str("http://ex.com/name"), key: "predicate" }),
      addIri({ content: str("http://ex.com/names/Heineken"), key: "objectIri" }),
      pairs(
        vocab.sdo.Brewery,
        [vocab.rdf.type, vocab.sdo.FoodEstablishment],
        [vocab.sdo.name, literal(str("Heineken"), vocab.languageTag("en"))],
        [vocab.sdo.name, str("Heineken")],
        [vocab.sdo.name, "objectIri"],
        [vocab.sdo.name, "naamPrimitive"],
      ),
      async (ctx, next) => {
        assert.equal(5, ctx.store.getQuads({}).length);
        return next();
      },
    ]).run();
  });

  it("should create 5 triples in a graph", () => {
    const graph = getFactory().namedNode("http://ex.com/graph");
    return getEtlForTesting([
      addLiteral({ content: str("Heineken"), language: vocab.languageTag("nl"), key: "naam" }),
      addValue({ content: "Heineken Brouwerij", key: "naamPrimitive" }),
      addIri({ content: str("http://ex.com/graph"), key: "graph" }),
      addIri({ content: str("http://ex.com/Brewery"), key: "subject" }),
      addIri({ content: str("http://ex.com/name"), key: "predicate" }),
      addIri({ content: str("http://ex.com/names/Heineken"), key: "objectIri" }),
      pairs(
        "graph",
        vocab.sdo.Brewery,
        [vocab.rdf.type, vocab.sdo.FoodEstablishment],
        [vocab.sdo.name, literal(str("Heineken"), vocab.languageTag("en"))],
        [vocab.sdo.name, str("Heineken")],
        [vocab.sdo.name, "objectIri"],
        [vocab.sdo.name, "naamPrimitive"],
      ),
      async (ctx, next) => {
        assert.equal(5, ctx.store.getQuads({ graph }).length);
        return next();
      },
    ]).run();
  });

  it("should create a triple from static strings", () => {
    const subject = "http://ex.com/Brewery";
    const predicate = "http://ex.com/name";
    const object = str("Heineken");
    return getEtlForTesting([
      pairs(str(subject), [str(predicate), str(object)]),
      async (ctx, next) => {
        assert.equal(1, ctx.store.getQuads({ subject: DataFactory.namedNode(subject) }).length);
        assert.equal(
          1,
          ctx.store.getQuads({ subject: DataFactory.namedNode(subject), predicate: DataFactory.namedNode(predicate) })
            .length,
        );
        assert.equal(
          1,
          ctx.store.getQuads({
            subject: DataFactory.namedNode(subject),
            predicate: DataFactory.namedNode(predicate),
            object: DataFactory.literal(object.toString()),
          }).length,
        );
        return next();
      },
    ]).run();
  });

  it("should create a triple from strings stored in keys", () => {
    const subject = "http://ex.com/Brewery";
    const predicate = "http://ex.com/name";
    const object = "Heineken";
    return getEtlForTesting([
      addValue({ key: "subject", content: str(subject) }),
      addValue({ key: "predicate", content: str(predicate) }),
      addValue({ key: "object", content: str(object) }),
      pairs("subject", ["predicate", "object"]),
      async (ctx, next) => {
        const subjectNode = DataFactory.namedNode(subject);
        const predicateNode = DataFactory.namedNode(predicate);
        const objectNode = DataFactory.literal(object);
        assert.equal(1, ctx.store.getQuads({ subject: subjectNode }).length);
        assert.equal(1, ctx.store.getQuads({ subject: subjectNode, predicate: predicateNode }).length);
        assert.equal(
          1,
          ctx.store.getQuads({ subject: subjectNode, predicate: predicateNode, object: objectNode }).length,
        );
        return next();
      },
    ]).run();
  });

  it("should create a triple where object is a typed literal", () => {
    const subject = "http://ex.com/Brewery";
    const predicate = "http://ex.com/name";
    const object = "2022";
    return getEtlForTesting([
      addValue({ key: "subject", content: subject }),
      addValue({ key: "predicate", content: predicate }),
      addLiteral({ key: "object", content: str(object), datatype: vocab.xsd.gYear }),
      pairs("subject", ["predicate", "object"]),
      async (ctx, next) => {
        const subjectNode = DataFactory.namedNode(subject);
        const predicateNode = DataFactory.namedNode(predicate);
        const objectNode = DataFactory.literal(object, vocab.xsd.gYear);
        assert.equal(1, ctx.store.getQuads({ subject: subjectNode }).length);
        assert.equal(1, ctx.store.getQuads({ subject: subjectNode, predicate: predicateNode }).length);
        assert.equal(
          1,
          ctx.store.getQuads({ subject: subjectNode, predicate: predicateNode, object: objectNode }).length,
        );
        return next();
      },
    ]).run();
  });
});
