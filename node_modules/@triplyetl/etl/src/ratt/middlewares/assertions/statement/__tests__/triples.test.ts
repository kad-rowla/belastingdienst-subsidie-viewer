import chai from "chai";
import { addIri, addLiteral, addValue } from "../../../transformations/index.js";
import { getEtlForTesting } from "../../../../__tests__/getEtlForTesting.js";
import triples from "../triples.js";
import { literal, str } from "../../index.js";
import * as vocab from "@triplyetl/vocabularies";
import { getFactory } from "@triplydb/data-factory";
const dataFactory = getFactory();

const assert = chai.assert;
const graph = dataFactory.namedNode("http://ex.com/graph");
const anotherGraph = dataFactory.namedNode("http://ex.com/anotherGraph");

describe("writing.triples", () => {
  it("should create 5 triples in 2 triples", () => {
    return getEtlForTesting([
      addLiteral({ content: str("Heineken"), language: vocab.languageTag("nl"), key: "naam" }),
      addValue({ content: "Heineken Brouwerij", key: "naamPrimitive" }),
      addIri({ content: str("http://ex.com/Brewery"), key: "subject" }),
      addIri({ content: str("http://ex.com/name"), key: "predicate" }),
      addIri({ content: str("http://ex.com/names/Heineken"), key: "objectIri" }),
      triples(
        graph,
        [vocab.sdo.Brewery, vocab.rdf.type, vocab.sdo.FoodEstablishment],
        [vocab.sdo.Brewery, vocab.sdo.name, literal(str("Heineken Brewery"), vocab.languageTag("en"))],
        [vocab.sdo.Brewery, vocab.sdo.name, str("Heineken")],
      ),
      triples(
        anotherGraph,
        [vocab.sdo.Brewery, vocab.sdo.name, "objectIri"],
        [vocab.sdo.Brewery, vocab.sdo.name, "naamPrimitive"],
      ),
      async (ctx, next) => {
        assert.equal(5, ctx.store.getQuads({}).length);
        assert.equal(3, ctx.store.getQuads({ graph }).length);
        assert.equal(2, ctx.store.getQuads({ graph: anotherGraph }).length);
        return next();
      },
    ]).run();
  });

  it("should create a quad from static strings", () => {
    const subject = "http://ex.com/Brewery";
    const predicate = "http://ex.com/name";
    const object = str("Heineken");
    return getEtlForTesting([
      triples(graph, [str(subject), str(predicate), str(object)]),
      async (ctx, next) => {
        assert.equal(1, ctx.store.getQuads({ graph }).length);
        assert.equal(1, ctx.store.getQuads({ graph, subject: dataFactory.namedNode(subject) }).length);
        assert.equal(
          1,
          ctx.store.getQuads({
            graph,
            subject: dataFactory.namedNode(subject),
            predicate: dataFactory.namedNode(predicate),
          }).length,
        );
        assert.equal(
          1,
          ctx.store.getQuads({
            graph,
            subject: dataFactory.namedNode(subject),
            predicate: dataFactory.namedNode(predicate),
            object: dataFactory.literal(object.toString()),
          }).length,
        );
        return next();
      },
    ]).run();
  });

  it("should create a quad from strings stored in keys", () => {
    const subject = "http://ex.com/Brewery";
    const predicate = "http://ex.com/name";
    const object = "Heineken";
    return getEtlForTesting([
      addValue({ key: "graph", content: str(graph.value) }),
      addValue({ key: "subject", content: str(subject) }),
      addValue({ key: "predicate", content: str(predicate) }),
      addValue({ key: "object", content: str(object) }),
      triples("graph", ["subject", "predicate", "object"]),
      async (ctx, next) => {
        const subjectNode = dataFactory.namedNode(subject);
        const predicateNode = dataFactory.namedNode(predicate);
        const objectNode = dataFactory.literal(object);
        assert.equal(1, ctx.store.getQuads({ graph, subject: subjectNode }).length);
        assert.equal(1, ctx.store.getQuads({ graph, subject: subjectNode, predicate: predicateNode }).length);
        assert.equal(
          1,
          ctx.store.getQuads({ graph, subject: subjectNode, predicate: predicateNode, object: objectNode }).length,
        );
        return next();
      },
    ]).run();
  });

  it("should create a quad where object is a typed literal", () => {
    const subject = "http://ex.com/Brewery";
    const predicate = "http://ex.com/name";
    const object = "2022";
    const etl = getEtlForTesting([
      addValue({ key: "graph", content: str(graph.value) }),
      addValue({ key: "subject", content: str(subject) }),
      addValue({ key: "predicate", content: str(predicate) }),
      addLiteral({ key: "object", content: str(object), datatype: vocab.xsd.gYear }),
      triples("graph", ["subject", "predicate", "object"]),
      async (ctx, next) => {
        const subjectNode = dataFactory.namedNode(subject);
        const predicateNode = dataFactory.namedNode(predicate);
        const objectNode = dataFactory.literal(object, vocab.xsd.gYear);
        assert.equal(1, ctx.store.getQuads({ graph, subject: subjectNode }).length);
        assert.equal(1, ctx.store.getQuads({ graph, subject: subjectNode, predicate: predicateNode }).length);
        assert.equal(
          1,
          ctx.store.getQuads({ graph, subject: subjectNode, predicate: predicateNode, object: objectNode }).length,
        );
        return next();
      },
    ]);
    return chai.expect(etl.run()).to.eventually.be.fulfilled;
  });
});
