import { getFactory } from "@triplydb/data-factory";
import chai from "chai";
import { Iri, declarePrefix, fromJson } from "../../../../../generic/index.js";
import { a, sdo } from "@triplyetl/vocabularies";
import { getEtlForTesting, getEtlForTestingNoExtractor } from "../../../../__tests__/getEtlForTesting.js";
import { concat, addSkolemIri, addIri } from "../../../transformations/index.js";
import nestedPairs from "../nestedPairs.js";
const DataFactory = getFactory();

const assert = chai.assert;

describe("writing.nestedPairs", () => {
  it("should created nested pairs", () => {
    const prefix = Iri("http://ex.com/");
    const data = { givenName: "John", familyName: "Doe" };
    return getEtlForTestingNoExtractor([
      fromJson(data),
      addSkolemIri({ key: "O", prefix }),
      concat({ key: "id", content: ["givenName", "familyName"] }),
      addIri({ key: "S", prefix, content: "id" }),
      nestedPairs("S", sdo.name, "O", [sdo.givenName, "givenName"], [sdo.familyName, "familyName"]),
      async (ctx, next) => {
        assert.equal(3, ctx.store.getQuads({}).length);
        const blanknodes = ctx.store.getObjects(ctx.getIri("S"), sdo.name, null);
        assert.equal(1, blanknodes.length);
        const givenName = DataFactory.literal(data.givenName);
        assert.equal(1, ctx.store.getQuads(blanknodes[0], sdo.givenName, givenName, null).length);
        const familyName = DataFactory.literal(data.familyName);
        assert.equal(1, ctx.store.getQuads(blanknodes[0], sdo.familyName, familyName, null).length);
        return next();
      },
    ]).run();
  });

  it("should create Skolem Iris (https://git.triply.cc/triply/etl/-/issues/221)", () => {
    const S = declarePrefix("http://ex.com/S");
    const P = declarePrefix("http://ex.com/P");
    return getEtlForTesting([
      nestedPairs(S, P, [a, sdo.Person]),
      nestedPairs(S, P, [a, sdo.Person]),
      async (ctx, _) => {
        const skolems = ctx.store.getQuads(null, a, sdo.Person, null);
        assert.equal(skolems.length, 2);
        const skolemPrefix = ctx.app.standardPrefixes.skolem.toString();
        assert.isFalse(skolems[0].subject.equals(skolems[1].subject));
        assert.isTrue(
          skolems[0].subject.value.startsWith(skolemPrefix),
          `Iri '${skolems[0].subject.value}' does not start with skolemPrefix '${skolemPrefix}'`,
        );
        assert.isTrue(
          skolems[1].subject.value.startsWith(skolemPrefix),
          `Iri '${skolems[1].subject.value}' does not start with skolemPrefix '${skolemPrefix}'`,
        );
      },
    ]).run();
  });

  it("should created nested pairs in a graph", () => {
    const prefix = Iri("http://ex.com/");
    const G = DataFactory.namedNode("http://ex.com/graph");
    const data = { givenName: "John", familyName: "Doe" };
    return getEtlForTestingNoExtractor([
      fromJson(data),
      addSkolemIri({ key: "O", prefix }),
      concat({ key: "id", content: ["givenName", "familyName"] }),
      addIri({ key: "S", prefix, content: "id" }),
      nestedPairs(G, "S", sdo.name, "O", [sdo.givenName, "givenName"], [sdo.familyName, "familyName"]),
      async (ctx, next) => {
        assert.equal(3, ctx.store.getQuads({ graph: G }).length);
        const blanknodes = ctx.store.getObjects(ctx.getIri("S"), sdo.name, G);
        assert.equal(1, blanknodes.length);
        const givenName = DataFactory.literal(data.givenName);
        assert.equal(1, ctx.store.getQuads(blanknodes[0], sdo.givenName, givenName, G).length);
        const familyName = DataFactory.literal(data.familyName);
        assert.equal(1, ctx.store.getQuads(blanknodes[0], sdo.familyName, familyName, G).length);
        return next();
      },
    ]).run();
  });
});
