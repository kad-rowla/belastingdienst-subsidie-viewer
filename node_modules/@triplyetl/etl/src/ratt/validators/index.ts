import _validator from "validator";
import { type AlphanumericLocale } from "validator/lib/isAlphanumeric.js";
import { type IsIBANOptions } from "validator/lib/isIBAN.js";
import { type IsCurrencyOptions } from "validator/lib/isCurrency.js";
import { type IsFQDNOptions } from "validator/lib/isFQDN.js";
import { type PostalCodeLocale } from "validator/lib/isPostalCode.js";
import { type IsURLOptions } from "validator/lib/isURL.js";
import { castArray } from "lodash-es";

const validator = _validator.default;

export function validate(literal: string, validators?: Validator | Validator[]) {
  if (validators) {
    const $validators = castArray(validators);
    const errors: string[] = [];
    for (const validator of $validators) {
      const result = validator(literal);
      const isValid = typeof result === "boolean" ? result : result.isValid;
      if (!isValid) {
        const msg =
          typeof result === "boolean"
            ? `The literal "${literal}" does not validate against the conditions provided.`
            : result.message;
        errors.push(msg);
      }
    }
    if (errors.length === 1) {
      throw new Error(errors[0]);
    } else if (errors.length !== 0) {
      throw new Error(errors.map((e) => `â€¢ ${e}`).join("\n"));
    }
  }
}

export type ValidationResult = { isValid: boolean; message: string };
export type Validator = (literal: string) => boolean | ValidationResult;

export function isEmail(): Validator {
  return (literal: string) => {
    const isValid = validator.isEmail(literal);
    if (isValid) return isValid;
    else
      return {
        isValid,
        message: `String "${literal}" is not an email address.`,
      };
  };
}

/**
 * Check if the string contains the seed.
 *
 * @param seed - Seed
 * @param options.minOccurrences indicates the number of times the seed must occur (defaults to 1)
 * @param options.ignoreCase indicates if the seed must be compared to String while ignoring the case of both
 */
export function contains(options: { seed: string; minOccurrences?: number; ignoreCase?: boolean }): Validator {
  return (literal: string) => {
    const isValid = validator.contains(literal, options.seed, {
      minOccurrences: options?.minOccurrences,
      ignoreCase: options?.ignoreCase,
    });
    if (isValid) return isValid;
    else {
      return {
        isValid,
        message: `String "${literal}" does not contain "${options.seed}"${
          options ? ` (options: ${JSON.stringify(options)})` : ""
        }.`,
      };
    }
  };
}

/**
 * Check if the string matches the comparison.
 *
 * @param comparison - String to compare
 */
export function equals(options: { compare: string }): Validator {
  return (literal: string) => {
    const isValid = validator.equals(literal, options.compare);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" does not equal "${options.compare}".`,
        };
  };
}

/**
 * Check if the string is a date that's after the specified date.
 *
 * @param [date] - Date string (defaults to now)
 */
export function isAfter(options?: { date?: string }): Validator {
  return (literal: string) => {
    const isValid = validator.isAfter(literal, options?.date);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not after "${options?.date ?? "now"}".`,
        };
  };
}

/**
 * Check if the string contains only letters and numbers.
 *
 * @param [locale] - AlphanumericLocale
 * @param [options] - IsAlphanumericOptions
 */
export function isAlpha(options?: { locale?: AlphanumericLocale; ignore?: string | RegExp }): Validator {
  return (literal: string) => {
    const isValid = validator.isAlpha(literal, options?.locale, { ignore: options?.ignore });
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not alphanumeric.`,
        };
  };
}

/**
 * Check if the string contains only letters and numbers.
 *
 * @param [locale] - AlphanumericLocale
 * @param [options] - IsAlphanumericOptions
 */
export function isAlphanumeric(options?: { locale?: AlphanumericLocale; ignore?: string | RegExp }): Validator {
  return (literal: string) => {
    const isValid = validator.isAlphanumeric(literal, options?.locale, { ignore: options?.ignore });
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not alphanumeric.`,
        };
  };
}

/**
 * Check if the string contains ASCII chars only.
 */
export function isAscii(): Validator {
  return (literal: string) => {
    const isValid = validator.isAscii(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" does not only contains ASCII chars.`,
        };
  };
}

/**
 * Check if a string is base32 encoded.
 */
export function isBase32(): Validator {
  return (literal: string) => {
    const isValid = validator.isBase32(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not base32 encoded.`,
        };
  };
}

/**
 * check if a string is base58 encoded
 */
export function isBase58(): Validator {
  return (literal: string) => {
    const isValid = validator.isBase58(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not base58 encoded.`,
        };
  };
}

/**
 * check if a string is base64 encoded
 */
export function isBase64(options?: { urlSafe?: boolean }): Validator {
  return (literal: string) => {
    const isValid = validator.isBase64(literal, options);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not base64 encoded.`,
        };
  };
}

/**
 * Check if the string is a date that's before the specified date.
 *
 * @param [date] - Date string (defaults to now)
 */
export function isBefore(options?: { date?: string }): Validator {
  return (literal: string) => {
    const isValid = validator.isBefore(literal, options?.date);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not before "${options?.date ?? "now"}".`,
        };
  };
}

/**
 * Check if a string is a IBAN (International Bank Account Number).
 */
export function isIBAN(options?: IsIBANOptions): Validator {
  return (literal: string) => {
    const isValid = validator.isIBAN(literal, options);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not an IBAN (International Bank Account Number).`,
        };
  };
}

/**
 * Check if a string is a BIC (Bank Identification Code) or SWIFT code.
 */
export function isBIC(): Validator {
  return (literal: string) => {
    const isValid = validator.isBIC(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a BIC (Bank Identification Code) or SWIFT code.`,
        };
  };
}

/**
 * Check if a string is a boolean.
 *
 * @param loose: boolean (default = false)
 *  If loose is is set to false, the validator will strictly match ['true', 'false', '0', '1'].
 *  If loose is set to true, the validator will also match 'yes', 'no', and will match a valid boolean string of any case. (eg: ['true', 'True', 'TRUE']).
 */
export function isBoolean(options?: { loose: boolean }): Validator {
  return (literal: string) => {
    const isValid = validator.isBoolean(literal, options);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a boolean.`,
        };
  };
}

/**
 * Check if the string's length (in UTF-8 bytes) falls in a range.
 *
 * @param [options] - Options
 */
export function isByteLength(options: { min: number; max?: number }): Validator {
  return (literal: string) => {
    const isValid = validator.isByteLength(literal, options);
    return isValid
      ? true
      : {
          isValid,
          message: `The length of literal "${literal}" does not fall in the range ${options?.min ?? 0}/${
            options?.max ?? "undefined"
          }.`,
        };
  };
}

/**
 * Check if the string is a credit card.
 *
 * @params provider
 */
export function isCreditCard(options?: {
  provider?: "amex" | "dinersclub" | "discover" | "jcb" | "mastercard" | "unionpay" | "visa" | "";
}): Validator {
  return (literal: string) => {
    const isValid = validator.isCreditCard(literal, options);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a credit card number.`,
        };
  };
}

export function isCurrency(options?: IsCurrencyOptions): Validator {
  return (literal: string) => {
    const isValid = validator.isCurrency(literal, options);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a currency.`,
        };
  };
}
/**
 * Check if the string is a [data uri format](https://developer.mozilla.org/en-US/docs/Web/HTTP/data_URIs).
 */
export function isDataURI(): Validator {
  return (literal: string) => {
    const isValid = validator.isDataURI(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a data uri format.`,
        };
  };
}

/**
 * Check if the string is a valid date.
 *
 * @params options.format?: string
 * @params options.strictMode?: boolean
 *   If strictMode is set to true, the validator will reject inputs different from format.
 * @params options.delimiters?: string[] an array of allowed date delimiters
 */
export function isDate(options?: { format?: string; strictMode?: boolean; delimiters?: string[] }): Validator {
  return (literal: string) => {
    const isValid = validator.isDate(literal, options);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a date.`,
        };
  };
}
type FloatLocale =
  | "en-US"
  | "ar"
  | "en-AU"
  | "en-GB"
  | "en-HK"
  | "en-IN"
  | "en-NZ"
  | "en-ZA"
  | "en-ZM"
  | "ar-AE"
  | "ar-BH"
  | "ar-DZ"
  | "ar-EG"
  | "ar-IQ"
  | "ar-JO"
  | "ar-KW"
  | "ar-LB"
  | "ar-LY"
  | "ar-MA"
  | "ar-QM"
  | "ar-QA"
  | "ar-SA"
  | "ar-SD"
  | "ar-SY"
  | "ar-TN"
  | "ar-YE"
  | "bg-BG"
  | "cs-CZ"
  | "da-DK"
  | "de-DE"
  | "el-GR"
  | "es-ES"
  | "fr-FR"
  | "it-IT"
  | "ku-IQ"
  | "hu-HU"
  | "nb-NO"
  | "nn-NO"
  | "nl-NL"
  | "pl-PL"
  | "pt-PT"
  | "ru-RU"
  | "sl-SI"
  | "sr-RS@latin"
  | "sr-RS"
  | "sv-SE"
  | "tr-TR"
  | "uk-UA"
  | "pt-BR"
  | "pl-Pl";

interface IsDecimalOptions {
  /**
   * @default false
   */
  force_decimal?: boolean;
  /**
   * `decimal_digits` is given as a range like `'1,3'`,
   * a specific value like `'3'` or min like `'1,'`
   *
   * @default '1,'
   */
  decimal_digits?: string;
  /**
   * DecimalLocale
   *
   * @default 'en-US'
   */
  locale?: FloatLocale;
}

/**
 * Check if the string represents a decimal number,
 * such as `0.1`, `.3`, `1.1`, `1.00003`, `4.0` etc.
 *
 * @param [options] - Options
 */
export function isDecimal(options?: IsDecimalOptions): Validator {
  return (literal: string) => {
    const isValid = validator.isDecimal(literal, options);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a decimal.`,
        };
  };
}

interface IsFloatOptions {
  /**
   * less or equal
   */
  min?: number;
  /**
   * greater or equal
   */
  max?: number;
  /**
   * greater than
   */
  gt?: number;
  /**
   * less than
   */
  lt?: number;
  /**
   * FloatLocale
   */
  locale?: FloatLocale;
}

/**
 * Check if the string is a float.
 *
 * @param [options] - IsFloatOptions
 */
export function isFloat(options?: IsFloatOptions): Validator {
  return (literal: string) => {
    const isValid = validator.isFloat(literal, options);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a float.`,
        };
  };
}

/**
 * Check if the string is a fully qualified domain name (e.g. `domain.com`).
 *
 * @param [options] - Options
 */
export function isFQDN(options?: IsFQDNOptions): Validator {
  return (literal: string) => {
    const isValid = validator.isFQDN(literal, options);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a fully qualified domain name.`,
        };
  };
}

/**
 * Check if the string contains any full-width chars.
 */
export function isFullWidth(): Validator {
  return (literal: string) => {
    const isValid = validator.isFullWidth(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" does not contain any full-width chars.`,
        };
  };
}

/**
 * Check if the string contains any full-width chars.
 */
export function isHalfWidth(): Validator {
  return (literal: string) => {
    const isValid = validator.isHalfWidth(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" does not contain any half-width chars.`,
        };
  };
}

type HashAlgorithm =
  | "md4"
  | "md5"
  | "sha1"
  | "sha256"
  | "sha384"
  | "sha512"
  | "ripemd128"
  | "ripemd160"
  | "tiger128"
  | "tiger160"
  | "tiger192"
  | "crc32"
  | "crc32b";

/**
 * Check if the string is a hash of type algorithm.
 *
 * @param otions.algorithm - HashAlgorithm (defaulkt = md5)
 */
export function isHash(options?: { algorithm?: HashAlgorithm }): Validator {
  return (literal: string) => {
    const isValid = validator.isHash(literal, options?.algorithm ?? "md5");
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a ${options?.algorithm ?? "md5"} hash.`,
        };
  };
}

export const isMD4 = () => isHash({ algorithm: "md4" });
export const isMD5 = () => isHash({ algorithm: "md5" });
export const isSHA1 = () => isHash({ algorithm: "sha1" });
export const isSHA256 = () => isHash({ algorithm: "sha256" });
export const isSHA384 = () => isHash({ algorithm: "sha384" });
export const isSHA512 = () => isHash({ algorithm: "sha512" });

/**
 * Check if the string is a hexadecimal number.
 */
export function isHexadecimal(): Validator {
  return (literal: string) => {
    const isValid = validator.isHexadecimal(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a hexadecimal number.`,
        };
  };
}

/**
 * Check if the string is a hexadecimal color.
 */
export function isHexColor(): Validator {
  return (literal: string) => {
    const isValid = validator.isHexColor(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a hexadecimal color.`,
        };
  };
}

/**
 * Check if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.
 * Comma-separated format supported. Space-separated format supported with the exception of a few edge cases (ex: hsl(200grad+.1%62%/1)).
 */
export function isHSL(): Validator {
  return (literal: string) => {
    const isValid = validator.isHSL(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not an HSL color.`,
        };
  };
}

/**
 * Check if the string is a rgb or rgba color.
 *
 * @param [includePercentValues=true] - If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false. (defaults to true)
 */
export function isRgbColor(options?: { includePercentValues?: boolean }): Validator {
  return (literal: string) => {
    const isValid = validator.isRgbColor(literal, options?.includePercentValues);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a rgb or rgba color.`,
        };
  };
}

/**
 * Check if the string is a valid IMEI.
 * Non-hyphenated (`###############`) only is supported by default.
 * Use the `options` param to enable hyphenated (`##-######-######-#`) support.
 *
 * @param options.allow_hyphens?: boolean
 */
export function isIMEI(options?: { allow_hyphens: boolean }): Validator {
  return (literal: string) => {
    const isValid = validator.isIMEI(literal, options);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not an IMEI.`,
        };
  };
}

/**
 * Check if the string is in a array of allowed values.
 *
 * @param options.values string[]
 */
export function isIn(options: { values: string[] }): Validator {
  return (literal: string) => {
    const isValid = validator.isIn(literal, options.values);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not in ${JSON.stringify(options.values)}.`,
        };
  };
}

interface IsIntOptions {
  /**
   * to check the integer min boundary
   */
  min?: number | undefined;
  /**
   * to check the integer max boundary
   */
  max?: number | undefined;
  /**
   * if `false`, will disallow integer values with leading zeroes
   * @default true
   */
  allow_leading_zeroes?: boolean | undefined;
  /**
   * enforce integers being greater than the value provided
   */
  lt?: number | undefined;
  /**
   * enforce integers being less than the value provided
   */
  gt?: number | undefined;
}

/**
 * Check if the string is an integer.
 *
 * @param options - IsIntOptions
 */
export function isInt(options?: IsIntOptions): Validator {
  return (literal: string) => {
    const isValid = validator.isInt(literal, options);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not an integer.`,
        };
  };
}
export const isInteger = isInt;

/**
 * Check if the string is an IP (version 4 or 6).
 *
 * @param options.version - IP Version
 */
export function isIP(options?: { version?: "4" | "6" | 4 | 6 }): Validator {
  return (literal: string) => {
    const isValid = validator.isIP(literal, options?.version);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not an IP${options?.version ? `v${options?.version}` : ""} address.`,
        };
  };
}

/**
 * Check if the string is an IPv4.
 */
export const isIPv4 = () => isIP({ version: 4 });

/**
 * Check if the string is an IPv6.
 */
export const isIPv6 = () => isIP({ version: 6 });

/**
 * Check if the string is an IP (version 4 or 6).
 *
 * @param options.version - IP Version
 */
export function isIPRange(options?: { version?: "4" | "6" | 4 | 6 }): Validator {
  return (literal: string) => {
    const isValid = validator.isIPRange(literal, options?.version);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not an IP${options?.version ? `v${options?.version}` : ""} range.`,
        };
  };
}

/**
 * Check if the string is an IPv4 range.
 */
export const isIPv4Range = () => isIPRange({ version: 4 });

/**
 * Check if the string is an IPv6 range.
 */
export const isIPv6Range = () => isIPRange({ version: 6 });

/**
 * Check if the string is an ISBN (version 10 or 13).
 *
 * @param options.version - IP Version
 */
export function isISBN(options?: { version?: "10" | "13" | 10 | 13 }): Validator {
  return (literal: string) => {
    const isValid = validator.isISBN(literal, options?.version);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not an ISBN${options?.version ? ` (v${options?.version})` : ""}.`,
        };
  };
}

/**
 * Check if the string is an IPv4 range.
 */
export const isISBNv13 = () => isISBN({ version: 13 });

/**
 * Check if the string is an IPv6 range.
 */
export const isISBNv10 = () => isISBN({ version: 10 });

/**
 * Check if the string is an EAN (European Article Number).
 */
export function isEAN(): Validator {
  return (literal: string) => {
    const isValid = validator.isEAN(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not an EAN (European Article Number).`,
        };
  };
}

/**
 * Check if the string is an [ISIN](https://en.wikipedia.org/wiki/International_Securities_Identification_Number) (stock/security identifier).
 */
export function isISIN(): Validator {
  return (literal: string) => {
    const isValid = validator.isISIN(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not an ISIN.`,
        };
  };
}

/**
 * Check if the string is a valid [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) officially assigned country code.
 */
export function isISO31661Alpha2(): Validator {
  return (literal: string) => {
    const isValid = validator.isISO31661Alpha2(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not an ISO 3166-1 alpha-2 string.`,
        };
  };
}

/**
 * Check if the string is a valid [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) officially assigned country code.
 */
export function isISO31661Alpha3(): Validator {
  return (literal: string) => {
    const isValid = validator.isISO31661Alpha3(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not an ISO 3166-1 alpha-3 string.`,
        };
  };
}

/**
 * Check if the string is a valid [ISO 6346](https://en.wikipedia.org/wiki/ISO_6346) shipping container identification.
 */
export function isISO6346(): Validator {
  return (literal: string) => {
    const isValid = validator.isISO6346(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not an ISO 6346 string.`,
        };
  };
}

/**
 * Alias for [isISO6346]
 */
export const isFreightContainerID = isISO6346;

/**
 * Check if the string is a valid [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) officially assigned language code.
 */
export function isISO6391(): Validator {
  return (literal: string) => {
    const isValid = validator.isISO6391(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not an ISO 6391 string.`,
        };
  };
}

/**
 * Check if the string is a valid [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date.
 *
 * @param options.strict if true performs additional checks for valid dates, e.g. invalidates dates like `2009-02-29`
 * @param options.strictSeparator if true, date strings with date and time separated by anything other than a T will be invalid
 */
export function isISO8601(options?: { strict?: boolean; strictSeparator?: boolean }): Validator {
  return (literal: string) => {
    const isValid = validator.isISO8601(literal, options);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not an ISO 8601 string.`,
        };
  };
}

/**
 * Check if the string is an [ISSN](https://en.wikipedia.org/wiki/International_Standard_Serial_Number).
 *
 * @param options.case_sensitive if true ISSNs with a lowercase `x` as the check digit are rejected
 * @param options.require_hyphen
 */
export function isISSN(options?: { case_sensitive?: boolean; require_hyphen?: boolean }): Validator {
  return (literal: string) => {
    const isValid = validator.isISSN(literal, options);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not an ISSN (International Standard Serial Number).`,
        };
  };
}

/**
 * Check if the string is a valid [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) officially assigned currency code.
 */
export function isISO4217(): Validator {
  return (literal: string) => {
    const isValid = validator.isISO4217(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not an ISO 4217 string.`,
        };
  };
}

/**
 * Check if the string is a [ISRC](https://en.wikipedia.org/wiki/International_Standard_Recording_Code).
 */
export function isISRC(): Validator {
  return (literal: string) => {
    const isValid = validator.isISRC(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not an ISRC (International Standard Recording Code).`,
        };
  };
}

/**
 * Check if the string is a valid [RFC 3339](https://tools.ietf.org/html/rfc3339) date.
 */
export function isRFC3339(): Validator {
  return (literal: string) => {
    const isValid = validator.isRFC3339(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not an RFC 3339 date.`,
        };
  };
}

/**
 * Check if the string is valid JSON (note: uses `JSON.parse`).
 */
export function isJSON(): Validator {
  return (literal: string) => {
    const isValid = validator.isJSON(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not valid JSON.`,
        };
  };
}
/**
 * Check if the string is valid JWT token.
 */
export function isJWT(): Validator {
  return (literal: string) => {
    const isValid = validator.isJWT(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a valid JWT token.`,
        };
  };
}
/**
 * Check if the string is a valid latitude-longitude coordinate in the format:
 *
 * `lat,long` or `lat, long`.
 */
export function isLatLong(): Validator {
  return (literal: string) => {
    const isValid = validator.isLatLong(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a valid latitude-longitude coordinate.`,
        };
  };
}

/**
 * Check if the string's length falls in a range.
 *
 * Note: this function takes into account surrogate pairs.
 *
 * @param options.min
 * @param options.max
 */
export function isLength(options?: { min?: number; max?: number }): Validator {
  return (literal: string) => {
    const isValid = validator.isLength(literal, options);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not of the correct length.`,
        };
  };
}

/**
 * Check if the string is a locale.
 */
export function isLocale(): Validator {
  return (literal: string) => {
    const isValid = validator.isLocale(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a locale.`,
        };
  };
}

/**
 * Check if the string is lowercase.
 */
export function isLowercase(): Validator {
  return (literal: string) => {
    const isValid = validator.isLowercase(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not in lowercase.`,
        };
  };
}

/**
 * Check if the string is uppercase.
 */
export function isUppercase(): Validator {
  return (literal: string) => {
    const isValid = validator.isUppercase(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not in uppercase.`,
        };
  };
}

/**
 * Check if the string matches to a valid [MIME type](https://en.wikipedia.org/wiki/Media_type) format.
 */
export function isMimeType(): Validator {
  return (literal: string) => {
    const isValid = validator.isMimeType(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a valid MIME type.`,
        };
  };
}

type MobilePhoneLocale = PhoneLocale | PhoneLocaleAlias;
type PhoneLocale =
  | "am-AM"
  | "ar-AE"
  | "ar-BH"
  | "ar-DZ"
  | "ar-LB"
  | "ar-EG"
  | "ar-IQ"
  | "ar-JO"
  | "ar-KW"
  | "ar-LY"
  | "ar-MA"
  | "ar-OM"
  | "ar-SA"
  | "ar-SY"
  | "ar-TN"
  | "az-AZ"
  | "bs-BA"
  | "be-BY"
  | "bg-BG"
  | "bn-BD"
  | "ca-AD"
  | "cs-CZ"
  | "da-DK"
  | "de-DE"
  | "de-AT"
  | "de-CH"
  | "de-LU"
  | "el-GR"
  | "en-AU"
  | "en-GB"
  | "en-GG"
  | "en-GH"
  | "en-HK"
  | "en-MO"
  | "en-IE"
  | "en-IN"
  | "en-KE"
  | "en-MT"
  | "en-MU"
  | "en-NG"
  | "en-NZ"
  | "en-PK"
  | "en-PH"
  | "en-RW"
  | "en-SG"
  | "en-SL"
  | "en-TZ"
  | "en-UG"
  | "en-US"
  | "en-ZA"
  | "en-ZM"
  | "en-ZW"
  | "es-AR"
  | "es-BO"
  | "es-CO"
  | "es-CL"
  | "es-CR"
  | "es-DO"
  | "es-HN"
  | "es-EC"
  | "es-ES"
  | "es-PE"
  | "es-MX"
  | "es-PA"
  | "es-PY"
  | "es-UY"
  | "es-VE"
  | "et-EE"
  | "fa-IR"
  | "fi-FI"
  | "fj-FJ"
  | "fo-FO"
  | "fr-FR"
  | "fr-GF"
  | "fr-GP"
  | "fr-MQ"
  | "fr-RE"
  | "he-IL"
  | "hu-HU"
  | "id-ID"
  | "it-IT"
  | "it-SM"
  | "ja-JP"
  | "ka-GE"
  | "kk-KZ"
  | "kl-GL"
  | "ko-KR"
  | "lt-LT"
  | "lv-LV"
  | "ms-MY"
  | "mz-MZ"
  | "nb-NO"
  | "ne-NP"
  | "nl-BE"
  | "nl-NL"
  | "nn-NO"
  | "pl-PL"
  | "pt-BR"
  | "pt-PT"
  | "pt-AO"
  | "ro-RO"
  | "ru-RU"
  | "si-LK"
  | "sl-SI"
  | "sk-SK"
  | "sq-AL"
  | "sr-RS"
  | "sv-SE"
  | "th-TH"
  | "tr-TR"
  | "uk-UA"
  | "uz-UZ"
  | "vi-VN"
  | "zh-CN"
  | "zh-TW";
type PhoneLocaleAlias = "en-CA" | "fr-CA" | "fr-BE" | "zh-HK" | "zh-MO" | "ga-IE" | "fr-CH" | "it-CH";

/**
 *
 * @param options.strictmode If this is set to `true`, the mobile phone number must be supplied with the country code and therefore must start with `+`.
 * @param options.locale locale of the Mobile Phone
 */
export function isMobilePhone(options?: {
  locale?: "any" | MobilePhoneLocale | MobilePhoneLocale[];
  strictmode?: boolean;
}): Validator {
  return (literal: string) => {
    const isValid = validator.isMobilePhone(literal, options?.locale, { strictMode: options?.strictmode });
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a valid mobile number.`,
        };
  };
}

/**
 * Check if the string is a valid hex-encoded representation of a [MongoDB ObjectId](http://docs.mongodb.org/manual/reference/object-id/).
 */
export function isMongoId(): Validator {
  return (literal: string) => {
    const isValid = validator.isMongoId(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a MongoDB ObjectId.`,
        };
  };
}

/**
 * Check if the string contains one or more multibyte chars.
 */
export function isMultibyte(): Validator {
  return (literal: string) => {
    const isValid = validator.isMultibyte(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" does not contain multibyte characters .`,
        };
  };
}

/**
 * Check if the string contains only numbers.
 *
 * @param options.no_symbols if true the validator will reject numeric strings that feature a symbol (e.g. `+`, `-`, or `.`).
 * @param options.locale string
 */
export function isNumeric(options?: { no_symbols?: boolean; locale?: AlphanumericLocale }): Validator {
  return (literal: string) => {
    const isValid = validator.isNumeric(literal, options);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" does not contain only numbers .`,
        };
  };
}

/**
 * Check if the string is a valid octal number.
 */
export function isOctal(): Validator {
  return (literal: string) => {
    const isValid = validator.isOctal(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a valid octal number.`,
        };
  };
}

type CountryCodes =
  | "AM"
  | "AR"
  | "AT"
  | "AU"
  | "AZ"
  | "BE"
  | "BG"
  | "BR"
  | "BY"
  | "CA"
  | "CH"
  | "CN"
  | "CY"
  | "CZ"
  | "DE"
  | "DK"
  | "DZ"
  | "EE"
  | "ES"
  | "FI"
  | "FR"
  | "GB"
  | "GR"
  | "HR"
  | "HU"
  | "IE"
  | "IN"
  | "ID"
  | "IR"
  | "IS"
  | "IT"
  | "JM"
  | "JP"
  | "KR"
  | "KZ"
  | "LI"
  | "LT"
  | "LU"
  | "LV"
  | "LY"
  | "MT"
  | "MZ"
  | "MY"
  | "MX"
  | "NL"
  | "NZ"
  | "PH"
  | "PK"
  | "PL"
  | "PT"
  | "RO"
  | "RU"
  | "SE"
  | "SL"
  | "SK"
  | "TH"
  | "TR"
  | "UA"
  | "US";

/**
 * Check if the string is a valid passport number relative to a specific country code.
 *
 * @param [countryCode] - Country code
 */
export function isPassportNumber(options: { countryCode: CountryCodes }): Validator {
  return (literal: string) => {
    const isValid = validator.isPassportNumber(literal, options.countryCode);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a ${options.countryCode} passport number.`,
        };
  };
}

/**
 * Check if the string is a valid port number.
 */
export function isPort(): Validator {
  return (literal: string) => {
    const isValid = validator.isPort(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a valid port number.`,
        };
  };
}

/**
 * Check if the string is a postal code
 *
 * @param locale - PostalCodeLocale
 */
export function isPostalCode(options?: { locale?: PostalCodeLocale }): Validator {
  return (literal: string) => {
    const isValid = validator.isPostalCode(literal, options?.locale ?? "any");
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a valid ${options?.locale ? options?.locale + " " : ""}postal code.`,
        };
  };
}

/**
 * Check if the string is a Semantic Versioning Specification (SemVer).
 */
export function isSemVer(): Validator {
  return (literal: string) => {
    const isValid = validator.isSemVer(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a Semantic Versioning Specification (SemVer).`,
        };
  };
}

interface StrongPasswordOptions {
  minLength?: number | undefined;
  minLowercase?: number | undefined;
  minUppercase?: number | undefined;
  minNumbers?: number | undefined;
  minSymbols?: number | undefined;
  returnScore?: boolean | undefined;
  pointsPerUnique?: number | undefined;
  pointsPerRepeat?: number | undefined;
  pointsForContainingLower?: number | undefined;
  pointsForContainingUpper?: number | undefined;
  pointsForContainingNumber?: number | undefined;
  pointsForContainingSymbol?: number | undefined;
}
/**
 * Check if string is considered a strong password.
 */
export function isStrongPassword(options?: StrongPasswordOptions): Validator {
  return (literal: string) => {
    const score = validator.isStrongPassword(literal, { ...options, returnScore: true });
    const isValid = validator.isStrongPassword(literal, { ...options, returnScore: false });
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a strong password (score ${score}).`,
        };
  };
}

/**
 * Check if the string contains any surrogate pairs chars.
 */
export function isSurrogatePair(): Validator {
  return (literal: string) => {
    const isValid = validator.isSurrogatePair(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" contains surrogate pairs chars.`,
        };
  };
}

/**
 * Check if the string is a valid time.
 *
 * @param options.hourFormat 'hour24' will validate hours in 24 format and 'hour12' will validate hours in 12 format.
 * @param options.mode 'default' will validate HH:MM format, 'withSeconds' will validate the HH:MM:SS format
 */
export function isTime(options?: { hourFormat?: "hour12"; withSeconds?: boolean }): Validator {
  return (literal: string) => {
    const isValid = validator.isTime(literal, {
      hourFormat: options?.hourFormat,
      mode: options?.withSeconds ? "withSeconds" : "default",
    });
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a valid time.`,
        };
  };
}

/**
 * Check if the string is an URL.
 *
 * @param [options] - Options
 */
export function isURL(options?: IsURLOptions): Validator {
  return (literal: string) => {
    const isValid = validator.isURL(literal, options);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not an URL.`,
        };
  };
}
/**
 * Return true if the passed string is a valid tax identification number
 * for the specified locale.
 */
export function isTaxID(options?: { locale: string }): Validator {
  return (literal: string) => {
    let isValid: boolean = false;
    const locale = options?.locale ?? "en-US";
    try {
      isValid = validator.isTaxID(literal, locale);
    } catch (e) {
      return {
        isValid,
        message: `Could not check if string "${literal}" is a valid ${locale} Tax ID (wrong locale).`,
      };
    }
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a valid ${locale} Tax ID.`,
        };
  };
}

type UUIDVersion = "1" | "2" | "3" | "4" | "5" | "all" | 1 | 2 | 3 | 4 | 5;
/**
 * Check if the string is a UUID (version 1, 2, 3, 4 or 5).
 *
 * @param [version="all"] - UUID version
 */
export function isUUID(options?: { version: UUIDVersion }): Validator {
  return (literal: string) => {
    const isValid = validator.isUUID(literal, options?.version);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a valid${options?.version ? "v" + options.version : ""} UUID.`,
        };
  };
}
export const isUUIDv1 = () => isUUID({ version: 1 });
export const isUUIDv2 = () => isUUID({ version: 2 });
export const isUUIDv3 = () => isUUID({ version: 3 });
export const isUUIDv4 = () => isUUID({ version: 4 });
export const isUUIDv5 = () => isUUID({ version: 5 });

/**
 * Check if the string contains a mixture of full and half-width chars.
 */
export function isVariableWidth(): Validator {
  return (literal: string) => {
    const isValid = validator.isVariableWidth(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" does not contain a mixture of full and half-width chars.`,
        };
  };
}

/**
 * Checks that the string is a valid VAT number
 */
export function isVAT(options: { countryCode: string }): Validator {
  return (literal: string) => {
    let isValid: boolean = false;
    try {
      isValid = validator.isVAT(literal, options.countryCode);
    } catch (e) {
      return {
        isValid,
        message: `Could not check if string "${literal}" is a valid ${options.countryCode} VAT number ID (unsupported countrycode).`,
      };
    }
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a valid ${options.countryCode} VAT number.`,
        };
  };
}

/**
 * Checks characters if they appear in the whitelist.
 *
 * @param chars - whitelist
 */
export function isWhitelisted(options: { chars: string | string[] }): Validator {
  return (literal: string) => {
    const isValid = validator.isWhitelisted(literal, options.chars);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" does not appear in the whitelist ${
            Array.isArray(options.chars) ? JSON.stringify(options.chars) : `"${options.chars}"`
          }.`,
        };
  };
}

/**
 * Check if string matches the pattern.
 *
 * @param options.pattern - `/foo/i`
 */
export function matches(options: { pattern: RegExp }): Validator {
  return (literal: string) => {
    const isValid = validator.matches(literal, options.pattern);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" does not match the pattern "${options.pattern}".`,
        };
  };
}

/**
 * Check if the string is of type slug.
 */
export function isSlug(): Validator {
  return (literal: string) => {
    const isValid = validator.isSlug(literal);
    return isValid
      ? true
      : {
          isValid,
          message: `String "${literal}" is not a slug.`,
        };
  };
}
