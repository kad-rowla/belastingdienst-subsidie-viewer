/**
 * Based on https://raw.githubusercontent.com/vadimdemedes/ink/master/src/components/ErrorOverview.tsx
 * Manipulated this component to get more readable stack trace (not grey on black...)
 */
import React from "react";

import StackUtils from "stack-utils";
import { Text, Box, useApp } from "ink";
import * as fs from "fs";
import codeExcerpt, { CodeExcerpt } from "code-excerpt";
import { isEmpty, uniq } from "lodash-es";
import { getErr, EtlError } from "../../utils/Error.js";
import URL from "url";

import { Location } from "get-current-line";

const stackUtils = new StackUtils({
  cwd: process.cwd(),
  internals: StackUtils.nodeInternals(),
});

interface Props {
  readonly error: Error | EtlError;
  readonly verbosity: number;
}

const Stacktrace: React.FC<Props> = ({ error: _error, verbosity }) => {
  const error = getErr(_error);
  const { exit } = useApp();
  let stack: string[] | undefined;
  const origError = error.getErrForStacktrace();
  let callSite: Partial<Location> = error.callSite || {};

  React.useEffect(() => {
    // we need to wrap the exit in a setTimeout to avoid the Static component rendering twice
    // see https://github.com/vadimdemedes/ink/issues/397
    setTimeout(() => exit(new Error("Exit")), 0);
  }, [exit]);

  /**
   * If we don't have a callsite property, use the stack trace to present the snippet
   */
  if (verbosity && isEmpty(callSite)) {
    stack = origError.stack ? origError.stack.split("\n").slice(1) : undefined;
    const origin = stack ? stackUtils.parseLine(stack[0]) : undefined;
    callSite = {
      char: origin?.column,
      line: origin?.line,
      file: origin?.file,
      method: origin?.method,
    };
  }

  return (
    <Box flexDirection="column">
      {callSite && <Excerpt callSite={callSite} />}

      {!!verbosity && origError.stack && (
        <Box marginTop={1} flexDirection="column">
          {
            //Making the stack uniq, to avoid possibly react key issues
            uniq(origError.stack.split("\n").slice(1)).map((line) => {
              const parsedLine = stackUtils.parseLine(line);

              // If the line from the stack cannot be parsed, we print out the unparsed line.
              if (!parsedLine) {
                return (
                  <Box key={line}>
                    <Text dimColor>- </Text>
                    <Text dimColor bold>
                      {line}
                    </Text>
                  </Box>
                );
              }

              return (
                <Box key={line}>
                  <Text dimColor>- </Text>
                  <Text color="white" bold>
                    {parsedLine.function}
                  </Text>
                  <Text color="white">
                    {" "}
                    ({parsedLine.file}:{parsedLine.line}:{parsedLine.column})
                  </Text>
                </Box>
              );
            })
          }
        </Box>
      )}
    </Box>
  );
};

export function getExcerpt(
  location: Partial<Location>,
  opts?: { around?: number },
): { excerpt?: CodeExcerpt[]; lineWidth?: number } {
  const locationPath = location.file && URL.fileURLToPath(location.file);
  if (location && locationPath && location.line && fs.existsSync(locationPath)) {
    const sourceCode = fs.readFileSync(locationPath, "utf8");
    const around = opts?.around === undefined ? 3 : opts.around;
    let excerpt = codeExcerpt(sourceCode, location.line, { around });
    let lineWidth = 0;
    if (excerpt) {
      for (const excerptLint of excerpt) {
        lineWidth = Math.max(lineWidth, String(excerptLint.line).length);
      }
      return { excerpt, lineWidth };
    }
  }
  return {};
}

export interface ExcerptProps {
  callSite: Partial<Location>;
  around?: number;
}

const Excerpt: React.FC<ExcerptProps> = ({ callSite, around }) => {
  const { excerpt, lineWidth } = getExcerpt(callSite, { around });
  if (!excerpt) return <></>;
  return (
    <Box paddingX={1} borderStyle="single" borderColor="white" flexDirection="column">
      <Box flexDirection="column" alignItems="center">
        <Text backgroundColor="red" color="white">
          {callSite.file}:{callSite.line}:{callSite.char}
        </Text>
      </Box>
      {excerpt.map(({ line, value }) => (
        <Box key={line}>
          <Box width={(lineWidth || 0) + 1}>
            <Text
              dimColor={line !== callSite.line}
              backgroundColor={line === callSite.line ? "red" : undefined}
              color={line === callSite.line ? "white" : undefined}
            >
              {String(line).padStart(lineWidth || 0, " ")}:
            </Text>
          </Box>

          <Text
            key={line}
            backgroundColor={line === callSite.line ? "red" : undefined}
            color={line === callSite.line ? "white" : undefined}
          >
            {" " + value}
          </Text>
        </Box>
      ))}
    </Box>
  );
};
export default Stacktrace;
