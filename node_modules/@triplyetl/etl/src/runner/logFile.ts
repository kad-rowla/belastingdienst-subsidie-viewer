import { AfterHookDuration, MwRuntimeInfo } from "../generic/Etl.js";
import fs from "fs-extra";
// import { formatDuration, intervalToDuration } from "date-fns";
import { table, TableUserConfig } from "table";
import { compact, flatten, mapValues, sortBy, sum } from "lodash-es";
import { getExcerptsByFile } from "./components/UntouchedMiddlewares.js";

/**
 * This helper function returns a tuple of functions used for sorting in _.sortBy
 * @param position is the index value
 * @returns tuple of functions used for sorting in _.sortBy
 */
function sortByIndicePosition(position: number) {
  return [
    (runtime: MwRuntimeInfo) => runtime.mwIndicesPosition[position],
    (runtime: MwRuntimeInfo) => runtime.mwIndicesPosition.length,
  ];
}
export default function writeLogsToFile(opts: {
  version: string | number;
  environment: string | number;
  etlStartTime: string | number;
  etlEndTime: string | number;
  totalRuntimeMs: number;
  beforeDuration?: bigint;
  mwRuntimes: { [mwIndicesPosition: string]: MwRuntimeInfo };
  afterDurations: Array<AfterHookDuration>;
  numQuads: number | undefined;
  file: string;
  etlScriptFile: string;
  untouchedMiddlewares?: import("get-current-line").Location[];
}) {
  const runtimes = Object.values(opts.mwRuntimes);
  const deepestMwLength = Math.max(0, ...runtimes.map((r) => r.mwIndicesPosition.length));
  const sortedRuntimes = sortBy(
    runtimes,
    /**
     * We are using the 'deepestMwLength' to determine how many tuples we need to return.
     * The tuples from 'sortByIndicePosition' are then flattened to an array of functions to pass to _.sortBy
     * We also protect against Math.max called with no arguments which returns '-infinity'
     */
    flatten(
      Array(deepestMwLength)
        .fill(0)
        .map((_, index) => sortByIndicePosition(index)),
    ),
  );
  let totalNumOfRecords = 0;
  let totalMwRuntimes = 0;

  function bigintToMs(val: bigint) {
    // Parsing 'bigint' to 'number' for time formatting
    return Number(val) / 1_000_000;
  }
  //@here the time is formatted
  function formatMilliseconds(milliseconds: number): string {
    const microseconds = milliseconds.toFixed(6).toString().split(".");
    const date = new Date(milliseconds);
    const hours = date.getUTCHours();
    const minutes = date.getUTCMinutes();
    const seconds = date.getUTCSeconds();
    const ms = date.getUTCMilliseconds();
    const formattedTime = microseconds[1]
      ? `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(
          2,
          "0",
        )}.${String(ms).padStart(3, "0")}${String(microseconds[1].padStart(2, "0"))}`
      : `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(
          2,
          "0",
        )}.${String(ms).padStart(3, "0")}`;
    return formattedTime;
  }
  function millisecondsToHoursMinsSeconds(milliseconds: number) {
    const formattedTime = formatMilliseconds(milliseconds);
    // if 'formatDuration' evaluates to anything less than a second it returns undefined.
    if (formattedTime) return formattedTime;
    return `${milliseconds.toFixed(2)} milliseconds`;
  }

  /**
   * 'whiteSpace'
   * The columns have a "right" alignment so that the decimal values will line up,
   * making it easier to read outlier times.
   * The 'whiteSpace' variable is used here to then "center" align those values in the columns.
   * Not great, but the library doesn't cater for more.
   */
  const whiteSpace = " ".repeat(2);
  const rows = sortedRuntimes.map((info) => {
    let { mwIndicesPosition, callSite, functionName, runtime, timesCalled, numOfRecords, whenMwDepth } = info;

    // Parsing 'bigint' to 'number' for time formatting
    const runtimeInMs = bigintToMs(runtime);

    // Runtime of all middleware will be greater than total runtime, bug caused by iterative conditional middlewares (forEach MWs)
    const excludedMw: string[] = [
      "forEach",
      "whenForEach",
      "ifElse",
      "switch",
      "when",
      "whenEqual",
      "whenNotEqual",
      "whenNot",
    ];
    if (!excludedMw.includes(functionName)) {
      /**
       * The total time taken for the middlewares to run differs from the total time
       * that it takes to run the entire ETL due to postprocssing.
       */
      totalMwRuntimes += runtimeInMs;
    }
    if (totalNumOfRecords < numOfRecords) totalNumOfRecords = numOfRecords;

    if (mwIndicesPosition.length > 1) {
      sortedRuntimes.forEach((i) => {
        // if Mw has a parentMw, then update its indentation level according to its parent's depth
        if (i.mwIndicesPosition.length == 1 && i.mwIndicesPosition[0] == mwIndicesPosition[0] && whenMwDepth) {
          const parentDepth = i.whenMwDepth;
          whenMwDepth = parentDepth ? whenMwDepth + parentDepth : whenMwDepth + 0;
        }
      });
    }

    /**
     * The white space added in 'mwDetails' matches the indentation commonly found in ETLs when using
     * 'when' and 'forEach' middlewares.
     */
    const mwDetails = `${whiteSpace.repeat(whenMwDepth || 0)}${functionName}`;
    const callSiteInfo = callSite ? `(${callSite.file}, Line: ${callSite.line})` : "";
    const mwRuntime = formatMilliseconds(runtimeInMs);
    const avgRuntime = formatMilliseconds(runtimeInMs / timesCalled);
    const avgTime = avgRuntime;
    return [
      `${mwDetails}  ${callSiteInfo}`,
      `${mwRuntime}${whiteSpace}`,
      `${avgTime}${whiteSpace}`,
      `${new Intl.NumberFormat("nl-nl").format(timesCalled)}${whiteSpace}`,
    ];
  });
  const columnHeaders = [["Middlewares", `Total Runtime`, `Average Runtime`, "Times Called"]];
  let untouchedMwLines: string = "";
  if (opts.untouchedMiddlewares?.length) {
    untouchedMwLines += `Untouched Middlewares:`;
    const byFile = mapValues(getExcerptsByFile(opts.untouchedMiddlewares), (v) => v?.excerpt);
    for (const f in byFile) {
      const excerpts = byFile[f];
      if (!excerpts) continue;
      untouchedMwLines += `\n\t> ${f}:`;
      for (const line of excerpts) {
        untouchedMwLines += `\n\t\t[line: ${line.line}] ${line.value}`;
      }
    }
  }

  const otherTime =
    opts.totalRuntimeMs -
    ((opts.afterDurations ? sum(opts.afterDurations.map((d) => bigintToMs(d.duration))) : 0) +
      (opts.beforeDuration ? bigintToMs(opts.beforeDuration) : 0) +
      totalMwRuntimes);
  const otherTimeFormatted = otherTime == 0 ? undefined : ["   - other:", millisecondsToHoursMinsSeconds(otherTime)];
  // Table config
  const topInfo = [
    `File:`,
    `   ${opts.etlScriptFile}`,
    `Version:`,
    `   ${opts.version}`,
    `Environment:`,
    `   ${opts.environment}`,
    `Started at:`,
    `   ${opts.etlStartTime}`,
    `Ended at:`,
    `   ${opts.etlEndTime}`,
    `${untouchedMwLines}`,
    `Totals:`,

    table(
      compact([
        [" - runtime:", millisecondsToHoursMinsSeconds(opts.totalRuntimeMs)],
        opts.beforeDuration
          ? ["   - before hooks:", millisecondsToHoursMinsSeconds(bigintToMs(opts.beforeDuration))]
          : undefined,
        ["   - middlewares:", millisecondsToHoursMinsSeconds(totalMwRuntimes)],
        opts.afterDurations.length
          ? [
              "   - after hooks:",
              millisecondsToHoursMinsSeconds(sum(opts.afterDurations.map((d) => bigintToMs(d.duration)))),
            ]
          : undefined,
        otherTimeFormatted,
        [" - statements:", opts.numQuads ? Intl.NumberFormat("nl-nl").format(opts.numQuads) : 0],
        [" - records:", Intl.NumberFormat("nl-nl").format(totalNumOfRecords)],
      ]),
      { drawVerticalLine: () => false, drawHorizontalLine: () => false },
    ),
  ];
  const tableConfig: TableUserConfig = {
    columns: [
      { alignment: "left", paddingLeft: 0 },
      { alignment: "right" },
      { alignment: "right" },
      { alignment: "right" },
    ],
    drawVerticalLine: (_lineIndex, _columnCount) => {
      return false;
    },
    drawHorizontalLine: (lineIndex, _rowCount) => {
      return lineIndex === 1;
    },
  };
  // Create the table
  const runtimesTable = table([...columnHeaders, ...rows], tableConfig);

  // // Write to file
  fs.writeFileSync(opts.file, topInfo.join("\n") + "\n\n" + runtimesTable);
  return runtimesTable;
}
