import { useState, useEffect } from "react";
import Etl, { MessageLevel, Stats, Message, InitEtl, Status } from "../generic/Etl.js";
import { useCliContext } from "./CliContext.js";
import TriplyDb from "@triply/triplydb/App.js";
import { EtlError } from "../utils/Error.js";
import { Location } from "get-current-line";
import path from "path";
import writeLogsToFile from "./logFile.js";
import { getLogFilename } from "../utils/index.js";
import { assertIsDefined } from "../utils/asserts.js";
import { Iri } from "@triplyetl/vocabularies";
import { fileURLToPath } from "node:url";
import { readFileSync } from "node:fs";
import compareSemVer from "../utils/compareSemVer.js";
export function useProgress(app?: Etl) {
  const [progress, setProgress] = useState<number>();
  useEffect(() => {
    if (!app) return;
    function listener(newProgress: number) {
      if (progress === newProgress && progress !== undefined) {
        //do nothing, it's the same
      }
      setProgress(newProgress);
    }
    app.on("progress", listener);
    return () => {
      app.off("progress", listener);
    };
  }, [app, setProgress, progress]);
  return progress;
}
export type MessageCounts = {
  [label: string]: { count: number; level: MessageLevel; type: "Shacl" | "Etl" };
};
export function useMessageCounts(app: Etl | undefined, hasFatalError: boolean) {
  const [messageCounts, setMessageCounts] = useState<MessageCounts>({
    EtlError: { count: 0, level: "Error", type: "Etl" },
    EtlWarning: { count: 0, level: "Warning", type: "Etl" },
    EtlInfo: { count: 0, level: "Info", type: "Etl" },
    ShaclViolation: { count: 0, level: "Violation", type: "Shacl" },
    ShaclWarning: { count: 0, level: "Warning", type: "Shacl" },
    ShaclInfo: { count: 0, level: "Info", type: "Shacl" },
  });
  useEffect(() => {
    if (!app) return;
    function listener(message: Message) {
      setMessageCounts((prevState) => {
        prevState[message.type + message.label].count++;
        return prevState;
      });
    }
    app.on("message", listener);
    return () => {
      app.off("message", listener);
    };
  }, [app, messageCounts]);

  if (hasFatalError) {
    if (messageCounts["Error"] === undefined) messageCounts["Error"] = { count: 0, level: "Error", type: "Etl" };
    messageCounts["Error"].count++;
  }
  return messageCounts;
}
export function useStats(app?: Etl) {
  const [stats, setStats] = useState<Stats>();
  useEffect(() => {
    if (!app) return;
    function listener(stats: Stats) {
      if (stats["#Statements"] && parseInt(stats["#Statements"].toString()) % 1000 === 0) setStats({ ...stats });
    }
    app.on("stats", listener);
    return () => {
      app.off("stats", listener);
    };
  }, [app, setStats]);
  return stats;
}

export function useEtl(getEtl?: InitEtl) {
  const [app, setApp] = useState<Etl>();
  const [status, setStatus] = useState<Status>();
  const [finalReport, setFinalReport] = useState<Stats>();
  const [untouchedMiddlewares, setUntouchedMiddlewares] = useState<Location[]>();
  const {
    offset,
    etlFile,
    limit,
    timeout,
    token,
    tokenApiUrl,
    dataDir,
    account,
    verbosity,
    debugTrace,
    logDir,
    logId,
    errorTrace,
    createErrorTrace,
  } = useCliContext();
  const [error, setError] = useState<Error | EtlError>();
  useEffect(() => {
    if (getEtl) {
      Etl.CliContext = {
        offset,
        limit,
        timeout,
        dataDir,
        account,
        verbosity,
        debugTrace,
        errorTrace,
        createErrorTrace,
      };

      if (token || tokenApiUrl) {
        Etl.CliContext.triplydb = TriplyDb.get({ token: token, url: tokenApiUrl });
      }

      Promise.resolve(Etl.CliContext?.triplydb?.getInfo())
        .then((info) => {
          if (info?.consoleUrl) {
            assertIsDefined(Etl.CliContext, "");
            Etl.CliContext.wellKnownIriPrefix = new Iri(info.consoleUrl + "/.well-known/genid/");
          }
        })
        .then(getEtl)
        .then(async (app) => {
          try {
            if (!app) {
              throw new Error(
                `File '${etlFile}' does not return any value. Expected the default function to end with \`return app;\``,
              );
            }
            if (!(app instanceof Etl)) {
              throw new Error(
                `File '${etlFile}' does not return a Etl instance. Expected the default function to end with \`return app;\``,
              );
            }
            if (app.status === "done") {
              throw new Error(
                `File '${etlFile}' returns a Etl instance that already ran. Make sure this function does _not_ call \`app.run()\`. This is something this Etl runner already does for you.`,
              );
            }
            setApp(app);
            app.on("status", setStatus);
            const packageJsonPath = path.join(path.dirname(fileURLToPath(import.meta.url)), "..", "..", "package.json");
            const packageJson = JSON.parse(readFileSync(packageJsonPath, "utf-8"));
            const diff = compareSemVer(process.version, packageJson.engines.node);

            console.info(`Running ${etlFile} with TriplyETL ${packageJson.version} and Node.js ${process.version}`);
            if (diff === -1) {
              app.warn(
                `Please upgrade your node version (currently ${process.version}) to ${packageJson.engines.node}.`,
              );
            }
            const stats = await app.run();
            writeLogsToFile({
              version: app["_reportStats"]["Version"],
              environment: app["_reportStats"]["Environment"],
              etlStartTime: app["_reportStats"]["Started at"],
              etlEndTime: app["_reportStats"]["Ended at"],
              mwRuntimes: app["mwRuntimesObj"],
              totalRuntimeMs: Date.now() - app["_startTime"]!.getTime(),
              beforeDuration: app["_beforeDuration"],
              afterDurations: app["_afterDurations"],
              numQuads: +app["_reportStats"]["#Statements"],
              file: getLogFilename({ etlFile: etlFile, logDir, logId, filename: "etl.log" }),
              etlScriptFile: etlFile,
              untouchedMiddlewares: app["getUntouchedMiddlewares"](),
            });
            setFinalReport(stats);
            setUntouchedMiddlewares(app["getUntouchedMiddlewares"]());
            setStatus("done");
          } catch (e) {
            setUntouchedMiddlewares(app?.["getUntouchedMiddlewares"]());
            throw e;
          }
        })
        .catch((e) => {
          setError(e);
        });
    }
  }, [
    getEtl,
    offset,
    etlFile,
    limit,
    timeout,
    token,
    tokenApiUrl,
    dataDir,
    account,
    verbosity,
    debugTrace,
    logDir,
    logId,
    errorTrace,
    createErrorTrace,
  ]);
  return { app, error, finalReport, untouchedMiddlewares, status } as const;
}
