import { Store, getFactory, parse } from "@triplydb/data-factory";
import { Quad } from "@triplydb/data-factory/Terms.js";
import { Context, Etl, Middleware } from "../../generic/index.js";
import { SourceGetter, StringSourceInfo } from "../../generic/locations/sources/index.js";
import { addMwCallSiteToError } from "../../utils/index.js";
import { castArray } from "lodash-es";
import { createHash } from "crypto";
import Validator from "@triplyetl/shacl/lib/Validator.js";

import getCurrentLine from "get-current-line";

const factory = { ...getFactory({ skipValidation: Etl.skipValidation }), dataset: (quads: Quad[]) => new Store(quads) };
export interface ValidateOptionsTerminate {
  graph?: never;
  terminateOn: "Info" | "Warning" | "Violation";
}

export interface ValidateOptionsNoTerminate {
  graph?: string | Quad["graph"];
  terminateOn?: "Never";
}
// generate a hash for the sources so we know which models have been validated with ShSh
const getFingerPrint = async (info: StringSourceInfo[]): Promise<string> => {
  const hash = createHash("md5");
  for (const i of info) hash.update(await i.id());
  return hash.digest("hex");
};

// Singleton patterns to prevent loading common used data more than once:
class Once {
  private constructor() {}
  private static validators: Map<string, Validator> = new Map();

  public static async getValidator(ctx: Context, oneOrMoreModelSources: OneOrMoreModelSources): Promise<Validator> {
    const sources = await ctx["_registerSources"](castArray(oneOrMoreModelSources), "statements");
    const hash = await getFingerPrint(sources);
    if (!Once.validators.has(hash)) {
      let sourceData: string = "";
      for (const source of sources) {
        sourceData += await source.getString();
      }
      const model = new Store(parse(sourceData), { factory });
      await Validator.validateModel(model);
      Once.validators.set(hash, new Validator(model, { skipShaclShaclValidaton: true }));
    }
    return Once.validators.get(hash)!;
  }
}

type OneOrMoreModelSources =
  | SourceGetter<"statements", StringSourceInfo>
  | SourceGetter<"statements", StringSourceInfo>[];

// TODO @DocumentationTeam: add TS doc comment here
export default function (
  oneOrMoreModelSources: OneOrMoreModelSources,
  opts?: ValidateOptionsTerminate | ValidateOptionsNoTerminate,
): Middleware {
  const callSite = getCurrentLine({ frames: 2 });
  return addMwCallSiteToError(
    async (ctx, next) => {
      const validator = await Once.getValidator(ctx, oneOrMoreModelSources);
      opts = opts ?? { terminateOn: "Violation" };
      // next step is to validate the Context's store:
      const prefixers = { ...ctx.app.standardPrefixes, ...ctx.app.prefix };
      const prefixes: Record<string, string> = {};
      let alias: keyof typeof prefixers;
      for (alias in prefixers) {
        prefixes[alias] = prefixers[alias].value;
      }
      const report = await validator.validate({ dataset: ctx.store });

      if (!report.conforms) {
        const writer = report.addPrefixes(prefixes).writer;
        ctx.app["_messageCounts"].ShaclViolation = ctx.app["_messageCounts"].ShaclViolation ?? 0;
        ctx.app["_messageCounts"].ShaclWarning = ctx.app["_messageCounts"].ShaclWarning ?? 0;
        ctx.app["_messageCounts"].ShaclInfo = ctx.app["_messageCounts"].ShaclInfo ?? 0;

        ctx.app["_messageCounts"].ShaclViolation += report.countViolations();
        ctx.app["_messageCounts"].ShaclWarning += report.countWarnings();
        ctx.app["_messageCounts"].ShaclInfo += report.countInfos();
        const message = `The instance data of record ${ctx.recordId} does not conform to the model${
          report.severityMessage ? ` (${report.severityMessage}).` : "."
        }`;

        if (opts.terminateOn !== "Never") {
          let terminate = true;
          switch (opts.terminateOn) {
            case "Info":
              terminate = report.countInfos() + report.countWarnings() + report.countViolations() > 0;
              break;
            case "Warning":
              terminate = report.countWarnings() + report.countViolations() > 0;
              break;
            case "Violation":
              terminate = report.countViolations() > 0;
              break;
          }

          if (terminate === true) {
            ctx.app.info("A copy of the SHACL Validation report is saved in the file `etl.validation-report.trig`.");
            await writer.saveRdf("etl.validation-report.trig");
            ctx.app.info("These are the validation results:\n" + (await writer.toString()));
            throw new Error(message);
          }
        }
        if (report.countViolations()) ctx.app.error(message);
        else if (report.countWarnings()) ctx.app.warn(message, "Shacl");
        else if (report.countInfos()) ctx.app.info(message, "Shacl");

        const graph = opts?.graph
          ? typeof opts.graph === "string"
            ? factory.namedNode(opts.graph)
            : opts.graph
          : ctx.app.standardGraphs.report;

        report.dataset.getQuads({}).forEach((q: Quad) => {
          const { subject, predicate, object } = q;
          ctx.store.addQuad(factory.quad(subject, predicate, object, graph));
        });
      }
      return next();
    },
    { reportTouched: true, callSite, sourceFuncName: "_validate" },
  );
}
