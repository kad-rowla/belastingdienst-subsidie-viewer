import validate from "../validate.js";
import { createReadStreamSafe } from "../../../utils/files.js";
import { getStreamParser, Store, parse, factory } from "@triplydb/data-factory";
import chai from "chai";
import fs from "fs-extra";
import chaiAsPromised from "chai-as-promised";
import Etl from "../../../generic/Etl.js";
import { Middleware, Source } from "../../../generic/index.js";
import { a, sh, xsd } from "@triplyetl/vocabularies";
chai.use(chaiAsPromised);
const expect = chai.expect;

const reportName = "etl.validation-report.trig";

const getValidationReport = (): Store => {
  return new Store(parse(fs.readFileSync(reportName, "utf-8")));
};

const errorMessage = /The instance data of record 1 does not conform to the model./;

function fromTtl(fileLocation: string): Middleware {
  return async function (ctx, next) {
    const dataFileStream = await createReadStreamSafe(fileLocation);
    const parser = getStreamParser();
    await new Promise((resolve, reject) => {
      ctx.store.import(dataFileStream.pipe(parser)).on("finish", resolve).on("error", reject);
    });
    await next();
  };
}

describe("SHACL Validation", function () {
  this.beforeEach(() => {
    if (fs.existsSync(reportName)) fs.unlinkSync(reportName);
    Etl.silent = true;
  });
  it("should throw on syntax error in shapefile", async function () {
    const app = new Etl();
    app.use(fromTtl("./src/__tests__/resources/validationFiles/data-correct.ttl"));
    app.use(validate(Source.file("./src/__tests__/resources/validationFiles/shapes_with_syntax_error.ttl")));
    await expect(app.run()).to.eventually.rejectedWith(/Expected entity but got abbreviation on line 8/);
  });

  it("shouldn't throw on valid input", async function () {
    const app = new Etl();

    app.use(fromTtl("./src/__tests__/resources/validationFiles/data-correct.ttl"));
    app.use(validate(Source.file("./src/__tests__/resources/validationFiles/shapes.ttl")));
    await app.run();
  });

  it("should catch invalid input", async function () {
    const app = new Etl();
    app.use(fromTtl("./src/__tests__/resources/validationFiles/data.ttl"));
    app.use(validate(Source.file("./src/__tests__/resources/validationFiles/shapes.ttl")));
    await expect(app.run()).to.eventually.be.rejectedWith(errorMessage);
  });

  it("should catch invalid shape of shapefile", async function () {
    const app = new Etl();
    app.info = () => {};
    app.error = () => {};
    app.use(fromTtl("./src/__tests__/resources/validationFiles/data.ttl"));
    app.use(validate(Source.file("./src/__tests__/resources/validationFiles/shapes_with_invalid_shape.ttl")));
    await expect(app.run()).to.eventually.rejectedWith(/^The model is not a valid SHACL model.$/);
  });

  it("should show first named node", async function () {
    const app = new Etl();
    app.use(fromTtl("./src/__tests__/resources/validationFiles/data.ttl"));
    app.use(validate(Source.file("./src/__tests__/resources/validationFiles/shapes-named.ttl")));
    await expect(app.run()).to.eventually.be.rejectedWith(errorMessage);
  });

  it("shouldn't throw when nothing is found", async function () {
    const app = new Etl();
    app.use(fromTtl("./src/__tests__/resources/validationFiles/data.ttl"));
    app.use(validate(Source.file("./src/__tests__/resources/validationFiles/shapes.ttl")));
    await expect(app.run()).to.eventually.be.rejectedWith(errorMessage);
  });

  it("should work with two shape files", async function () {
    const app = new Etl();
    app.use(fromTtl("./src/__tests__/resources/validationFiles/data.ttl"));
    app.use(
      validate([
        Source.file("./src/__tests__/resources/validationFiles/shapes_half1.ttl"),
        Source.file("./src/__tests__/resources/validationFiles/shapes_half2.ttl"),
      ]),
    );
    await expect(app.run()).to.eventually.be.rejectedWith(errorMessage);
    expect(await fs.pathExists(reportName)).to.be.true;
    const report = getValidationReport();
    expect(report.getQuads({ predicate: a, object: sh.ValidationReport }).length).equal(1);
    expect(report.getQuads({ predicate: sh.conforms }).length).equal(1);
    expect(report.getObjects(null, sh.conforms, null)[0].equals(factory.literal("false", xsd.boolean))).to.be.true;
    expect(report.getQuads({ predicate: a, object: sh.ValidationResult }).length).equal(2);
  });

  it("can use the same file multiple times", async function () {
    const app = new Etl();
    const validation = validate(Source.file("./src/__tests__/resources/validationFiles/shapes.ttl"));

    app.use(fromTtl("./src/__tests__/resources/validationFiles/data.ttl"));
    app.use(validation);
    app.use(validation);
    await expect(app.run()).to.eventually.be.rejectedWith(errorMessage);
    expect(await fs.pathExists(reportName)).to.be.true;
  });

  it("Don't error on Warning", async () => {
    const app = new Etl();
    app.use(fromTtl("./src/__tests__/resources/validationFiles/data.ttl"));
    app.use(validate(Source.file("./src/__tests__/resources/validationFiles/shapes-warning.ttl")));
    await app.run();
  });

  it("Error on Warning", async () => {
    const app = new Etl();
    app.use(fromTtl("./src/__tests__/resources/validationFiles/data.ttl"));
    app.use(
      validate(Source.file("./src/__tests__/resources/validationFiles/shapes-warning.ttl"), {
        terminateOn: "Warning",
      }),
    );
    await expect(app.run()).to.eventually.be.rejectedWith(errorMessage);
  });

  it("Error on Info", async () => {
    const app = new Etl();
    app.use(fromTtl("./src/__tests__/resources/validationFiles/data.ttl"));
    app.use(
      validate(Source.file("./src/__tests__/resources/validationFiles/shapes-info.ttl"), {
        terminateOn: "Info",
      }),
    );
    await expect(app.run()).to.eventually.be.rejectedWith(errorMessage);
  });

  it("Error non-existent file", async () => {
    const app = new Etl();
    app.use(fromTtl("./src/__tests__/resources/validationFiles/data.ttl"));
    app.use(validate(Source.file("./src/__tests__/resources/validationFiles/shapes-missing.ttl")));
    await expect(app.run()).to.eventually.be.rejectedWith(/File not found/);
  });

  it("Compressed shapefile", async () => {
    const app = new Etl();
    app.use(fromTtl("./src/__tests__/resources/validationFiles/data-correct.ttl"));
    app.use(validate(Source.file("./src/__tests__/resources/validationFiles/shapes.ttl.gz")));
    await app.run();
  });
});
