import { getErr } from "@triply/triplydb/utils/Error.js";
import { BlankNode, Literal, NamedNode } from "@triplydb/data-factory/Terms.js";
import {
  assertIsArray,
  assertIsDefined,
  assertIsString,
  isBlankNode,
  isNamedNode,
  isLiteral,
  isTable,
} from "./asserts.js";
import { TypeForName, TypeName } from "../generic/Context.js";
import { isArray, once } from "lodash-es";
import { coerceLiteral } from "../ratt/middlewares/assertions/statement/rdf/utils/coerceLiteral.js";
import { StaticString } from "../ratt/middlewares/assertions/term/str.js";
import { getFactory } from "@triplydb/data-factory";
import { Iri, LanguageTag } from "@triplyetl/vocabularies";
import Etl from "../generic/Etl.js";
const dataFactory = once(() => getFactory({ skipValidation: Etl.skipValidation }));

function throwCoercionError(value: unknown, key: string, type: string): never {
  let objectType: string;
  if (Array.isArray(value)) objectType = "array";
  else if (isLiteral(value)) objectType = "literal";
  else if (isNamedNode(value)) objectType = "iri";
  else if (isBlankNode(value)) objectType = "blankNode";
  else objectType = typeof value;
  throw getErr(`Could not coerce '${value}' of type '${objectType}' from key '${key}' to the desired type '${type}'`);
}

function ifPossibleCoerceToString(value: unknown, key: string): string {
  if (typeof value === "string") {
    return value;
  } else if (typeof value === "number") {
    return value + "";
  } else if (typeof value === "boolean") {
    return `${value}`;
  } else if (isLiteral(value)) {
    return `${value.value}`;
  } else if (isNamedNode(value)) {
    throwCoercionError(value, key, "string");
  } else if (isBlankNode(value)) {
    throwCoercionError(value, key, "string");
  } else {
    throwCoercionError(value, key, "string");
  }
}

function ifPossibleCoerceToNumber(value: unknown, key: string): number {
  if (typeof value === "number") {
    return value;
  } else if (typeof value === "string") {
    const anyNonDigit = /\D/g;
    if (!anyNonDigit.test(value)) return Number(value);
    else {
      throwCoercionError(value, key, "number");
    }
  } else if (isLiteral(value)) {
    return ifPossibleCoerceToNumber(value.value, key);
  } else {
    throwCoercionError(value, key, "number");
  }
}

function ifPossibleCoerceToBoolean(value: unknown, key: string): boolean {
  if (typeof value === "boolean") {
    return value;
  } else if (typeof value === "string") {
    const regExTrue = /^(true|1)$/i;
    const regExFalse = /^(false|0)$/i;
    if (regExTrue.test(value)) return true;
    else if (regExFalse.test(value)) return false;
    else {
      throwCoercionError(value, key, "boolean");
    }
  } else if (typeof value === "number") {
    if (value === 0 || value === 1) {
      return !!value;
    } else {
      throwCoercionError(value, key, "boolean");
    }
  } else if (isLiteral(value)) {
    return ifPossibleCoerceToBoolean(value.value, key);
  } else {
    throwCoercionError(value, key, "boolean");
  }
}
type LanguageTagOrDataType = string | StaticString | LanguageTag | NamedNode;
function ifPossibleCoerceToLiteral(
  value: unknown,
  key: string,
  languageTagOrDataType?: LanguageTagOrDataType,
): Literal {
  if (isLiteral(value)) {
    if (languageTagOrDataType) return unknownValToLiteral(value.value, key, languageTagOrDataType);
    return value;
  } else if (typeof value === "string") {
    return unknownValToLiteral(value, key, languageTagOrDataType);
  } else if (typeof value === "number") {
    return unknownValToLiteral(String(value), key, languageTagOrDataType);
  } else if (typeof value === "boolean") {
    return unknownValToLiteral(value.toString(), key, languageTagOrDataType);
  } else {
    throwCoercionError(value, key, "literal");
  }
}

function ifPossibleCoerceToIri(value: unknown, key: string): NamedNode {
  if (isNamedNode(value)) {
    return value;
  } else if (typeof value === "string") {
    return unknownValToIri(value);
  } else {
    throwCoercionError(value, key, "iri");
  }
}

function ifPossibleCoerceToBlankNode(value: unknown, key: string): BlankNode {
  if (isBlankNode(value)) {
    return value;
  } else if (typeof value === "string") {
    return dataFactory().blankNode(value);
  } else {
    throwCoercionError(value, key, "blankNode");
  }
}

function ifPossibleCoerceToTable<T = unknown>(value: unknown, key: string): { [key: string]: T } {
  if (isTable(value)) {
    return value;
  } else {
    throwCoercionError(value, key, "table");
  }
}

export function ifPossibleCoerce<T extends TypeName>(
  value: unknown,
  key: string,
  type: T,
  languageTagOrDataType?: LanguageTagOrDataType,
): TypeForName<T> {
  if (typeof type === "object") {
    const elementType = type.array;
    assertIsArray(value, `Expected key '${key}' to reference an array value. Got '${typeof value}'`);
    return value.map((v) => ifPossibleCoerce(v, key, elementType)) as TypeForName<T>;
  } else {
    switch (type) {
      case "string":
        return ifPossibleCoerceToString(value, key) as TypeForName<T>;
      case "number":
        return ifPossibleCoerceToNumber(value, key) as TypeForName<T>;
      case "boolean":
        return ifPossibleCoerceToBoolean(value, key) as TypeForName<T>;
      case "literal":
        return ifPossibleCoerceToLiteral(value, key, languageTagOrDataType) as TypeForName<T>;
      case "iri":
        return ifPossibleCoerceToIri(value, key) as TypeForName<T>;
      case "blankNode":
        return ifPossibleCoerceToBlankNode(value, key) as TypeForName<T>;
      case "table":
        return ifPossibleCoerceToTable(value, key) as TypeForName<T>;
      case "unknown":
        return value as TypeForName<T>;
      case "any":
        return value as TypeForName<T>;
    }
  }
  throw Error("This should really never happen. Please contact a developer.");
}

export function unknownValToIri(val: unknown, keyLabel?: string, opts?: { prefix?: Iri }) {
  assertIsDefined(val, "undefined value can not be used to coerce an Iri");

  if (isNamedNode(val)) {
    return val;
  }

  // We want to support passing numbers when creating IRI. This is a typical usecase, e.g. when using numerical identifier as local-name
  if (typeof val === "number") val = val.toString();

  // The type can still be anything other than a string (e.g. an object, array or whatever)
  assertIsString(
    val,
    `Cannot create IRI: ${
      keyLabel
        ? `Expected key '${keyLabel}' to reference a string or a number.`
        : "Expected value to be a string or a number."
    } Instead, got value of type ${isArray(val) ? "array" : typeof val}.`,
  );

  return opts?.prefix ? opts.prefix.concat(val) : dataFactory().namedNode(val);
}

export function unknownValToLiteral(
  val: unknown,
  keyLabel?: string,
  datatypeOrLanguageTag?: NamedNode | string | StaticString | LanguageTag,
): Literal {
  return coerceLiteral(val, datatypeOrLanguageTag, keyLabel);
}
