import chai, { expect } from "chai";
import strtodate from "../strtodate.js";
import { addYears, addDays, addHours, addMinutes, differenceInMilliseconds, addSeconds } from "date-fns";

const assert = chai.assert;
describe("utils.strtodate ", () => {
  it("should parse all sorts of text into a date", () => {
    const now = new Date();
    assert.isTrue(strtodate("now").getTime() - now.getTime() <= 1);
    assert.equal(strtodate("2022").toISOString(), "2022-01-01T00:00:00.000Z");
    assert.equal(strtodate("2022-12").toISOString(), "2022-12-01T00:00:00.000Z");
    assert.equal(strtodate("2022-12-08").toISOString(), "2022-12-08T00:00:00.000Z");
    assert.equal(strtodate("2022-12-08T10:11:12.134Z").toISOString(), "2022-12-08T10:11:12.134Z");
    assert.equal(strtodate("2022-12-08T10:11:12.134Z").toISOString(), "2022-12-08T10:11:12.134Z");
    const relDate = strtodate("2022-12-11"); // sunday
    let day = 4;
    for (const weekday of ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"]) {
      const strDay = day < 10 ? `0${day}` : day;
      assert.equal(strtodate(`last ${weekday}`, relDate).toISOString(), `2022-12-${strDay}T00:00:00.000Z`);
      day++;
    }
    day++;
    for (const weekday of ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]) {
      assert.equal(strtodate(`next ${weekday}`, relDate).toISOString(), `2022-12-${day}T00:00:00.000Z`);
      day++;
    }
  });

  it("should fail on strings that can not be made into a Date", () => {
    assert.throw(() => strtodate("xxx"), /^Could not parse '.+' as a date.$/);
    assert.throw(() => strtodate("---"), /^Could not parse '.+' as a date.$/);
  });
  it("Should accept human readable short-hand time notation", function () {
    const now = new Date(Date.now());
    const fns = { addYears, addDays, addHours, addMinutes, addSeconds };
    for (const [fnName, fn] of Object.entries(fns)) {
      expect(differenceInMilliseconds(fn(now, 1), strtodate(`1 ${fnName.slice(3, 4)}`))).to.be.lessThan(2);
    }
  });
  it("Should accept human readable short-hand time notation, using time argument", function () {
    const plus20Years = addYears(new Date(Date.now()), 20);
    const fns = { addYears, addDays, addHours, addMinutes, addSeconds };
    for (const [fnName, fn] of Object.entries(fns)) {
      expect(
        differenceInMilliseconds(fn(plus20Years, 1), strtodate(`1 ${fnName.slice(3, 4)}`, plus20Years))
      ).to.be.lessThan(1);
    }
  });
  it("Should fail for incorrect short-hand time notation", function () {
    for (const incorrectNotation of ["yea", "wee", "da", "hou", "mi", "se"]) {
      expect(() => strtodate(`115 ${incorrectNotation}`)).to.throw(
        `Could not parse '115 ${incorrectNotation}' as a date`
      );
    }
  });
  it("Incorrect shorthand notation should produce correct results", function () {
    // These tests pass even without the most recent changes. Here I'm just making sure that they give the correct results.
    const shouldntWorkButDoesSeconds = ["seco", "secon"];
    const shouldntWorkButDoesMinutes = ["minu", "minut"];
    const now = new Date(Date.now());
    for (let i = 0; i < 2; i++) {
      const secs = shouldntWorkButDoesSeconds[i];
      const mins = shouldntWorkButDoesMinutes[i];
      const diffSecs = differenceInMilliseconds(addSeconds(now, 12), strtodate(`19 ${secs}`));
      const diffMins = differenceInMilliseconds(addMinutes(now, 19), strtodate(`19 ${mins}`));
      expect(diffSecs).to.be.lessThan(2);
      expect(diffMins).to.be.lessThan(2);
    }
  });
});
