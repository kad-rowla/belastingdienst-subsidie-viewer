import { Stream } from "stream";
import { findUpSync } from "find-up";
import dotenv from "dotenv";
import { castArray, compact, flatten, once } from "lodash-es";
import path from "path";
import fs from "fs-extra";
import crypto from "crypto";
import getCurrentLine, { Location } from "get-current-line";
import { getErr } from "./Error.js";
import { SourceGetter, StringSourceInfo } from "../generic/locations/sources/index.js";
import { v4 as uuid } from "uuid";
export { default as quadsToString } from "./quadsToString.js";
import * as TriplyIri from "@triplydb/iri";
import { StaticString } from "../ratt/middlewares/assertions/term/str.js";
import { Context, Etl, Key, Middleware, MiddlewareList, Store } from "../generic/index.js";
import { BaseQuad, DefaultGraph, Literal, NamedNode, Term } from "@triplydb/data-factory/Terms.js";
export { default as hashify } from "./hashify.js";
import { getFactory } from "@triplydb/data-factory";
import { termToString } from "rdf-string";
import * as RDF from "rdf-js";

const dataFactory = once(() => getFactory({ skipValidation: Etl.skipValidation }));

export type NamedNodeCompatibleType = string | NamedNode;

export type PossibleIri = (<L extends string>(local: L) => NamedNode<string>) | NamedNode | StaticString | Key;

export function coerceToIri(val: NamedNodeCompatibleType) {
  if (typeof val === "function") return val;
  if (typeof val === "string") return dataFactory().namedNode(val);
  return val;
}
export function coerceToString(val: NamedNodeCompatibleType) {
  if (typeof val === "object") return val.value;
  return val;
}

export function validateIri(term: Term, quad?: BaseQuad): void {
  switch (term.termType) {
    case "Quad":
      validateIri(term.subject, term);
      validateIri(term.predicate, term);
      validateIri(term.object, term);
      validateIri(term.graph, term);
      break;
    case "NamedNode":
      try {
        TriplyIri.validate(term.value);
      } catch (error: any) {
        console.error(error);
        let message: string;
        if (quad) {
          const quadAsString = termToString(quad as unknown as RDF.BaseQuad).slice(2, -2);
          message = `An invalid IRI [1] was added to the store, as part of quad [2]:
  
  [1]: ${term.value}
  [2]: ${quadAsString}`;
        } else {
          message = `An invalid IRI [1] was added to the store:
  [1]: ${term.value}`;
        }
        throw getErr(error).setMessage(message);
      }
  }
}

/**
 * The stream is modified in-place
 */
export function modifyStreamError(stream: Stream, modifyError: (error: Error) => Error) {
  (<any>stream)._emit = stream.emit;
  stream.emit = function (event, error, ...args) {
    if (event === "error" && error instanceof Error) {
      error = modifyError(error);
    }
    return (<any>stream)._emit(event, error, ...args);
  };
}

/**
 * Try to find a `.env` or `.etl` file. Merge it with the process.env
 * so we can use it in the ETL itself. Latest item in the array has highest priority
 */
export function includeEtlVariablesInEnv() {
  const etlFiles = compact([
    findUpSync([".etl"]),
    findUpSync([".env"]),
    findUpSync([`.env-${Etl.environment.toLowerCase()}`]),
    findUpSync([`.etl-${Etl.environment.toLowerCase()}`]),
  ]);
  if (etlFiles.length) {
    //Make sure that latest item in the array has highest priority
    const sortedEtlFilesByPrio = etlFiles.sort((a, b) => {
      return path.dirname(a).localeCompare(path.dirname(b));
    });
    for (const etlFile of sortedEtlFilesByPrio) {
      process.env = { ...process.env, ...dotenv.parse(fs.readFileSync(etlFile)) };
    }
  }
}

/**
 *  Use all the values in an array to create an md5 hash.
 */
export function md5OfArray(array: string[]): string {
  const hash = crypto.createHash("md5");
  for (const value of array) {
    hash.update(value);
  }
  return hash.digest("hex");
}
/**
 * Prevent users from adding multiple extractors to an ETL.
 * Note this is a run-time only check!
 *
 * @see https://git.triply.cc/triply/etl/-/issues/301
 */
export function assertOneExtractorPerETL(app: Etl, extractorName: string) {
  if (app.extractorName !== undefined) {
    throw new Error(
      `Extractor '${extractorName}' can not be used: a ETL allows 1 extractor which currently is '${app.extractorName}'.`,
    );
  }
  app.extractorName = extractorName;
}

export function addMwCallSiteToError<R = unknown>(
  mw: Middleware<R>,
  opts?: {
    /**
     * By default we're reporting this middleware as touched. If you want to control this yourself,
     * then set this value to false
     */
    reportTouched?: boolean;
    /**
     * We're storing the callsites by reference. I.e., to be able track the touched status,
     * we want to use 1 callsite object. That means when tracking the touched status externa to this function,
     * we want to use one and the same callsite reference
     */
    callSite?: Location;
    /**
     * Pass in the name of the function you are wrapping.
     * This is used for correctly identifying middlewares in the log file.
     */
    sourceFuncName: Middleware["name"];
  },
): Middleware<R> {
  const callSite = opts?.callSite || getCurrentLine({ frames: 3 });
  callSite.file = path.relative(process.cwd(), callSite.file);
  const reportTouched = opts?.reportTouched !== false;
  const _mw: Middleware<R> = async (ctx, next) => {
    if (reportTouched) ctx.app["markMwTouched"](callSite);
    let innerError = false;
    try {
      await mw(ctx, async (...args) => {
        try {
          await next(...args);
        } catch (e) {
          innerError = true;
          throw e;
        }
      });
    } catch (e: any) {
      const err = getErr(e);
      if (!innerError && (opts?.callSite || !err.callSite)) err.setCallSite(callSite);
      throw err;
    }
  };

  _mw.callSite = callSite;
  _mw.sourceFuncName = opts?.sourceFuncName ? opts?.sourceFuncName : mw.name;
  return _mw;
}

export function safeStringify(record?: Object) {
  return JSON.stringify(record, cleanupJson(), 2);
}

/**
 * Avoid circular references, and avoid printing the whole store
 */
export function cleanupJson() {
  const seen = new WeakSet();
  return (_key: string, value: any) => {
    if (typeof value === "function") {
      return `${value.name}()`;
    }
    if (typeof value === "object" && value !== null) {
      if (value instanceof Store) return "__store__";
      if (seen.has(value)) {
        return "__circular__";
      }
      seen.add(value);
    }
    return value;
  };
}
export function removeCliArgument(
  cliArgs: Array<string>,
  opts: { removeArg: string; isPair: boolean | ((nextArg: string | undefined) => boolean) },
): Array<string> {
  const cliArgsClone = [...cliArgs]; // making a copy to avoid mutating the array. Probably superfluous, but doesnt hurt
  const fromRecordIdArgIndex = cliArgsClone.indexOf(opts.removeArg);
  if (fromRecordIdArgIndex >= 0) {
    const isPair = typeof opts.isPair === "boolean" ? opts.isPair : opts.isPair(cliArgsClone[fromRecordIdArgIndex + 1]);
    cliArgsClone.splice(fromRecordIdArgIndex, isPair ? 2 : 1); // when this is an argument pair, also remove the next argument
  }
  return cliArgsClone;
}
export function isNodejs() {
  return typeof process !== "undefined" && process.versions != null && process.versions.node != null;
}

export function getLogFilename(opts: {
  etlFile: string;
  filename: string;
  logDir: string | undefined;
  logId: string | undefined;
}) {
  if (!opts.logDir) return compact([opts.filename, opts.logId]).join("-"); // e.g. `etl.log` or `.trace-1235215125612`

  // We're using a log dir. Assuming we want to make the filename unique.
  const etlScriptName = path.parse(opts.etlFile).name;

  return path.join(opts.logDir, `${etlScriptName}_${opts.logId}_${opts.filename}`); // e.g. logdir/main_13-02-22-123_etl.log
}

export async function getQueryStrings(
  ctx: Context,
  query:
    | string
    | ((ctx: Context) => string | string[])
    | SourceGetter<"string", StringSourceInfo>
    | Array<string | ((ctx: Context) => string | string[]) | SourceGetter<"string", StringSourceInfo>>,
): Promise<Array<string>> {
  return flatten(
    await Promise.all(
      castArray(query).map(async (stringOrSourceGetter) => {
        if (typeof stringOrSourceGetter === "string") {
          return [stringOrSourceGetter];
        } else if (typeof stringOrSourceGetter === "function") {
          return castArray(stringOrSourceGetter(ctx));
        } else {
          const sourceInfos = await ctx["_registerSources"]([stringOrSourceGetter], "string");
          return Promise.all(sourceInfos.map((sourceInfo) => sourceInfo.getString()));
        }
      }),
    ),
  );
}
type Quad = [
  Array<NamedNode>, // subject
  Array<NamedNode>, // predicate
  Array<NamedNode | Literal>, // object
  NamedNode | DefaultGraph, // graph
];
/**
 * Utility function to add quads to a store, and track progress
 */
export function addQuadsToStore(store: Store, quads: Quad[]) {
  for (const [s, p, o, graph] of quads) {
    for (const subject of s) {
      for (const predicate of p) {
        for (const object of o) {
          store.addQuad(subject, predicate, object, graph);
        }
      }
    }
  }
}

export function iriCharacterCleaner(content: string): NamedNode<string> {
  return dataFactory().namedNode(
    // eslint-disable-next-line no-control-regex
    content.replace(/[ <>{}|\\^`"\u000B\b\n\t\f\r\u00A0]/g, (char) => encodeURI(char)),
  );
}

/**
 * Creates a random MD5 style hash based on UUIDv4
 */
export function randomHash(): string {
  return uuid().replace(/-/g, "");
}

export function convertMwListToMiddleware(list: MiddlewareList, sourceFuncName: string): Middleware {
  return addMwCallSiteToError(
    async function (ctx, next) {
      let middlewaresToSkip = 0;
      for (let middlewares of list) {
        async function recursivelyResolve(mws: Middleware | MiddlewareList) {
          if (Array.isArray(mws)) {
            for (const mw of mws) {
              if (middlewaresToSkip) {
                /**
                 * if we skip inside a MiddlewareList, we are in a when/whenNot case.
                 * This number comes from the @see _whenMw, where if the when condition fails
                 * we pass in the amount of middlewares (middleware.length) we should skip.
                 * Here then we skip those middlewares 1-by-1.
                 */
                middlewaresToSkip--;
                continue;
              }
              await recursivelyResolve(mw);
            }
          } else {
            try {
              await mws(ctx, async (record, _store, skip) => {
                /**
                 * The skip count is used in the comes from the @see _whenMw function.
                 * if no skip is passed, we reset the skip number
                 */
                ctx.record = { ...ctx.record, ...record };
                middlewaresToSkip = skip ?? 0; //
                return Promise.resolve();
              });
            } catch (e) {
              throw new Error((e as Error).message);
            }
          }
        }
        await recursivelyResolve(middlewares);
      }
      return next();
    },
    { sourceFuncName, callSite: getCurrentLine({ frames: 3 }) },
  );
}
