import { addYears, addMonths, addDays, addHours, addMinutes, addSeconds } from "date-fns";

export default function strToDate(text: string, now?: Date): Date {
  text = text
    .trim()
    .replace(/\s{2,}/g, " ")
    .replace(/[\t\r\n]/g, "")
    .toLowerCase();
  if (text === "") return new Date();
  const _now: Date | undefined = now === undefined ? new Date() : new Date(now.getTime());

  if (!isNaN(Date.parse(text))) return new Date(Date.parse(text));
  if (text === "now") return _now;

  let match = text.match(/^(\d{2,4})-(\d{2})-(\d{2})(?:T(\d{1,2}):(\d{2})(?::\d{2})?)?(?:\.(\d+)?Z)?$/);
  if (match !== null) {
    const ints = match as unknown as [
      string,
      number,
      string,
      number,
      number | undefined,
      number | undefined,
      number | undefined,
      number | undefined
    ];
    const year = ints[1] >= 0 && ints[1] <= 69 ? +ints[1] + 2000 : ints[1];
    return new Date(year, parseInt(ints[2], 10) - 1, ints[3], ints[4] ?? 0, ints[5] ?? 0, ints[6] ?? 0, ints[7] ?? 0);
  }

  const days = {
    sun: 0,
    mon: 1,
    tue: 2,
    wed: 3,
    thu: 4,
    fri: 5,
    sat: 6,
  };
  const ranges = {
    yea: "FullYear",
    mon: "Month",
    day: "Date",
    hou: "Hours",
    min: "Minutes",
    sec: "Seconds",
  };

  const lastNext = (type: "last" | "next", range: keyof typeof days, modifier: number): void => {
    let diff;
    const day = days[range];

    if (typeof day !== "undefined") {
      diff = day - _now.getDay();

      if (diff === 0) {
        diff = 7 * modifier;
      } else if (diff > 0 && type === "last") {
        diff -= 7;
      } else if (diff < 0 && type === "next") {
        diff += 7;
      }

      _now.setDate(_now.getDate() + diff);
    }
  };

  const process = (val: string): boolean => {
    const splt = val.split(" ");
    const type = splt[0];
    const range = splt[1].substring(0, 3) as unknown as keyof typeof days;
    const typeIsNumber = /\d+/.test(type);
    const ago = splt[2] === "ago";
    let num = (type === "last" ? -1 : 1) * (ago ? -1 : 1);

    if (typeIsNumber) num *= parseInt(type, 10);

    if (Object.prototype.hasOwnProperty.call(ranges, range) && splt[1].match(/^mon(day|\.)?$/i) == null) {
      const fnSet = `set${ranges[range as unknown as keyof typeof ranges]}` as
        | "setFullYear"
        | "setMonth"
        | "setDate"
        | "setHours"
        | "setMinutes"
        | "setSeconds";
      const fnGet = `get${ranges[range as unknown as keyof typeof ranges]}` as
        | "getFullYear"
        | "getMonth"
        | "getDate"
        | "getHours"
        | "getMinutes"
        | "getSeconds";
      _now[fnSet](_now[fnGet]() + num);
      return true;
    }
    if ((range as string) === "wee") {
      _now.setDate(_now.getDate() + num * 7);
      return true;
    }

    if (type === "next" || type === "last") {
      lastNext(type, range, num);
    } else if (!typeIsNumber) {
      return false;
    }
    return true;
  };

  const humanReadabletimes = new RegExp(
    /^[0-9]* +(years?|y|months?|weeks?|w|days?|d|hours?|h|minutes?|m|seconds?|s)$/i
  );
  if (humanReadabletimes.test(text)) {
    type K = keyof typeof fns;
    const fns = {
      y: addYears,
      month: addMonths,
      d: addDays,
      h: addHours,
      m: addMinutes,
      s: addSeconds,
    };
    const [amount, hrTime] = text.split(" ");
    if (hrTime.startsWith("month")) return fns.month(_now, +amount);
    const time = hrTime[0] as K;
    return fns[time](_now, +amount);
  }

  const times =
    "(years?|months?|weeks?|days?|hours?|minutes?|mins?|seconds?|sec" +
    "|sunday|sun\\.?|monday|mon\\.?|tuesday|tue\\.?|wednesday|wed\\.?" +
    "|thursday|thu\\.?|friday|fri\\.?|saturday|sat\\.?)";
  const regex = "([+-]?\\d+\\s" + times + "|" + "(last|next)\\s" + times + ")(\\sago)?";

  match = text.match(new RegExp(regex, "gi"));

  if (match === null) throw new Error(`Could not parse '${text}' as a date.`);

  for (let i = 0, len = match.length; i < len; i++) {
    if (!process(match[i])) throw new Error(`Could not parse '${text}' as a date.`);
  }
  return _now;
}
