import { BlankNode, Literal, NamedNode } from "@triplydb/data-factory/Terms.js";
import { AssertionError } from "assert";
import { has, isEmpty, isEmpty as lodashIsEmpty, isPlainObject } from "lodash-es";
import { TypeForName, TypeName } from "../generic/Context.js";
import chalk from "chalk";
import { Record } from "../generic/Record.js";
import { SourceGetter, SourceInfo } from "../generic/locations/sources/index.js";
import { Environment } from "../generic/index.js";
import { isJPath, JPath } from "../ratt/middlewares/assertions/term/jpath.js";
import jp from "jsonpath";
import { Iri } from "@triplyetl/vocabularies";

//see https://stackoverflow.com/questions/61462867/missing-flow-in-type-narrowing-with-unknown-datatype-in-typescript
function toUnion(_x: unknown): asserts _x is object | string | number | boolean | null | undefined {}

function assertTermIs(term: unknown, termType: "Literal" | "NamedNode" | "BlankNode") {
  toUnion(term);
  const label = termType === "NamedNode" ? `an IRI` : `a ${termType}`;
  if (!term || typeof term !== "object")
    throw new AssertionError({ message: `Expected ${label}, but received ${term}` });

  if (!("termType" in term)) {
    throw new AssertionError({ message: `Expected ${label}, but we're missing a term type` });
  }
  if ((term as any).termType !== termType) {
    throw new AssertionError({ message: `Expected ${label}, but received termtype ${(term as any).termType}` });
  }
}
export const isEnvironment = (value: any): value is Environment =>
  typeof value === "string" && ["Development", "Testing", "Acceptance", "Production"].includes(value);

export function assertEnvironment(value: any): asserts value {
  if (!isEnvironment(value)) {
    throw new Error(`The environment is currently '${value}', but it can only be 'Development', 'Testing', 'Acceptance' or 'Production.
${chalk.cyan(`Here are some things you can try:
- create a file '.env' and make sure it hase a line 'ENV=Development' (or another valid environment)
- on Linux/Max/Unix systems, type 'export ENV=Development' (or another valid environment)
- run your ETL like this 'ENV=Development npx etl <lib/main.js>'
- contact Triply support (support@triply.cc)`)}`);
  }
}

export function assertHasToken(value: unknown): asserts value {
  if (value === undefined || typeof value !== "string")
    throw new Error(`Missing a TriplyDb Token.
${chalk.cyan(`Here are some things you can try:
- look at https://triply.cc/docs/triply-api#creating-an-api-token
- Run \`npx etl --help\` for more information on how to pass your TriplyDB credentials.
- generate a token using \`npx tool create-token\`
- contact Triply support (support@triply.cc)`)}
`);
}

export function isLiteral(term: unknown): term is Literal {
  toUnion(term);
  return !!term && typeof term === "object" && "termType" in term && (term as Literal).termType === "Literal";
}

export const isIri = (obj: any): obj is Iri => {
  return isNamedNode(obj) && Object.hasOwn(obj, "$IriClass");
};

export function isNamedNode(term: unknown): term is NamedNode {
  toUnion(term);
  return !!term && typeof term === "object" && "termType" in term && (term as NamedNode).termType === "NamedNode";
}
export function isBlankNode(term: unknown): term is BlankNode {
  toUnion(term);
  return !!term && typeof term === "object" && "termType" in term && (term as BlankNode).termType === "BlankNode";
}
export function isArray(val: unknown): val is Array<unknown> {
  return Array.isArray(val);
}
export function isString(val: unknown): val is string {
  return typeof val === "string";
}
export function isNumber(val: unknown): val is number {
  return typeof val === "number";
}

export function isTable(val: unknown): val is { [key: string]: any } {
  if (typeof val !== "object" || !isPlainObject(val) || val === null) return false;
  for (const key of Object.keys(val)) {
    if (typeof key !== "string") return false;
  }
  return true;
}

export function assertTable(val: unknown): asserts val is { [key: string]: any } {
  if (!isTable(val)) throw new AssertionError({ message: `Expected a key => value table object` });
}

export function assertLiteral(term: unknown): asserts term is Literal {
  assertTermIs(term, "Literal");
}
export function assertNamedNode(term: unknown): asserts term is NamedNode {
  assertTermIs(term, "NamedNode");
}
export function assertBnode(term: unknown): asserts term is BlankNode {
  assertTermIs(term, "BlankNode");
}
export function assertIsDefined<T>(val: T, msg: string): asserts val is NonNullable<T> {
  if (val === undefined || val === null) {
    throw new AssertionError({ message: msg, expected: "defined", actual: val });
  }
}
export function assertIsObject(val: unknown, msg: string): asserts val is { [key: string]: unknown } {
  if (typeof val !== "object") {
    throw new AssertionError({ message: msg, expected: "object", actual: val });
  }
}

export class NullableOrEmptyString extends Error {}
/**
 * Slightly different than assertIsDefined. It'll throw a different error in order for us to catch it properly.
 * It also checks for empty strings
 */
export function assertIsNotNullableOrEmptyString<T>(val: T): asserts val is NonNullable<T> {
  if (val === undefined || val === null) {
    throw new NullableOrEmptyString(`Expected value to be set. Instead, got value ${val}`);
  } else if (typeof val === "string" && val.trim().length === 0) {
    throw new NullableOrEmptyString(`Expected value to be set. Instead, got an empty string`);
  }
}

export function assertIsArray<A = unknown>(val: unknown, msg: string): asserts val is Array<A> {
  if (val === undefined || val === null) {
    throw new NullableOrEmptyString(msg);
  }
  if (!Array.isArray(val)) {
    throw new AssertionError({ message: msg, expected: "array", actual: val });
  }
}
export function assertIsNonEmptyArray<A = unknown>(val: unknown, msg: string): asserts val is Array<A> {
  assertIsArray(val, msg);
  if (val.length === 0) throw new NullableOrEmptyString(msg);
}
export function assertIsString(val: unknown, msg: string): asserts val is string {
  if (typeof val !== "string") {
    throw new AssertionError({ message: msg, expected: "string", actual: val });
  }
}
export function assertIsNonEmptyString(val: unknown, msg: string): asserts val is string {
  if (typeof val !== "string" || val.trim().length === 0) {
    throw new AssertionError({ message: msg, expected: "non-empty-string", actual: val });
  }
}
export function assertIsNumber(val: unknown, msg: string): asserts val is number {
  if (typeof val !== "number") {
    throw new AssertionError({ message: msg, expected: "number", actual: val });
  }
}
export function assertIsBoolean(val: unknown, msg: string): asserts val is boolean {
  if (typeof val !== "boolean") {
    throw new AssertionError({ message: msg, expected: "boolean", actual: val });
  }
}

/**
 * Find out whether something is considered empty and if so, why.
 *
 * Values considered empty are:
 * - Empty strings, or strings with only whitespace
 * - Empty arrays
 * - Empty objects
 * - undefined and null values
 */
export function getReasonWhysomethingIsEmpty(val: unknown, key?: string): string | undefined {
  let isEmpty = false;
  const keyMessage = key !== undefined ? `Key '${key}' has` : "Has";
  let reason = `${keyMessage} an empty value of type '${typeof val}'`;
  if (val === undefined) isEmpty = true;
  else if (val === null) {
    isEmpty = true;
    reason = `${keyMessage} an empty value of type 'null'`;
  } else if (typeof val === "string" && val.trim().length === 0) isEmpty = true;
  else if (Array.isArray(val) && lodashIsEmpty(val)) {
    reason = `${keyMessage} an empty value of type 'array'`;
    isEmpty = true;
  } else if (typeof val === "object" && lodashIsEmpty(val)) isEmpty = true;

  if (isEmpty) return reason;
}

export function assertIsNotEmpty(val: unknown, key?: string) {
  const reason = getReasonWhysomethingIsEmpty(val, key);
  if (reason) throw new AssertionError({ message: reason, expected: "value not to be empty", actual: val });
}

export function assertKeyExists(object: unknown, keyOrExpression: string | JPath) {
  const hasValue = isJPath(keyOrExpression)
    ? jp.query(object, keyOrExpression.toString()).length > 0
    : has(object, keyOrExpression);
  if (!isEmpty(keyOrExpression) && !hasValue) {
    throw new AssertionError({
      message: `Object does not have key '${keyOrExpression}'`,
      expected: `key '${keyOrExpression}' to exists`,
      actual: `key '${keyOrExpression}' does not exists`,
    });
  }
}

export function isDeeplyEmpty(val: unknown): boolean {
  if (typeof val === "object") {
    if (val === null) return true;
    if (Array.isArray(val)) {
      return val.every(isDeeplyEmpty);
    } else {
      return isDeeplyEmpty(Object.values(val));
    }
  } else {
    return !!getReasonWhysomethingIsEmpty(val);
  }
}

export function assertIs<T extends TypeName = "unknown">(value: TypeName, key: string, type: T): asserts value is T {
  const errMsg = `Assertion failed. Expected '${key}' to be '${type}'. Got '${typeof value}'.`;
  if (typeof type === "object") {
    const elementType = type.array;
    if (!Array.isArray(value)) return;
    return value.map((v) => assertIs(v, key, elementType)) as TypeForName<T>;
  } else {
    switch (type) {
      case "string":
        return assertIsString(value, errMsg);
      case "number":
        return assertIsNumber(value, errMsg);
      case "boolean":
        return assertIsBoolean(value, errMsg);
      case "literal":
        return assertLiteral(value);
      case "iri":
        return assertNamedNode(value);
      case "blankNode":
        return assertBnode(value);
      case "table":
        return assertTable(value);
      case "unknown":
        // Needed for type narrowing, but we don't need to do anything here.
        return;
      case "any":
        // Needed for type narrowing, but we don't need to do anything here.
        return;
    }
  }
  throw Error("This should really never happen. Please contact a developer. Assertion");
}

export function isSourceGetterArray(source: Array<any>): source is SourceGetter<"records", SourceInfo<Record>>[] {
  return (
    source.length > 0 && typeof source[0] === "object" && "get" in source[0] && typeof source[0].get === "function"
  );
}

export function isSourceGetter(source: any): source is SourceGetter<"records", SourceInfo<Record>> {
  return typeof source === "object" && "get" in source && typeof source.get === "function";
}
