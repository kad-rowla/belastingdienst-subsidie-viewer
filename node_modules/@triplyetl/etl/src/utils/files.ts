import * as zlib from "zlib";
import fs from "fs-extra";
import * as path from "path";
import { sum } from "lodash-es";
import filenamify from "filenamify";
import { Readable } from "stream";
import pumpify from "pumpify";

/**
 * Need this for better error handling.
 * see https://stackoverflow.com/a/59217504/1052020
 */
export function createReadStreamSafe(filename: string): Promise<fs.ReadStream> {
  return new Promise((resolve, reject) => {
    const fileStream = fs.createReadStream(filename);
    fileStream.on("error", reject).on("open", () => {
      resolve(fileStream);
    });
  });
}

export async function getFileSizes(files: string[]) {
  return sum(
    await Promise.all(
      files.map(async (f) => {
        const stat = await fs.stat(f);
        return stat.size;
      })
    )
  );
}
export const WRITABLE_LD_EXTENSIONS = ["nq", "ttl", "nt", "trig"] as const;
export type LdExtensions = (typeof WRITABLE_LD_EXTENSIONS)[number];
export type LdFormats = ReturnType<typeof ldExtensionToN3Format>;
export function ldExtensionToN3Format(ext: LdExtensions) {
  switch (ext) {
    case "nq":
      return "n-quads";
    case "trig":
      return "trig";
    case "nt":
      return "n-triples";
    case "ttl":
      return "turtle";
  }
}

export type CompressionType = "gz" | undefined;
export interface Options<F> {
  extension: F;
  compression: CompressionType;
}
export function parsePath<F extends string>(filepath: string, allowedExtensions?: ReadonlyArray<F>): Options<F> {
  let compression: CompressionType = undefined;
  let extension = path.extname(filepath);

  if (extension === ".gz") {
    compression = "gz";
    extension = path.extname(path.basename(filepath, ".gz"));
  }

  if (!allowedExtensions || allowedExtensions.indexOf(extension.substring(1) as any) >= 0) {
    return {
      compression,
      extension: extension.substring(1) as F,
    };
  } else {
    throw new Error(
      `Unsupported extension for '${filepath}'. Use one of the following: ${allowedExtensions.join(
        ", "
      )}. Append .gz to enable gzip compression.`
    );
  }
}

export function resolveAndFilenamify(directory: string, name: string) {
  return path.resolve(directory, filenamify(name, { replacement: "-", maxLength: 255 }));
}

export async function streamToString(readable: Readable, compression: CompressionType) {
  let stream: Readable;
  switch (compression) {
    case undefined:
      stream = readable;
      break;
    case "gz":
      stream = new pumpify([readable, zlib.createGunzip()]);
      break;
  }
  const chunks = [];
  try {
    for await (const chunk of stream) {
      chunks.push(chunk);
    }
    return Buffer.concat(chunks).toString();
  } catch (e) {
    return "";
  }
}
