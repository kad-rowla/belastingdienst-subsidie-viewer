import rml from "rocketrml";
import { addMwCallSiteToError } from "../../utils/index.js";
import { parse } from "@triplydb/data-factory";
import Source, { FileSourceInfo, SourceGetter } from "../../generic/locations/sources/index.js";
import path from "node:path";
import { castArray } from "lodash-es";
import { existsSync, mkdirSync, readFileSync } from "node:fs";
import { getQuads } from "../../generic/middlewares/sources/loadRdf.js";
import { Quad } from "@triplydb/data-factory/Terms.js";

interface Options {
  // remove xmlns in xml documents (for easier xPaths)
  removeNameSpace?: Record<string, string>;
  // xpath evaluator library
  xpathLib?: "default" | "xpath" | "pugixml" | "fontoxpath";
  // functions
  functions?: Record<string, Function>;
  // add no triples for empty strings
  ignoreEmptyStrings?: boolean;
  // ignore values from the input
  ignoreValues?: string[];
  // csv options
  csv?: {
    delimiter?: string;
  };
}

/**
 * Transformations using RDF mapping language ([RML](http://rml.io/spec.html)).
 *
 * @param mapping A local file containg the mapping
 * @param fileSources An optional Record with key => filesource, usefull to prevent issues with paths to file
 * @param opts
 */
export default function map(
  mapping: SourceGetter<"records", FileSourceInfo>,
  fileSources?: Record<string, SourceGetter<"records", FileSourceInfo>>,
  opts?: Partial<Options>,
) {
  return addMwCallSiteToError(async (ctx, next) => {
    if (!existsSync(ctx.app.getTmpDir())) mkdirSync(ctx.app.getTmpDir());
    const tmpFileOut = path.join(ctx.app.getTmpDir(), `${Math.floor(1000000000 * Math.random())}.n3`);
    const sources = await ctx["_registerSources"](castArray(mapping), "records");
    if (!sources.length) return next();
    const source = sources.pop()!;
    let quads: Quad[] = [];
    if (fileSources && Object.keys(fileSources).length) {
      const inputFiles: Record<string, string> = {};
      for (let filename in fileSources) {
        const s = await ctx["_registerSources"](castArray(fileSources[filename]), "records");
        if (s.length) {
          inputFiles[filename] = readFileSync(await s[0].getLocalPath(), "utf-8");
        }
      }
      const mapfile = readFileSync(await source.getLocalPath(), "utf-8");
      const result = await rml.parseFileLive(mapfile, inputFiles, { ...opts, toRDF: true });

      quads = parse(result);
    } else {
      await rml.parseFile(await source.getLocalPath(), tmpFileOut, { ...opts, toRDF: true });
      quads = await getQuads(ctx, Source.file(tmpFileOut));
    }
    ctx.store.addQuads(quads);
    return next();
  });
}
