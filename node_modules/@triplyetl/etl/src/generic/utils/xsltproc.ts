import { Etl, Source } from "../index.js";
import { ContentType, FileSourceInfo, SourceGetter, StringSourceInfo } from "../locations/sources/index.js";
import SaxonJS from "saxon-js";
import crypto from "crypto";
import path from "path";
import { execSync } from "node:child_process";
import { existsSync, mkdirSync, writeFileSync } from "fs";
import { has } from "lodash-es";

const isStringSource = (i: FileSourceInfo | StringSourceInfo): i is StringSourceInfo => !has(i, "getLocalPath");
const isCorrectSourceGetter = <C extends ContentType = ContentType>(
  i: SourceGetter<C, FileSourceInfo | StringSourceInfo>,
  f: boolean,
): i is SourceGetter<C, FileSourceInfo> => f && typeof i === "object";

export default async <
  C extends ContentType = ContentType,
  S extends FileSourceInfo | StringSourceInfo = FileSourceInfo,
>(
  app: Etl,
  oneOreMoreSources:
    | SourceGetter<C, FileSourceInfo | StringSourceInfo>[]
    | SourceGetter<C, FileSourceInfo | StringSourceInfo>
    | string,
  stylesheet: SourceGetter<C, FileSourceInfo>,
): Promise<{ sources: SourceGetter<C, S>[]; filenameMap: Map<string, string | undefined> }> => {
  if (!existsSync(app.getTmpDir())) mkdirSync(app.getTmpDir(), { recursive: true });
  const filenameMap: Map<string, string | undefined> = new Map();

  if (typeof oneOreMoreSources === "string") {
    const tmpFileName = path.join(app.getTmpDir(), `${crypto.randomUUID()}.xml`);
    writeFileSync(tmpFileName, oneOreMoreSources, "utf-8");
    filenameMap.set(tmpFileName, undefined);
    oneOreMoreSources = Source.file(tmpFileName);
  }
  if (!Array.isArray(oneOreMoreSources)) {
    oneOreMoreSources = [oneOreMoreSources];
  }

  const processedSources: SourceGetter<C, S>[] = [];
  const onlyFileSources: SourceGetter<C, FileSourceInfo>[] = [];

  for (const source of oneOreMoreSources) {
    // @ts-ignore
    const info = await source.get(app);
    let sourceIsStringSource = false;
    for (let i of info) {
      // if we have a StringSourceInfo, we need to save it to file first:
      if (isStringSource(i)) {
        sourceIsStringSource = true;
        const content = await (i as StringSourceInfo).getString();
        const stringSourceToFileFileName = path.join(
          app.getTmpDir(),
          `${crypto.generateKeySync("hmac", { length: 10 })}.txt`,
        );
        writeFileSync(stringSourceToFileFileName, content, "utf-8");
        onlyFileSources.push(Source.file(stringSourceToFileFileName));
        filenameMap.set(stringSourceToFileFileName, undefined);
        //@ts-ignore
      }
    }
    // @ts-ignore
    if (!isCorrectSourceGetter(source, sourceIsStringSource)) onlyFileSources.push(source);
  }
  // @ts-ignore
  const xslFile = await (await stylesheet.get(app))[0].getLocalPath();
  const sefFile = path.join(app.getTmpDir(), `${path.basename(xslFile, path.extname(xslFile))}.json`);
  //create SEF from XSL:
  const DevNull = process.platform === "win32" ? "NUL" : "/dev/null";
  const cmd = `npx xslt3 -xsl:"${xslFile}" -export:"${sefFile}" -nogo 2>${DevNull}`;
  try {
    execSync(cmd, { windowsHide: true });
  } catch (e) {
    throw new Error(`Failed to compile your stylesheet '${xslFile}'.\ndebug info:\n${(e as Error).message}`);
  }

  for (const source of onlyFileSources) {
    //@ts-ignore
    const info = await source.get(app);
    for (let i of info) {
      const hash = crypto.createHash("md5");
      const sourceFileName = await i.getLocalPath();
      hash.update(sourceFileName);
      const tmpFileName = `${hash.digest("hex")}.xml`;
      const tmpFilePath = path.join(app.getTmpDir(), tmpFileName);
      if (!filenameMap.has(tmpFilePath))
        filenameMap.set(tmpFilePath, filenameMap.get(sourceFileName) ?? sourceFileName);
      try {
        const output: any = await SaxonJS.transform(
          {
            stylesheetFileName: sefFile,
            sourceFileName,
            destination: "serialized",
          },
          "async",
        );
        writeFileSync(tmpFilePath, output.principalResult, "utf-8");
      } catch (e) {
        throw new Error(`Failed to apply the stylesheet '${xslFile}' to the XML.`);
      }
      //@ts-ignore
      processedSources.push(Source.file(tmpFilePath));
    }
  }
  filenameMap.forEach((value, key) => {
    if (value !== undefined && value.startsWith(app.getTmpDir())) {
      filenameMap.set(key, undefined);
    }
  });
  return { sources: processedSources, filenameMap };
};
