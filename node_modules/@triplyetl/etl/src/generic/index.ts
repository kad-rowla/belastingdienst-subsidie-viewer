import Context from "./Context.js";
import Store from "./Store.js";
import { Location } from "get-current-line";

export { default as Context, Key } from "./Context.js";
export { Record, key } from "./Record.js";
export { default as Source } from "./locations/sources/index.js";
export { default as Destination } from "./locations/destinations/index.js";
export { default as Store } from "./Store.js";
export { default as Etl } from "./Etl.js";
export { default as Iri } from "./Iri.js";
export * from "./middlewares/index.js";
export { default as declarePrefix } from "./utils/declarePrefix.js";

export type NextFn = <R = unknown>(record?: R, store?: Store, skip?: number) => Promise<void>;
export type Middleware<R = unknown> = ((
  //Etl context referencing the current record and the N3 store where the quads are tored
  context: Context<R>,
  //A reference to the next middleware. Make sure to await this function when calling it
  next: NextFn,
) => Promise<void>) & { callSite?: Location; sourceFuncName?: string; whenMwDepth?: number };
export type MiddlewareList<R = unknown> = Array<MiddlewareList<R> | Middleware<R>>;
export type Environment = "Development" | "Testing" | "Acceptance" | "Production";

export const environments: {
  [key in Environment]: Environment;
} = {
  Development: "Development",
  Testing: "Testing",
  Acceptance: "Acceptance",
  Production: "Production",
};

/**
 * Returns a randomly created key name.
 *
 * This can be used to store intermedate results in between two middlewares.
 */
export function randomKey(): string {
  return `_tmp_${Math.random()}`;
}
