import { getFactory, Store as TriplyStore } from "@triplydb/data-factory";
import { BlankNode, Literal, NamedNode, Quad, Term } from "@triplydb/data-factory/Terms.js";
import { flatMap, once } from "lodash-es";
import { Writer } from "n3";
import { Pattern } from "@triplydb/data-factory/Store.js";
import Etl from "./Etl.js";
import crypto from "crypto";
import { unknownValToIri, unknownValToLiteral } from "../utils/coercions.js";
import { LanguageTagOrDataType } from "../ratt/middlewares/assertions/term/literal.js";
import { Iri } from "@triplyetl/vocabularies";

const dataFactory = once(() => getFactory({ skipValidation: Etl.skipValidation }));
export type OTerm = Term | string | null;

export default class Store extends TriplyStore {
  private _app: Etl;
  constructor(app: Etl) {
    super();
    this._app = app;
  }

  public addQuad(quad: Quad): void;
  public addQuad(
    subject: Quad["subject"],
    predicate: Quad["predicate"],
    object: Quad["object"] | Array<Quad["object"]>,
    graph?: Quad["graph"],
    done?: () => void,
  ): void;
  public addQuad(
    subjectOrQuad: Quad["subject"] | Quad,
    predicate?: Quad["predicate"],
    object?: Quad["object"] | Array<Quad["object"]>,
    graph?: Quad["graph"],
    done?: () => void,
  ) {
    if ("graph" in subjectOrQuad) {
      // this is a quad
      let quad = subjectOrQuad;
      if (subjectOrQuad.graph.termType === "DefaultGraph") {
        quad = dataFactory().quad(quad.subject, quad.predicate, quad.object, this._app.defaultGraph);
      }
      super.addQuad(this.blankNodesToIris(subjectOrQuad));
    } else {
      if (!graph || graph.termType === "DefaultGraph") {
        graph = this._app.defaultGraph;
      }

      const subject = this.blankNodesToIris(subjectOrQuad);
      predicate = this.blankNodesToIris(predicate!);
      object = this.blankNodesToIris(object!);
      graph = this.blankNodesToIris(graph);
      super.addQuad(subject, predicate, object, graph, done);
    }
  }

  public addQuads(quads: Quad[]) {
    const modifiedQuads = quads.map((q) => {
      if (q.graph.termType === "DefaultGraph") {
        return dataFactory().quad(q.subject, q.predicate, q.object, this._app.defaultGraph);
      }
      return q;
    });
    super.addQuads(this.blankNodesToIris(modifiedQuads));
  }
  public map(mapper: (quad: Readonly<Quad>) => undefined | Quad | Quad[], pattern?: Pattern): Quad[] {
    const quads = this.getQuads(pattern || {});
    const newQuads = flatMap(quads, mapper).filter((q) => !!q) as Quad[];
    this.removeQuads(quads);
    this.addQuads(newQuads);
    return newQuads;
  }

  private containsBnode(quad: Quad) {
    for (const position of ["subject", "predicate", "object", "graph"] as const) {
      if (quad[position].termType === "BlankNode") return true;
    }
    return false;
  }
  private blankNodesToIris(blankNode: BlankNode): NamedNode<string>;
  private blankNodesToIris<T extends Term | undefined>(term: T): Exclude<T, BlankNode>;
  private blankNodesToIris<T extends Term | undefined>(term: T[]): Exclude<T, BlankNode>[];
  private blankNodesToIris<T extends Term>(term: T | T[]): Exclude<T, BlankNode> | Exclude<T, BlankNode>[];
  private blankNodesToIris<T extends Term | undefined>(zeroOneOrMoreTerms: T | T[]) {
    if (zeroOneOrMoreTerms === undefined) {
      return undefined;
    } else if (Array.isArray(zeroOneOrMoreTerms)) {
      return zeroOneOrMoreTerms.map((quad) => this.blankNodesToIris(quad));
    } else if (zeroOneOrMoreTerms.termType === "Quad") {
      if (this.containsBnode(zeroOneOrMoreTerms as Quad)) {
        return dataFactory().quad(
          this.blankNodesToIris(zeroOneOrMoreTerms.subject as Quad["subject"]),
          this.blankNodesToIris(zeroOneOrMoreTerms.predicate as Quad["predicate"]),
          this.blankNodesToIris(zeroOneOrMoreTerms.object as Quad["object"]),
          this.blankNodesToIris(zeroOneOrMoreTerms.graph as Quad["graph"]),
        );
      } else {
        return zeroOneOrMoreTerms;
      }
    } else if (zeroOneOrMoreTerms.termType === "BlankNode") {
      return this.wellKnownForBnode(zeroOneOrMoreTerms as BlankNode);
    } else {
      return zeroOneOrMoreTerms;
    }
  }
  private wellKnownForBnode(blankNode: BlankNode) {
    return this.blankNodeIri(blankNode.value);
  }
  public createBlankNode(_suggestedName?: string): never {
    throw new Error("Please use the `blankNodeIri` method of this store.");
  }
  public blankNodeIri(val?: string): NamedNode {
    const content = val !== undefined ? this._app.id + val : crypto.randomBytes(16).toString("hex");
    return this._app.wellKnownIri.concat(content);
  }
  public iri(val: unknown, opts?: { prefix?: Iri }): NamedNode {
    const node = unknownValToIri(val, undefined, opts);
    return node;
  }
  public literal(val: unknown, languageTagOrDataType?: LanguageTagOrDataType): Literal {
    return unknownValToLiteral(val, undefined, languageTagOrDataType);
  }
  public copy() {
    const newStore = this._app.getNewStore();
    if (this.size === 0) return newStore;
    newStore.addQuads(this.getQuads(null, null, null, null));
    return newStore;
  }

  public toNquadsString() {
    const writer = new Writer({ format: "nquads" });
    return writer.quadsToString(this.getQuads({})).split("\n").sort().join("\n") + "\n";
  }
}
