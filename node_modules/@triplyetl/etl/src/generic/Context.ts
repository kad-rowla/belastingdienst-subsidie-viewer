import jp from "jsonpath";
import { flatten, get as lodashGet, isString as _isString, toNumber, has, unset, once } from "lodash-es";
import { BlankNode, Literal, NamedNode, Quad } from "@triplydb/data-factory/Terms.js";
import { Record } from "./Record.js";
import { DestinationGetter } from "./locations/destinations/index.js";
import { ContentType, getTotalSize, SourceGetter, SizeableSourceInfo, SourceInfo } from "./locations/sources/index.js";
import { PossibleIri } from "../utils/index.js";
import {
  assertIs,
  assertIsNotEmpty,
  assertKeyExists,
  getReasonWhysomethingIsEmpty,
  isArray,
  isNamedNode,
  isLiteral,
  isNumber,
  isString,
} from "../utils/asserts.js";
import { ifPossibleCoerce } from "../utils/coercions.js";
import { LanguageTagOrDataType } from "../ratt/middlewares/assertions/term/literal.js";
import Store from "./Store.js";
import { Etl } from "./index.js";
import { isStatic, StaticString } from "../ratt/middlewares/assertions/term/str.js";
import { coerceLiteral } from "../ratt/middlewares/assertions/statement/rdf/utils/coerceLiteral.js";
import { isJPath, JPath } from "../ratt/middlewares/assertions/term/jpath.js";
import { getFactory } from "@triplydb/data-factory";
import * as TriplyIri from "@triplydb/iri";
import { isIri } from "@triplyetl/vocabularies/lib/Classes/Iri.js";
const dataFactory = once(() => getFactory({ skipValidation: Etl.skipValidation }));

export type Key = string | JPath;

export function isKey(value: any): value is Key {
  return (typeof value === "string" || isJPath(value)) && !isStatic(value);
}

interface PrimitiveTypeMapping {
  string: string;
  number: number;
  boolean: boolean;
  literal: Literal;
  iri: NamedNode;
  blankNode: BlankNode;
  unknown: unknown;
  any: any;
  table: { [key: string]: any };
}
type PrimitiveTypeName = keyof PrimitiveTypeMapping;
type ArrayTypeName = { array: TypeName };

export type TypeName = PrimitiveTypeName | ArrayTypeName;

export type TypeForName<T extends TypeName> = T extends ArrayTypeName
  ? Array<TypeForName<T["array"]>>
  : T extends PrimitiveTypeName
  ? PrimitiveTypeMapping[T]
  : never;

export function getTypedValFromRecord(ctx: Context, key: string, type: TypeName) {
  if (typeof type === "string") {
    switch (type) {
      case "any":
        return ctx.getAny(key);
      case "unknown":
        return ctx.getUnknown(key);
      case "string":
        return ctx.getString(key);
      case "number":
        return ctx.getNumber(key);
      case "boolean":
        return ctx.getBoolean(key);
      case "iri":
        return ctx.getIri(key);
      case "literal":
        return ctx.getLiteral(key);
    }
  } else if ("array" in type) {
    return ctx.getArray(key, type.array);
  } else {
    throw new Error(`Unexpected type ${type} requested`);
  }
}
type LiteralOptions<T> = T extends "literal" ? LanguageTagOrDataType : never;
export function getType<T extends TypeName = "unknown">(
  object: unknown,
  keyOrPathExpression: Key,
  type: T,
  opts?: LiteralOptions<T>,
): TypeForName<T> {
  let value, key;
  assertKeyExists(object, keyOrPathExpression);
  if (isJPath(keyOrPathExpression)) {
    value = jp.value(object, keyOrPathExpression.toString());
    key = keyOrPathExpression.toString();
  } else {
    value = lodashGet(object, keyOrPathExpression);
    key = keyOrPathExpression;
  }
  if (type === "any" || type === "unknown") return value;
  assertIsNotEmpty(value, key);
  const coercedValue = ifPossibleCoerce(value, key, type, opts);
  assertIs(coercedValue, key, type);
  return coercedValue;
}

export default class Context<R = unknown> {
  // @ts-ignore Ignore, it's private, but we're using it in the trace middleware
  private traceInfo: {
    fromMwIndex: Array<number>;
    recordId: number;
    record: any;
    quads: string;
  };
  // @ts-ignore Ignore, it's private, but we're using it to trace middleware for when they error
  private traceError: {
    fromMwIndex: Array<number>;
    recordId: number;
    record: any;
    quads: string;
  };
  public recordId = 0;
  public readonly app: Etl;
  public record = {} as R & Record;
  public store: Store;
  public source?: SourceInfo;
  constructor(app: Etl) {
    this.app = app;
    this.store = app.getNewStore();
  }

  //@ts-ignore Private to keep a clean interface. It's used somewhere else though
  private async _registerSources<C extends ContentType, I extends SourceInfo<unknown>>(
    sourceGetters: SourceGetter<C, I>[],
    requestedContentType: C,
    opts?: { registerTotalProgress: boolean },
  ) {
    const sources = flatten(
      await Promise.all(sourceGetters.map(async (location) => location.get(this.app, requestedContentType))),
    );
    if (opts?.registerTotalProgress && this.app["_totalToProcess"] === undefined) {
      this.app.setTotalProgress(await getTotalSize(sources.filter((s) => "getSize" in s) as SizeableSourceInfo[]));
    }
    return sources;
  }

  public hasParent(): boolean {
    return this.hasKey("$parent");
  }

  public getParent(): (R & Record) | undefined {
    if (this.hasKey("$parent")) {
      const parent = { ...this.getAny("$parent") };
      unset(parent, "$index");
      unset(parent, "$parent");
      unset(parent, "$root");
      return parent;
    }
  }

  public getRoot(): R & Record {
    return this.hasKey("$root") ? this.getAny("$root") : this.record;
  }

  public getAny(key: Key | StaticString) {
    return isStatic(key) ? key.toString() : getType(this.record, key, "any");
  }

  public getUnknown(key: Key) {
    return getType(this.record, key, "unknown");
  }

  public getString(key: StaticString | Key) {
    // currently fetching a value from a Record that is empty ('') this will throw an error.
    // We have to reconcider if this is correct. For now, we can overrule with allowEmptyString = true.

    if (isStatic(key)) {
      // to make this consistant, Etl should throw on empty static strings as well, which is a bit weird ...
      // if (key.toString() === '' && !allowEmptyString) throw new AssertionError({ message: 'static value not to be empty' })
      return key.toString();
    }

    return getType(this.record, key, "string");
  }

  public getArray<T extends TypeName>(key: Key, elementType: T): TypeForName<T>[] {
    return getType(this.record, key, { array: elementType });
  }

  public getTable<To = unknown>(key: Key): { [key: string]: To } {
    return getType(this.record, key, "table");
  }

  public getNumber(key: Key | StaticString): number {
    return isStatic(key) ? toNumber(key.toString()) : getType(this.record, key, "number");
  }

  public getBoolean(key: Key) {
    return getType(this.record, key, "boolean");
  }
  public getLiteral(key: Key | StaticString, languageOrDatatype?: LanguageTagOrDataType): Literal {
    return coerceLiteral(
      isStatic(key) ? key : this.getAny(key),
      languageOrDatatype,
      isStatic(key) ? `str('${key}')` : isJPath(key) ? `jsonpath('${key}')` : key,
      languageOrDatatype?.toString(),
    );
  }

  public getIri(iriCandidate: PossibleIri): NamedNode {
    if (isIri(iriCandidate)) {
      return iriCandidate;
    } else if (_isString(iriCandidate)) {
      if (isStatic(iriCandidate)) {
        try {
          return dataFactory().namedNode(new URL(iriCandidate.toString()).toString());
        } catch (e) {
          throw new Error(`'${iriCandidate}': ${(e as Error).message}`);
        }
      } else {
        try {
          // If this is already an Iri, we can return it
          return getType(this.record, iriCandidate, "iri");
        } catch (e) {
          // Otherwise we need a string and  cast that as an Iri
          let iriString = "";
          let value = this.getAny(iriCandidate.toString());
          if (isNamedNode(value)) return value;
          if (typeof value === "function") {
            const valueFromFunction = value("");
            if (isNamedNode(valueFromFunction)) return valueFromFunction;
            if (typeof valueFromFunction !== "string") {
              throw new Error(
                `Expected the key '${iriCandidate}' to contain a function that returns either an Iri or a URL string, got type '${typeof valueFromFunction}'`,
              );
            }
            iriString = valueFromFunction;
          } else if (typeof value === "string") {
            iriString = value;
          } else if (typeof value === "number") {
            iriString = value.toString();
          } else if (typeof value === "object") {
            throw new Error(
              `Key '${iriCandidate.toString()}' points to an object the Etl record, I can not process that type.`,
            );
          } else {
            throw new Error(
              `Expected a function (): Iri or IRI string for key '${iriCandidate.toString()}' in the Etl record.`,
            );
          }
          try {
            TriplyIri.validate(iriString);
          } catch (e) {
            throw new Error(`Can not make value '${iriString}' into a valid URL.`);
          }
          return dataFactory().namedNode(iriString);
        }
      }
    } else if (typeof iriCandidate === "function") {
      return iriCandidate("") as NamedNode;
    } else {
      return iriCandidate as NamedNode;
    }
  }

  public getBnode(key: string) {
    return getType(this.record, key, "blankNode");
  }

  public hasKey(key: Key): boolean {
    if (isJPath(key)) return jp.query(this.record, key.toString()).length > 0;
    else return has(this.record, key);
  }

  /**
   * Check whether this key has a non empty value.
   * False is returned for:
   * - Empty strings, or strings with only whitespace
   * - Empty arrays
   * - Empty objects
   * - Values undefined and null
   */
  public isNotEmpty(key: Key) {
    if (isJPath(key)) return jp.value(this.record, key.toString()).length > 0;
    else return !this.isEmpty(key);
  }

  /**
   * Check whether this key has a non empty value.
   * True is returned for:
   * - Empty strings, or strings with only whitespace
   * - Empty arrays
   * - Empty objects
   * - Values undefined and null
   */
  public isEmpty(key: Key) {
    const value = isJPath(key) ? jp.value(this.record, key.toString()) : lodashGet(this.record, key);
    return !!getReasonWhysomethingIsEmpty(value);
  }
  public isLiteral(key: string) {
    return isLiteral(this.getAny(key));
  }
  public isIri(key: string) {
    return isNamedNode(this.getAny(key));
  }
  public isNumber(key: Key) {
    return isNumber(this.getAny(key));
  }
  public isString(key: Key) {
    return isString(this.getAny(key));
  }
  public isArray(key: Key) {
    return isArray(this.getAny(key));
  }

  public async writeQuads(
    quads: Quad[],
    destinationGetter: DestinationGetter,
    opts?: Parameters<Etl["getDestinationStream"]>[1],
  ) {
    const destination = typeof destinationGetter === "function" ? await destinationGetter(this) : destinationGetter;

    if (destination.fileInfo.extension === "nt" || destination.fileInfo.extension === "ttl") {
      // We're removing the graph manually now.
      // See https://github.com/rdfjs/N3.js/issues/165
      const defaultGraph = dataFactory().defaultGraph();
      quads = quads.map((q) => dataFactory().quad(q.subject, q.predicate, q.object, defaultGraph));
    }

    const stream = await this.app["getDestinationStream"](destination, opts);
    for (const quad of quads) {
      // Handling backpressure
      await new Promise<void>((resolve, reject) => {
        try {
          if (stream.write(quad)) return resolve();
          stream.once("drain", () => resolve());
        } catch (e) {
          reject(e);
        }
      });
    }
  }
}
