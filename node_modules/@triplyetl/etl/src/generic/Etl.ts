import TriplyDb, { AppConfig as TriplyDbConfig } from "@triply/triplydb/App.js";
import chalk from "chalk";
import { format, formatDuration, intervalToDuration } from "date-fns";
import { EventEmitter } from "events";
import filenamify from "filenamify";
import { fromJSON as fromJsonFlatted } from "flatted";
import fs from "fs-extra";
import prettyMilliseconds from "pretty-ms";
import getCurrentLine, { Location } from "get-current-line";

import { compact, flatMap, flattenDeep, get } from "lodash-es";
import { parse } from "@triplydb/data-factory";
import path from "path";
import Pumpify from "pumpify";
import * as zlib from "zlib";
import { Environment, Middleware, MiddlewareList, Store } from "./index.js";
import { Record } from "./Record.js";
import Context, { Key } from "./Context.js";
import { Destination, DestinationGetter, TempFileInfo } from "./locations/destinations/index.js";
import { FileSourceInfo, SourceGetter, SourceInfo } from "./locations/sources/index.js";
import {
  addMwCallSiteToError,
  coerceToIri,
  includeEtlVariablesInEnv,
  isNodejs,
  md5OfArray,
  NamedNodeCompatibleType,
  randomHash,
} from "../utils/index.js";

import { assertEnvironment, assertHasToken, assertIsDefined } from "../utils/asserts.js";
import { getErr, SerializedTraceInfo } from "../utils/Error.js";
import { ldExtensionToN3Format } from "../utils/files.js";
import { randomUUID } from "crypto";
import { str } from "../ratt/index.js";
import { NamedNode } from "@triplydb/data-factory/Terms.js";
import { getFactory } from "@triplydb/data-factory";
import { Prefixes, getStreamWriter } from "@triplydb/data-factory/serialize.js";
import * as TriplyIri from "@triplydb/iri";
import { getTraceInfo } from "../debug/traceEnd.js";
import { setTraceErrorInfo } from "../debug/traceStart.js";
import { Iri } from "@triplyetl/vocabularies";
import { readFileSync } from "fs";
import { fileURLToPath } from "node:url";

export const DEFAULT_BASE_IRI = "https://triplydb.com";
export const DEFAULT_GRAPH_IRI = `${DEFAULT_BASE_IRI.replace(/\/+$/, "")}/graph/default`;
export interface Iris {
  [key: string]: Iri;
}

export interface Config<
  P extends Iris,
  S extends { [key: string]: SourceGetter<any, SourceInfo> },
  D extends { [key: string]: DestinationGetter },
> {
  /**
   * List of prefixes. To access these later on, use `app.prefix.<prefix>`
   */
  prefixes: P;
  /**
   * Default graph when writing quads
   */
  defaultGraph: NamedNodeCompatibleType;
  /**
   * Base iri for generating skolem iri's and default prefixes/graphnames.
   * NOTE: This configuration property does not yet support IRIs that are not URIs.
   */
  baseIri: string | NamedNode;
  /**
   * Prefix for well-known IRIs (skolemised blank-nodes). If not provided it will use the `baseIri` setting.
   */
  wellKnownIriPrefix: Iri | string;
  /**
   * Sources that you can use in your ETL. To access these, use `app.sources.<source-name>`
   */
  sources: S;
  /**
   * Destinations that you can use in your ETL. To access these, use `app.destinations.<source-name>`
   */
  destinations: D;
}

type ConfigArg<
  P extends Iris,
  S extends { [key: string]: SourceGetter<any, SourceInfo> },
  D extends { [key: string]: DestinationGetter },
> = Partial<Config<P, S, D>>;

/**
 * Stats are statistics we track for a complete Etl run
 * These are used by the CLI to draw the final report, and optionally shown at real-time
 */
export interface Stats {
  [label: string]: string | number;
}

interface AfterHook {
  fn: AfterHookFn;
  always?: boolean;
  callsite: Location;
}
type AfterHookFn = (etlFinishedSuccessfully: boolean) => void | Promise<void>;
type BeforeHookFn = () => void | Promise<void>;
export interface CliContext {
  triplydb?: TriplyDb;
  wellKnownIriPrefix?: Iri;
  offset?: number;
  limit?: number;
  timeout?: number;
  dataDir?: string;
  account?: string;
  verbosity?: number;
  debugTrace?: SerializedTraceInfo;
  errorTrace?: boolean;
  createErrorTrace?: boolean;
}
export type InitEtl = () => Etl | Promise<Etl>;

/**
 * Messages are logged by default. They are also shown (as a counter) in the final report and real-time
 */
export type MessageLevel = "Error" | "Violation" | "Warning" | "Info";
export interface Message {
  type: "Shacl" | "Etl";
  level: MessageLevel;
  label: string;
  message: string;
  // How often (including this message) was this message emitted?
  count: number;
}
export type Status = "idle" | "running" | "afterHook" | "beforeHook" | "done" | "error";
interface DestinationAfterHook {
  fn: AfterHookFn;
  name: string;
}
export interface AfterHookDuration {
  name: string;
  duration: bigint;
  callsite?: Location;
}
export type MwRuntimeInfo = {
  timerStart?: bigint;

  trailingMwDuration: bigint;
  runtime: bigint;
  /**
   * nested position of middlewares using an array of index values.
   * when calling a middleware inside a forEach, the array length increases,
   * and a new mw index value is created.
   */
  mwIndicesPosition: Array<number>;
  functionName: string;
  callSite: Location | undefined;
  numOfRecords: number;
  timesCalled: number;
  whenMwDepth: number | undefined;
};
interface Etl<
  P extends Iris,
  S extends { [key: string]: SourceGetter<any, SourceInfo> },
  D extends { [key: string]: DestinationGetter },
> {
  on(event: "progress", listener: (progress: number) => void): this;
  off(event: "progress", listener: (progress: number) => void): this;
  emit(event: "progress", progress: number): boolean;
  on(event: "finished", listener: (stats: Stats) => void): this;
  off(event: "finished", listener: (stats: Stats) => void): this;
  emit(event: "finished", stats: Stats): boolean;
  on(event: "message", listener: (statusMessage: Message) => void): this;
  off(event: "message", listener: (statusMessage: Message) => void): this;
  emit(event: "message", statusMessage: Message): boolean;
  on(event: "stats", listener: (stats: Stats) => void): this;
  off(event: "stats", listener: (stats: Stats) => void): this;
  emit(event: "stats", stats: Stats): boolean;
  on(event: "status", listener: (status: Status) => void): this;
  off(event: "status", listener: (status: Status) => void): this;
  emit(event: "status", status: Status): boolean;
}
class Etl<
  P extends Iris = {},
  S extends { [key: string]: SourceGetter<any, SourceInfo> } = {},
  D extends { [key: string]: DestinationGetter } = {},
> extends EventEmitter {
  private _totalToProcess: number | undefined;
  private _processedAbsolute: number | undefined;
  private _processedPercentage: number | undefined;
  private _runtimeStats: Stats = {};
  private _reportStats: Stats = {};
  private _startTime?: Date;
  // @ts-ignore Marked private to keep the interface clean. Used externaly though
  private _beforeDuration?: bigint;
  private _after: AfterHook[] = [];
  // @ts-ignore Marked private to keep the interface clean. Used externaly though
  private _afterDurations: Array<AfterHookDuration> = [];
  private _before: BeforeHookFn[] = [];
  private _destinationPostProcess: Array<DestinationAfterHook> = [];
  private readonly offset: number;
  private readonly limit?: number;
  private readonly createErrorTrace: boolean = false;
  private readonly _timeout?: number;
  public status: Status = "idle";

  // utility key to precvent messages being print, useful in tests:
  public static silent = false;

  // keep track of number of extractors, we allow only 1 per ETL:
  public extractorName?: string = undefined;

  public static skipValidation = false;

  public prefix: Iris;

  /**
   * String that is different for every app
   */
  public readonly id: string;
  public readonly defaultGraph: NamedNode;
  public readonly wellKnownIri: Iri;
  /**
   * The baseIri used for all other Iri's. Trailing slashes will always be removed!
   */
  public readonly baseIri: Iri = new Iri(DEFAULT_BASE_IRI.replace(/\/+$/, ""));
  public readonly verbosity: number = 0;
  private middlewares: Array<Middleware> = [];
  private _dataDir = "./data";
  // @ts-ignore Marked private to keep the interface clean. Used externaly though
  private _fromCli: boolean;

  // Keep track of which middlewares were executed
  private touchedMiddlewares = new Map<Location, boolean>();
  public sources: S;
  public destinations: D;
  private _triplyDb?: TriplyDb;
  // @ts-ignore Marked private to keep the interface clean. Used externaly though
  private currentMwIndices: Array<number> = [0];
  // @ts-ignore Marked private to keep the interface clean. Used externaly though
  private _defaultAccount?: string;
  private debugTrace: SerializedTraceInfo | undefined;
  // @ts-ignore This value is not read here but read in the forEach middleware
  private errorTrace: boolean | undefined;
  private mwRuntimesObj: { [mwIndicesPosition: string]: MwRuntimeInfo };
  private afterMiddlewaresFromConfig: Middleware[] = [];

  private readonly _runId = randomUUID();

  public constructor(conf?: ConfigArg<P, S, D>) {
    super();
    includeEtlVariablesInEnv();
    this.id = Date.now().toString(); // epoch in milliseconds
    if (conf?.baseIri) this.baseIri = this.getBaseIri(conf.baseIri);
    if (conf?.wellKnownIriPrefix) {
      this.wellKnownIri =
        typeof conf.wellKnownIriPrefix === "string"
          ? new Iri(this.getBaseIri(conf.wellKnownIriPrefix).toString() + "/")
          : conf.wellKnownIriPrefix;
    } else this.wellKnownIri = new Iri(new URL("/.well-known/genid/", this.baseUrl).toString());

    this.prefix = {
      ...DEFAULT_PREFIXES,
      ...conf?.prefixes,
    };
    this.defaultGraph = conf?.defaultGraph
      ? coerceToIri(conf.defaultGraph)
      : this.baseIri
      ? this.standardGraphs.default
      : this.dataFactory.namedNode(DEFAULT_GRAPH_IRI);

    this._triplyDb = Etl.CliContext?.triplydb;
    this._defaultAccount = Etl.CliContext?.account;
    this.offset = Etl.CliContext?.offset ?? 1;
    if (this.offset < 1) {
      throw new Error("fromRecordId must be strictly greater than 0");
    }
    this.limit = Etl.CliContext?.limit;
    this._timeout = Etl.CliContext?.timeout;
    this.debugTrace = Etl.CliContext?.debugTrace;
    this.errorTrace = Etl.CliContext?.errorTrace;
    this.createErrorTrace = Etl.CliContext?.createErrorTrace ?? false;
    this._fromCli = !!Etl.CliContext;
    if (Etl.CliContext?.dataDir) this._dataDir = Etl.CliContext.dataDir;
    if (Etl.CliContext?.verbosity) {
      this.verbosity = Etl.CliContext.verbosity;
    }
    this.sources = conf?.sources || ({} as any);
    this.destinations = conf?.destinations || ({} as any);
    for (const destinationName in this.destinations) {
      const destination = this.destinations[destinationName];
      if (typeof destination !== "function") {
        destination.name = `destination.${destinationName}`;
      }
    }
    this.mwRuntimesObj = {};
  }
  get dataFactory() {
    return getFactory({ skipValidation: Etl.skipValidation });
  }

  private getBaseIri(possibleIri: string | NamedNode): Iri {
    let iriAsString = "";
    if (typeof possibleIri === "string") iriAsString = possibleIri;
    else iriAsString = possibleIri.value;
    try {
      TriplyIri.validate(iriAsString);
      return new Iri(this.dataFactory.namedNode(iriAsString.replace(/\/+$/, "")));
    } catch (e) {
      throw new Error(`Could not make '${iriAsString}' into a valid URL`);
    }
  }

  public get baseUrl(): URL {
    return new URL(this.baseIri.value);
  }

  private _setStatus(status: Status) {
    this.status = status;
    this.emit("status", status);
  }
  private _messageCounts: { [label: string]: number } = {};
  private toMessageObject(
    message: string | Pick<Message, "message" | "label">,
    level: MessageLevel,
    type: "Etl" | "Shacl",
  ): Message {
    const messageObject =
      typeof message === "string"
        ? {
            label: level,
            level: level,
            message: message,
            type: type,
          }
        : { ...message, level: level, type: type };
    if (this._messageCounts[messageObject.type + messageObject.label] === undefined) {
      this._messageCounts[messageObject.type + messageObject.label] = 0;
    }
    this._messageCounts[messageObject.type + messageObject.label]++;
    return {
      ...messageObject,
      count: this._messageCounts[messageObject.type + messageObject.label],
    };
  }
  // @ts-ignore Marked private to keep the interface clean. Used externaly though
  private setMwIndices(mwIndex: number) {
    const last = this.currentMwIndices.length - 1;
    this.currentMwIndices[last] = mwIndex;
  }
  private startMwTimer(opts: {
    timerLabel: string;
    recordId: number;
    callSite: Location | undefined;
    mwName: string | undefined;
    whenMwDepth: number | undefined;
  }) {
    // Only track time when we're in node
    if (!isNodejs()) return;

    // when 'this.currentMwIndices' is later updated we don't want the 'mwIndicesPosition' to change.
    const mwIndicesPosition = [...this.currentMwIndices];
    let functionName: string = "unnamed middleware";
    if (opts.mwName) {
      /**
       * all middlewares in Etl are wrapped with addMwCallSiteToError
       * when wrapped the function.name property is prepended with an underscore "_"
       * here we are removing it for logging purposes.
       */
      if (opts.mwName.startsWith("_")) functionName = opts.mwName.substring(1);
      else functionName = opts.mwName;
    }
    if (this.mwRuntimesObj[opts.timerLabel]) {
      this.mwRuntimesObj[opts.timerLabel].timerStart = process.hrtime.bigint();
      this.mwRuntimesObj[opts.timerLabel].numOfRecords = opts.recordId;
      this.mwRuntimesObj[opts.timerLabel].timesCalled++;
    } else {
      const startTimerObj: MwRuntimeInfo = {
        timerStart: process.hrtime.bigint(),
        mwIndicesPosition,
        functionName,
        callSite: opts.callSite,
        runtime: BigInt(0),
        trailingMwDuration: BigInt(0),
        numOfRecords: opts.recordId ? opts.recordId : 1,
        timesCalled: 1,
        whenMwDepth: opts.whenMwDepth,
      };
      this.mwRuntimesObj[opts.timerLabel] = startTimerObj;
    }
  }
  private addToMwTimerTrailingDuration(timerLabel: string, duration: bigint) {
    if (!this.mwRuntimesObj[timerLabel]) {
      throw new Error(`Failed to find runtime info for middleware ${timerLabel}. Please contact a developer.`);
    }
    this.mwRuntimesObj[timerLabel].trailingMwDuration += duration;
  }

  private endMwTimer(timerLabel: string) {
    // Only track time when we're in node
    if (!isNodejs()) return;
    if (!this.mwRuntimesObj[timerLabel]) {
      throw new Error(`Failed to find runtime info for middleware ${timerLabel}. Please contact a developer.`);
    }
    const { timerStart, trailingMwDuration } = this.mwRuntimesObj[timerLabel];
    if (timerStart) {
      const endTime = process.hrtime.bigint();
      const timeDifference = endTime - timerStart - trailingMwDuration;
      this.mwRuntimesObj[timerLabel].runtime += timeDifference;
      this.mwRuntimesObj[timerLabel].timerStart = undefined;
      this.mwRuntimesObj[timerLabel].trailingMwDuration = BigInt(0);
    }
  }
  private debugTraceToDispatchOpts(): DispatchOpts {
    assertIsDefined(this.debugTrace, "Expected debug trace to be defined");

    let store: Store;
    let record: any;
    if (this.debugTrace.fromMwIndex.length > 1) {
      // we have a middleware stack (i.e. a foreach or something) to dive into
      // i.e., the record we have in the debugTrace wont apply to the current level anyway
      // So, use an empty store and record
      store = this.getNewStore();
      record = {};
    } else {
      store = this.getNewStore();
      store.addQuads(parse(this.debugTrace.quadsAtStart));
      record = fromJsonFlatted(this.debugTrace.recordAtStart);
    }
    return {
      mwIndex: this.debugTrace.fromMwIndex.shift(),
      record,
      store,
    };
  }
  private logMessage(status: Message) {
    if (Etl.silent) return;
    if (status.level === "Error") {
      console.error(`${chalk.red(status.label)} ${status.message}`);
    } else if (status.level === "Violation") {
      console.error(`${chalk.red(status.label)} ${status.message}`);
    } else if (status.level === "Warning") {
      console.warn(`${chalk.yellow(status.label)} ${status.message}`);
    } else {
      console.info(`${chalk.blue(status.label)} ${status.message}`);
    }
  }

  private registeredDestinations: {
    [fingerprint: string]: {
      alwaysInfo: {
        writeableRdfStream?: Pumpify;
        files: Array<TempFileInfo>;
      };
      onSuccessInfo: {
        writeableRdfStream?: Pumpify;
        files: Array<TempFileInfo>;
      };
    };
  } = {};

  public async copySource(source: SourceGetter<"statements", FileSourceInfo>, destination: Destination) {
    switch (this.status) {
      case "beforeHook":
      case "idle":
      case "running":
        break;
      default:
        throw new Error(
          `Can only copy a source when the app hasn't finished running yet. Currently, the app is in the ${this.status} state.`,
        );
    }
    const sources = await source.get(this, "statements");
    const extraFiles = await Promise.all(
      // for each source we register the information given the destination function's registerSource function (rdf.ts, terminal.ts, file.ts, or TriplyDB.ts)
      sources.map((sourceInfo) => destination.registerSource(sourceInfo, this.getTmpDir(destination.type))),
    );
    // Register the files with the destination.
    // NB: `destinationInfo` is a mutable reference to an item of `this.registeredDestinations`
    // getDestinationInfo retrieves the file destinations using the destination's unique fingerprint, this fingerprint is a key in the dictionairy object (this.registeredDestinations) that is created in the destination functions (rdf.ts, terminal.ts, file.ts, or TriplyDB.ts)
    const destinationInfo = await this.getDestinationInfo(destination, { alwaysPostProcess: false });
    destinationInfo.files.push(...extraFiles);
  }

  private async getDestinationInfo(destination: Destination, opts: { alwaysPostProcess: boolean }) {
    let info = this.registeredDestinations[destination.fingerprint];
    if (!info) {
      // Register a destination for the first time
      await destination.init(this);
      this._destinationPostProcess.push(this.postProcessFactory(destination));
      info = this.registeredDestinations[destination.fingerprint] = {
        alwaysInfo: { files: [] },
        onSuccessInfo: { files: [] },
      };
    }
    return opts.alwaysPostProcess ? info.alwaysInfo : info.onSuccessInfo;
  }

  // @ts-ignore used in `Context.writeQuads` but private to keep the API clean
  private async getDestinationStream(
    destination: Destination,
    opts?: { extraPrefixes?: Iris } & Parameters<Etl["getDestinationInfo"]>[1],
  ) {
    const alwaysPostProcess = opts?.alwaysPostProcess ?? false;
    const info = await this.getDestinationInfo(destination, { alwaysPostProcess });
    if (info.writeableRdfStream) return info.writeableRdfStream;
    const extension = `.${destination.fileInfo.extension}${destination.fileInfo.compression === "gz" ? ".gz" : ""}`;
    const tmpFile =
      path.join(this.getTmpDir(destination.type), md5OfArray([destination.fingerprint, `${alwaysPostProcess}`])) +
      extension;
    info.files.push({ filename: tmpFile, remove: true });
    await fs.ensureFile(tmpFile);
    const fileStream = fs.createWriteStream(tmpFile);
    const prefixes: Prefixes = {};
    const etlPrefixes = { ...this.prefix, ...opts?.extraPrefixes };
    for (const prefix in etlPrefixes) {
      prefixes[prefix] = etlPrefixes[prefix];
    }
    const triplyStreamWriter = getStreamWriter({
      format: ldExtensionToN3Format(destination.fileInfo.extension),
      prefixes: { ...this.prefix, ...opts?.extraPrefixes },
    });
    const stream = (info.writeableRdfStream =
      destination.fileInfo.compression === "gz"
        ? new Pumpify.obj(triplyStreamWriter, zlib.createGzip(), fileStream)
        : new Pumpify.obj(triplyStreamWriter, fileStream));
    return stream;
  }

  private async flushWriters() {
    // wait for any write processes to finish
    await Promise.all<void>(
      flatMap(Object.values(this.registeredDestinations), (info) => [
        info.alwaysInfo.writeableRdfStream,
        info.onSuccessInfo.writeableRdfStream,
      ]).map(
        (writeableRdfStream) =>
          new Promise<void>((resolve) => (writeableRdfStream ? writeableRdfStream.end(resolve) : resolve())),
      ),
    );
  }

  private postProcessFactory(destination: Destination): DestinationAfterHook {
    return {
      fn: async (etlFinishedSuccessfully: boolean) => {
        const info = this.registeredDestinations[destination.fingerprint];
        if (!info) return;
        delete this.registeredDestinations[destination.fingerprint];
        const files = info.alwaysInfo.files.concat(etlFinishedSuccessfully ? info.onSuccessInfo.files : []);
        const filesWithMetadata = compact(
          await Promise.all(
            files.map(async (f) => {
              if (await fs.pathExists(f.filename)) return f;
            }),
          ),
        );
        // Each postProcess function of the given destination function is executed
        // This check is necessary as postProcess expects filesWithMetadata to have at least one element.
        if (filesWithMetadata.length) return destination.postProcess(this, filesWithMetadata);
      },
      name: destination.name || destination.fingerprint,
    };
  }

  // @ts-ignore Marked private to keep the interface clean. Used externaly though
  private getUntouchedMiddlewares() {
    return [...this.touchedMiddlewares].filter(([, val]) => !val).map(([key]) => key);
  }
  // @ts-ignore Marked private to keep the interface clean. Used externaly though
  private markMwTouched(location: Location) {
    this.touchedMiddlewares.set(location, true);
  }

  private async removeTmpDir() {
    return fs.remove(this.getTmpDir());
  }

  //////////////////////////////////////////////
  /////// Public methods ///////////////////////
  //////////////////////////////////////////////

  public static get token(): string | undefined {
    includeEtlVariablesInEnv();
    return get(process.env, "TRIPLYDB_TOKEN");
  }

  public get triplyDb() {
    if (!this._triplyDb) {
      if (this._fromCli) {
        throw new Error(
          `No TriplyDB token or API URL set. Run \`npx etl --help\` for more information on how to pass your TriplyDB credentials.
If you do not have a TriplyDB token yet, you can run \`npx tools create-token\` to have on created for you.`,
        );
      }
      const token = Etl.token;
      assertHasToken(get(process.env, "TRIPLYDB_TOKEN"));
      return TriplyDb.get({
        token,
        url: get(process.env, "TRIPLYDB_API"),
      });
    }
    return this._triplyDb;
  }

  public get skolemIri(): NamedNode {
    return this.standardPrefixes.skolem.concat(randomHash());
  }

  public static get environment(): Environment {
    const env = str(get(process.env, "ENV") ?? get(process.env, "NODE_ENV") ?? "Development").capitalize();
    if (env === "") return "Development";
    assertEnvironment(env);
    return env as Environment;
  }

  public getNewStore(): Store {
    const store = new Store(this);
    store["_app"] = this;
    return store;
  }
  /**
   * Set expected total progress of this Etl run. Can be any number (e.g. byte-size, array length).
   */
  public setTotalProgress(size: number) {
    this._totalToProcess = size;
  }

  /**
   * Add to the current progress of the Etl run. Can be any number (e.g.
   * bytes processed, number of processed array elements). This function is
   * typically used in the first Etl middleware
   */
  public incrementProgress(processed: number) {
    // see issue #313: if a user defines a custom Record creator, the progressbar will explode
    this._processedAbsolute = processed + (this._processedAbsolute ?? 0);
    if ((this._processedAbsolute ?? 0) + processed > (this._totalToProcess ?? 0)) {
      this.setTotalProgress((this._processedAbsolute ?? 0) + processed);
    }
    if (this._totalToProcess) {
      this.showProgress();
    }
    return this._processedAbsolute;
  }

  public showProgress() {
    let percentage: number;
    if (this._totalToProcess && this._processedAbsolute) {
      percentage = Math.round((this._processedAbsolute / this._totalToProcess) * 100);
    } else {
      percentage = 0;
    }
    if (percentage !== this._processedPercentage) {
      this._processedPercentage = percentage;
      this.emit("progress", this._processedPercentage);
    }
  }

  /**
   * Print and emit error message
   */
  public error(message: string | Pick<Message, "message" | "label">) {
    const statusObj = this.toMessageObject(message, "Error", "Etl");
    this.logMessage(statusObj);
    this.emit("message", statusObj);
  }

  /**
   * Print and emit violation message
   */
  public violation(message: string | Pick<Message, "message" | "label">, type: "Shacl" | "Etl" = "Shacl") {
    const statusObj = this.toMessageObject(message, "Violation", type);
    this.logMessage(statusObj);
    this.emit("message", statusObj);
  }

  /**
   * Print and emit warning message
   * @param type type of warning message (SHACL validation severity or ETL warning)
   */
  public warn(message: string | Pick<Message, "message" | "label">, type: "Shacl" | "Etl" = "Etl") {
    const statusObj = this.toMessageObject(message, "Warning", type);
    this.emit("message", statusObj);
    this.logMessage(statusObj);
  }

  /**
   * Print and emit info message
   * @param type type of warning message (SHACL validation severity or ETL warning)
   */
  public info(message: string | Pick<Message, "message" | "label">, type: "Shacl" | "Etl" = "Etl") {
    const statusObj = this.toMessageObject(message, "Info", type);
    this.logMessage(statusObj);
    this.emit("message", statusObj);
  }

  /**
   * Update Etl run statistics. These can be displayed at runtime, or only in the final report
   */
  public updateStats(
    label: string,
    value: number | string | undefined | ((v: number | string | undefined) => number | string | undefined),
    opts?: { display: "runtime" | "finalReport" },
  ) {
    const runtimeStat = opts?.display !== "finalReport";
    const stats = runtimeStat ? this._runtimeStats : this._reportStats;
    const newValue = typeof value === "function" ? value(stats[label]) : value;
    const changed = newValue !== stats[label];
    if (newValue === undefined) {
      delete stats[label];
    } else {
      stats[label] = newValue;
    }
    if (runtimeStat && changed) {
      //Only emitting the stats when we want runtime feedback.
      this.emit("stats", stats);
    }
  }
  public getStats(type: "runtime" | "finalReport") {
    if (type === "runtime") return this._runtimeStats;
    return this._reportStats;
  }

  public after(fn: AfterHookFn, options: { always: boolean } = { always: false }) {
    const callsite = getCurrentLine({ frames: 2 });
    if (options.always) {
      this._after.push({ fn, always: true, callsite });
    } else {
      this._after.push({ fn, callsite });
    }
  }
  public before(fn: BeforeHookFn) {
    this._before.push(fn);
  }

  public setDataDir(dataDir: string) {
    this._dataDir = dataDir;
  }
  public getDataDir(...subpaths: string[]) {
    return path.resolve(
      this._dataDir,
      ...subpaths.map((p) =>
        filenamify(p, {
          replacement: "-",
          maxLength: 255,
        }),
      ),
    );
  }
  public getCacheDir(...subpaths: string[]) {
    return this.getDataDir("cache", ...subpaths);
  }
  public getTmpDir(...subpaths: string[]) {
    return this.getDataDir("tmp", `run-id-${this._runId}`, ...subpaths);
  }

  public setTriplyDb(triplyDb: TriplyDb | TriplyDbConfig) {
    if (triplyDb instanceof TriplyDb) {
      this._triplyDb = triplyDb;
    } else {
      this._triplyDb = TriplyDb.get(triplyDb);
    }
    return this._triplyDb;
  }

  public get standardPrefixes() {
    if (this.baseIri === undefined) {
      throw new Error("To use the standard prefixes, a 'baseIri' must be set when you create an Etl instance.");
    }
    const base = this.baseUrl;
    const port = base.port === "80" || base.port === "443" || base.port === "" ? "" : `:${base.port}`;
    const skolem = new Iri(`${base.protocol}//${base.hostname}${port}/.well-known/genid/`);
    return {
      /**
       * The IRI prefix for blank node-replacing well-known IRIs.
       */
      skolem,
      /**
       * The IRI prefix for graph names.
       */
      graph: this.baseIri.concat("/graph/"),
      /**
       * The IRI prefix for SKOS concepts.
       */
      con: this.baseIri.concat("/model/con/"),
      /**
       * The IRI prefix for definitions, i.e. OWL classes and OWL properties.
       */
      def: this.baseIri.concat("/model/def/"),
      /**
       * The IRI prefix for instances.
       */
      id: this.baseIri.concat("/id/"),
      /**
       * The IRI prefix for SKOS concept schemes.
       */
      scheme: this.baseIri.concat("/model/scheme/"),
      /**
       * The IRI prefix for SHACL shapes.
       */
      shp: this.baseIri.concat("/model/shp/"),
    };
  }

  /**
   * Function for creating graph names that follow [the Triply IRI
   * Strategy](https://triplydb.com/how-to-model/-/stories/how-to-model-iris).
   *
   * Many datasets have a repeating core set of graph names, e.g. 'metadata',
   * 'report', 'model', and 'instances'.  This function makes such common graph
   * names available within the given prefix/namespace.
   */
  public get standardGraphs() {
    if (this.baseIri === undefined) {
      throw new Error("To use the standard graphnames, a 'baseIri' must be set when you create an Etl instance.");
    }
    return {
      /**
       * The name of the default graph.
       *
       * In TriplyDB the default graph is a named graph with this name.
       */
      default: this.baseIri.concat("/graph/default"),
      /**
       * The name of the graph that contains instance data.
       */
      instances: this.baseIri.concat("/graph/instances"),
      /**
       * The graph that contains the metadata that described this dataset.
       */
      metadata: this.baseIri.concat("/graph/metadata"),
      /**
       * The name of the graph that contains the meta-model.
       *
       * The meta-model is used to verify the correctness of the data model
       * and/or dataset metadata.
       */
      metamodel: this.baseIri.concat("/graph/metamodel"),
      /**
       * The name of the graph that contains the data model.
       */
      model: this.baseIri.concat("/graph/model"),
      /**
       * The name of the graph that contains the SHACL validation report.
       */
      report: this.baseIri.concat("/graph/report"),
    };
  }

  /**
   * Register one or more middlewares
   */
  public use<R = unknown>(...middlewaresArray: MiddlewareList<R>): Etl {
    if (this._startTime) throw new Error("Cannot register a new middleware when the Etl app already started");
    const middlewares: Middleware<R>[] = flattenDeep(middlewaresArray).filter((m) => !!m);
    for (const mw of middlewares) {
      if (mw.callSite) this.touchedMiddlewares.set(mw.callSite, false);
    }
    this.middlewares.push(...(middlewares as Middleware[]));
    return this;
  }
  /**
   * Conditionally register one er more middlewares
   */
  public useWhen<R = unknown>(when: string | UseWhenCb<R>, ...middlewaresArray: MiddlewareList<R>) {
    if (this._startTime) throw new Error("Cannot register a new middleware when the Etl app already started");
    const mw = whenMw(when, ...middlewaresArray);
    this.middlewares.push(...(mw as Middleware[]));
  }

  /**
   * Run the Etl app
   */
  public async run() {
    if (this._startTime) throw new Error("Cannot call `run()` on a Etl app that is already running");
    this.middlewares.push(...this.afterMiddlewaresFromConfig);
    this._startTime = new Date();
    const context = new Context(this);

    if (this._before.length) {
      this._setStatus("beforeHook");
      const beforeTime = process.hrtime.bigint();
      await Promise.all(this._before.map((p) => p()));
      this._beforeDuration = process.hrtime.bigint() - beforeTime;
    }

    try {
      this._setStatus("running");
      const dispatch = composeMiddlewares({
        middlewares: this.middlewares,
        context,
        onEnd: (context) => {
          if (this.limit && context.recordId - (this.offset - 1) === this.limit) {
            throw getErr().setStoppedAtHead();
          }
          // Track the exact number for the final report
          this.updateStats("#Statements", (val) => +(val || 0) + context.store.size, { display: "finalReport" });
          // Track a human readable (less exact) string for the runtime stats
          const currentNumQuads = +this.getStats("finalReport")["#Statements"];
          this.updateStats("#Statements", isNaN(currentNumQuads) ? 0 : currentNumQuads, { display: "runtime" });
          this.updateStats("#Records", context.recordId, { display: "finalReport" });
        },
        onNextRecord: (context) => {
          context.recordId++;
          if (context.recordId < this.offset) {
            return "skipRecord";
          }
          // If flag --timeout is set and (runtime < timeout) - otherwise exit gracefully
          if (this._startTime && this._timeout) {
            let timeoutRunCondition: boolean;
            timeoutRunCondition = Date.now() - this._startTime.valueOf() < this._timeout;
            if (!timeoutRunCondition) {
              this.error(
                `The runtime has exceeded the timeout of ${prettyMilliseconds(
                  this._timeout,
                )}!\nTimedout at recordID: ${context.recordId.valueOf()}\n`,
              );
              throw getErr().setTimedout();
            }
          }
          // If the last middleware isn't nice and doesn't call `next`, we can't
          // rely on the above stoppedAtHead-error to fire, as it only fires
          // after `next` is called by the last middleware. Therefore,
          // to make sure that we _always_ stop at least during the first
          // record we shouldn't be processing, this catch is here.
          if (this.limit && context.recordId - (this.offset - 1) > this.limit) {
            throw getErr().setStoppedAtHead();
          }
        },
      });
      if (this.debugTrace) {
        await dispatch(this.debugTraceToDispatchOpts());
      } else {
        await dispatch();
      }
    } catch (_e: any) {
      const e = getErr(_e);
      /**
       * The 'context.traceError' only exists if we run the ETL over at least one record.
       * Not all errors come from running the ETL. Those we need to just pass on.
       * We also want to not modify TraceErrors set from the traceMiddleware
       */
      if (this.createErrorTrace) {
        const traceErrorInfo = getTraceInfo(context, "error");
        if (!e.trace?.isTraceDebug && traceErrorInfo) e.setTraceInfo(traceErrorInfo);
      }

      /**
       * (1) We ran the etl with a `--head` argument. We want to exit gracefully, so not throwing things,
       * and (considering we have partial results) not calling the after hooks
       * (2) We ran the etl with a `--timeout` argument.
       */
      if (!e.stoppedAtHead && !e.timedout) {
        // Clean up writers before throwing errors
        await this.flushWriters();
        /**
         * We received an error. We still want to call the after-always hooks so we e.g.
         * still upload the validation report when the validation threw
         * That being said, we dont want to call the after hooks when we only have partial results, such as
         * - When we only execute a traced record (via `--trace <file>`)
         * - When we exit early due to creating a trace (via traceStart() and traceEnd())
         */
        const afterAlwaysHooks = [...this._destinationPostProcess, ...this._after.filter((x) => x.always === true)];
        if (afterAlwaysHooks.length && !e.trace?.isTraceDebug && !this.debugTrace) {
          this._setStatus("afterHook");
          for (const afterAlwaysHook of afterAlwaysHooks) {
            const start = process.hrtime.bigint();
            await afterAlwaysHook.fn(false);
            const name = "name" in afterAlwaysHook ? afterAlwaysHook.name : undefined;
            this._afterDurations.push({
              name: name || afterAlwaysHook.fn.name || "unnamed function",
              duration: process.hrtime.bigint() - start,
              callsite: "callsite" in afterAlwaysHook ? afterAlwaysHook.callsite : undefined,
            });
          }
        }
        await this.removeTmpDir();
        this._setStatus("error");
        if (!e.stoppedAtHead && !e.timedout) {
          // Manipulate error so we have more actionable information
          throw e.setRecordId(context.recordId).setRecord(context.record);
        }
      }
    }
    await this.flushWriters();

    const afterHooks = [...this._destinationPostProcess, ...this._after];
    if (afterHooks.length) {
      this._setStatus("afterHook");
      for (const afterHook of afterHooks) {
        const start = process.hrtime.bigint();
        await afterHook.fn(true);
        const name = "name" in afterHook ? afterHook.name : undefined;
        this._afterDurations.push({
          name: name || afterHook.fn.name || "unnamed function",
          duration: process.hrtime.bigint() - start,
          callsite: "callsite" in afterHook ? afterHook.callsite : undefined,
        });
      }
    }

    this._setStatus("done");
    const packageJsonPath = path.join(path.dirname(fileURLToPath(import.meta.url)), "..", "..", "package.json");
    this._reportStats["Version"] =
      "TriplyETL " + JSON.parse(readFileSync(packageJsonPath, "utf-8")).version + "; Node.js " + process.version;
    this._reportStats["Environment"] = Etl.environment;
    this._reportStats["Started at"] = format(this._startTime, "yyyy-LL-dd kk:mm:ss");
    this._reportStats["Ended at"] = format(Date.now(), "yyyy-LL-dd kk:mm:ss");
    this._reportStats["Runtime"] =
      formatDuration(intervalToDuration({ start: this._startTime, end: Date.now() })) || "0 sec";
    this.emit("finished", { ...this._runtimeStats, ...this._reportStats });
    await this.removeTmpDir();
    return { ...this._runtimeStats, ...this._reportStats };
  }

  public staticStore?: Store;
  public async staticAssertions(...mws: Middleware[]) {
    const ctx = new Context(this);
    for (const mw of mws) {
      await mw(ctx, () => Promise.resolve());
    }
    if (this.staticStore === undefined) this.staticStore = ctx.store;
    else this.staticStore.addQuads(ctx.store.getQuads({}));
    const currentNumQuads = +ctx.app.getStats("finalReport")["#Statements"];
    ctx.app.getStats("finalReport")["#Statements"] = (isNaN(currentNumQuads) ? 0 : currentNumQuads) + ctx.store.size;
    return this;
  }
  /**
   * Statics
   */

  public static CliContext: CliContext | undefined;
}

export default Etl;

export type UseWhenCb<R> = ((context: Context<R>) => boolean | Promise<boolean>) & {
  sourceFuncName?: string;
  callsite?: Location;
};

// This is the only middleware that's part of Etl core, considering Etl depends on this
// for the `useWhen` functionality

/**
 * Run one or more middlewares when some condition is met.
 *
 * @param when - The condition under which the middlewares are run.  This is
 * either a key or a function that takes the Etl Context and returns a
 * Boolean value.
 *
 * If the condition is a key, the middlewares are run if (i) the key exists
 * and (ii) has a value that is non-empty.  The value for a key is considered
 * empty if it is `undefined`, `null`, the empty string (`''`), the empty
 * array (`[]`), or the empty object (`{}`).
 *
 * If the condition is a function, its signature is `ctx => boolean`.
 *
 * @param middleware - An array with zero or more middlewares.
 *
 * @example
 * The following snippet always asserts the last name of a person, and
 * optionally asserts the first name if it is present:
 *
 * ```ts
 * fromJson([
 *   { id: '123', first: 'John', last: 'Doe' },
 *   { id: '456', last: 'Smith' },
 * ]),
 * addIri({
 *   prefix: prefix.person,
 *   content: 'id',
 *   key: '_person',
 * }),
 * triple('_person', foaf.lastName, 'last'),
 * when('first', [
 *   triple('_person', foaf.firstName, 'first'),
 * ]),
 * ```
 *
 * This results in the following linked data assertions:
 *
 * ```ttl
 * person:123
 *   foaf:firstName 'John';
 *   foaf:lastName 'Doe'.
 * person:456 lastName 'Smith'.
 * ```
 *
 * @example
 * The following snippet shows assertions that are only made if two keys are
 * present in the Etl Record:
 *
 * ```ts
 * fromJson([
 *   { id: '123', first: 'John', last: 'Doe' },
 *   { id: '456', last: 'Smith' },
 * ]),
 * when(ctx => ctx.hasString('first') && ctx.hasString('last'), [
 *   couples(iri(prefix.person, 'id'), [
 *     [foaf.firstName, 'first'],
 *     [foaf.lastName, 'last'],
 *   ]),
 * ]),
 * ```
 */
export function whenMw<R = unknown>(
  when: Key | UseWhenCb<R>,
  ...middlewaresArray: MiddlewareList<R>
): Array<Middleware<R>> {
  const middlewares: Middleware<R>[] = flattenDeep(middlewaresArray).filter((m) => !!m);

  const whenFn: UseWhenCb<R> = typeof when === "function" ? when : (ctx) => ctx.isNotEmpty(when);
  let registeredTouchedMiddlewares = false;
  // Setting whenMwDepth value for logging indentation
  for (let mw of middlewares) {
    if (!mw.whenMwDepth) mw.whenMwDepth = 0;
    mw.whenMwDepth++;
  }
  let sourceFuncName = "_when";
  if (whenFn.sourceFuncName) sourceFuncName = whenFn.sourceFuncName;
  return [
    addMwCallSiteToError(
      async function _whenMw(ctx, next) {
        if (!registeredTouchedMiddlewares) {
          for (const mw of middlewares) {
            if (mw.callSite) ctx.app["touchedMiddlewares"].set(mw.callSite, false);
          }
          registeredTouchedMiddlewares = true;
        }
        if (await whenFn(ctx)) return next();

        return next(ctx.record, ctx.store, middlewares.length);
      },
      { sourceFuncName, callSite: whenFn.callsite },
    ),
    ...middlewares,
  ];
}

const DEFAULT_PREFIXES = {
  rdf: new Iri("http://www.w3.org/1999/02/22-rdf-syntax-ns#"),
  rdfs: new Iri("http://www.w3.org/2000/01/rdf-schema#"),
};
export interface DispatchOpts {
  mwIndex?: number;
  record?: unknown;
  store?: Store;
}
export type DispatchFn = (dispatchOpts?: DispatchOpts) => Promise<bigint>;
export function composeMiddlewares(opts: {
  middlewares: Middleware[];
  context: Context;
  onNextRecord?: (context: Context) => "skipRecord" | void;
  onEnd?: (context: Context) => void;
  store?: Store;
  record?: Record;
}): DispatchFn {
  // dispatch a next middleware. Information needed to dispatch is the middleware index, and a record+store
  async function dispatch(dispatchOpts?: DispatchOpts): Promise<bigint> {
    const mwIndex = dispatchOpts?.mwIndex || 0;
    const app = opts.context.app;
    const mw = opts.middlewares[mwIndex];
    // There is no next middleware to run for this record. This happens when our last middleware calls `next()`
    if (!mw) {
      opts.onEnd?.(opts.context);
      return BigInt(0);
    }
    const beginDispatch = process.hrtime.bigint();

    app["setMwIndices"](mwIndex);
    const timerLabel = app["currentMwIndices"].join(",");
    app["startMwTimer"]({
      timerLabel: timerLabel,
      recordId: opts.context.recordId,
      callSite: mw.callSite,
      mwName: mw.sourceFuncName ? mw.sourceFuncName : mw.name,
      whenMwDepth: mw.whenMwDepth,
    });
    if (dispatchOpts?.record) {
      opts.context.record = dispatchOpts.record as Record;
    }
    if (dispatchOpts?.store) {
      opts.context.store = dispatchOpts.store;
    }
    /**
     * We want to set the traceErrorInfo when each new record is being processed,
     * not each time we call a middleware. Otherwise there is a massive performance hit.
     */
    if (app["createErrorTrace"]) {
      if (opts.context["traceError"] === undefined || opts.context["traceError"].recordId !== opts.context.recordId) {
        setTraceErrorInfo(opts.context);
      }
    }
    await mw(opts.context, async (record?: unknown, store?: Store, skip?: number) => {
      if (mwIndex === 0) {
        if (opts.onNextRecord?.(opts.context) === "skipRecord") {
          return; // stop processing this record
        }
      }
      const nextMiddlewareIndex = mwIndex + 1 + (skip ?? 0);
      const duration = await dispatch({ mwIndex: nextMiddlewareIndex, record, store });
      app["addToMwTimerTrailingDuration"](timerLabel, duration);
    }).finally(() => {
      app["endMwTimer"](timerLabel);
    });
    return process.hrtime.bigint() - beginDispatch;
  }
  return dispatch;
}
