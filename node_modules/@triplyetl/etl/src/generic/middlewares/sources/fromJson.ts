import { castArray, has, get, isPlainObject } from "lodash-es";
import fs from "fs-extra";

const { readFile } = fs;

import { Record } from "../../Record.js";
import { SourceGetter, SourceInfo } from "../../locations/sources/index.js";
import { addMwCallSiteToError, assertOneExtractorPerETL } from "../../../utils/index.js";
import trimRecordFromSource from "./util/trimRecordFromSource.js";
import { validatePaths } from "./fromXml.js";
import { OaiRecord } from "./fromOai.js";
import { isSourceGetterArray } from "../../../utils/asserts.js";
import { Context, Etl, Middleware } from "../../index.js";

export interface Options {
  /**
   *  Transform json read from a source before using it for records
   */
  toRecords?: (json: unknown) => Array<Record>;
  // Trim both keys and values (default: true)
  skipTrim?: boolean;
  skipEnrich?: boolean;
  /**
   * Choose what keys we want to get the records for.
   * Each match will produce a new record.
   * Nested keys should use dot notation:
   *
   * eg: { selectors: "header.subHeader.anotherSubheader" }
   * returns { header: { subHeader: { anotherSubheader: { key: value }}}}
   */
  selectors?: string | string[];
}

// TODO @DocumentationTeam: add TS doc comment here
export default function fromJson(
  oneOrMoreInputs:
    | Array<any>
    | Array<SourceGetter<"records", SourceInfo<Record>>>
    | {}
    | SourceGetter<"records", SourceInfo<Record>>,
  opts?: Options,
): Middleware {
  const inputs = castArray(oneOrMoreInputs);
  if (inputs.length === 0) return async function () {};

  return addMwCallSiteToError(
    async function _fromJson(ctx, next) {
      assertOneExtractorPerETL(ctx.app, "fromJson");
      for await (const record of getRecords(ctx, inputs, opts)) {
        await next(opts?.skipTrim ? record : trimRecordFromSource(record), ctx.app.getNewStore());
      }
    },
    { sourceFuncName: "_fromJson" },
  );
}
async function* getRecords(
  ctx: Context,
  inputs: Array<any> | Array<SourceGetter<"records", SourceInfo<Record>>>,
  opts?: Options,
) {
  ctx.app.setTotalProgress(inputs.length);
  const selectors = opts?.selectors ? castArray(opts.selectors) : [];
  validatePaths(selectors);
  if (isSourceGetterArray(inputs)) {
    const sources = await ctx["_registerSources"](inputs, "records");
    let records: AsyncIterable<Record> | Array<Record>;
    for (const source of sources) {
      ctx.source = source;
      if ("getAsyncIterable" in source) {
        records = await source.getAsyncIterable();
      } else if ("getBoolean" in source) {
        records = [{ boolean: await source.getBoolean() } as any as Record];
      } else {
        const jsonString =
          "getString" in source ? await source.getString() : await readFile(await source.getLocalPath(), "utf8");
        try {
          records = JSON.parse(jsonString);
        } catch (e) {
          if (e instanceof Error) {
            e.message = `Failed to parse JSON ${source.name}: ${e.message}`;
          }
          throw e;
        }
        if (opts?.toRecords) {
          // an array is an async iterable, even though typescript disagrees
          records = opts.toRecords(records);
        } else {
          records = castArray(records as Array<Record>);
        }
      }
      for await (let record of records) {
        // casting because of ASK results:
        record = record as Record;
        // one element of `inputs` per source
        ctx.app.incrementProgress(1);
        const possiblyEnrichRecord = configureEnrichment({
          ctx,
          fileName: source.name,
          skipEnrich: opts?.skipEnrich,
        });
        if (selectors.length) {
          for (const recordFound of processRecordBySelectors({ record, selectors })) {
            possiblyEnrichRecord(recordFound);
            yield recordFound;
          }
        } else {
          /**
           * Return all record values
           */
          possiblyEnrichRecord(record);
          yield record;
        }
      }
    }
  } else {
    for await (let record of inputs) {
      const possiblyEnrichRecord = configureEnrichment({
        ctx,
        skipEnrich: opts?.skipEnrich,
      });
      if (selectors.length) {
        for (const recordFound of processRecordBySelectors({ selectors, record })) {
          possiblyEnrichRecord(recordFound);
          yield recordFound;
        }
      } else {
        possiblyEnrichRecord(record);
        yield record;
      }
      // one element of `inputs` per record
      ctx.app.incrementProgress(1);
    }
  }
}

function configureEnrichment({
  ctx,
  fileName,
  skipEnrich,
}: {
  ctx: Context;
  fileName?: string;
  skipEnrich: boolean | undefined;
}) {
  return function possiblyEnrichRecord(record: Record) {
    if (skipEnrich) return;
    record.$recordId = ctx.recordId + 1;
    record.$environment = Etl.environment;
    if (fileName) record.$fileName = fileName;
  };
}

export function matchFromRecord(record: Record | OaiRecord, selector: string) {
  if (has(record, selector)) {
    // Casting here as we want any match to be a new 'Record'
    const value = get(record, selector) as Record;
    // Check to make sure its not an array or primative
    if (isPlainObject(value)) {
      value.$tagName = selector.split(".").pop();
      value.$selector = selector;
      return value;
    }
    throw new Error(
      `Only plain objects can be returned as records. Selector '${selector}' returned type: '${typeof value}'`,
    );
  }
}

function processRecordBySelectors({ record, selectors }: { record: Record; selectors: string[] }) {
  const matchesFound: Record[] = [];
  for (const selector of selectors) {
    const matchFound = matchFromRecord(record, selector);
    if (!matchFound) continue;
    matchesFound.push(matchFound);
  }
  return matchesFound;
}
