import { Etl, Middleware } from "../../index.js";
import postgres from "postgres";
import { castArray } from "lodash-es";
import { addMwCallSiteToError, assertOneExtractorPerETL } from "../../../utils/index.js";
import trimRecordFromSource from "./util/trimRecordFromSource.js";

type Options<T extends { [key: string]: postgres.PostgresType }> = postgres.Options<T> & {
  url: string;
  showParsedOptions: boolean;
  skipTrim?: boolean;
  skipEnrich?: boolean;
};

/**
 * A record for every row returned by a postgres query.
 *
 * Ways to configure the database connection:
 * - `url`: a `postgres://` url connection string
 * - environment variables
 * - lowercase key-value pairs,
 *   e.g. `{port: 5432, username: postgres}`
 *
 * Values described in later items of the above list take precedence.
 *
 * Supported environment variables:
 * - `POSTGRES_HOST`
 * - `POSTGRES_PORT`
 * - `POSTGRES_DATABASE`
 * - `POSTGRES_USERNAME`
 * - `POSTGRES_PASSWORD`
 */
export default function fromPostgres<T extends { [key: string]: postgres.PostgresType }>(
  query: string | string[],
  opts: Partial<Options<T>> = {},
): Middleware {
  return addMwCallSiteToError(
    async function _fromPostgres(ctx, next) {
      assertOneExtractorPerETL(ctx.app, "fromPostgres");
      const options = { ...opts }; // make sure we don't overwrite the input
      const keys = ["host", "database", "username", "password"] as ["host", "database", "username", "password"];
      for (const key of keys) {
        if (options[key] === undefined) options[key] = process.env["POSTGRES_" + key.toUpperCase()] || undefined;
      }
      if (options.port === undefined && process.env.POSTGRES_PORT !== undefined)
        options.port = Number.parseInt(process.env.POSTGRES_PORT);

      const sql = options.url === undefined ? postgres(options) : postgres(options.url, options);

      if (options.showParsedOptions) console.info(sql.options);

      try {
        // progress isn't set because we don't know the total without loading all
        // results into memory.
        for (const queryString of castArray(query)) {
          // Use batch size of 100
          for await (const rows of sql.unsafe(queryString).cursor(100)) {
            for (const row of rows) {
              const enrich = opts?.skipEnrich
                ? {}
                : {
                    $recordId: ctx.recordId + 1,
                    $environment: Etl.environment,
                  };
              await next({ ...enrich, ...(opts.skipTrim ? row : trimRecordFromSource(row)) }, ctx.app.getNewStore());
            }
          }
        }
      } finally {
        await sql.end();
      }
    },
    { sourceFuncName: "_fromPostgres" },
  );
}
