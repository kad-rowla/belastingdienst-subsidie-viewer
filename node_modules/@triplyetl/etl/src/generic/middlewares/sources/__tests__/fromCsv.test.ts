//external dependencies
import chai, { assert } from "chai";

import chaiAsPromised from "chai-as-promised";
import fs from "fs-extra";

const { readFile, readFileSync } = fs;

import { parse } from "csv-parse/sync";

chai.use(chaiAsPromised);
const expect = chai.expect;

import { DuplicateColumnsError } from "../fromCsv.js";
import trimRecordFromSource from "../util/trimRecordFromSource.js";
import { Etl, Middleware, Source, fromCsv } from "../../../index.js";
import { str } from "../../../../ratt/index.js";

export function getCountingMw(): [{ count: number }, Middleware] {
  const count = { count: 0 };
  return [
    count,
    async function (_ctx, next) {
      count.count++;
      return next();
    },
  ];
}
describe("Read csv documents", function () {
  it("Read a single csv document", async function () {
    const app = new Etl({ defaultGraph: "https://default.com/" });
    app.use(fromCsv(Source.file("./src/__tests__/resources/csvFiles/addresses.csv")));
    const [count, mw] = getCountingMw();
    app.use(mw);
    await app.run();
    expect(count.count).to.equal(6);
  });
  it("Read multiple csv documents", async function () {
    const app = new Etl({ defaultGraph: "https://default.com/" });
    app.use(
      fromCsv([
        Source.file("./src/__tests__/resources/csvFiles/addresses.csv"),
        Source.file("./src/__tests__/resources/csvFiles/cities.csv"),
      ]),
    );
    const [count, mw] = getCountingMw();
    app.use(mw);
    await app.run();
    expect(count.count).to.equal(6 + 3041);
  });
  it("Report problematic document", async function () {
    const app = new Etl({ defaultGraph: "https://default.com/" });
    app.use(fromCsv(Source.file("./package.json")));
    return expect(app.run()).to.eventually.be.rejectedWith(/package\.json/);
  });

  /**
   * @see https://issues.triply.cc/issues/5631
   */
  it("should trim keys and values by default, but not when requested", async () => {
    const filePath = "./src/__tests__/resources/csvFiles/issue-redmine-5631.csv";
    // load and parse CSV file as a reference for our test:
    const content = await readFile(filePath, "utf-8");
    const record = parse(content, { columns: true, groupColumnsByName: true, trim: false })[0];
    const appWithTrim = new Etl();
    appWithTrim.use(
      fromCsv(Source.file(filePath), {
        groupColumnsByName: true,
        skipEnrich: true,
      }),
      async (ctx, next) => {
        assert.deepEqual(ctx.record, trimRecordFromSource({ ...record }));
        return next();
      },
    );
    await appWithTrim.run();

    const appWithoutTrim = new Etl();
    appWithoutTrim.use(
      fromCsv(Source.file(filePath), {
        groupColumnsByName: true,
        skipTrim: true,
        skipEnrich: true,
      }),
      async (ctx, next) => {
        assert.deepEqual(ctx.record, record);
        return next();
      },
    );
    await appWithoutTrim.run();
  });
  it("Should report used key when cell is empty", async () => {
    const app = new Etl();
    app.use(fromCsv(Source.file("src/__tests__/resources/csvFiles/with-empty-cell.csv")), async (ctx, next) => {
      ctx.getString("B");
      return next();
    });
    await expect(app.run()).to.be.rejectedWith(/Key 'B' has an empty value of type 'string'/);
  });
  describe("Should throw on duplicate when 'groupColumnsByName' option not set", async () => {
    it("using a file", async () => {
      const app = new Etl();
      app.use(fromCsv(Source.file("./src/__tests__/resources/csvFiles/duplicate-header-example.csv")));
      await expect(app.run()).to.eventually.be.rejectedWith(
        new DuplicateColumnsError("./src/__tests__/resources/csvFiles/duplicate-header-example.csv").message,
      );
    });
    it("using a static string", async () => {
      const app = new Etl();
      const data = readFileSync("./src/__tests__/resources/csvFiles/duplicate-header-example.csv", "utf-8");
      app.use(fromCsv(str(data)));
      await expect(app.run()).to.eventually.be.rejectedWith(new DuplicateColumnsError("A,B,A\r\n1,2,3").message);
    });
  });
  describe("Should allow duplicate column names with 'groupColumnsByName' set", async () => {
    it("using a file", async () => {
      const app = new Etl();
      app.use(
        fromCsv(Source.file("./src/__tests__/resources/csvFiles/duplicate-header-example.csv"), {
          groupColumnsByName: true,
        }),
        async (ctx, next) => {
          assert.doesNotThrow(() => ctx.getArray("A", "string"));
          assert.doesNotThrow(() => ctx.getString("B"));
          assert.deepEqual(ctx.getArray("A", "string"), ["1", "3"]);
          assert.deepEqual(ctx.getString("B"), "2");
          return next();
        },
      );
      await app.run();
    });
    it("using a static string", async () => {
      const app = new Etl();
      const data = readFileSync("./src/__tests__/resources/csvFiles/duplicate-header-example.csv", "utf-8");
      app.use(fromCsv(str(data), { groupColumnsByName: true }), async (ctx, next) => {
        assert.doesNotThrow(() => ctx.getArray("A", "string"));
        assert.doesNotThrow(() => ctx.getString("B"));
        assert.deepEqual(ctx.getArray("A", "string"), ["1", "3"]);
        assert.deepEqual(ctx.getString("B"), "2");
        return next();
      });
      await app.run();
    });
  });
  /**
   * This test was not able to be resolved in a reasonable time but is still an issue
   * This should be resolved in the future, see link below
   * https://git.triply.cc/triply/etl/-/merge_requests/81#note_46572
   */
  it.skip("Should read duplicate column names containing additional spaces with 'groupColumnsByName' set", async () => {
    const app = new Etl({ defaultGraph: "https://default.com/" });
    app.use(
      fromCsv(Source.file("./src/__tests__/resources/csvFiles/duplicate-header-with-space.csv"), {
        groupColumnsByName: true,
      }),
      async (ctx, next) => {
        assert.deepEqual(ctx.record["A"], ["1", "3"]);
        assert.deepEqual(ctx.record["B"], "2");
        return next();
      },
    );
    await expect(app.run()).to.eventually.be.fulfilled;
  });

  it("should read SELECT results from https://triplydb.com/academy/-/queries/3-1", async () => {
    const select = Source.TriplyDb.query("academy", "3-1", { triplyDb: { url: "https://api.triplydb.com" } });
    const app = new Etl();
    let c = 0;
    app.use(fromCsv(select, { skipEnrich: true, skipTrim: true }));
    app.use((_, next) => {
      c++;
      return next();
    });
    await app.run();
    assert.equal(c, 2958, "Expected 2.958 pokemons from query (make sure the query actually returns this number!)");
  });

  it("should read ASK results from https://triplydb.com/academy/-/queries/ask-1", async () => {
    const select = Source.TriplyDb.query("academy", "ask-1", { triplyDb: { url: "https://api.triplydb.com" } });
    const app = new Etl();
    let c = 0;
    app.use(fromCsv(select, { skipEnrich: true, skipTrim: true }));
    app.use((ctx, next) => {
      c++;
      assert.deepEqual(ctx.record as any, { boolean: true });
      return next();
    });
    await app.run();
    assert.equal(c, 1, "Expected 1 result from query (make sure the query actually returns this number!)");
  });
});
