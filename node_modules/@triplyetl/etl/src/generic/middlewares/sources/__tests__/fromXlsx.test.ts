import fromXlsx from "../fromXlsx.js";
import Etl from "../../../Etl.js";

import chai, { assert } from "chai";
import chaiAsPromised from "chai-as-promised";
import { DuplicateColumnsError } from "../fromCsv.js";
import Source from "../../../locations/sources/index.js";
import logRecord from "../../../../debug/logRecord.js";
chai.use(chaiAsPromised);
const expect = chai.expect;

describe("fromXlsx", function () {
  /**
   * This test fails because fromXlsx just happily parses any file I try to feed
   * it
   */
  it.skip("Report problematic document", async function () {
    const app = new Etl({ defaultGraph: "https://default.com/" });
    app.use(fromXlsx(Source.file("./src/__tests__/resources/shapeFiles/places.shp")));
    app.use(logRecord());
    return expect(app.run()).to.eventually.be.rejectedWith(/places\.shp/);
  });

  it("Should work with example xlsx file", async () => {
    const app = new Etl();
    let i = 0;
    let recordId = 0;
    app.use(
      fromXlsx(Source.file("./src/__tests__/resources/xlsxFiles/addresses_and_cities.xlsx")),
      async (ctx, next) => {
        i++;
        recordId = ctx.record.$recordId;
        return next();
      },
    );
    await app.run();
    expect(recordId).equal(i);
    expect(recordId).equal(15);
  });
  it("Should throw on duplicate when 'groupColumnsByName' option not set", async () => {
    const app = new Etl({ defaultGraph: "https://default.com/" });
    app.use(fromXlsx(Source.file("./src/__tests__/resources/xlsxFiles/duplicate-header-example.xlsx")));
    await expect(app.run()).to.eventually.be.rejectedWith(
      new DuplicateColumnsError("./src/__tests__/resources/xlsxFiles/duplicate-header-example.xlsx").message,
    );
  });
  it("Should allow duplicate column names with 'groupColumnsByName' set", async () => {
    const app = new Etl({ defaultGraph: "https://default.com/" });
    app.use(
      fromXlsx(Source.file("./src/__tests__/resources/xlsxFiles/duplicate-header-example.xlsx"), {
        groupColumnsByName: true,
      }),
      async (ctx, next) => {
        assert.doesNotThrow(() => ctx.getArray("A", "string"));
        assert.doesNotThrow(() => ctx.getString("B"));
        assert.deepEqual(ctx.getArray("A", "string"), ["1", "3"]);
        assert.deepEqual(ctx.getString("B"), "2");
        return next();
      },
    );
    await app.run();
  });
  it("Should throw on undefined/empty column header names when 'groupColumnsByName' is set", async () => {
    const app = new Etl({ defaultGraph: "https://default.com/" });
    app.use(
      fromXlsx(Source.file("./src/__tests__/resources/xlsxFiles/undefined-header-test.xlsx"), {
        groupColumnsByName: true,
      }),
    );
    await expect(app.run()).to.eventually.be.rejectedWith(
      "Undefined header found in file, please name all headers in source file.",
    );
  });
  it("Should be able to read duplicate header and empty row values in source file", async () => {
    const app = new Etl({ defaultGraph: "https://default.com/" });
    app.use(
      fromXlsx(Source.file("./src/__tests__/resources/xlsxFiles/empty-values.xlsx"), {
        groupColumnsByName: true,
      }),
      async (ctx, next) => {
        assert.doesNotThrow(() => ctx.getArray("A", "string"));
        assert.doesNotThrow(() => ctx.getString("B"));
        assert.deepEqual(ctx.getArray("A", "string"), ["1", "11", "3", "33", "333"]);
        assert.deepEqual(ctx.getString("B"), "2");
        return next();
      },
    );
    await app.run();
  });

  it("Should trim leading and/or trailing spaces in both headers and values", async () => {
    const app = new Etl();
    app.use(fromXlsx(Source.file("./src/__tests__/resources/xlsxFiles/untrimmed_data.xlsx")), async (ctx, _) => {
      for (const key of Object.keys(ctx.record).filter((key) => !key.startsWith("$"))) {
        assert.isTrue(key === key.trim());
        assert.isTrue(ctx.getString(key) === ctx.getString(key).trim());
      }
    });
    await app.run();
  });
  it("Should NOT trim leading and/or trailing spaces in both headers and values", async () => {
    const app = new Etl();
    const expected = {
      " header leading space": " value leading space",
      "header trailing space ": "value trailing space ",
      " header leading and trailing space ": " value leading and trailing space ",
    };
    app.use(
      fromXlsx(Source.file("./src/__tests__/resources/xlsxFiles/untrimmed_data.xlsx"), { skipTrim: true }),
      async (ctx, _) => {
        const actual: { [key: string]: string } = {};
        for (const key of Object.keys(ctx.record).filter((key) => !key.startsWith("$"))) {
          actual[key] = ctx.getString(key);
        }
        assert.deepEqual(actual, expected);
      },
    );
    await app.run();
  });
});
describe("XLSX files with dates", function () {
  it("Should parse time objects from source file", async function () {
    const etl = new Etl();
    etl.use(fromXlsx(Source.file("src/__tests__/resources/xlsxFiles/dateTimeTest.xlsx")), async (ctx, next) => {
      const dataType = ctx.record["Type"];
      if (dataType == "Date") {
        assert.deepEqual(ctx.record["Value"], "2048-10-06");
      }
      if (dataType == "Time") {
        assert.deepEqual(ctx.record["Value"], "15:00");
      }
      if (dataType == "DateTime") {
        // BUG in XLSX: parser seems unable to do date operations -> B2 + B3 (date addition) - yields the wrong date
        assert.deepEqual(ctx.record["Value"], "1970-01-01 01:00:00");
      }
      if (dataType == "Date2") {
        // BUG in XLSX: parser seems unable to do date functions -> =DATE(y,m,d) - yields the wrong date
        assert.deepEqual(ctx.record["Value"], "1/1/70");
      }
      if (dataType == "DateString") {
        assert.deepEqual(ctx.record["Value"], "31-12-2023");
      }
      if (dataType == "DateString2") {
        assert.deepEqual(ctx.record["Value"], "31.12.2023");
      }
      if (dataType == "Date3") {
        assert.deepEqual(ctx.record["Value"], "31.12.2023");
      }
      return next();
    });
    await expect(etl.run()).to.eventually.be.fulfilled;
  });
});

// skipping test since empty cells won't generate keys (#228 https://git.triply.cc/triply/etl/-/issues/228)
it.skip("Should report used key when cell is empty", async () => {
  const app = new Etl();
  app.use(fromXlsx(Source.file("src/__tests__/resources/xlsxFiles/with-empty-cell.xlsx")), async (ctx, next) => {
    ctx.getString("B");
    return next();
  });
  await expect(app.run()).to.be.rejectedWith(/Key 'B' has an empty value of type 'string'/);
});
