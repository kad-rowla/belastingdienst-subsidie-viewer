import chai from "chai";
import chaiAsPromised from "chai-as-promised";
import { has } from "lodash-es";
import { Etl, fromCsv, fromJson, loadRecords, Source } from "../../../index.js";
import { concat } from "../../../../ratt/index.js";

chai.use(chaiAsPromised);
const expect = chai.expect;
const assert = chai.assert;

const familyDoe = [
  { id: 1, firstName: "John", familyName: "Doe", $recordId: 1 },
  { id: 2, firstName: "Jane", familyName: "Doe", $recordId: 2 },
];

// !! It needs to be an array!
const table = [
  {
    be: "http://ex.com/Belgium",
    nl: "http://ex.com/Netherlands",
    de: "http://ex.com/Germany",
    en: "http://ex.com/England",
  },
];

describe("Reading.loadFromSource ", () => {
  it("Should accept a source file using Ratt 'config.sources'", async () => {
    const etl = new Etl({
      sources: {
        example: Source.file("src/__tests__/resources/jsonFiles/family-doe.json"),
      },
    });
    etl.use(loadRecords(fromJson(etl.sources.example, { skipEnrich: true }), "data"), async (ctx, next) => {
      assert.deepEqual(familyDoe, ctx.getUnknown("data"));
      return next();
    });
    await etl.run();
  });

  it("Should NOT accept a source file that does not contain JSON encoded strings", async () => {
    const etl = new Etl({
      sources: {
        example: Source.file("src/__tests__/resources/csvFiles/tableMap.csv"),
      },
    });
    etl.use(loadRecords(fromJson(etl.sources.example, { skipEnrich: true }), "data"));
    await expect(etl.run()).to.eventually.rejectedWith(/Failed to parse JSON /);
  });

  describe("Should accept a Ratt.Source.file", async () => {
    it("using JSON", () => {
      const etl = new Etl();
      const content = Source.file("src/__tests__/resources/jsonFiles/family-doe.json");
      etl.use(loadRecords(fromJson(content, { skipEnrich: true }), "data"), async (ctx, next) => {
        assert.deepEqual(familyDoe, ctx.getUnknown("data"));
        return next();
      });
      return etl.run();
    });
    it("using CSV", () => {
      const etl = new Etl();
      const content = Source.file("src/__tests__/resources/csvFiles/episodes.csv");
      etl.use(loadRecords(fromCsv(content, { skipEnrich: true }), "data"), async (ctx, next) => {
        // sum all id's
        const sum = ctx.getArray("data", "any").reduce((a, c) => a + parseInt(c["number"]), 0);
        assert.equal(sum, 10);
        return next();
      });
      return etl.run();
    });
  });

  it("Should accept a Ratt.Source.file and change its content", async () => {
    const etl = new Etl();
    const content = Source.file("src/__tests__/resources/jsonFiles/family-doe.json");
    etl.use(
      loadRecords(
        [
          fromJson(content, { skipEnrich: true }),
          concat({ content: ["firstName", "familyName"], separator: " ", key: "name" }),
        ],
        "data"
      ),
      async (ctx, next) => {
        ctx.getArray("data", "any").forEach((record) => {
          assert.isTrue(has(record, "name"));
          assert.equal(record.name, `${record.firstName} ${record.familyName}`);
        });
        return next();
      }
    );
    return etl.run();
  });

  it("Should accept a Ratt.Source.url", async function () {
    this.timeout(5000);
    const etl = new Etl();
    const content = Source.url(
      "https://gist.githubusercontent.com/mightymax/b5496516a61f8324c3eafa53d29bd162/raw/d1487f0bd1a05424b5cf0988718f03d0fb0c4302/tableMap.json"
    );
    etl.use(
      fromJson([{ a: 1 }, { a: 1 }, { a: 1 }, { a: 1 }]),
      loadRecords(fromJson(content, { skipEnrich: true }), "table"),
      async (ctx, next) => {
        assert.deepEqual(table, ctx.getUnknown("table"));
        return next();
      }
    );
    return etl.run();
  });

  it("Should accept a Ratt.Source.TriplyDb.asset", async function () {
    this.timeout(5000);
    const etl = new Etl();
    const content = Source.TriplyDb.asset("Triply", "ratt-test-assets", {
      name: "tableMap.json",
      triplyDb: { url: "https://api.nightly.triplydb.com" },
    });
    etl.use(loadRecords(fromJson(content, { skipEnrich: true }), "table"), async (ctx, next) => {
      assert.deepEqual(table, ctx.getUnknown("table"));
      return next();
    });
    return etl.run();
  });
});
