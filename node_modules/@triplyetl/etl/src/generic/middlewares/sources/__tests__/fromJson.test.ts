//external dependencies
import Etl from "../../../Etl.js";
import chai, { expect, assert } from "chai";
import fromJson, { Options } from "../fromJson.js";
import path from "path";
import { exec } from "child_process";
import { randomUUID } from "crypto";
import chaiAsPromised from "chai-as-promised";
import trimRecordFromSource from "../util/trimRecordFromSource.js";
import { unset } from "lodash-es";
import Source from "../../../locations/sources/index.js";
import { getFactory } from "@triplydb/data-factory";
chai.use(chaiAsPromised);
async function recordsFromJson(files: string | string[] | { [key: string]: unknown }, opts?: Options) {
  const app = new Etl({ defaultGraph: "https://default.com/" });
  if (typeof files === "string" || Array.isArray(files)) {
    // For testing it is important that both the array version and the
    // single SourceGetter version are tested.
    const sources = typeof files === "string" ? Source.file(files) : files.map(Source.file);
    app.use(fromJson(sources, opts));
  } else {
    app.use(fromJson(files, opts));
  }
  const records: any[] = [];
  app.use(async (ctx) => {
    unset(ctx.record, "$fileName");
    unset(ctx.record, "$recordId");
    unset(ctx.record, "$environment");
    // leaving tagName and selector on purpose
    records.push(ctx.record);
  });
  await app.run();
  return records;
}

const src: any = {
  wsEnd: "Bar ",
  wsStart: " Bar",
  wsBoth: " Bar ",
  wsNone: "Bar",
  wsEmbed: "Ba r",
};

const origSrc = { ...src };

describe("fromJson", function () {
  afterEach(function () {
    Etl.CliContext = undefined; // reset if we've made changes
  });
  it("should read a single json file", async function () {
    expect(await recordsFromJson("./src/__tests__/resources/jsonFiles/abc.json")).to.deep.equal([{ a: 1, b: 2, c: 3 }]);
  });
  it("should read multiple json files", async function () {
    expect(
      await recordsFromJson([
        "./src/__tests__/resources/jsonFiles/abc.json",
        "./src/__tests__/resources/jsonFiles/abc.json",
      ]),
    ).to.deep.equal([
      { a: 1, b: 2, c: 3 },
      { a: 1, b: 2, c: 3 },
    ]);
  });
  it("should preprocess json object when needed", async function () {
    expect(
      await recordsFromJson(["./src/__tests__/resources/jsonFiles/objectWithArrayInside.json"], {
        toRecords: (json: any) => json.someArray,
      }),
    ).to.deep.equal([{ a: "a" }, { b: "b" }]);
  });
  it("should report problematic document", async function () {
    return expect(recordsFromJson(".envrc")).to.eventually.be.rejectedWith(/\.envrc/);
  });
  it("should read results from select query (> 10k)", async function () {
    this.timeout(15000);
    const dataDir = path.resolve("data", "tmp", "unit-tests", randomUUID());
    after(async () => exec(`rm -r ${dataDir}`));
    Etl.CliContext = { dataDir }; // "disable" the cache
    const app = new Etl({
      defaultGraph: "https://default.com/",
      sources: {
        query: Source.TriplyDb.query("triply", "ratt-select-query-test", {
          variables: { fake: "whatever" },
          triplyDb: { url: "https://api.nightly.triplydb.com" },
        }),
      },
    });
    app.use(fromJson(app.sources.query));
    let count = 0;
    app.use(async () => {
      count++;
    });
    await app.run();
    expect(count).to.equal(50_000);
  });

  /**
   * @see https://issues.triply.cc/issues/5631
   *
   * Skipping this test until issue 119 is resolved
   * https://git.triply.cc/triply/etl/-/issues/119
   *
   */
  it("should trim keys and values by default, but not when requested", async () => {
    const data: { [key: string]: any } = {
      " header-quoted-before": " value-quoted-before",
      "header-quoted-after ": "value-quoted-after ",
      " header-quoted-before-and-after ": " value-quoted-before-and-after ",
      "header quoted inside": "value quoted inside",
      " ": "",
      " header-int ": 1,
      " header-bool ": true,
    };

    data.level1 = { ...data };
    data.level1.level2 = { ...data.level1 };

    const appWithTrim = new Etl();
    appWithTrim.use(fromJson(data, { skipEnrich: true }), async (ctx, next) => {
      assert.deepEqual(ctx.record, trimRecordFromSource({ ...data }));
      return next();
    });
    await appWithTrim.run();

    const appWithoutTrim = new Etl();
    appWithoutTrim.use(fromJson(data, { skipTrim: true, skipEnrich: true }), async (ctx, next) => {
      assert.deepEqual(ctx.record, data);
      return next();
    });
    await appWithoutTrim.run();
  });

  it("should trim both", async () => {
    const etl = new Etl();
    etl.use(fromJson(src, { skipEnrich: true })),
      etl.use(async (ctx, next) => {
        for (const key in ctx.record) {
          chai.assert.equal(ctx.getString(key), origSrc[key].trim());
        }
        return next();
      });
    return etl.run();
  });

  it.skip("Should not remove 'id' or 'equal' properties from Triply Iri", function () {
    // Note by ML: I really do not believe this is a valid use case: fromJSON deals with serialized JS Objects.
    /**
     * This test is about an error caused by the trimRecord in fromJson that removed datafactory properties
     * https://git.triply.cc/triply/etl/-/issues/119
     */
    const legitIri = getFactory().namedNode("https://ex.com/shouldHave/Id/validationStatus");
    const etl = new Etl();
    etl.use(fromJson({ s: legitIri })),
      etl.use(
        // this custom mw proves problem is not with the store
        (ctx, next) => {
          ctx.store.addQuad(legitIri, legitIri, legitIri);
          const quads = ctx.store.getQuads({});
          const idFromTriplyStore = quads[0].subject.id;
          expect(idFromTriplyStore).to.equal(legitIri.id);
          expect(ctx.store.size).to.equal(1);
          return next();
        },
      );
    etl.use(
      // this custom mw proves fromJson is at fault
      (ctx, next) => {
        expect(ctx.store.size).to.equal(1);
        const quad = ctx.store.getQuads({})[0];
        ctx.store.delete(quad);
        expect(ctx.store.size).to.equal(0);
        const fromJsonIri = ctx.getIri("s");
        console;
        ctx.store.addQuad(fromJsonIri, legitIri, legitIri);
        expect(ctx.store.size).to.equal(1);
        const quads = ctx.store.getQuads({});
        const idFromTriplyStore = quads[0].subject.id;
        expect(idFromTriplyStore).to.equal(legitIri.id);
        return next();
      },
    );
    return etl.run();
  });
  describe("Using Selectors with 'file' inputs", () => {
    it("should get records from a 'string' selector", async function () {
      const selectors = "a";
      expect(
        await recordsFromJson("./src/__tests__/resources/jsonFiles/abcdeNested.json", { selectors }),
      ).to.deep.equal([{ b: 2, $tagName: "a", $selector: "a" }]);
    });
    it("should get records from an 'array' of selectors", async function () {
      const selectors = ["b", "c.b"];
      expect(
        await recordsFromJson("./src/__tests__/resources/jsonFiles/abcdeNested.json", { selectors }),
      ).to.deep.equal([
        { c: 3, $tagName: "b", $selector: "b" },
        { a: 1, $tagName: "b", $selector: "c.b" },
      ]);
    });
    it("should get records from a mix of selectors", async function () {
      const selectors = "c.b";
      expect(
        await recordsFromJson("./src/__tests__/resources/jsonFiles/abcdeNested.json", { selectors }),
      ).to.deep.equal([{ a: 1, $tagName: "b", $selector: "c.b" }]);
    });
    it("Should return no results if key isn't in data", async function () {
      const selectors = "c.doesntExist";
      expect(
        await recordsFromJson("./src/__tests__/resources/jsonFiles/abcdeNested.json", { selectors }),
      ).to.deep.equal([]);
    });
    it("Should return all results if given an empty selector argument", async () => {
      const records = await recordsFromJson("./src/__tests__/resources/jsonFiles/abcdeNested.json", { selectors: [] });
      expect(records).length(1);
    });
    it("should throw error when 2 selector paths conflict", async function () {
      // This matches the expected behaviour from 'fromXml'
      const selectors = ["c.b", "f.g", "123", "bn.c", "asdf", "c.b.a"];
      await expect(
        recordsFromJson("./src/__tests__/resources/jsonFiles/abcdeNested.json", { selectors }),
      ).to.eventually.rejectedWith(/A pattern starts with another pattern/);
      // What if the selectors are the exact same
      await expect(
        recordsFromJson("./src/__tests__/resources/jsonFiles/abcdeNested.json", { selectors: ["c.b", "c.b"] }),
      ).to.eventually.rejectedWith(/A pattern starts with another pattern/);
    });
    it("should return empty array if there is no object found at key", async function () {
      const selectors = "e";
      await expect(
        recordsFromJson("./src/__tests__/resources/jsonFiles/abcdeNested.json", { selectors }),
      ).to.eventually.rejectedWith(/Only plain objects can be returned as records/);
    });
  });
  describe("Using selectors with 'data' inputs", () => {
    const data = {
      a: { b: 2 },
      b: { c: 3 },
      c: { b: { a: 1 } },
      d: [{ b: 3 }, { v: 5 }],
      e: 1,
      f: [{ a: ["3"] }, { b: { a: 1 } }],
    };
    it("should get records from given 'string' selector", async function () {
      const selectors = "a";
      expect(await recordsFromJson(data, { selectors })).to.deep.equal([{ b: 2, $tagName: "a", $selector: "a" }]);
    });
    it("should get records from given 'array' of selectors", async function () {
      const selectors = ["b", "c.b"];
      expect(await recordsFromJson(data, { selectors })).to.deep.equal([
        { c: 3, $tagName: "b", $selector: "b" },
        { a: 1, $tagName: "b", $selector: "c.b" },
      ]);
    });
    it("should get records from a selectors path", async function () {
      const selectors = "c.b";
      expect(await recordsFromJson(data, { selectors })).to.deep.equal([{ a: 1, $tagName: "b", $selector: "c.b" }]);
    });
    it("Should return no results if key isn't in data", async function () {
      const selectors = "c.doesntExist";
      expect(await recordsFromJson(data, { selectors })).to.deep.equal([]);
    });
    it("Should return all results if given an empty selector argument", async () => {
      const records = await recordsFromJson(data, { selectors: [] });
      expect(records).length(1);
    });
    it("should throw error when 2 selector paths conflict", async () => {
      const selectors = ["c.b", "a", "g", "sf35", "123", "c.b.v"];
      await expect(recordsFromJson(data, { selectors })).to.eventually.rejectedWith(
        /A pattern starts with another pattern/,
      );
    });
    it("should throw if there is no object found at key", async () => {
      const selectors = "e";
      await expect(recordsFromJson(data, { selectors })).to.eventually.rejectedWith(
        /Only plain objects can be returned as records/,
      );
    });
  });

  describe("Using saved queries", () => {
    it("should read SELECT results from https://triplydb.com/academy/-/queries/3-1", async () => {
      const select = Source.TriplyDb.query("academy", "3-1", { triplyDb: { url: "https://api.triplydb.com" } });
      const app = new Etl();
      let c = 0;
      app.use(fromJson(select, { skipEnrich: true, skipTrim: true }));
      app.use((_, next) => {
        c++;
        return next();
      });
      await app.run();
      assert.equal(c, 2958, "Expected 2.958 pokemons from query (make sure the query actually returns this number!)");
    });

    it("should read ASK results from https://triplydb.com/academy/-/queries/ask-1", async () => {
      const select = Source.TriplyDb.query("academy", "ask-1", { triplyDb: { url: "https://api.triplydb.com" } });
      const app = new Etl();
      let c = 0;
      app.use(fromJson(select, { skipEnrich: true, skipTrim: true }));
      app.use((ctx, next) => {
        c++;
        assert.deepEqual(ctx.record as any, { boolean: true });
        return next();
      });
      await app.run();
      assert.equal(c, 1, "Expected 1 result from query (make sure the query actually returns this number!)");
    });
  });
});
