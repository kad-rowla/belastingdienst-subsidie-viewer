/**
 * To test the OAI-PMH, you have to use Docker to run a OAI-PMH server.
 * Meertens Instituut has a repository: https://github.com/meertensinstituut/oai-pmh
 *
 * TLDR:
 * ```bash
 * docker build -t oai-pmh https://raw.githubusercontent.com/meertensinstituut/oai-pmh/master/docker/Dockerfile
 * docker run -it -p 8080:80 --name oai-pmh oai-pmh
 * ```
 *
 * Also to run the tests locally update the following env var: OAI_URL=http://localhost:8080/oaipmh/
 *
 * A OAI-PMH server is now available at http://localhost:8080/oaipmh/
 */

import { Etl, Record } from "../../../index.js";

import { assert, expect } from "chai";
import { FromOaiOptions, FromOaiOptionsBase, FromOaiOptionsGetRecord } from "../fromOai.js";
import trimRecordFromSource from "../util/trimRecordFromSource.js";
import fs from "fs-extra";

const { pathExists, readdir, rmSync, stat } = fs;

import { resolve as pathResolve } from "path";
import fromOai from "../fromOai.js";
import dotenv from "dotenv";
dotenv.config();

const setSpec = "provincie";
const opts: FromOaiOptionsBase = {
  url: process.env.OAI_URL ?? "",
  timeout: 1,
};

const OAI_TESTER = {
  " key1 ": " key1 ",
  " key2": " key2",
  "key3 ": "key3 ",
  nested: {
    " key1 ": " key1 ",
    " key2": " key2",
    "key3 ": "key3 ",
  },
};

process.env.OAI_TESTER = JSON.stringify(OAI_TESTER);
const runTestLocally = process.env.OAI_URL !== undefined ? describe : describe.skip;
runTestLocally("OAI-PMH", () => {
  describe("Basic functionality", () => {
    beforeEach(() => {
      Etl.silent = true;
    });
    afterEach(() => {
      Etl.silent = false;
    });
    it("Should work for 402 records", async () => {
      const app = new Etl();
      let i = 0;
      let recordId = 0;
      const trimmed = trimRecordFromSource(OAI_TESTER);
      app.use(fromOai(opts), async (ctx, next) => {
        assert.deepEqual(ctx.getAny("header.OAI_TESTER"), trimmed);
        assert.doesNotThrow(() => ctx.getAny("header"));
        assert.isObject(ctx.getAny("header"));
        assert.doesNotThrow(() => ctx.getNumber("header.identifier"));

        assert.doesNotThrow(() => ctx.getAny("metadata"));
        assert.isObject(ctx.getAny("metadata"));
        assert.equal(ctx.getNumber("$recordId"), ctx.recordId);
        i++;
        recordId = ctx.recordId;
        //test if trim
        return next();
      });
      await app.run();
      assert.equal(402, recordId);
      assert.equal(402, i);
    });

    it("Should work for a setSpec", async () => {
      const app = new Etl();
      let i = 0;
      let recordId = 0;
      app.use(fromOai({ ...opts, set: setSpec }), async (ctx, next) => {
        i++;
        recordId = ctx.recordId;
        assert.equal(ctx.getString("header.setSpec"), setSpec);
        return next();
      });
      await app.run();
      assert.equal(12, recordId);
      assert.equal(12, i);
    });

    it("Should work for ListIdentifiers, no set", async () => {
      const app = new Etl();
      let i = 0;
      app.use(fromOai({ ...opts, verb: "ListIdentifiers" }), async (ctx, next) => {
        i++;
        assert.equal(ctx.getNumber("identifier"), ctx.recordId);
        return next();
      });
      await app.run();
      assert.equal(402, i);
    });

    it("Should work for ListIdentifiers, with set", async () => {
      const app = new Etl();
      let i = 0;
      app.use(fromOai({ ...opts, set: setSpec, verb: "ListIdentifiers" }), async (ctx, next) => {
        i++;
        assert.equal(ctx.getString("setSpec"), setSpec);
        assert.equal(ctx.getNumber("identifier"), ctx.recordId);
        return next();
      });
      await app.run();
      assert.equal(12, i);
    });

    it("Should skip trimming records when requested", async () => {
      const app = new Etl();
      app.use(fromOai({ set: setSpec, skipTrim: true, ...opts }), async (ctx, next) => {
        assert.deepEqual(ctx.getAny("header.OAI_TESTER"), OAI_TESTER);
        return next();
      });
      await app.run();
    });
  });

  describe("Using selectors", () => {
    before(() => {
      Etl.silent = true;
    });
    after(() => {
      Etl.silent = false;
    });
    describe("Calling OAI API", function () {
      it("Should match from 'list records' using a single string selector, no-cache", async () => {
        const nestedValuesTrimmed = Object.values(OAI_TESTER.nested).map((v) => v.trim());
        const records: Record[] = [];
        const app = new Etl();
        const selectors = "header.OAI_TESTER.nested";
        app.use(fromOai({ ...opts, cacheOverride: "do not cache", selectors }), async (ctx, next) => {
          records.push(ctx.record);
          const recordValues = [ctx.getAny("key1"), ctx.getAny("key2"), ctx.getAny("key3")];
          expect(nestedValuesTrimmed).to.deep.equal(recordValues);
          return next();
        });
        await app.run();
        expect(records).length(402);
      });
      it("Should return all records if an empty selector array is passed in, no-cache", async () => {
        const records: Record[] = [];
        const app = new Etl();
        app.use(fromOai({ ...opts, cacheOverride: "do not cache", selectors: [] }), async (ctx, next) => {
          records.push(ctx.record);
          return next();
        });
        await app.run();
        expect(records).length(402);
      });
      it("Should match from 'list records' using an array of selectors, no-cache", async () => {
        const selectors = ["metadata.oai_dc:dc", "header.OAI_TESTER"];
        const records: Record[] = [];
        const app = new Etl();
        let recordIdCount = 0;
        app.use(fromOai({ ...opts, cacheOverride: "do not cache", selectors }), async (ctx, next) => {
          records.push(ctx.record);
          if (ctx.recordId % 2 === 0) {
            assert.doesNotThrow(() => ctx.getAny("nested"));
          }
          expect(ctx.recordId).to.equal(++recordIdCount);
          return next();
        });
        await app.run();
        expect(records).length(402 * 2);
      });
      it("Should throw an error if 2 selector paths match, from the cache", async () => {
        const selectors = ["header", "metadata.oai_dc:dc", "metadata.oai_dc:dc.dc:relation"];
        const app = new Etl();
        app.use(fromOai({ ...opts, cacheOverride: "do not cache", selectors }));
        await expect(app.run()).to.eventually.rejectedWith(/A pattern starts with another pattern. Conflict between/);
      });
      it("Should be able to use 'setSpec' and 'selectors', no-cache", async () => {
        const selectors = ["metadata.oai_dc:dc.dc:identifier"];
        const records: Record[] = [];
        const app = new Etl();
        app.use(fromOai({ ...opts, set: setSpec, cacheOverride: "do not cache", selectors }), async (ctx, next) => {
          records.push(ctx.record);
          // returning a number from the "dc:identifer" { "$text" : number }
          expect(ctx.getNumber("$text")).to.be.a("number");
          return next();
        });
        await app.run();
        expect(records).length(12);
      });
      it("Should fail when a selector results in a value that is not an object", async () => {
        const selectors = ["metadata.oai_dc:dc.dc:identifier.$text"];
        const records: Record[] = [];
        const app = new Etl();
        app.use(fromOai({ ...opts, cacheOverride: "do not cache", selectors }), async (ctx, next) => {
          records.push(ctx.record);
          return next();
        });
        await expect(app.run()).to.eventually.rejectedWith(/Only plain objects can be returned as records/);
      });
    });
    describe.skip("Cached values", function () {
      let cacheFileCount = 0;
      let setCacheCount = 0;
      before("Removes and then repopulates the current cache from localhost-8080-oaipmh folder", async function () {
        return new Promise<void>(async function (resolve) {
          const relCacheDirPath = "data/cache/source-oai/http-localhost-8080-oaipmh";
          // delete existing cache
          rmSync(relCacheDirPath, { recursive: true, force: true });
          // populate new cache
          const populateCache = new Etl();
          populateCache.use(fromOai({ ...opts, cacheOverride: "use cache" }));
          await populateCache.run();
          // count records in cache
          if (await pathExists(relCacheDirPath)) {
            for (const dirName of await readdir(relCacheDirPath)) {
              const dirPath = pathResolve(relCacheDirPath, dirName);
              if (!(await stat(dirPath)).isDirectory()) continue;
              (await readdir(dirPath)).forEach((_file) => ++cacheFileCount);
            }
          }
          // Delete then populate the set cache
          const relSetCacheDirPath = `data/cache/source-oai/http-localhost-8080-oaipmh/${setSpec}`;
          // rmSync(relSetCacheDirPath, { recursive: true, force: true });
          const populateSetCache = new Etl();
          populateSetCache.use(fromOai({ ...opts, set: setSpec, cacheOverride: "use cache" }));
          await populateSetCache.run();
          // count records in cache
          if (await pathExists(relSetCacheDirPath)) {
            for (const dirName of await readdir(relSetCacheDirPath)) {
              const dirPath = pathResolve(relSetCacheDirPath, dirName);
              if (!(await stat(dirPath)).isDirectory()) continue;
              (await readdir(dirPath)).forEach((_file) => ++setCacheCount);
            }
          }
          resolve();
        });
      });
      it("Should test that the cache & set cache is full", () => {
        expect(cacheFileCount).to.equal(402, "Not all files from the OAI server are in the cache");
        expect(setCacheCount).to.equal(12, `Not all files from the OAI server from set: '${setSpec}' are in the cache`);
      });
      it("Should return 'list records' from the cache for single selector", async () => {
        const selectors = "header";
        const records: Record[] = [];
        const app = new Etl();
        app.use(fromOai({ ...opts, cacheOverride: "use cache", selectors }), async (ctx, next) => {
          records.push(ctx.record);
          expect(ctx.getAny("fromCache")).to.be.true;
          return next();
        });
        await app.run();
        expect(records).length(402);
      });
      it("Should return 'list records' from the cache for an array of selectors", async () => {
        const selectors = ["header", "metadata.oai_dc:dc"];
        const records: Record[] = [];
        const app = new Etl();
        app.use(fromOai({ ...opts, cacheOverride: "use cache", selectors: selectors }), async (ctx, next) => {
          records.push(ctx.record);
          expect(ctx.getAny("fromCache")).to.be.true;
          return next();
        });
        await app.run();
        expect(records).length(402 * 2);
      });
      it("Should return all records if an empty selector array is passed in, from the cache", async () => {
        const records: Record[] = [];
        const app = new Etl();
        app.use(fromOai({ ...opts, cacheOverride: "use cache", selectors: [] }), async (ctx, next) => {
          records.push(ctx.record);
          return next();
        });
        await app.run();
        expect(records).length(402);
      });
      it("Should throw an error if 2 selector paths match, from the cache", async () => {
        const selectors = ["header", "metadata.oai_dc:dc", "metadata.oai_dc:dc.dc:relation"];
        const app = new Etl();
        app.use(fromOai({ ...opts, cacheOverride: "use cache", selectors }));
        await expect(app.run()).to.eventually.rejectedWith(/A pattern starts with another pattern. Conflict between/);
      });
      it("Should test behaviour using cache selectors and set", async () => {
        const selectors = ["metadata.oai_dc:dc"];
        const records: Record[] = [];
        const app = new Etl();
        app.use(
          fromOai({ ...opts, set: setSpec, cacheOverride: "use cache", selectors: selectors }),
          async (ctx, next) => {
            records.push(ctx.record);
            expect(ctx.getAny("fromCache")).to.be.true;
            expect(ctx.getNumber("dc:identifier.$text")).to.be.a("number");
            return next();
          }
        );
        await app.run();
        expect(records).length(12);
      });
      it("Should fail when a selector results in a value that is not an object", async () => {
        const selectors = ["metadata.oai_dc:dc.dc:identifier.$text"];
        const records: Record[] = [];
        const app = new Etl();
        app.use(fromOai({ ...opts, cacheOverride: "use cache", selectors }), async (ctx, next) => {
          records.push(ctx.record);
          return next();
        });
        await expect(app.run()).to.eventually.rejectedWith(/Only plain objects can be returned as records/);
      });
    });
  });
  describe("Using GetRecord", () => {
    it("Should get specific known record using GetRecord `identifier`", async () => {
      const app = new Etl();
      const identifier = "23";
      const records: Record[] = [];
      app.use(fromOai({ ...opts, identifier }), async (ctx, next) => {
        records.push(ctx.record);
        expect(ctx.getAny("header.identifier")).to.equal(identifier);
        return next();
      });
      await app.run();
      expect(records).length(1);
    });
    it("Should accept a 'metadataPrefix' argument", async () => {
      const appErr = new Etl();
      const errorOptions: FromOaiOptions<FromOaiOptionsGetRecord> = {
        url: opts.url,
        identifier: "23",
        metadataPrefix: "hello",
      };
      appErr.use(fromOai(errorOptions));
      await expect(appErr.run()).to.eventually.rejectedWith(/metadataPrefix=hello/);
      const appPass = new Etl();
      const records: Record[] = [];
      const identifier = "23";
      appPass.use(
        fromOai({
          url: opts.url,
          identifier,
          metadataPrefix: "oai_dc",
        }),
        async (ctx, next) => {
          records.push(ctx.record);
          expect(ctx.getAny("header.identifier")).to.equal(identifier);
          return next();
        }
      );
      await expect(appPass.run()).to.eventually.fulfilled;
      expect(records).length(1);
    });
    it("Should handle errors when no record from OAI is available", async () => {
      const app = new Etl();
      const identifier = "123456789";
      const metadataPrefix = "oai_dc";
      const records: Record[] = [];
      app.use(fromOai({ ...opts, identifier, metadataPrefix }), async (ctx, next) => {
        records.push(ctx.record);
        expect(ctx.getAny("header.identifier")).to.equal(identifier);
        expect(ctx.getAny("header.fromCache")).to.equal(true);
        return next();
      });
      await expect(app.run()).to.eventually.rejectedWith("[idDoesNotExist]");
    });
  });
});
