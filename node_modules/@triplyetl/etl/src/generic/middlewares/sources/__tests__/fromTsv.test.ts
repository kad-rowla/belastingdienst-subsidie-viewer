//external dependencies

import chai, { assert } from "chai";

import chaiAsPromised from "chai-as-promised";
chai.use(chaiAsPromised);
const expect = chai.expect;

import fromtsv from "../fromTsv.js";
import { getCountingMw } from "./fromCsv.test.js";
import fs from "fs-extra";

const { readFile, readFileSync } = fs;

import { parse } from "csv-parse/sync";
import { has } from "lodash-es";
import trimRecordFromSource from "../util/trimRecordFromSource.js";
import { DuplicateColumnsError } from "../fromCsv.js";
import { Etl, Source } from "../../../index.js";
import { str } from "../../../../ratt/index.js";

describe("Read tsv documents", function () {
  it("Read a single tsv document", async function () {
    const app = new Etl({ defaultGraph: "https://default.com/" });
    app.use(fromtsv(Source.file("./src/__tests__/resources/tsvFiles/addresses.tsv"), { skipEnrich: true }));
    const [count, mw] = getCountingMw();
    app.use(mw);
    await app.run();
    expect(count.count).to.equal(6);
  });
  it("Read multiple tsv documents", async function () {
    const app = new Etl({ defaultGraph: "https://default.com/" });
    app.use(
      fromtsv(
        [
          Source.file("./src/__tests__/resources/tsvFiles/addresses.tsv"),
          Source.file("./src/__tests__/resources/tsvFiles/cities.tsv"),
        ],
        { skipEnrich: true },
      ),
    );
    const [count, mw] = getCountingMw();
    app.use(mw);
    await app.run();
    expect(count.count).to.equal(6 + 3041);
  });
  it("Report problematic document", async function () {
    const app = new Etl({ defaultGraph: "https://default.com/" });
    app.use(fromtsv(Source.file("./src/__tests__/resources/tsvFiles/addresses-broken.tsv"), { skipEnrich: true }));
    return expect(app.run()).to.eventually.be.rejectedWith(/addresses-broken\.tsv/);
  });
  it("Doesn't report with 'csv'", async function () {
    const app = new Etl({ defaultGraph: "https://default.com/" });
    app.use(fromtsv(Source.file("./src/__tests__/resources/tsvFiles/addresses-broken.tsv"), { skipEnrich: true }));
    return expect(app.run()).to.eventually.be.rejectedWith(/^((?!csv).)*$/i);
  });

  /**
   * @see https://issues.triply.cc/issues/5631
   */
  it("should trim keys and values by default, but not when requested", async () => {
    const filePath = "./src/__tests__/resources/tsvFiles/issue-redmine-5631.tsv";
    // load and parse CSV file as a reference for our test:
    const content = await readFile(filePath, "utf-8");
    const record = parse(content, {
      columns: true,
      delimiter: "\t",
      escape: "\\",
      quote: '"',
      groupColumnsByName: true,
      trim: false,
    })[0];
    const appWithTrim = new Etl();
    appWithTrim.use(
      fromtsv(Source.file(filePath), {
        groupColumnsByName: true,
        escape: "\\",
        quote: '"',
        skipEnrich: true,
      }),
      async (ctx, next) => {
        assert.deepEqual(ctx.record, trimRecordFromSource({ ...record }));
        return next();
      },
    );
    await appWithTrim.run();

    const appWithoutTrim = new Etl();
    appWithoutTrim.use(
      fromtsv(Source.file(filePath), {
        groupColumnsByName: true,
        escape: "\\",
        quote: '"',
        skipTrim: true,
        skipEnrich: true,
      }),
      async (ctx, next) => {
        assert.deepEqual(ctx.record, record);
        return next();
      },
    );
    await appWithoutTrim.run();
  });

  it("Should fix issue https://issues.triply.cc/issues/5631", async () => {
    const app = new Etl();
    app.use(
      fromtsv(Source.file("./src/__tests__/resources/tsvFiles/issue-redmine-5631.tsv"), {
        escape: "\\",
        quote: '"',
        skipEnrich: true,
      }),
      async (ctx, next) => {
        assert.isTrue(has(ctx.record, ""));
        assert.isFalse(has(ctx.record, " "));
        for (const key in ctx.record) {
          if (key === "") {
            assert.throw(() => ctx.getString(key));
            assert.equal(ctx.record[key], "");
          } else {
            assert.equal(key, key.trim());
            assert.equal(ctx.getString(key), (ctx.record[key] as string).trim());
          }
        }
        return next();
      },
    );
    return expect(app.run()).to.eventually.be.fulfilled;
  });

  describe("Should throw on duplicate when 'groupColumnsByName' option not set", async () => {
    it("using a file", async () => {
      const app = new Etl();
      app.use(fromtsv(Source.file("./src/__tests__/resources/tsvFiles/duplicate-header-example.tsv")));
      await expect(app.run()).to.eventually.be.rejectedWith(
        new DuplicateColumnsError("./src/__tests__/resources/tsvFiles/duplicate-header-example.tsv").message,
      );
    });
    it("using a static string", async () => {
      const app = new Etl();
      const data = readFileSync("./src/__tests__/resources/tsvFiles/duplicate-header-example.tsv", "utf-8");
      app.use(fromtsv(str(data)));
      await expect(app.run()).to.eventually.be.rejectedWith(new DuplicateColumnsError("A\tB\tA\r\n1\t2\t3").message);
    });
  });

  describe("Should allow duplicate column names with 'groupColumnsByName' set", async () => {
    it("using a file", async () => {
      const app = new Etl();
      app.use(
        fromtsv(Source.file("./src/__tests__/resources/tsvFiles/duplicate-header-example.tsv"), {
          groupColumnsByName: true,
        }),
        async (ctx, next) => {
          assert.doesNotThrow(() => ctx.getArray("A", "string"));
          assert.doesNotThrow(() => ctx.getString("B"));
          assert.deepEqual(ctx.getArray("A", "string"), ["1", "3"]);
          assert.deepEqual(ctx.getString("B"), "2");
          return next();
        },
      );
      await app.run();
    });
    it("using a static string", async () => {
      const app = new Etl();
      const data = readFileSync("./src/__tests__/resources/tsvFiles/duplicate-header-example.tsv", "utf-8");
      app.use(fromtsv(str(data), { groupColumnsByName: true }), async (ctx, next) => {
        assert.doesNotThrow(() => ctx.getArray("A", "string"));
        assert.doesNotThrow(() => ctx.getString("B"));
        assert.deepEqual(ctx.getArray("A", "string"), ["1", "3"]);
        assert.deepEqual(ctx.getString("B"), "2");
        return next();
      });
      await app.run();
    });
  });
  it("should read SELECT results from https://triplydb.com/academy/-/queries/3-1", async () => {
    const select = Source.TriplyDb.query("academy", "3-1", { triplyDb: { url: "https://api.triplydb.com" } });
    const app = new Etl();
    let c = 0;
    app.use(fromtsv(select, { skipEnrich: true, skipTrim: true }));
    app.use((_, next) => {
      c++;
      return next();
    });
    await app.run();
    assert.equal(c, 2958, "Expected 2.958 pokemons from query (make sure the query actually returns this number!)");
  });

  it("should read ASK results from https://triplydb.com/academy/-/queries/ask-1", async () => {
    const select = Source.TriplyDb.query("academy", "ask-1", { triplyDb: { url: "https://api.triplydb.com" } });
    const app = new Etl();
    let c = 0;
    app.use(fromtsv(select, { skipEnrich: true, skipTrim: true }));
    app.use((ctx, next) => {
      c++;
      assert.deepEqual(ctx.record as any, { boolean: true });
      return next();
    });
    await app.run();
    assert.equal(c, 1, "Expected 1 result from query (make sure the query actually returns this number!)");
  });
});
