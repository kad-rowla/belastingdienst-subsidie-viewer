import { expect } from "chai";
import loadRdf from "../loadRdf.js";
import { assertIsDefined } from "../../../../utils/asserts.js";
import { expectNoBlankNodesMw } from "../../../../__tests__/util.js";
import { getFactory } from "@triplydb/data-factory";
import { a, sdo } from "@triplyetl/vocabularies";
import { Etl, Middleware, Source, compareGraphs } from "../../../index.js";
import { Quad } from "@triplydb/data-factory/Terms.js";

describe("loadRdf", function () {
  it("should remove all blank nodes", async function () {
    const app = new Etl({
      defaultGraph: "https://default.com/",
      sources: {
        in: Source.file("./src/__tests__/resources/rdfFiles/ten-blank-triples.ttl"),
      },
    });
    app.use(loadRdf(app.sources.in));
    app.use(expectNoBlankNodesMw);
    app.use((ctx, next) => {
      expect(ctx.store.countQuads(null, null, null, null)).to.equal(10);
      return next();
    });
    return app.run();
  });
  it("should not merge blank nodes from different sources", async function () {
    const app = new Etl({
      defaultGraph: "https://default.com/",
      sources: {
        in1: Source.file("./src/__tests__/resources/rdfFiles/ten-blank-triples.ttl"),
        in2: Source.file("./src/__tests__/resources/rdfFiles/five-blank-triples.ttl"),
      },
    });
    app.use(loadRdf([app.sources.in1, app.sources.in2]));
    app.use(expectNoBlankNodesMw);
    app.use((ctx, next) => {
      expect(ctx.store.countQuads(null, null, null, null)).to.equal(15);
      return next();
    });
    return app.run();
  });
  it("loading order should not to matter for blank node hash", async function () {
    const sources = {
      in1: Source.string("[] <http://a> [] ."),
      in2: Source.string("[] <http://b> [] ."),
    };

    // 1 first, 2 second
    const app = new Etl({
      defaultGraph: "https://default.com/",
      sources,
    });
    app.use(loadRdf([app.sources.in1, app.sources.in2], { contentType: "text/turtle" }));
    let firstOrder: Quad[] | undefined;
    app.use(async (ctx) => {
      firstOrder = ctx.store.getQuads({});
    });
    await app.run();

    // 2 first, 1 second
    const app2 = new Etl({
      defaultGraph: "https://default.com/",
      sources,
    });
    app2.use(loadRdf([app2.sources.in2, app2.sources.in1], { contentType: "text/turtle" }));
    let secondOrder: Quad[] | undefined;
    app2.use(async (ctx) => {
      secondOrder = ctx.store.getQuads({});
    });
    await app2.run();

    assertIsDefined(firstOrder, "firstOrder should be defined");
    assertIsDefined(secondOrder, "secondOrder should be defined");
    expect(firstOrder).to.have.lengthOf(2);
    expect(secondOrder).to.have.lengthOf(2);
    // if (firstOrder[0].predicate.value !== secondOrder[0].predicate.value) {
    //   firstOrder = firstOrder.reverse();
    // }
    // expect(firstOrder).to.equal(secondOrder);
  });
  it("Report problematic document", async function () {
    const app = new Etl({ defaultGraph: "https://default.com/" });
    app.use(loadRdf(Source.file("./src/__tests__/resources/validationFiles/shapes_with_syntax_error.ttl")));
    return expect(app.run()).to.eventually.be.rejectedWith(/shapes_with_syntax_error\.ttl/);
  });

  it("should load TriG", function () {
    const app = new Etl();
    app.use(loadRdf(Source.file("./src/__tests__/resources/rdfFiles/john-doe.trig")), assertJohnDoe);
    return app.run();
  });

  it("should load JSON-LD", function () {
    const app = new Etl();
    app.use(loadRdf(Source.file("./src/__tests__/resources/rdfFiles/john-doe.jsonld")), assertJohnDoe);
    return app.run();
  });

  it("should load RDFa from HTML", function () {
    const app = new Etl();
    app.use(
      loadRdf(Source.file("./src/__tests__/resources/rdfFiles/john-doe.html"), {
        defaultGraph: "http://ex.com/",
        contentType: "text/html",
      }),
      assertJohnDoe,
    );
    return app.run();
  });
  it("should load RDFa from HTML without defaultGraph", function () {
    const app = new Etl();
    app.use(
      loadRdf(Source.file("./src/__tests__/resources/rdfFiles/john-doe.html"), {
        contentType: "text/html",
      }),
      assertJohnDoe,
    );
    return app.run();
  });

  it("should work without content type for simple strings (see issue #229)", async () => {
    const etl = new Etl();
    const graph = getFactory().namedNode("http://ex.com/g");
    const subject = getFactory().namedNode("http://ex.com/s");
    const predicate = getFactory().namedNode("http://ex.com/p");
    const object = getFactory().namedNode("http://ex.com/o");
    etl.use(
      loadRdf(Source.string(`<${graph.value}> { <${subject.value}> <${predicate.value}> <${object.value}> }`)),
      loadRdf(Source.string(`<${subject.value}> <${predicate.value}> <${object.value}> .`)),
      loadRdf(Source.string(`prefix ex: <http://ex.com/>\nex:s2 ex:p ex:o .`)),
      async (ctx, _) => {
        expect(ctx.store.getQuads({}).length).equal(3);
        expect(ctx.store.getQuads({ subject, predicate, object, graph }).length).equal(1);
        expect(ctx.store.getQuads({ subject, predicate, object, graph: etl.defaultGraph }).length).equal(1);
        expect(
          ctx.store.getQuads({
            subject: getFactory().namedNode("http://ex.com/s2"),
            predicate,
            object,
            graph: etl.defaultGraph,
          }).length,
        ).equal(1);
      },
    );
    await etl.run();
  });

  it("should apply a stylesheet export file (XSL)", async () => {
    const etl = new Etl();
    const xml = "src/__tests__/resources/xslt/family-doe.xml";
    const rdf = "src/__tests__/resources/xslt/result.trig";
    const xsl = "src/__tests__/resources/xslt/stylesheet.xsl";
    etl.use(
      loadRdf(Source.file(xml), {
        contentType: "application/rdf+xml",
        stylesheet: Source.file(xsl),
      }),
      compareGraphs(Source.file(rdf), { terminate: false, throw: true }),
    );
    await etl.run();
  });
});

const assertJohnDoe: Middleware = async (ctx, next) => {
  const DataFactory = getFactory();
  const subject = DataFactory.namedNode("http://ex.com/1");
  expect(ctx.store.getQuads({}).length).equal(3);
  expect(
    ctx.store.getQuads({
      subject,
      predicate: sdo.givenName,
      object: DataFactory.literal("John"),
    }).length,
  ).equal(1);
  expect(
    ctx.store.getQuads({
      subject,
      predicate: sdo.familyName,
      object: DataFactory.literal("Doe"),
    }).length,
  ).equal(1);
  expect(
    ctx.store.getQuads({
      subject,
      predicate: a,
      object: sdo.Person,
    }).length,
  ).equal(1);
  return next();
};
