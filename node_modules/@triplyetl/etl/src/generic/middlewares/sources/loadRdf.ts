import { Context, Etl, Middleware } from "../../index.js";
import { NamedNode, Quad, Term } from "@triplydb/data-factory/Terms.js";
import { FileSourceInfo, SourceGetter, StringSourceInfo } from "../../locations/sources/index.js";
import { castArray, unset, once } from "lodash-es";
import _rdfParser from "rdf-parse";
const rdfParser = _rdfParser.default;
import { getStreamParser, getFactory } from "@triplydb/data-factory";
import { addMwCallSiteToError, coerceToIri, md5OfArray, NamedNodeCompatibleType } from "../../../utils/index.js";

import { Readable } from "stream";
import xsltproc from "../../utils/xsltproc.js";
const dataFactory = once(() => getFactory({ skipValidation: Etl.skipValidation }));
export interface LoadRdfOptionsWithSEF {
  /**
   * The default graph to use for this import
   * @default The default graph of Etl
   */
  defaultGraph?: NamedNodeCompatibleType;
  stylesheet?: SourceGetter<"statements", FileSourceInfo>;
  contentType?: "application/xhtml+xml" | "application/xml" | "text/xml" | "image/svg+xml" | "application/rdf+xml";
}

export interface LoadRdfOptions {
  /**
   * The default graph to use for this import
   * @default The default graph of Etl
   */
  defaultGraph?: NamedNodeCompatibleType;
  stylesheet?: never;
  contentType?:
    | "application/ld+json"
    | "application/json"
    | "text/html"
    | "application/n-quads"
    | "application/trig"
    | "application/n-triples"
    | "text/turtle"
    | "text/n3";
}

// Triply parser only parses a limited number of formats, the rest are 'undefined'
const contentTypeMap = {
  "application/ld+json": undefined,
  "application/json": undefined,
  "text/html": undefined,
  "application/xhtml+xml": undefined,
  "application/xml": undefined,
  "text/xml": undefined,
  "image/svg+xml": undefined,
  "application/rdf+xml": undefined,
  "application/n-quads": "n-quads",
  "application/trig": "trig",
  "application/n-triples": "n-triples",
  "text/turtle": "turtle",
  "text/n3": "n3",
} as const;

const positions = ["graph", "subject", "predicate", "object"] as const;
function needsToSanitize(quad: Quad) {
  for (const position of positions) {
    const shouldSanitize = quad[position].termType === "BlankNode" || quad[position].termType === "DefaultGraph";
    if (shouldSanitize) return true;
  }
  return false;
}

export async function getQuads(
  ctx: Context,
  oneOrMoreSources: SourceGetter<"statements", StringSourceInfo> | SourceGetter<"statements", StringSourceInfo>[],
  opts?: LoadRdfOptions,
): Promise<Quad[]> {
  return new Promise(async (resolve, reject) => {
    const quads: Quad[] = [];
    let sources: Array<StringSourceInfo> = [];
    try {
      sources = await ctx["_registerSources"](castArray(oneOrMoreSources), "statements");
    } catch (e) {
      reject(e);
    }

    let defaultGraph: NamedNode | undefined;
    if (opts?.defaultGraph) {
      defaultGraph = coerceToIri(opts.defaultGraph);
    } else {
      defaultGraph = ctx.app.defaultGraph;
    }
    for (const source of sources) {
      try {
        (await sourceToQuads(ctx, source, defaultGraph, opts)).forEach((quad) => quads.push(quad));
      } catch (e) {
        reject(e);
      }
    }
    resolve(quads);
  });
}

const sourceToQuads = async (
  ctx: Context,
  source: StringSourceInfo,
  defaultGraph: NamedNode<string> | undefined,
  opts?: LoadRdfOptions,
): Promise<Quad[]> => {
  return new Promise(async (resolve, reject) => {
    const contentType = opts?.contentType || (await source.mediaType());
    let useTriplyDbParser = false;
    if (contentType === "text/plain") {
      // old parser assumes N3, Turtle, Trig:
      useTriplyDbParser = true;
    } else {
      if (!contentType || !(await rdfParser.getContentTypes()).includes(contentType)) {
        return reject(
          new Error(
            `The contentType of your source ('${contentType}') is not recognized, if you are sure your RDF is valid, specify the format using the 'contentType' option.`,
          ),
        );
      }
    }
    const textStream = Readable.from(await source.getString());
    const quadsOfSource: Quad[] = [];
    getParser(textStream, contentType, defaultGraph, useTriplyDbParser)
      .on("data", (quad: Quad) => {
        if (shouldUseTriplyParser(contentType)) quadsOfSource.push(quad);
        else quadsOfSource.push(dataFactory().fromQuad(quad));
      })
      .on("error", (e: unknown) => {
        if (e instanceof Error) reject(new Error(`Failed to parse RDF ${source.name}: ${e.message}`));
        else throw e;
      })
      .on("end", async () => {
        const quads: Quad[] = [];
        for (let quad of quadsOfSource) {
          if (needsToSanitize(quad)) {
            const sourceId = await source.id();
            function sanitizeTerm<T extends Term>(term: T, graphName: string): T | NamedNode {
              if (term.termType === "BlankNode") {
                return ctx.app.standardPrefixes.skolem.concat(md5OfArray([sourceId, term.value, graphName]));
              } else if (defaultGraph !== undefined && term.termType === "DefaultGraph") {
                return defaultGraph;
              }
              return term;
            }
            quads.push(
              dataFactory().quad(
                sanitizeTerm(quad.subject, quad.graph.value),
                sanitizeTerm(quad.predicate, quad.graph.value),
                sanitizeTerm(quad.object, quad.graph.value),
                sanitizeTerm(quad.graph, quad.graph.value),
              ),
            );
          } else {
            quads.push(quad);
          }
        }
        ctx.source = source;
        resolve(quads);
      });
  });
};

function shouldUseTriplyParser(contentType: string) {
  return !!contentTypeMap[contentType as keyof typeof contentTypeMap];
}
function getParser(
  readStream: any,
  contentType: string,
  defaultGraph: NamedNode<string> | undefined,
  useTriplyDbParser: boolean = false,
) {
  if (useTriplyDbParser || shouldUseTriplyParser(contentType)) {
    const triplyParserOptions = {
      baseIri: defaultGraph?.value,
      format: contentTypeMap[contentType as keyof typeof contentTypeMap],
    };
    return readStream.pipe(getStreamParser(triplyParserOptions));
  }
  return rdfParser.parse(readStream, {
    contentType,
    baseIRI: defaultGraph ? defaultGraph.value : undefined,
  });
}

// TODO @DocumentationTeam: add TS doc comment here
export default function loadRdf(
  oneOrMoreSources: SourceGetter<"statements", StringSourceInfo> | SourceGetter<"statements", StringSourceInfo>[],
  opts?: LoadRdfOptions | LoadRdfOptionsWithSEF,
): Middleware {
  return addMwCallSiteToError(
    async function _loadRdf(ctx, next) {
      if (opts?.stylesheet !== undefined) {
        const proc = await xsltproc(ctx.app, oneOrMoreSources, opts.stylesheet);
        // @ts-expect-error we now this works, the type is different but still correct
        oneOrMoreSources = proc.sources;
        unset(opts, "stylesheet");
      }
      const quads = await getQuads(ctx, oneOrMoreSources, opts as LoadRdfOptions);
      ctx.store.addQuads(quads);
      return next();
    },
    { sourceFuncName: "_loadRdf" },
  );
}
