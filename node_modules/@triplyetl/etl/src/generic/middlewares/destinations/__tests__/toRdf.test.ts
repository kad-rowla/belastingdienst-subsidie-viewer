import { Etl, Context, fromJson, Destination } from "../../../index.js";
import toRdf from "../toRdf.js";
import path from "path";
import fs from "fs-extra";
import { expect } from "chai";
import { triple, iri, quad } from "../../../../ratt/index.js";
import { a } from "@triplyetl/vocabularies";
const tmpDataDir = path.resolve("tmp");
const expectedOutputFiles = "./src/__tests__/resources/outputFiles";

async function compareFiles(lhs: string, rhs: string) {
  expect((await fs.readFile(lhs, "utf-8")).replace(/(?:\r\n|\r|\n)/g, "")).to.equal(
    (await fs.readFile(rhs, "utf-8")).replace(/(?:\r\n|\r|\n)/g, ""),
  );
}
async function compareFileWithString(file: string, rhs: string) {
  expect((await fs.readFile(file, "utf-8")).trim()).to.equal(rhs.trim());
}
function getApp(type: "triples" | "quads") {
  const app = new Etl({ defaultGraph: "https://default.com/" });
  app.use(
    fromJson([
      {
        col1: "a1:a1",
        col2: "b1:b1",
        col3: "c1:c1",
        col4: "d1:d1",
      },
      {
        col1: "a2:a2",
        col2: "b2:b2",
        col3: "c2:c2",
        col4: "d2:d2",
      },
    ]),
  );
  if (type === "triples") {
    app.use(triple(iri("col1"), iri("col2"), iri("col3")));
  } else {
    app.use(quad(iri("col1"), iri("col2"), iri("col3"), iri("col4")));
  }
  return app;
}
describe("Write RDF", function () {
  before(async function () {
    await fs.emptyDir(tmpDataDir);
  });
  it("Nquads", async function () {
    const app = getApp("quads");
    const tmpFile = path.resolve(tmpDataDir, "out.nq");
    app.use(toRdf(Destination.file(tmpFile)));
    await app.run();
    await compareFiles(tmpFile, path.resolve(expectedOutputFiles, "out.nq"));
  });
  it("Ttl", async function () {
    const app = getApp("quads");
    const tmpFile = path.resolve(tmpDataDir, "out.ttl");
    app.use(toRdf(Destination.file(tmpFile)));
    await app.run();
    await compareFiles(tmpFile, path.resolve(expectedOutputFiles, "out.ttl"));
  });
  it("Ntriples", async function () {
    const app = getApp("quads");
    const tmpFile = path.resolve(tmpDataDir, "out.nt");
    app.use(toRdf(Destination.file(tmpFile)));
    await app.run();
    await compareFiles(tmpFile, path.resolve(expectedOutputFiles, "out.nt"));
  });
  it("Trig", async function () {
    const app = getApp("quads");
    const tmpFile = path.resolve(tmpDataDir, "out.trig");
    app.use(toRdf(Destination.file(tmpFile)));
    await app.run();
    await compareFiles(tmpFile, path.resolve(expectedOutputFiles, "out.trig"));
  });
  it("Write with graph include list", async function () {
    const app = getApp("quads");
    const tmpFile = path.resolve(tmpDataDir, "out.nq");
    app.use(toRdf(Destination.file(tmpFile), { includeGraphs: ["d1:d1"] }));
    await app.run();
    await compareFileWithString(tmpFile, "<a1:a1> <b1:b1> <c1:c1> <d1:d1> .");
  });
  it("Write with graph exclude list", async function () {
    const app = getApp("quads");
    const tmpFile = path.resolve(tmpDataDir, "out.nq");
    app.use(toRdf(Destination.file(tmpFile), { excludeGraphs: ["d2:d2"] }));
    await app.run();
    await compareFileWithString(tmpFile, "<a1:a1> <b1:b1> <c1:c1> <d1:d1> .");
  });
  it("Write with dynamic destination", async function () {
    const app = new Etl({
      defaultGraph: "",
      destinations: { d: (ctx: Context) => Destination.file(path.resolve(tmpDataDir, `${ctx.recordId % 2}.nq`)) },
    });
    app.use(
      fromJson([
        { col1: "a1:a1", col2: "b1:b1", col3: "c1:c1", col4: "d1:d1" },
        { col1: "a2:a2", col2: "b2:b2", col3: "c2:c2", col4: "d2:d2" },
        { col1: "a3:a3", col2: "b3:b3", col3: "c3:c3", col4: "d3:d3" },
        { col1: "a4:a4", col2: "b4:b4", col3: "c4:c4", col4: "d4:d4" },
      ]),
    );
    app.use(quad(iri("col1"), iri("col2"), iri("col3"), iri("col4")));
    app.use(toRdf(app.destinations.d));
    await app.run();
    await compareFileWithString(
      path.resolve(tmpDataDir, "0.nq"),
      "<a2:a2> <b2:b2> <c2:c2> <d2:d2> .\n<a4:a4> <b4:b4> <c4:c4> <d4:d4> .",
    );
    await compareFileWithString(
      path.resolve(tmpDataDir, "1.nq"),
      "<a1:a1> <b1:b1> <c1:c1> <d1:d1> .\n<a3:a3> <b3:b3> <c3:c3> <d3:d3> .",
    );
  });
  it.skip("toRdf performance test", async function () {
    // This test was used while working on #6840. It writes 1 quad to toRdf 1,000,000 times.
    this.timeout(0);
    const app = new Etl();
    const store = app.getNewStore();
    store.addQuad(a, a, a);
    app.use(async (_ctx, next) => {
      let i = 0;
      while (i++ < 1_000_000) await next({}, store);
    });
    const file = Destination.file(path.resolve(app.getTmpDir(), "test", Math.random().toString() + ".nt"));
    app.use(toRdf(file));
    await app.run();
  });
});
