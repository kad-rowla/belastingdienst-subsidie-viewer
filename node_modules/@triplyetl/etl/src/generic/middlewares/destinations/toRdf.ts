import { Middleware } from "../../index.js";
import { NamedNode } from "rdf-js";
import { unknownValToIri } from "../../../utils/coercions.js";
import { DestinationGetter } from "../../locations/destinations/index.js";
import { Quad } from "@triplydb/data-factory/Terms.js";
import { PatternTerm } from "@triplydb/data-factory/Store.js";
import { flatten } from "lodash-es";

interface GraphPattern {
  graph: PatternTerm;
}

function asPattern(graphOrPattern: string | NamedNode | GraphPattern): GraphPattern {
  if (typeof graphOrPattern === "string") {
    return { graph: unknownValToIri(graphOrPattern) };
  } else if ("graph" in graphOrPattern) {
    return graphOrPattern;
  } else {
    return { graph: graphOrPattern };
  }
}
export interface ToRdfOptions {
  /**
   * Which graphs to include
   */
  includeGraphs?: Array<string | NamedNode | GraphPattern>;

  /**
   * Which graphs to exclude.
   * When specified in combination with `includeGraphs`, the blacklist will take precedence
   */
  excludeGraphs?: Array<string | NamedNode | GraphPattern>;
}
export default function (destination: DestinationGetter, opts?: ToRdfOptions): Middleware {
  const includePatterns = opts?.includeGraphs ? opts.includeGraphs.map((include) => asPattern(include)) : undefined;
  return async function _toRdf(ctx, next) {
    let quads: Quad[] = [];
    if (includePatterns) {
      if (ctx.app.staticStore) {
        quads.push(...flatten(includePatterns.map((pattern) => ctx.app.staticStore!.getQuads(pattern))));
      }
      quads.push(...flatten(includePatterns.map((pattern) => ctx.store.getQuads(pattern))));
    } else {
      if (ctx.app.staticStore) {
        quads.push(...ctx.app.staticStore.getQuads({}));
      }
      quads.push(...ctx.store.getQuads({}));
    }
    ctx.app.staticStore = undefined;
    if (opts?.excludeGraphs) {
      const graphsToExclude = opts.excludeGraphs.map((g) => unknownValToIri(g));
      quads = ctx.store.getQuads({}).filter((quad) => {
        const shouldExclude = graphsToExclude.some((excludeGraph) => quad.graph.equals(excludeGraph));
        return !shouldExclude;
      });
    }

    if (quads.length) {
      // Track the exact number for the final report
      // Track a human readable (less exact) string for the runtime stats
      const currentNumQuads = +ctx.app.getStats("finalReport")["#Statements"];
      ctx.app.updateStats("#Statements", currentNumQuads, { display: "runtime" });
      await ctx.writeQuads(quads, destination);
    }
    return next();
  };
}
