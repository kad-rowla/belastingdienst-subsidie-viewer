import getCurrentLine from "get-current-line";
import { Context, Key, Middleware, MiddlewareList, whenNot } from "../../index.js";
import { addMwCallSiteToError, randomHash } from "../../../utils/index.js";
import { getErr } from "../../../utils/Error.js";
import when from "./when.js";
import { unset } from "lodash-es";

export interface IfThen {
  if: Key | ((context: Context) => boolean);
  then: Middleware | MiddlewareList;
  else?: never;
}

export interface Else {
  if?: never;
  then?: never;
  else: Middleware | MiddlewareList;
}

const isElse = (IfThenElse: IfThen | Else): IfThenElse is Else =>
  Object.prototype.hasOwnProperty.call(IfThenElse, "else") &&
  !Object.prototype.hasOwnProperty.call(IfThenElse, "if") &&
  !Object.prototype.hasOwnProperty.call(IfThenElse, "then");

export const ifElseErrorMessages = {
  multipleElse: "`IfElse` middleware reported: there can only be one `else` object.",
  wrongElsePosition: "`IfElse` middleware reported: the `else` object must be provided as final argument.",
};

/**
 * This middleware determines which other middlewares are run based on one or
 * more specified conditions.
 * Every condition is specified with an `if` key.  In case the condition is
 * true, the middlewares specified in the `then` key are run.
 * If none of the `if` conditions is true, the middlewares specified in an
 * `else` key, if present, are run.
 *
 * @param first - The first parameter must be an `{ if: ..., then: ... }`
 * object.
 *
 * @param rest - The non-first parameters are either additional
 * `{ if: ..., then: ... }` objects or a final `{ else: ... }` object.
 *
 * @remarks
 * Each `if` key specifies a condition that is either true or false.
 * Conditions are either a key name or a function that takes the Etl Context
 * and returns a Boolean value.
 * Specifying a key name is identical to specifying the following function:
 * `ctx => ctx.getString('KEY')`
 *
 * The `then` and `else` keys take either one middleware, or an array of zero
 * or more middlewares.
 *
 * @example
 * The following snippet uses different conditions to determine the age
 * category that a person belongs to:
 *
 * ```ts
 * fromJson([
 *   { id: 'johndoe', age: 12 },
 *   { id: 'janedoe', age: 32 },
 *   ...
 * ]),
 * addIri({
 *   prefix: prefix.person,
 *   content: 'id',
 *   key: '_person',
 * }),
 * ifElse({
 *   if: ctx => ctx.getNumber('age') < 12,
 *   then: triple('_person', a, def.Child),
 * }, {
 *   if: ctx => {
 *     const age = ctx.getNumber('age')
 *     return age >= 12 && age < 20
 *   },
 *   then: triple('_person', a, def.Teenager),
 * }, {
 *   if: ctx => {
 *     const age = ctx.getNumber('age')
 *     return age >= 20 && age < 65
 *   },
 *   then: triple('_person', a, def.Adult),
 * }, {
 *   else: triple('_person', a, def.Senior),
 * }),
 * ```
 *
 * @example
 * The following snippet either asserts data about persons or data about
 * organizations, and uses an `ifElse` to make the conditional determination
 * on which assertion to make:
 *
 * ```ts
 * fromJson([
 *   { first: 'John', last: 'Doe' },
 *   { name: 'Triply' },
 * ]),
 * ifElse({
 *   if: 'name',
 *   then:
 *     couples(iri(prefix.id, 'name'), [
 *       [a, sdo.Organization],
 *       [sdo.name, 'name'],
 *     ]),
 * }, {
 *   else: [
 *     concat({
 *       content: ['first', 'last'],
 *       separator: '-',
 *       key: 'name',
 *     }),
 *     couples(iri(prefix.id, 'name'), [
 *       [a, sdo.Person],
 *       [sdo.givenName, 'first'],
 *       [sdo.familyName, 'last'],
 *     ]),
 *   ],
 * }),
 * ```
 */
export default function ifElse(first: IfThen, ...rest: Array<IfThen | Else>): MiddlewareList<unknown> {
  // handling of error messsages
  const IfThenElseMerged = [first, ...rest];
  const elseCount = IfThenElseMerged.filter((arg) => isElse(arg)).length;
  const e = getErr(new Error());
  e.setCallSite(getCurrentLine({ frames: 3 }));

  if (elseCount > 1) {
    return [
      async () => {
        e.setMessage(ifElseErrorMessages.multipleElse);
        throw e;
      },
    ];
  } else if (elseCount === 1 && !isElse(IfThenElseMerged.at(-1)!)) {
    return [
      async () => {
        e.setMessage(ifElseErrorMessages.wrongElsePosition);
        throw e;
      },
    ];
  }

  const middlewares: MiddlewareList = [];
  const sentinelKey = `$sentinel-${randomHash()}`;
  const setSentinelMw = (key: string): Middleware => {
    return addMwCallSiteToError(
      (ctx, next) => {
        ctx.record[key] = true;
        return next();
      },
      { sourceFuncName: "_setSentinelMw" },
    );
  };
  // first if check
  middlewares.push(when(first.if, [setSentinelMw(sentinelKey), first.then]));

  // other if else
  for (const ifThenOrElse of rest) {
    if (isElse(ifThenOrElse)) {
      middlewares.push(whenNot(sentinelKey, ifThenOrElse.else));
    } else {
      middlewares.push(when(ifThenOrElse.if, whenNot(sentinelKey, setSentinelMw(sentinelKey), ifThenOrElse.then)));
    }
  }
  // remove sentinel keys at the end
  middlewares.push(
    when(sentinelKey, async (ctx, next) => {
      unset(ctx.record, sentinelKey);
      return next();
    }),
  );
  return [
    addMwCallSiteToError(
      (_ctx, next) => {
        return next();
      },
      {
        sourceFuncName: "_ifElse",
      },
    ),
    middlewares,
  ];
}
