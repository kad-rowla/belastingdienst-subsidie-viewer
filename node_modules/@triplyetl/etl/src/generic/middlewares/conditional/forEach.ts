import { flattenDeep } from "lodash-es";
import { Key, Middleware, MiddlewareList } from "../../index.js";
import { addMwCallSiteToError } from "../../../utils/index.js";
import { assertIsArray, assertIsObject } from "../../../utils/asserts.js";
import { composeMiddlewares, DispatchFn } from "../../Etl.js";

/**
 * Runs the same middlewares for each object in a list of objects.
 *
 * @remarks
 * Notice that this middleware can only loop over *objects*.  It cannot loop
 * over other types like strings or numbers.
 *
 * @param key - A key that stores a list of objects.
 *
 * @param middleware - One or more middlewares that are run for each object.
 *
 * @throws An error if `key` does not exist in the current Etl Record.
 *
 * @example
 * The following example iterates over a list of objects that represent names:
 *
 * ```ts
 * fromJson([
 *   {
 *     id: '123',
 *     names: [
 *       { first: 'John', last: 'Doe' },
 *       { first: 'J.', last: 'Doe' },
 *     ]
 *   },
 * ]),
 * forEach('names', [
 *   concat({
 *     content: ['first', 'last'],
 *     separator: ' ',
 *     key:' '_name',
 *   }),
 *   triple(iri(prefix.person, $parent.id), foaf.name, '_name'),
 * ]),
 * ```
 *
 * This results in the following linked data assertions:
 *
 * ```turtle
 * id:123 foaf:name 'John Doe', 'J. Doe'.
 * ```
 *
 * @see If you want to loop over primitive types like strings or numbers, use
 * {@link iri} and {@link literal} instead.
 */
export default function <R = unknown>(key: Key, ...middlewaresArray: MiddlewareList<R>): Middleware<R> {
  const middlewares = flattenDeep(middlewaresArray).filter((m) => !!m) as Middleware[];
  let dispatch: DispatchFn;
  return addMwCallSiteToError(
    async (ctx, next) => {
      if (!dispatch) {
        for (const mw of middlewares) {
          // Setting whenMwDepth value for logging indentation for MWs used in forEach
          if (!mw.whenMwDepth) mw.whenMwDepth = 0;
          mw.whenMwDepth++;
          if (mw.callSite) {
            ctx.app["touchedMiddlewares"].set(mw.callSite, false);
          }
        }
        dispatch = composeMiddlewares({ middlewares: middlewares, context: ctx });
      }
      const origRecord = { ...ctx.record };
      ctx.app["currentMwIndices"].push(0); // we're one level deeper, so add to stack of middlewares
      if (ctx.app["debugTrace"] && !ctx.app["errorTrace"]) {
        await dispatch(ctx.app["debugTraceToDispatchOpts"]());
      } else {
        const array = ctx.getAny(key);
        assertIsArray(array, `Expected key '${key}' to reference an array value. Got '${typeof array}'`);
        for (let i = 0; i < array.length; i++) {
          const item = array[i];
          assertIsObject(item, "Expected array item to be an object");
          await dispatch({
            store: ctx.store,
            record: {
              ...item,
              $index: i,
              $parent: origRecord,
              $root: origRecord.$root || origRecord,
            },
          });
        }
      }
      // we're done looping, so remove last item of middleware stack
      ctx.app["currentMwIndices"].pop();
      // when we running a debug trace, we shouldnt go back to a 'lower level' in the middeware tree:
      // we dont have the correct record for that
      if (!ctx.app["debugTrace"]) {
        await next(origRecord);
      }
    },
    {
      sourceFuncName: "_forEach",
    }
  );
}
