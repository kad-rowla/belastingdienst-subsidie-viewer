import chai from "chai";
import { addValue, concat } from "../../../../ratt/middlewares/transformations/index.js";
import { getEtlForTestingNoExtractor } from "../../../../ratt/__tests__/getEtlForTesting.js";
import forEach from "../forEach.js";
import chaiAsPromised from "chai-as-promised";
import { Etl, fromJson, Middleware } from "../../../index.js";

const assert = chai.assert;
const expect = chai.expect;
chai.use(chaiAsPromised);
const data = {
  names: [
    { first: "John", last: "Doe" },
    { first: "J.", last: "Doe" },
  ],
};

let i = 0;
describe("conditional.forEach ", () => {
  it("should run the documentation example", () => {
    return getEtlForTestingNoExtractor([
      fromJson(data, { selectors: "names.first" }),
      forEach("names", [
        concat({
          content: ["first", "last"],
          separator: " ",
          key: "_name",
        }),
        async (ctx, next) => {
          assert.doesNotThrow(() => ctx.getString("_name"));
          assert.equal(ctx.getString("_name"), `${data.names[i].first} ${data.names[i].last}`);
          i++;
          return next();
        },
      ]),
    ]).run();
  });

  it("should fix https://issues.triply.cc/issues/6537", () => {
    return getEtlForTestingNoExtractor([
      /**
       * @see https://issues.triply.cc/issues/6537#note-13
       * I think a missing key should still throw
       */
      // fromJson([{'a': [{'b': 'c'}]}, {'a': []}, {}]),
      fromJson([{ a: [{ b: "c" }] }, { a: [] }]),
      forEach("a", addValue({ key: "test", content: true }), async (ctx, _) => {
        assert.doesNotThrow(() => ctx.getBoolean("test"));
      }),
    ]).run();
  });

  it("should throw when key does not exist", () => {
    return expect(
      getEtlForTestingNoExtractor([
        fromJson(data),
        forEach("NONAMES", addValue({ key: "test", content: true })),
        async (ctx, next) => {
          assert.throws(() => ctx.getBoolean("test"));
          return next();
        },
      ]).run(),
    ).to.eventually.be.rejected;
  });

  it("where mw is not calling next", async function () {
    const app = new Etl({ defaultGraph: "https://default/" });
    app.use(fromJson([{ array: [{ a: true }, { b: true }, { a: true }], c: "c" }]));
    const aKeyChecker = checkCountMw({ message: "key a", expectedCount: 2, selector: "a" });
    const bKeyChecker = checkCountMw({ message: "key b", expectedCount: 0, selector: "b" });
    const cKeyChecker = checkCountMw({ message: "key c", expectedCount: 1, selector: "c" });
    const lastMwChecker = checkCountMw({ message: "lastkey", expectedCount: 0 });
    app.use(
      forEach(
        "array",
        aKeyChecker.mw,
        async () => {
          // Stop the chain
        },
        bKeyChecker.mw,
      ),
      cKeyChecker.mw,
      async () => {
        // Stop the chain
      },
      lastMwChecker.mw,
    );
    await app.run();
    aKeyChecker.countIsValid();
    bKeyChecker.countIsValid();
    cKeyChecker.countIsValid();
    lastMwChecker.countIsValid();
  });
  it("with a deep hierarchy", async function () {
    const app = new Etl({ defaultGraph: "https://default/" });
    app.use(fromJson([{ level0: [{ level1: [{ level2: [{ a: true }, { b: true }] }] }] }]));
    const deepestLevelChecker = checkCountMw({ message: "key a [1]", expectedCount: 2 });
    app.use(forEach("level0", forEach("level1", forEach("level2", deepestLevelChecker.mw))));
    await app.run();
    deepestLevelChecker.countIsValid();
  });
});

function checkCountMw(opts: { message?: string; expectedCount: number; selector?: string }): {
  mw: Middleware;
  countIsValid: () => void;
} {
  let count = 0;
  return {
    mw: async (ctx, next) => {
      if (!opts.selector || ctx.isNotEmpty(opts.selector)) {
        count++;
      }
      return next();
    },
    countIsValid: () => {
      expect(count).to.equal(opts.expectedCount, opts.message);
    },
  };
}
