import chai from "chai";
import chaiAsPromised from "chai-as-promised";
import { forEach, fromJson } from "../../index.js";
import { addSkolemIri, addValue } from "../../../../ratt/index.js";
import { getEtlForTesting, getEtlForTestingNoExtractor } from "../../../../ratt/__tests__/getEtlForTesting.js";
import ifElse, { ifElseErrorMessages } from "../ifElse.js";
import Etl from "../../../Etl.js";

chai.use(chaiAsPromised);
const assert = chai.assert;
const expect = chai.expect;

describe("conditional.ifElse ", () => {
  it("should fail on runtime with an If statements, multiple Else statements", () => {
    return expect(
      getEtlForTesting(
        ifElse(
          { if: "foo", then: addValue({ key: "test1", content: true }) },
          { else: addValue({ key: "test2", content: true }) },
          { else: addValue({ key: "test3", content: true }) },
        ),
      ).run(),
    ).to.eventually.be.rejectedWith(ifElseErrorMessages.multipleElse);
  });

  it("should work with 1 If statements, no Else statements", () => {
    return getEtlForTesting([
      ifElse({ if: "foo", then: addValue({ key: "test", content: true }) }),
      async (ctx, next) => {
        assert.doesNotThrow(() => ctx.getBoolean("test"));
        return next();
      },
    ]).run();
  });

  it("should work with 3 If statements, stopping at the second If, no Else statements", () => {
    return getEtlForTesting([
      ifElse(
        { if: "bar", then: addValue({ content: true, key: "testBar" }) },
        { if: "foo", then: addValue({ content: true, key: "testFoo" }) },
        { if: "aap", then: addValue({ content: true, key: "testAap" }) },
      ),
      async (ctx, next) => {
        assert.throws(() => ctx.getBoolean("testBar"));
        assert.doesNotThrow(() => ctx.getBoolean("testFoo"));
        assert.throws(() => ctx.getBoolean("testAap"));
        return next();
      },
    ]).run();
  });

  it("should work when the ifElse is used more than once", () => {
    return getEtlForTesting([
      ifElse({ if: "foo", then: addValue({ key: "foo1", content: true }) }),
      ifElse({ if: "foo", then: addValue({ key: "foo2", content: true }) }),
      ifElse(
        { if: "foo", then: addValue({ key: "foo3", content: true }) },
        { else: addValue({ key: "no-foo3", content: true }) },
      ),
      ifElse(
        { if: "bar", then: addValue({ key: "no-foo4", content: true }) },
        { else: addValue({ key: "foo4", content: true }) },
      ),
      ifElse(
        { if: (_) => true, then: addValue({ key: "foo5", content: true }) },
        { else: addValue({ key: "no-foo5", content: true }) },
      ),
      ifElse(
        { if: (_) => false, then: addValue({ key: "no-foo6", content: true }) },
        { else: addValue({ key: "foo6", content: true }) },
      ),
      async (ctx, next) => {
        for (let i = 1; i <= 6; i++) {
          assert.doesNotThrow(() => ctx.getBoolean(`foo${i}`));
        }
        for (let i = 4; i < 6; i++) {
          assert.throws(() => ctx.getBoolean(`no-foo${i}`));
        }
        return next();
      },
    ]).run();
  });

  it("should work with 3 If statements and Else statements, Ifs do not fulfill", () => {
    return getEtlForTestingNoExtractor([
      fromJson({ foo: "bar" }, { skipEnrich: true }),
      ifElse(
        { if: "bar", then: addValue({ key: "not-foo1", content: true }) },
        {
          if: (ctx) => ctx.getString("foo") === "Joe Doe",
          then: addValue({ key: "not-foo2", content: true }),
        },
        { if: "aap", then: addValue({ key: "not-foo3", content: true }) },
        { else: addValue({ key: "foo1", content: true }) },
      ),
      async (ctx, next) => {
        assert.doesNotThrow(() => ctx.getBoolean("foo1"));
        for (let i = 1; i <= 3; i++) {
          assert.throws(() => ctx.getBoolean(`no-foo${i}`));
        }
        // Test if sentinal is gone and remaining 1 key is still foo => bar:
        assert.deepEqual(["foo", "foo1"], Object.keys(ctx.record));
        chai.assert.equal("bar", ctx.getString("foo"));
        return next();
      },
    ]).run();
  });

  it("should fail if Else statements is not the final argument", () => {
    return expect(
      getEtlForTesting(
        ifElse(
          { if: "foo", then: addValue({ key: "test1", content: true }) },
          { else: addValue({ key: "test2", content: true }) },
          { if: "foo", then: addValue({ key: "test3", content: true }) },
        ),
      ).run(),
    ).to.eventually.be.rejectedWith(ifElseErrorMessages.wrongElsePosition);
  });
  it("should work with nested forEach middleware (#262)", async function () {
    const etl = new Etl();
    etl.use(
      fromJson([{ aap: [{}] }]),
      addValue({ content: "noot", key: "_test1" }),
      ifElse(
        {
          if: "_test1",
          then: forEach(
            "aap",
            addSkolemIri({
              key: "_test2",
            }),
          ),
        },
        {
          else: forEach(
            "aap",
            addSkolemIri({
              key: "_test2",
            }),
          ),
        },
      ),
      async (ctx, next) => {
        expect(Object.keys(ctx.record).length).to.equal(4);
        expect(Object.keys(ctx.record)).to.deep.equal(["aap", "$recordId", "$environment", "_test1"]);
        return next();
      },
    );
    await etl.run();
  });
});
