import chai from "chai";
import chaiAsPromised from "chai-as-promised";
import { getEtlForTesting, getEtlForTestingNoExtractor } from "../../../../ratt/__tests__/getEtlForTesting.js";
import { addSkolemIri, addValue } from "../../../../ratt/middlewares/transformations/index.js";
import { default as _switch } from "../switch.js";
import { forEach, fromJson } from "../../index.js";
import Etl from "../../../Etl.js";

chai.use(chaiAsPromised);
const assert = chai.assert;
const expect = chai.expect;

describe("conditional.switch ", () => {
  it("should fail with empty arguments", () =>
    assert.throw(() => getEtlForTesting(_switch("foo", [])), "`switch` middleware reported: no Cases provided."));

  it("should fail with no CaseWhen statements, just 1 Else", () =>
    assert.throw(
      () => getEtlForTesting(_switch("foo", addValue({ key: "test", content: true }))),
      "`switch` middleware reported: no Cases provided, only a Default.",
    ));

  it("should fail with no CaseWhen statements, multiple Else", () =>
    assert.throw(
      () =>
        getEtlForTesting(
          _switch("foo", addValue({ key: "test1", content: true }), addValue({ key: "test2", content: true })),
        ),
      "Only one default value allowed in a switch statement.",
    ));

  it("should work with 1 CaseWhen statements, no Else statements", () => {
    return getEtlForTesting([
      _switch("foo", ["bar", addValue({ key: "test", content: true })]),
      async (ctx, next) => {
        assert.doesNotThrow(() => ctx.getBoolean("test"));
        assert.isTrue(ctx.getBoolean("test"));
        return next();
      },
    ]).run();
  });

  it("should work with 3 CaseWhen statements, stopping at the second CaseWhen, no Else statements", () => {
    return getEtlForTestingNoExtractor([
      fromJson({ foo: "bar" }, { skipEnrich: true }),
      _switch(
        "foo",
        ["foo", addValue({ key: "testFoo", content: true })],
        ["bar", addValue({ key: "testBar", content: true })],
        ["aap", addValue({ key: "testAap", content: true })],
      ),
      async (ctx, next) => {
        assert.doesNotThrow(() => ctx.getBoolean("testBar"));
        assert.throws(() => ctx.getBoolean("testFoo"));
        assert.throws(() => ctx.getBoolean("testAap"));
        // Test if sentinal is gone and foo i still 'bar':
        assert.deepEqual(["foo", "testBar"], Object.keys(ctx.record));
        assert.equal("bar", ctx.getString("foo"));
        return next();
      },
    ]).run();
  });

  it("should work with 3 CaseWhen statements and Else statements, no CaseWhen matches", () => {
    return getEtlForTestingNoExtractor([
      fromJson({ foo: "bar" }, { skipEnrich: true }),
      _switch(
        "foo",
        ["aap", addValue({ key: "aap", content: true })],
        ["noot", addValue({ key: "noot", content: true })],
        ["mies", addValue({ key: "mies", content: true })],
        addValue({ key: "wim", content: true }),
      ),
      async (ctx, next) => {
        assert.doesNotThrow(() => ctx.getBoolean("wim"));
        assert.throws(() => ctx.getBoolean("aap"));
        assert.throws(() => ctx.getBoolean("noot"));
        assert.throws(() => ctx.getBoolean("mies"));
        // Test if sentinal is gone and foo i still 'bar':
        assert.deepEqual(["foo", "wim"], Object.keys(ctx.record));
        assert.equal("bar", ctx.getString("foo"));
        return next();
      },
    ]).run();
  });
  it("should work with nested forEach middleware (#262)", async function () {
    const etl = new Etl();
    etl.use(
      fromJson([{ aap: [{}] }]),
      addValue({ content: "noot", key: "_test1" }),
      _switch("_test1", [
        "noot",
        forEach(
          "aap",
          addSkolemIri({
            key: "_test2",
          }),
        ),
      ]),
      async (ctx, next) => {
        expect(Object.keys(ctx.record).length).to.equal(4);
        expect(Object.keys(ctx.record)).to.deep.equal(["aap", "$recordId", "$environment", "_test1"]);
        return next();
      },
    );
    await etl.run();
  });
});
