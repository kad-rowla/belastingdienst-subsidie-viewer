import { Etl } from "../../index.js";
import { QueryInfo, QuerySourceGetter } from "../../locations/sources/savedQuery.js";

export class SparqlResultsXmlIterator implements AsyncIterator<string>, AsyncIterable<string> {
  private nextLink?: string;
  private firstLink!: string;
  private $queryInfo?: QueryInfo & { headers?: Record<string, string> };
  private runs = 0;

  public constructor(
    private app: Etl,
    private query: QuerySourceGetter,
  ) {}

  protected async queryInfo() {
    if (!this.$queryInfo) {
      const queryInfo = await this.query.getQueryInfo(this.app);
      const headers: Record<string, string> = {};
      if (queryInfo.triplyDb.getConfig().token) {
        headers.Authorization = `Bearer ${queryInfo.triplyDb.getConfig().token}`;
      }
      if (queryInfo.triplyDb.getConfig().httpProxy)
        (global as any).GLOBAL_AGENT.HTTP_PROXY = queryInfo.triplyDb.getConfig().httpProxy;
      if (queryInfo.triplyDb.getConfig().httpsProxy)
        (global as any).GLOBAL_AGENT.HTTPS_PROXY = queryInfo.triplyDb.getConfig().httpsProxy;
      this.$queryInfo = { ...queryInfo, headers };
      this.firstLink = `${await this.$queryInfo.query.getRunLink()}.srx`;
    }
    return this.$queryInfo;
  }

  private async fetch() {
    const info = await this.queryInfo();
    const url = this.nextLink ?? this.firstLink;

    return fetch(url, { headers: info.headers }).then(async (response) => {
      this.runs++;
      return { xml: await response.text(), headers: response.headers };
    });
  }

  public async next() {
    return this.fetch().then((response) => {
      const done = this.nextLink === undefined && this.runs > 1;
      this.parseLink(response.headers);
      return {
        value: response.xml,
        done,
      };
    });
  }

  public [Symbol.asyncIterator]() {
    return this;
  }

  private parseLink(headers: Headers): void {
    this.nextLink = undefined;
    if (!headers.get("link")) return;
    headers
      .get("link")
      ?.split(",")
      .map((link) => {
        const parts = link.split(";").map((p) =>
          p
            .trim()
            .replace(/rel="(first|next|previous)"/, "$1")
            .replace(/^</, "")
            .replace(/>$/, ""),
        );
        switch (parts[1]) {
          case "next":
            this.nextLink = parts[0];
        }
      });
  }
}
