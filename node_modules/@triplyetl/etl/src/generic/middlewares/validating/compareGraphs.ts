import chalk from "chalk";
import { castArray, get, has } from "lodash-es";
import { BaseQuad, BlankNode, Quad } from "@triplydb/data-factory/Terms.js";
import {
  getGraphBlankNodes,
  getQuadsWithBlankNodes,
  hashTerms,
  isomorphic,
  ITermHash,
  uniqGraph,
} from "rdf-isomorphic";
import { everyTerms, someTerms } from "rdf-terms";
import { Etl, Middleware } from "../../index.js";
import { addMwCallSiteToError } from "../../../utils/index.js";
import { quadsToString } from "../../../utils/index.js";
import { SourceGetter, StringSourceInfo } from "../../locations/sources/index.js";
import { getQuads, LoadRdfOptions } from "../sources/loadRdf.js";
import { getFactory } from "@triplydb/data-factory";
import { once } from "lodash-es";
const dataFactory = once(() => getFactory({ skipValidation: Etl.skipValidation }));

export interface CompareGraphsOptions {
  key?: string;
  throw?: boolean;
  terminate?: boolean;
}

// TODO @DocumentationTeam: add TS doc comment here
export default (
  oneOrMoreSources: SourceGetter<"statements", StringSourceInfo> | SourceGetter<"statements", StringSourceInfo>[],
  opts?: LoadRdfOptions & CompareGraphsOptions,
): Middleware => {
  return addMwCallSiteToError(
    async (ctx, next) => {
      const quads = await getQuads(ctx, oneOrMoreSources, {
        defaultGraph: opts?.defaultGraph,
        contentType: opts?.contentType,
      });
      const receivedQuads = deSkolimizeQuads(quads);
      const expectedQuads = deSkolimizeQuads(ctx.store.getQuads({}));
      const isIsomorphic = isomorphic(receivedQuads, expectedQuads);

      const report: IsomorphicReport = {
        isomorphic: isIsomorphic,
        quads: {
          missing: isIsomorphic ? undefined : getNonBlankDiff([...receivedQuads], [...expectedQuads]),
          additional: isIsomorphic ? undefined : getNonBlankDiff([...expectedQuads], [...receivedQuads]),
        },
        blanknodes: { missing: undefined, additional: undefined },
        report: "",
      };

      if (!isIsomorphic) {
        const { received: additionalBnodes, expected: missingBnodes } = getBnodeDiff(
          [...receivedQuads],
          [...expectedQuads],
        );
        report.blanknodes = {
          missing: Object.keys(missingBnodes).length ? missingBnodes : undefined,
          additional: Object.keys(additionalBnodes).length ? additionalBnodes : undefined,
        };
        report.report = getReport(report);
        const sources = await ctx["_registerSources"](castArray(oneOrMoreSources), "statements");
        const names = sources.map((source) => `'${source.name}'`);
        ctx.app.error(`${report.report}\n`);
        const msg = `${chalk.red(`Graphs for ${chalk.bold(names.join(" & "))} are not isomorphic.`)}`;
        if (opts?.throw ?? false) throw new Error(msg);
        else ctx.app.error(msg);

        if (opts?.terminate ?? true) process.exit(1);
      }

      if (opts?.key) {
        ctx.record[opts.key] = report;
      }
      return next();
    },
    { sourceFuncName: "_compareGraphs" },
  );
};

type Quad_Type = BaseQuad["subject"] | BaseQuad["object"] | BaseQuad["graph"];
const deSkolimizeNode = <T extends Quad_Type>(node: T): T | BlankNode => {
  if ((node.termType !== "NamedNode" && node.termType !== "DefaultGraph") || node.value === "") return node;
  let url;
  try {
    url = new URL(node.value);
  } catch (e) {
    throw new Error(`compareGraphs middleware reported: Could not make value '${node.value}' into an URL`);
  }
  return url.pathname.startsWith("/.well-known/genid/") ? dataFactory().blankNode() : node;
};
const deSkolimizeQuads = (quads: Quad[]): Quad[] => {
  return quads.map((quad) => {
    return dataFactory().quad(
      quad.subject.termType === "Quad" ? deSkolimizeQuads([quad.subject])[0] : deSkolimizeNode(quad.subject),
      quad.predicate,
      quad.object.termType === "Quad" ? deSkolimizeQuads([quad.object])[0] : deSkolimizeNode(quad.object),
      deSkolimizeNode(quad.graph),
    );
  });
};

export interface IsomorphicReport {
  isomorphic: boolean;
  quads: {
    missing: Quad[] | undefined;
    additional: Quad[] | undefined;
  };
  blanknodes: {
    missing: Record<string, Quad[]> | undefined;
    additional: Record<string, Quad[]> | undefined;
  };
  report: string;
}

export const isIsomorphicReport = (value: any): value is IsomorphicReport => {
  return (
    value &&
    typeof value === "object" &&
    has(value, "isomorphic") &&
    has(value, "quads.missing") &&
    has(value, "quads.additional") &&
    has(value, "blanknodes.missing") &&
    has(value, "blanknodes.additional") &&
    typeof get(value, "isomorphic") === "boolean"
  );
};

const getReport = (report: IsomorphicReport): string => {
  const msg: string[] = [];
  if (report.quads.missing && report.quads.missing.length > 0) {
    msg.push(
      chalk.underline.grey("Missing Quads (that don't contain Blank Nodes):"),
      quadsToString(report.quads.missing),
    );
  }

  if (report.blanknodes.missing && Object.entries(report.blanknodes.missing).length > 0) {
    msg.push(
      chalk.underline.grey("Missing BlankNode Patterns:"),
      Object.entries(report.blanknodes.missing)
        .map(([_, quads]) => quadsToString(quads))
        .join("\n"),
    );
  }

  if (report.quads.additional && report.quads.additional.length > 0) {
    msg.push(
      chalk.underline.grey("Additional Quads (that don't contain Blank Nodes):"),
      quadsToString(report.quads.additional),
    );
  }

  if (report.blanknodes.additional && Object.entries(report.blanknodes.additional).length > 0) {
    msg.push(
      chalk.underline.grey("Additional BlankNode Patterns:"),
      Object.entries(report.blanknodes.additional)
        .map(([_, quads]) => quadsToString(quads))
        .join("\n"),
    );
  }

  return msg.join("\n").trim();
};

/**
 * Code from https://github.com/rubensworks/jest-rdf/blob/master/lib/matchers/toBeRdfIsomorphic.ts
 *
 * It can generate the resulting differences between two graphs
 */
function getNonBlankDiff<Q extends Quad = Quad>(a1: Q[], a2: Q[]): Q[] | undefined {
  const quads = a1.filter(
    (quad) => everyTerms(quad, (term) => term.termType !== "BlankNode") && a2.every((q2) => !q2.equals(quad)),
  );
  return quads.length ? quads : undefined;
}

/**
 * @param hash1 {blankNodeId: hashed predicate & object}
 * @param hash2 {blankNodeId: hashed predicate & object}
 * @returns Values that are in 'hash1' but are not found in 'hash2'
 */
function getDiff(hash1: ITermHash, hash2: ITermHash) {
  const diffed: string[] = [];

  const hash1Values = Object.values(hash1);
  const hash1ValuesCount: { [hashedValue: string]: number } = {};
  for (const val of hash1Values) hash1ValuesCount[val] = !hash1ValuesCount[val] ? 1 : hash1ValuesCount[val] + 1;

  const hash2Values = Object.values(hash2);
  const hash2ValuesCount: { [hashedValue: string]: number } = {};
  for (const val of hash2Values) hash2ValuesCount[val] = !hash2ValuesCount[val] ? 1 : hash2ValuesCount[val] + 1;

  /**
   * Figure out the Diff from left hand side:
   * if lefthand side doesnt exist in righthand side, add to diff
   * if if does exist,
   *  If the left hand side is greater than the right,
   *    add to diff & reduce count of that value (to account for duplicates)
   */
  const uniqueHash2Values = new Set(hash2Values);
  for (const key in hash1) {
    if (!uniqueHash2Values.has(hash1[key])) {
      diffed.push(key);
    } else {
      if (hash1ValuesCount[hash1[key]] > hash2ValuesCount[hash1[key]]) {
        diffed.push(key);
        hash1ValuesCount[hash1[key]]--;
      }
    }
  }
  return diffed;
}

function unGroundHashes<Q extends Quad = Quad>(graph: Q[]) {
  return hashTerms(uniqGraph(getQuadsWithBlankNodes(graph)), getGraphBlankNodes(graph), {})[1];
}

export function getBnodeDiff<Q extends Quad = Quad>(receivedQuads: Q[], expectedQuads: Q[]) {
  // Hash every term based on the signature of the quads if appears in.
  const ungroundedHashesA = unGroundHashes(expectedQuads);
  const ungroundedHashesB = unGroundHashes(receivedQuads);

  const blankA = uniqGraph(getQuadsWithBlankNodes(expectedQuads));
  const blankB = uniqGraph(getQuadsWithBlankNodes(receivedQuads));

  const expected: Record<string, Q[]> = {};
  const received: Record<string, Q[]> = {};

  for (const elem of getDiff(ungroundedHashesA, ungroundedHashesB)) {
    received[elem] = blankA.filter((quad) =>
      someTerms(quad, (term) => term.termType === "BlankNode" && term.value === elem.slice(2)),
    );
  }

  for (const elem of getDiff(ungroundedHashesB, ungroundedHashesA)) {
    expected[elem] = blankB.filter((quad) =>
      someTerms(quad, (term) => term.termType === "BlankNode" && term.value === elem.slice(2)),
    );
  }

  // const unreportedRecieved = Object.keys(ungroundedHashesA).filter((key) => !Object.keys(received).includes(key));
  // for (const elem of unreportedRecieved) {
  //   received[elem] = blankA.filter((quad) =>
  //     someTerms(quad, (term) => term.termType === "BlankNode" && term.value === elem.slice(2))
  //   );
  // }
  // const unreportedExpected = Object.keys(ungroundedHashesB).filter((key) => !Object.keys(expected).includes(key));
  // for (const elem of unreportedExpected) {
  //   expected[elem] = blankB.filter((quad) =>
  //     someTerms(quad, (term) => term.termType === "BlankNode" && term.value === elem.slice(2))
  //   );
  // }

  return {
    received,
    expected,
  };
}
