import { Destination } from "./index.js";
import path from "path";
import fs from "fs-extra";
import { LdExtensions, parsePath, WRITABLE_LD_EXTENSIONS } from "../../../utils/files.js";
import { Options as FileInfo } from "../../../utils/files.js";
import { FileSourceInfo } from "../sources/index.js";

export default function file(filename: string): Destination {
  // !!NB!!   Apart from the arguments passed to the destination, this scope
  //          must not contain any state. For example, the state must not
  //          depend on `app`, because a destination may be re-used across
  //          apps.
  let fileInfo: FileInfo<LdExtensions>;
  try {
    fileInfo = parsePath(filename, WRITABLE_LD_EXTENSIONS);
  } catch (e: any) {
    e.message = `Failed creating Destination.file(${filename}): ${e.message}`;
    throw e;
  }
  return {
    type: "file",
    fingerprint: `file://${path.resolve(filename)}`,
    fileInfo,
    registerSource,
    init: async (app) => {
      await fs.ensureDir(path.dirname(filename));
      const tmpDir = app.getTmpDir("destination-file");
      await fs.ensureDir(tmpDir);
    },
    postProcess: async (_app, filesWithMetaData) => {
      await fs.remove(filename);
      if (filesWithMetaData.length === 1) {
        const fileData = filesWithMetaData[0];
        if (fileData.remove) {
          await fs.move(fileData.filename, filename);
        } else {
          await fs.copy(fileData.filename, filename);
        }
      } else {
        const dirname = filename;
        await fs.ensureDir(dirname);
        await Promise.all(
          filesWithMetaData.map(async (fileData, i) => {
            if (fileData.remove) {
              await fs.move(fileData.filename, path.resolve(dirname, i.toString()));
            } else {
              await fs.copy(fileData.filename, path.resolve(dirname, i.toString()));
            }
          }),
        );
      }
    },
  };
}

export async function registerSource(source: FileSourceInfo) {
  return { filename: await source.getLocalPath(), remove: false };
}
