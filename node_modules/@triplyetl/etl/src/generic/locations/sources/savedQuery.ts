import TriplyDb, { AppConfig as TriplyDbConfig } from "@triply/triplydb/App.js";
import { requestConfigToFetchConfig, ReqOptsObj } from "@triply/triplydb/RequestHandler.js";
import {
  ContentType,
  FileSourceInfo,
  IterableSourceInfo,
  BooleanSourceInfo,
  SourceGetter,
  StringSourceInfo,
} from "./index.js";
import fs from "fs-extra";
import { getTriplyDb } from "../index.js";
import { resolveAndFilenamify, streamToString } from "../../../utils/files.js";
import { Readable } from "stream";
import { Models } from "@triply/utils";
import Query, { Binding, VariableValues } from "@triply/triplydb/Query.js";
import fetch from "cross-fetch";
import md5 from "md5";
import Etl from "../../Etl.js";
import { fileCache } from "@triply/triplydb/utils/cache.js";

export interface SavedQueryOptions {
  triplyDb?: TriplyDb | TriplyDbConfig;
  variables?: VariableValues;
  version?: number;
}

export interface QueryInfo {
  triplyDb: TriplyDb;
  query: Query;
  info: Models.Query;
  account: User | Org;
  cacheDir: string;
  opts?: SavedQueryOptions;
  accountName?: string;
  queryName: string;
}

// type QueryTypes = 'SELECT' | 'CONSTRUCT' | 'ASK' | 'DESCRIBE'

type QuerySourceInfo<C extends ContentType> = C extends "statements"
  ? StringSourceInfo & FileSourceInfo
  : C extends "string"
  ? StringSourceInfo & FileSourceInfo
  : C extends "records"
  ? IterableSourceInfo<Binding>
  : C extends "boolean"
  ? BooleanSourceInfo
  : never;

type SharedParameters = "id" | "name";
type SharedSourceInfo<C extends ContentType> = Pick<QuerySourceInfo<C>, SharedParameters>;
type PartialSourceInfo<C extends ContentType> = Omit<QuerySourceInfo<C>, SharedParameters>;

export const isQuerySourceGetter = (val: any): val is QuerySourceGetter => {
  return typeof val === "object" && Object.hasOwn(val, "$id") && val.$id == "QuerySourceGetter";
};

export type QuerySourceGetter = SourceGetter<"statements", QuerySourceInfo<"statements">> &
  SourceGetter<"string", QuerySourceInfo<"string">> &
  SourceGetter<"records", QuerySourceInfo<"records">> &
  SourceGetter<"boolean", BooleanSourceInfo> & { $id: string; getQueryInfo: (app: Etl) => Promise<QueryInfo> };

// triplyDb, account, query, info, opts, accountName, queryName
export default function (queryName: string, opts?: SavedQueryOptions): QuerySourceGetter;
export default function (accountName: string, queryName: string, opts?: SavedQueryOptions): QuerySourceGetter;
export default function (
  accountOrQueryName: string,
  queryNameOrOpts?: string | SavedQueryOptions,
  optionalOpts?: SavedQueryOptions,
): QuerySourceGetter {
  const getQueryInfo = async (app: Etl): Promise<QueryInfo> => {
    let accountName: string | undefined = app["_defaultAccount"];
    let queryName: string;
    let opts: SavedQueryOptions | undefined = optionalOpts;

    if (typeof queryNameOrOpts === "string") {
      queryName = queryNameOrOpts;
      accountName = accountOrQueryName;
    } else {
      queryName = accountOrQueryName;
      if (queryNameOrOpts) {
        opts = queryNameOrOpts;
      }
    }
    const triplyDb = getTriplyDb(app, opts?.triplyDb);
    const account = await triplyDb.getAccount(accountName);
    const query = await account.getQuery(queryName);
    if (typeof opts?.version === "number") await query.useVersion(opts.version);
    const info = await query.getInfo();

    if (info.requestConfig === undefined) {
      throw new Error("No versions found for this saved query: " + info.link);
    }
    return { triplyDb, account, query, info, opts, accountName, queryName, cacheDir: "unknown" };
  };
  const getQueryType = async (app: Etl) => {
    const queryInfo = await getQueryInfo(app);
    const cacheDir = app.getCacheDir(`source-query-string`);
    await fs.ensureDir(cacheDir);
    const queryString = await getString({ ...queryInfo, cacheDir });
    const parser = new sparqljs.Parser();
    const parsed = parser.parse(await queryString.getString());
    if (parsed.type !== "query") {
      throw new Error(`Unsupported query type '${parsed.type}'.`);
    }
    return parsed.queryType;
  };
  return {
    $id: "QuerySourceGetter",
    getQueryInfo,
    get: async function <C extends ContentType>(app: Etl, requestedContentType: C): Promise<QuerySourceInfo<C>[]> {
      const queryInfo = await getQueryInfo(app);
      queryInfo.cacheDir = app.getCacheDir(`source-query-${requestedContentType}`);
      await fs.ensureDir(queryInfo.cacheDir);

      let partialSourceInfo: PartialSourceInfo<ContentType>;
      switch (requestedContentType as ContentType) {
        case "string":
          partialSourceInfo = await getString(queryInfo);
          break;
        case "statements":
          partialSourceInfo = await getStatements(queryInfo);
          break;
        case "boolean":
          partialSourceInfo = await getBoolean(queryInfo);
          break;
        case "records":
          const queryType = await getQueryType(app);
          if (queryType === "ASK") {
            partialSourceInfo = await getBoolean(queryInfo);
          } else {
            partialSourceInfo = await getBindings(queryInfo);
          }
          break;
      }

      const apiUrl = (await queryInfo.triplyDb.getInfo()).apiUrl;

      const sharedSourceInfo: SharedSourceInfo<C> = {
        name: `${requestedContentType} of ${queryInfo.info.link}`,
        id: async () =>
          `TriplyDb-query-${requestedContentType}://${apiUrl}/${queryInfo.accountName}/${queryInfo.queryName}/${queryInfo.info.version}`,
      };
      let sourceInfo = {
        ...sharedSourceInfo,
        ...partialSourceInfo,
      } as QuerySourceInfo<C>;
      return [sourceInfo];
    },
  };
}
import sparqljs from "sparqljs";
import Org from "@triply/triplydb/Org.js";
import User from "@triply/triplydb/User.js";

async function getString(queryInfo: QueryInfo): Promise<PartialSourceInfo<"string">> {
  const { query, info, cacheDir } = queryInfo;
  // Doesn't make an additional request, as we have already made a request
  // to "info" and the query string is in that response
  const queryString = await query.getString(queryInfo.opts?.variables);
  const fingerprint = `${info.id}_${new Date(info.updatedAt).getTime()}`;

  return {
    compression: async () => undefined,
    mediaType: async () => "application/sparql-query",
    extension: async () => "rq",
    getStream: async () => Readable.from(queryString),
    getString: async () => queryString,
    getSize: async () => Buffer.from(queryString).byteLength,
    getLocalPath: async () => {
      await fs.ensureDir(cacheDir);
      const cacheFile = resolveAndFilenamify(cacheDir, fingerprint + `.rq`);
      if (!(await fs.pathExists(cacheFile))) {
        await fs.writeFile(cacheFile, queryString);
      }
      return cacheFile;
    },
  };
}

async function getBindings(queryInfo: QueryInfo): Promise<PartialSourceInfo<"records">> {
  const { query, cacheDir } = queryInfo;

  return {
    getAsyncIterable: async () =>
      query
        .results(queryInfo.opts?.variables, { cache: fileCache({ cacheDir: cacheDir, compression: "gz" }) })
        .bindings(),
    mediaType: async () => "application/json",
  };
}

async function getBoolean(queryInfo: QueryInfo): Promise<PartialSourceInfo<"boolean">> {
  const { query, cacheDir, opts } = queryInfo;
  return {
    getBoolean: async () => {
      return query
        .results(opts?.variables, { cache: fileCache({ cacheDir: cacheDir, compression: "gz" }) })
        .boolean()
        .toArray()
        .then((askResult) => {
          if (askResult.length === 0) {
            throw new Error("Unexpected empty ASK response.");
          }
          return askResult.pop() ?? false;
        });
    },
    mediaType: async () => "application/json",
  };
}

async function getFingerprint(url: string, triplyDb: TriplyDb, variables: SavedQueryOptions["variables"]) {
  const headResponse = await fetch(url + "/run", requestConfigToFetchConfig("HEAD", { app: triplyDb } as ReqOptsObj));
  const etag = headResponse.headers.get("etag");

  // Older versions may not return the etag. In that case, fall back to a random string, i.e. we're never properly caching the result
  return etag ? `${etag}_${md5(JSON.stringify(variables || ""))}` : String(Math.random());
}

async function getStatements(queryInfo: QueryInfo): Promise<PartialSourceInfo<"statements">> {
  const { triplyDb, cacheDir, query, opts } = queryInfo;

  const compression = "gz";
  const extension = "nt";

  let fingerprint: string | undefined;
  async function fetchToCacheWhenNeeded() {
    await fs.ensureDir(cacheDir);
    if (fingerprint === undefined) {
      fingerprint = await getFingerprint(await query.getApiUrl(), triplyDb, opts?.variables);
    }
    const cacheFile = resolveAndFilenamify(cacheDir, `${fingerprint}.${extension}.${compression}`);
    if (!(await fs.pathExists(cacheFile))) {
      // create a temporary file to make sure we don't create an illegal cache
      // when something goes wrong
      const tempCacheFile = cacheFile + ".part";
      await query
        .results(opts?.variables)
        .statements()
        .toFile(tempCacheFile, { compressed: true });
      await fs.rename(tempCacheFile, cacheFile);
    }
    return cacheFile;
  }

  async function getStream() {
    const cacheFile = await fetchToCacheWhenNeeded();
    return fs.createReadStream(cacheFile);
  }

  return {
    compression: async () => compression,
    mediaType: async () => "application/n-triples",
    extension: async () => extension,
    getStream: getStream,
    getString: async () => streamToString(await getStream(), compression),
    getSize: async () => {
      const file = await fetchToCacheWhenNeeded();
      const stat = await fs.stat(file);
      return stat.size;
    },
    getLocalPath: async () => fetchToCacheWhenNeeded(),
  };
}
