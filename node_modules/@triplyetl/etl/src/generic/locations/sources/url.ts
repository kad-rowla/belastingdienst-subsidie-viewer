import { SourceGetter } from "./index.js";
import fs from "fs-extra";

import fetch from "cross-fetch";
import { assertIsDefined, isNamedNode } from "../../../utils/asserts.js";
import { parsePath, resolveAndFilenamify, streamToString } from "../../../utils/files.js";
import { randomUUID } from "crypto";
import path from "path";
import HttpRequestHeaders from "../../../utils/HttpRequestHeaders.js";
import { NamedNode } from "@triplydb/data-factory/Terms.js";
import { Vocabulary } from "@triplyetl/vocabularies";

export interface UrlOptions extends RequestInit {
  headers?: HttpRequestHeaders & HeadersInit;
  method?: "GET" | "HEAD" | "POST" | "PUT" | "DELETE" | "CONNECT" | "OPTIONS" | "TRACE" | "PATCH";
}

export default function url(url: string | NamedNode | Vocabulary<string>, request?: UrlOptions): SourceGetter {
  return {
    get: async (app) => {
      let $url: string;
      if (isNamedNode(url)) {
        $url = url.value;
      } else if (typeof url !== "string") {
        $url = url.toString();
      } else {
        $url = url;
      }
      const cacheDir = app.getCacheDir("source-url");
      await fs.ensureDir(cacheDir);
      const tmpDir = app.getTmpDir("source-url");
      await fs.ensureDir(tmpDir);
      const uncachedFile = resolveAndFilenamify(tmpDir, $url + "-" + Math.random());

      async function getFingerPrintArray() {
        const lastModified = headResponse.headers.get("Last-Modified");
        const etag = headResponse.headers.get("ETag");
        return [$url, (lastModified || "").replace(/ /g, ""), etag || ""];
      }
      async function fetchWhenNeeded() {
        let localFile: string;
        const fingerPrintArray = await getFingerPrintArray();
        const canCache = !!fingerPrintArray[1] || !!fingerPrintArray[2];
        if (canCache) {
          localFile = resolveAndFilenamify(cacheDir, fingerPrintArray.join("-"));
        } else {
          localFile = uncachedFile;
        }
        if (!(await fs.pathExists(localFile))) {
          const tmpFile = path.resolve(tmpDir, randomUUID());
          const response = await fetch($url, { ...request, redirect: "follow" });
          if (!response.body) throw new Error(`Response of ${$url} did not return a valid body`);
          if (!response.ok) throw new Error(`${response.status} - ${response.statusText}`);
          const fileStream = fs.createWriteStream(tmpFile);
          await new Promise((resolve, reject) => {
            try {
              assertIsDefined(response.body, "");
              (response.body as any).pipe(fileStream).on("error", reject);
              (response.body as any).on("error", reject);
              fileStream.on("finish", resolve);
            } catch (e) {
              reject(e);
            }
          });
          // Make sure we only set the actual file after a full download
          await fs.rename(tmpFile, localFile);
        }
        return localFile;
      }

      const headResponse = await fetch($url, { ...request, redirect: "follow", method: "HEAD", body: null });
      const parsedUrl = new URL($url);
      const parsedPath = parsePath(parsedUrl.pathname);

      let compression: "gz" | undefined;
      if (parsedPath.compression) {
        compression = parsedPath.compression;
      } else if (headResponse.headers.get("Content-Encoding") === "application/gzip") {
        compression = "gz";
      }
      async function getStream() {
        const cacheFile = await fetchWhenNeeded();
        return fs.createReadStream(cacheFile);
      }
      return [
        {
          name: $url,
          id: async () => "url://" + (await getFingerPrintArray()).reverse().join("/"),
          compression: async () => compression,
          mediaType: async () => headResponse.headers.get("Content-Type") || undefined,
          extension: async () => parsedPath.extension || undefined,
          getStream,
          getString: async () => streamToString(await getStream(), compression),
          getSize: async () => {
            const cacheFile = await fetchWhenNeeded();
            const stat = await fs.stat(cacheFile);
            return stat.size;
          },
          getLocalPath: async () => fetchWhenNeeded(),
        },
      ];
    },
  };
}
