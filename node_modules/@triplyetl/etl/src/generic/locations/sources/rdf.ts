import TriplyDb, { AppConfig as TriplyDbConfig } from "@triply/triplydb/App.js";
import { Models } from "@triply/utils";
import { SourceGetter } from "./index.js";
import fs from "fs-extra";
import { getTriplyDb } from "../index.js";
import Multistream from "multistream";
import path from "path";
import Graph from "@triply/triplydb/Graph.js";
import Dataset from "@triply/triplydb/Dataset.js";
import filenamify from "filenamify";
import { get, sum } from "lodash-es";
import { Readable } from "stream";
import md5 from "md5";
import { resolveAndFilenamify, streamToString } from "../../../utils/files.js";
import { coerceToString, NamedNodeCompatibleType } from "../../../utils/index.js";
import { jwtDecode } from "jwt-decode";

export interface LoadRdfOptions {
  triplyDb?: TriplyDb | TriplyDbConfig;
  graphs?: NamedNodeCompatibleType[];
}
export default function rdf(datasetName: string): SourceGetter;
export default function rdf(accountName: string, datasetName: string): SourceGetter;
export default function rdf(accountName: string, datasetName: string, opts: LoadRdfOptions): SourceGetter;
export default function rdf(datasetName: string, opts: LoadRdfOptions): SourceGetter;
export default function rdf(
  accountOrDatasetName: string,
  datasetNameOrOpts?: string | LoadRdfOptions,
  optionalOpts?: LoadRdfOptions,
): SourceGetter {
  return {
    get: async (app) => {
      const cacheDir = app.getCacheDir("source-rdf");
      const tmpDir = app.getTmpDir("source-rdf");
      await fs.ensureDir(cacheDir);
      await fs.ensureDir(tmpDir);
      let accountName: string | undefined = app["_defaultAccount"];
      let datasetName: string;
      let opts: LoadRdfOptions | undefined = optionalOpts;
      if (typeof datasetNameOrOpts === "string") {
        datasetName = datasetNameOrOpts;
        if (accountOrDatasetName !== "me") {
          accountName = accountOrDatasetName;
        }
      } else {
        datasetName = accountOrDatasetName;
        if (datasetNameOrOpts) {
          opts = datasetNameOrOpts;
        }
      }
      const graphs = opts?.graphs?.map((thing) => coerceToString(thing));

      const triplyDb = getTriplyDb(app, opts?.triplyDb);

      let _datasetObj: Dataset;
      async function getDataset(): Promise<Dataset> {
        if (_datasetObj) return Promise.resolve(_datasetObj);
        return triplyDb
          .getAccount(accountName)
          .then((account) => account.getDataset(datasetName))
          .catch((e) => {
            app.error(`Failed to load dataset '${datasetName}'${accountName ? `for account '${accountName}'` : ""}.`);
            app.info(`Original error message:\n${(e as Error).message}`);
            const config = triplyDb.getConfig();
            if (config.token) {
              const decodedToken: Models.JwtPayload = jwtDecode(config.token);
              config.token = "[hidden]";
              if (decodedToken.iss && decodedToken.iss !== config.url) {
                app.info(
                  `This is probably an error in your TriplyDB configuration:\nthe url '${decodedToken.iss}' defined in your token does not match \nthe url '${config.url}' provided in the configuration.`,
                );
                process.exit();
              }
            }

            app.info(`This is probably an error in your TriplyDB configuration:`);
            for (const key of Object.keys(config)) {
              app.info(`  - ${key}: ${get(config, key)}`);
            }
            process.exit(1);
          });
      }

      const graphObjects: { [graphName: string]: Graph } = {};
      async function getGraphObject(graphName: string) {
        if (!graphObjects[graphName]) {
          const account = await triplyDb.getAccount(accountName);
          const dataset = await account.getDataset(datasetName);
          graphObjects[graphName] = await dataset.getGraph(graphName);
        }
        return graphObjects[graphName];
      }

      async function getId() {
        let id = `TriplyDb-rdf://${(await triplyDb.getInfo()).apiUrl}/${accountName}/${datasetName}`;
        if (graphs) {
          id += (
            await Promise.all(
              graphs.map(async (graphName) => {
                const graphObj = await getGraphObject(graphName);
                const info = await graphObj.getInfo();
                const modifiedTime = info.uploadedAt || info.importedAt;
                return `/${modifiedTime}/${graphName}`;
              }),
            )
          ).join("/");
        } else {
          const dataset = await getDataset();
          const info = await dataset.getInfo();
          id += `/${info.updatedAt}`;
        }
        return id;
      }

      async function fetchToCacheWhenNeeded() {
        let cacheFiles: string[] = [];
        if (graphs) {
          for (const graphName of graphs) {
            const graphObj = await getGraphObject(graphName);
            const info = await graphObj.getInfo();
            const modifiedTime = info.uploadedAt || info.importedAt;
            if (!modifiedTime) throw new Error("Missing graph date metadata");
            const unsafeFilename = `${info.id}_${new Date(modifiedTime).getTime()}_${graphName}.trig.gz`;
            const cacheFile = resolveAndFilenamify(cacheDir, unsafeFilename);
            if (!(await fs.pathExists(cacheFile))) {
              const tmpFile = resolveAndFilenamify(tmpDir, unsafeFilename);
              await graphObj.toFile(tmpFile, { compressed: true });
              // Make sure we only set the actual file after a full download
              await fs.rename(tmpFile, cacheFile);
            }
            cacheFiles.push(cacheFile);
          }
          return cacheFiles;
        } else {
          const dataset = await getDataset();
          const info = await dataset.getInfo();
          const unsafeFilename = `${info.id}_${new Date(info.updatedAt).getTime()}.trig.gz`;
          const cacheFile = resolveAndFilenamify(cacheDir, unsafeFilename);
          if (!(await fs.pathExists(cacheFile))) {
            const tmpFile = resolveAndFilenamify(tmpDir, unsafeFilename);
            await dataset.graphsToFile(tmpFile, { compressed: true });
            // Make sure we only set the actual file after a full download
            await fs.rename(tmpFile, cacheFile);
          }
          cacheFiles.push(cacheFile);
          return cacheFiles;
        }
      }

      const humanReadableFilename = filenamify(
        `${accountName}-${datasetName}-${opts?.graphs?.length || 1}graph.trig.gz`,
        {
          replacement: "-",
        },
      );
      async function getStream() {
        const cacheFiles = await fetchToCacheWhenNeeded();
        //Remove 'any' trick after @types/multistream is upgraded. Right now, we cant use it as a constructor
        let _Multistream: any = Multistream;
        return new _Multistream(cacheFiles.map((f) => fs.createReadStream(f))) as Readable;
      }
      const compression = "gz";
      return [
        {
          name: humanReadableFilename,
          id: getId,
          compression: async () => compression,
          mediaType: async () => "application/trig",
          extension: async () => "trig",
          getStream,
          getString: async () => streamToString(await getStream(), compression),
          getSize: async () => {
            // We could read the size from some response header I think, or by doing some HEAD request,
            // Considering we'll probably need the file locally anyway, lets just do a stat
            const cacheFiles = await fetchToCacheWhenNeeded();
            return sum(
              await Promise.all(
                cacheFiles.map(async (f) => {
                  const stat = await fs.stat(f);
                  return stat.size;
                }),
              ),
            );
          },
          getLocalPath: async () => {
            const cacheFiles = await fetchToCacheWhenNeeded();
            if (cacheFiles.length === 1) return cacheFiles[0];
            const localPath = path.resolve(
              cacheDir,
              `${accountName}-${datasetName}-concatenated-${md5(cacheFiles.join("-"))}.trig.gz`,
            );

            if (!(await fs.pathExists(localPath))) {
              const inputStream = await getStream();
              await new Promise((resolve, reject) => {
                inputStream
                  .on("error", reject)
                  .pipe(fs.createWriteStream(localPath))
                  .on("finish", resolve)
                  .on("error", reject);
              });
            }
            return localPath;
          },
        },
      ];
    },
  };
}
