import { SourceGetter } from "./index.js";
import fs from "fs-extra";
import { createReadStreamSafe, Options, parsePath, streamToString } from "../../../utils/files.js";
import mime from "mime";
import { castArray } from "lodash-es";
import { createHash } from "crypto";
export default function file(oneOrMorefilenames: string | string[]): SourceGetter {
  const parsedFilenames: [string, Options<string>][] = castArray(oneOrMorefilenames).map((f) => [f, parsePath(f)]);
  return {
    get: async (_app) => {
      return Promise.all(
        parsedFilenames.map(async (pair) => {
          const [filename, parsedFilename] = pair;
          if (!(await fs.pathExists(filename))) {
            throw new Error("File not found: " + filename);
          }
          const info = await fs.stat(filename);
          async function getStream() {
            return createReadStreamSafe(filename);
          }
          return {
            name: filename,
            id: async () => {
              if (info.size < 1024 * 1024 * 10) {
                // less than 10mb
                /**
                 * For small sizes, we want to use a more accurate ID based on the file content.
                 * This caters to a usecase where:
                 * - The file is used in the `loadRdf` middleware
                 * - The ID is used to create well-known IRIs
                 * - Where the file is committed to git, and used in the CI (i.e., the modified time will change)
                 *
                 * This creates different well-known IRIs for each run (and, in the context of this customer it invalidates a caching layer)
                 */
                const hasher = createHash("md5");
                hasher.update(await fs.readFile(filename));
                const md5 = hasher.digest("hex");
                return `file://${md5}/${filename}`;
              }
              return `file://${info.mtimeMs}/${info.size}/${filename}`;
            },
            compression: async () => parsedFilename.compression,
            mediaType: async () => mime.getType(parsedFilename.extension) || undefined,
            extension: async () => parsedFilename.extension,
            getStream,
            getString: async () => streamToString(await getStream(), parsedFilename.compression),
            getSize: async () => {
              const stat = await fs.stat(filename);
              return stat.size;
            },
            getLocalPath: async () => filename,
          };
        })
      );
    },
  };
}
