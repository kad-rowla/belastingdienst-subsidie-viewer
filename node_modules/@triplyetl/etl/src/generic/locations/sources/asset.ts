import Asset from "@triply/triplydb/Asset.js";
import TriplyDb, { AppConfig as TriplyDbConfig } from "@triply/triplydb/App.js";
import { SourceGetter } from "./index.js";
import fs from "fs-extra";
import { getTriplyDb } from "../index.js";
import { last } from "lodash-es";
import mime from "mime";
import { assertIsDefined } from "../../../utils/asserts.js";
import path from "path";
import { parsePath, streamToString } from "../../../utils/files.js";
import { randomUUID } from "crypto";
type AssetFilter = (name: string, asset: Asset) => boolean;

function getLastVersionInfo(asset: Asset) {
  const versionInfo = last(asset.getInfo().versions);
  //This should never happen. An asset always has a version
  if (!versionInfo) throw new Error("Asset does not have any versions");
  return versionInfo;
}

function getCacheFile(cacheDir: string, assetObject: Asset) {
  const versionInfo = getLastVersionInfo(assetObject);
  return path.resolve(cacheDir, `${versionInfo.id}_${assetObject.getInfo().assetName}`);
}

async function fetchToCacheWhenNeeded(cacheDir: string, tmpDir: string, asset: Asset) {
  const cacheFile = getCacheFile(cacheDir, asset);
  if (!(await fs.pathExists(cacheFile))) {
    const tmpFile = path.resolve(tmpDir, randomUUID());
    await asset.toFile(tmpFile);
    // Make sure we only set the actual file after a full download
    await fs.rename(tmpFile, cacheFile);
  }
  return cacheFile;
}

export interface AssetConfig {
  triplyDb?: TriplyDb | TriplyDbConfig;
  /**
   * Get a list of filtered assets for this dataset
   */
  filter?: AssetFilter;
  /**
   * Name of the asset
   */
  name?: string;
  /**
   * Version of the asset
   */
  version?: number;
}
/**
 * Get all dataset asset of the current account
 */
export default function asset(datasetName: string, opts?: AssetConfig): SourceGetter;
/**
 * Get all assets of a dataset
 */
export default function asset(accountName: string, datasetName: string, opts?: AssetConfig): SourceGetter;
export default function asset(
  accountNameOrDatasetName: string,
  datasetNameOrOpts?: string | AssetConfig,
  opts?: AssetConfig
): SourceGetter {
  return {
    get: async (app) => {
      let accountName: string | undefined = app["_defaultAccount"];
      let datasetName: string;
      let assetName: string | undefined;
      let assetFilter: AssetFilter | undefined;
      let version: number | undefined;

      if (typeof datasetNameOrOpts === "string") {
        accountName = accountNameOrDatasetName;
        datasetName = datasetNameOrOpts;
      } else {
        opts = datasetNameOrOpts;
        datasetName = accountNameOrDatasetName;
      }
      if (opts?.name) {
        assetName = opts?.name;
      }

      if (opts?.filter) {
        assetFilter = opts.filter;
      }
      if (opts?.version) {
        version = opts.version;
      }
      let triplydbConfig = opts?.triplyDb;
      const cacheDir = app.getCacheDir("source-asset");
      const tmpDir = app.getTmpDir("source-asset");

      await fs.ensureDir(cacheDir);
      await fs.ensureDir(tmpDir);

      const triplyDb = getTriplyDb(app, triplydbConfig);

      let assets: Asset[];
      const account = await triplyDb.getAccount(accountName);
      const dataset = await account.getDataset(datasetName);
      if (assetName) {
        assets = [await dataset.getAsset(assetName, version)];
      } else {
        //We want to complete list
        const allAssets = await dataset.getAssets().toArray();
        if (assetFilter) {
          assets = allAssets.filter((asset) => {
            assertIsDefined(assetFilter, "");
            return assetFilter(asset.getInfo().assetName, asset);
          });
        } else {
          assets = allAssets;
        }
      }

      const apiUrl = (await triplyDb.getInfo()).apiUrl;
      return assets.map((asset) => {
        async function getStream() {
          return fs.createReadStream(await fetchToCacheWhenNeeded(cacheDir, tmpDir, asset));
        }
        const name = asset.getInfo().assetName;
        const parsedFilename = parsePath(name);
        return {
          name: name,
          id: async () => `asset://${apiUrl}/${account}/${dataset}/${name}/${getLastVersionInfo(asset).id}`,
          compression: async () => parsedFilename.compression,
          mediaType: async () => mime.getType(parsedFilename.extension) || undefined,
          extension: async () => parsedFilename.extension,
          getStream,
          getString: async () => streamToString(await getStream(), parsedFilename.compression),
          getSize: async () => {
            const versionInfo = getLastVersionInfo(asset);
            return versionInfo.fileSize;
          },
          getLocalPath: async () => fetchToCacheWhenNeeded(cacheDir, tmpDir, asset),
        };
      });
    },
  };
}
