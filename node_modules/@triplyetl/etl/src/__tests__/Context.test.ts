import Etl from "../generic/Etl.js";
import { expect } from "chai";
import { forEach, fromJson } from "../generic/index.js";
import jpath from "../ratt/middlewares/assertions/term/jpath.js";
import { str } from "../ratt/index.js";
import { BlankNode, NamedNode } from "@triplydb/data-factory/Terms.js";
describe("Context", function () {
  describe("Getters", function () {
    it("getString should try to coerce to a string", async function () {
      const app = new Etl();
      const coercionToString = { a: 12345, b: true, c: false, d: 1.25, e: "98765", f: "hello" };
      app.use(fromJson(coercionToString, { skipEnrich: true }));
      app.use(async (ctx, _next) => {
        for (let key in coercionToString) {
          expect(typeof ctx.getString(key)).to.equal("string");
          expect(typeof ctx.getString(jpath(`$.${key}`))).to.equal("string");
        }
      });
      await app.run();
    });
    it("getNumber should try to coerce to a number", async function () {
      const app = new Etl();
      const coercionToNumber = { a: 12345, b: "98765" };
      app.use(fromJson(coercionToNumber, { skipEnrich: true }));
      app.use(async (ctx, _next) => {
        for (let key in coercionToNumber) {
          expect(typeof ctx.getNumber(key)).to.equal("number");
          expect(typeof ctx.getNumber(jpath(`$.${key}`))).to.equal("number");
        }
      });
      await app.run();
    });
    it("getBoolean should try to coerce to a boolean", async function () {
      const app = new Etl();
      const coercionToBoolean = { a: "true", b: "fAlSe", c: false, d: "0", e: "1", f: 0, g: 1 };
      app.use(fromJson(coercionToBoolean, { skipEnrich: true }));
      app.use(async (ctx, _next) => {
        for (let key in coercionToBoolean) {
          expect(typeof ctx.getBoolean(key)).to.equal("boolean");
          expect(typeof ctx.getBoolean(jpath(`$.${key}`))).to.equal("boolean");
        }
      });
      await app.run();
    });

    it("getLiteral should try to coerce to a Literal", async function () {
      const app = new Etl();
      const coercionToLiteral = {
        a: "true",
        b: "false",
        c: false,
        d: 12345,
        e: {
          termType: "Literal",
          value: "isLiteral",
          language: "nl",
          datatype: "https://schema.org/Text",
          something: "dfdf",
        },
      };
      app.use(fromJson(coercionToLiteral));
      app.use(async (ctx, _next) => {
        for (let key in coercionToLiteral) {
          const gottenLiteral = ctx.getLiteral(key, str("en"));
          expect("termType" in gottenLiteral).to.equal(true);
          expect(gottenLiteral.termType).to.equal("Literal");
          expect(gottenLiteral.datatype).to.include(/langString/);
          expect(gottenLiteral.language).to.equal("en");
          expect(typeof gottenLiteral.value).to.equal("string");
        }
      });
      await app.run();
    });
    it("getLiteral 'opts' should override previous 'language' or 'datatype' values", async () => {
      const app = new Etl();
      const jsonErroneousLiteral = {
        a: {
          termType: "Literal",
          value: "isLiteral",
          language: "nl",
          datatype: "https://schema.org/Text",
          something: "dfdf",
        },
        b: {
          termType: "Literal",
          value: "isLiteral",
          datatype: "https://schema.org/Text",
          something: "shouldn't remove this property",
        },
      };
      app.use(fromJson(jsonErroneousLiteral));
      app.use(async (ctx, _next) => {
        const changeDatatype = ctx.getLiteral("a", ctx.store.iri("https://schema.org/new-data-type"));

        expect("termType" in changeDatatype).to.equal(true);
        expect(changeDatatype.termType).to.equal("Literal");
        expect(changeDatatype.language).to.equal("");
        expect(typeof changeDatatype.value).to.equal("string");

        const changeLanguage = ctx.getLiteral("a", str("en"));
        expect("termType" in changeLanguage).to.equal(true);
        expect(changeLanguage.termType).to.equal("Literal");
        expect(changeLanguage.language).to.equal("en");
        expect(changeLanguage.datatype).to.contain(/langString/);
        expect(typeof changeLanguage.value).to.equal("string");

        const removeSomethingProperty = ctx.getLiteral("b");
        expect("termType" in removeSomethingProperty).to.equal(true);
        expect(removeSomethingProperty.termType).to.equal("Literal");
        expect(typeof removeSomethingProperty.value).to.equal("string");
        expect((removeSomethingProperty as any).something).to.equal("shouldn't remove this property");
      });
      await app.run();
    });
    it("getIri should try to coerce to an Iri", async function () {
      const app = new Etl();
      const coercionToIri = {
        a: "https://example.com/true",
        b: "https://example.com/false",
        c: "https://example.com/12345",
        d: { termType: "NamedNode", value: "http://ex.com/isIri-aka-NamedNode" },
      };
      app.use(fromJson(coercionToIri, { skipEnrich: true }));
      app.use(async (ctx, _next) => {
        for (let key in coercionToIri) {
          const gottenNamedNode: NamedNode = ctx.getIri(key);
          expect("termType" in gottenNamedNode).to.equal(true);
          expect(gottenNamedNode.termType).to.equal("NamedNode");
          expect(typeof gottenNamedNode.value).to.equal("string");
        }
      });
      await app.run();
    });
    it("getBlankNode should try to coerce to a BlankNode", async function () {
      const app = new Etl();
      const coercionToBlankNode = {
        a: "true",
        b: "false",
        c: "12345",
        d: { termType: "BlankNode", value: "is a BlankNode" },
      };
      app.use(fromJson(coercionToBlankNode, { skipEnrich: true }));
      app.use(async (ctx, _next) => {
        for (let key in coercionToBlankNode) {
          const gottenBlankNode: BlankNode = ctx.getBnode(key);
          expect("termType" in gottenBlankNode).to.equal(true);
          expect(gottenBlankNode.termType).to.equal("BlankNode");
          expect(typeof gottenBlankNode.value).to.equal("string");
        }
      });
      await app.run();
    });
    it("getNumber should try to coerce and fail, throwing errors", async function () {
      const app = new Etl();
      const coercionToNumberThrowErrors = {
        a: "http://12345",
        b: [{ termType: "BlankNode", value: "blank" }],
        c: { 98765: "number" },
      };
      const regExNumber = /^(Could not coerce)(.+)(to the desired type 'number')$/i;
      app.use(fromJson(coercionToNumberThrowErrors, { skipEnrich: true }));
      app.use(async (ctx, _next) => {
        for (const key in coercionToNumberThrowErrors) {
          expect(() => ctx.getNumber(key)).to.throw(regExNumber);
          expect(() => ctx.getNumber(jpath(`$.${key}`))).to.throw(regExNumber);
        }
      });
      await app.run();
    });
    it("getArray should do a runtime type check/conversion on all the elements of the array before returning", async function () {
      const app = new Etl();
      const testGetArrayJson = {
        str: ["true", "false", "12345", { termType: "Literal", value: "isIri aka NamedNode" }],
        num: ["12345", { termType: "Literal", value: "1565" }, { termType: "Literal", value: "1234" }],
        bool: ["true", "fAlse", "1", { termType: "Literal", value: "0" }, { termType: "Literal", value: 0 }],
        arr: [
          ["hello", 122],
          [true, "wOrld"],
          [{ termType: "Literal", value: false }, "world"],
        ],
        nestedArr: [
          [
            ["hello", 122],
            [true, "wOrld"],
          ],
          [[{ termType: "Literal", value: false }], ["hello", "world"]],
        ],
      };
      app.use(fromJson(testGetArrayJson, { skipEnrich: true }));
      app.use(async (ctx, _next) => {
        // Strings
        expect(
          ctx.getArray("str", "string").every((element: unknown) => {
            return typeof element === "string";
          })
        ).to.equal(true);
        expect(
          ctx.getArray(jpath("$.str"), "string").every((element: unknown) => {
            return typeof element === "string";
          })
        ).to.equal(true);
        // Numbers
        expect(
          ctx.getArray("num", "number").every((element: unknown) => {
            return typeof element === "number";
          })
        ).to.equal(true);
        expect(
          ctx.getArray(jpath("$.num"), "number").every((element: unknown) => {
            return typeof element === "number";
          })
        ).to.equal(true);
        // Booleans
        expect(
          ctx.getArray("bool", "boolean").every((element: unknown) => {
            return typeof element === "boolean";
          })
        ).to.equal(true);
        expect(
          ctx.getArray(jpath("$.bool"), "boolean").every((element: unknown) => {
            return typeof element === "boolean";
          })
        ).to.equal(true);
        // 1 Deep Nested Array
        expect(
          ctx.getArray("arr", { array: "string" }).every((element: unknown) => {
            if (Array.isArray(element)) {
              return element.every((el) => typeof el === "string");
            } else return false;
          })
        ).to.equal(true);
        expect(
          ctx.getArray(jpath("$.arr"), { array: "string" }).every((element: unknown) => {
            if (Array.isArray(element)) {
              return element.every((el) => typeof el === "string");
            } else return false;
          })
        ).to.equal(true);
        // 2 Deep Nested Array
        expect(
          ctx.getArray("nestedArr", { array: { array: "string" } }).every((element: unknown) => {
            if (Array.isArray(element)) {
              return element.flatMap((el) => el).every((el) => typeof el === "string");
            } else return false;
          })
        ).to.equal(true);
        expect(
          ctx.getArray(jpath("$.nestedArr"), { array: { array: "string" } }).every((element: unknown) => {
            if (Array.isArray(element)) {
              return element.flatMap((el) => el).every((el) => typeof el === "string");
            } else return false;
          })
        ).to.equal(true);
      });
      await app.run();
    });

    it("should get parent and root", async () => {
      const app = new Etl();
      const data = {
        L1: [{ L2: [{ L3: "A" }] }],
      };
      app.use(
        fromJson(data, { skipEnrich: true }),
        forEach(
          "L1",
          async (ctx, next) => {
            expect(ctx.getParent()).deep.equal(data);
            expect(ctx.getRoot()).deep.equal(data);
            return next();
          },
          forEach("L2", async (ctx, next) => {
            expect(ctx.getParent()).deep.equal(data.L1[0]);
            expect(ctx.getRoot()).deep.equal(data);
            return next();
          })
        )
      );
      await app.run();
    });
  });
});
