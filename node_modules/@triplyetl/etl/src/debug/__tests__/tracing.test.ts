//external dependencies
import chai from "chai";
import chaiAsPromised from "chai-as-promised";
import { Etl, fromJson } from "../../generic/index.js";
import { forEach, when } from "../../generic/middlewares/conditional/index.js";
import traceEnd from "../traceEnd.js";
import traceStart from "../traceStart.js";
import { EtlError } from "../../utils/Error.js";
import { addValue, literal, literals, str, triple } from "../../ratt/index.js";
import { a, xsd } from "@triplyetl/vocabularies";

chai.use(chaiAsPromised);
const expect = chai.expect;

describe("Tracing", function () {
  describe("traceStart and traceEnd middlewares", function () {
    it("Should handle foreach in between", async function () {
      const pipeline = new Etl({ defaultGraph: "" });
      pipeline.use(fromJson([{ b: [{ a: 1 }] }]), traceStart(), forEach("b", []), traceEnd());
      await expect(pipeline.run()).to.eventually.be.rejectedWith("TraceDebug");
    });
    it("Should work in a foreach", async function () {
      const pipeline = new Etl({ defaultGraph: "" });
      pipeline.use(fromJson([{ b: [{ a: 1 }] }]), forEach("b", traceStart(), traceEnd()));
      await expect(pipeline.run()).to.eventually.be.rejectedWith("TraceDebug");
    });
    it("Should handle forgetting to set traceEnd", async function () {
      const pipeline = new Etl({ defaultGraph: "" });
      pipeline.use(fromJson([{ b: [{ a: 1 }] }, { c: [{ d: 1 }] }]), traceStart(), forEach("b", []));
      await expect(pipeline.run()).to.eventually.be.rejectedWith(
        "Trace info already exist. Did you forget to add a traceEnd",
      );
    });
    it("Should handle forgetting to set traceStart", async function () {
      const pipeline = new Etl({ defaultGraph: "" });
      pipeline.use(fromJson([{ b: [{ a: 1 }] }, { c: [{ d: 1 }] }]), traceEnd(), forEach("b", []));
      await expect(pipeline.run()).to.eventually.be.rejectedWith("No trace info found.");
    });
    it("Should handle trace info at different levels (1)", async function () {
      const pipeline = new Etl({ defaultGraph: "" });
      pipeline.use(fromJson([{ b: [{ a: 1 }] }, { c: [{ d: 1 }] }]), traceStart(), forEach("b", [traceEnd()]));
      await expect(pipeline.run()).to.eventually.be.rejectedWith(/at a different level than the/);
    });
    it("Should handle trace info at different levels (2)", async function () {
      const pipeline = new Etl({ defaultGraph: "" });
      pipeline.use(fromJson([{ b: [{ a: 1 }] }, { c: [{ d: 1 }] }]), forEach("b", [traceStart()]), traceEnd());
      await expect(pipeline.run()).to.eventually.be.rejectedWith(/at a different level than the/);
    });
  });
  describe("Trace on Error", function () {
    const fooGood: { [key: string]: any } = Array.from({ length: 1000 }, () => ({ foo: "bar", bar: ["foo", "bar"] }));
    const fooData = fooGood.concat({ fooo: "bar", bar: ["foo", "bar"] });
    it("Should correctly update traceError property on each new record", async function () {
      const etl = new Etl();
      // @ts-expect-error this property is readonly
      etl["createErrorTrace"] = true;
      etl.use(fromJson(fooData));
      etl.use(function testErrorTracing(ctx, next) {
        const currentMwIndex = ctx["traceError"].fromMwIndex.shift() || 0;
        const prevMwIndex = currentMwIndex - 1;
        const middlewareList = ctx.app["middlewares"];
        const currentMiddlewareName = middlewareList[currentMwIndex];
        const prevMiddlewareName = middlewareList[prevMwIndex];
        expect(prevMiddlewareName.sourceFuncName).to.equal("_fromJson");
        expect(currentMiddlewareName.name).to.equal("testErrorTracing");
        expect(ctx["traceError"].recordId).to.equal(ctx.recordId);
        return next();
      });
      await etl.run();
    });
    it("Should update EtlError object with traceInfo on an error from a middleware", async function () {
      const etl = new Etl();
      // @ts-expect-error this property is readonly
      etl["createErrorTrace"] = true;
      etl.use(fromJson(fooData));
      etl.use(when("fooo", triple(a, a, literal("foo", xsd.string))));
      try {
        await etl.run();
      } catch (_e) {
        expect(_e instanceof EtlError).to.be.true;
        const error = _e as EtlError;
        expect(!!error.trace).to.be.true;
        expect(error.trace?.isTraceError).to.be.true;
        expect(error.trace?.isTraceDebug).to.be.false;
        expect(error.recordId).to.equal(Array.from(fooData).length);
        expect(error.message).to.equal("The key 'foo' is missing, unable to get a Literal.");
      }
    });
    it("Should traceError correctly when used in conjuntion with the trace middleware", async function () {
      const etl = new Etl();
      // @ts-expect-error this property is readonly
      etl["createErrorTrace"] = true;
      etl.use(fromJson(fooData));
      etl.use(when("fooo", traceStart(), triple(a, a, literal("foo", xsd.string)), traceEnd()));
      try {
        await etl.run();
      } catch (_e) {
        expect(_e instanceof EtlError).to.be.true;
        const error = _e as EtlError;
        expect(!!error.trace).to.be.true;
        expect(error.trace?.isTraceError).to.be.true;
        expect(error.trace?.isTraceDebug).to.be.false;
        expect(error.recordId).to.equal(Array.from(fooData).length);
        expect(error.message).to.equal("The key 'foo' is missing, unable to get a Literal.");
      }
    });
    it("Should correctly track diff of any 'record' data added between the start of the record and the error", async function () {
      const etl = new Etl();
      // @ts-expect-error this property is readonly
      etl["createErrorTrace"] = true;
      etl.use(fromJson(fooData));
      etl.use(
        addValue({ key: "beforeError", content: str("someValueAdded") }),
        when("fooo", triple(a, a, literal("foo", xsd.string))),
      );
      try {
        await etl.run();
      } catch (_e) {
        expect(_e instanceof EtlError).to.be.true;
        const error = _e as EtlError;
        expect(!!error.trace).to.be.true;
        expect(error.trace?.isTraceError).to.be.true;
        expect(error.trace?.isTraceDebug).to.be.false;
        const addedValue = error.trace?.recordDiff.find((diff) => diff.added);
        expect(!!addedValue).to.be.true;
        expect(addedValue?.value)
          .to.include("beforeError")
          .and.to.include("someValueAdded");
      }
    });
    it("Should correctly track diff of any 'Quad' data added between the start of the record and the error", async function () {
      const etl = new Etl();
      // @ts-expect-error this property is readonly
      etl["createErrorTrace"] = true;
      etl.use(fromJson(fooData));
      etl.use(
        triple(a, a, literal(str("addLiteral"), xsd.string)),
        when("fooo", triple(a, a, literal("foo", xsd.string))),
      );
      try {
        await etl.run();
      } catch (_e) {
        expect(_e instanceof EtlError).to.be.true;
        const error = _e as EtlError;
        expect(!!error.trace).to.be.true;
        expect(error.trace?.isTraceError).to.be.true;
        expect(error.trace?.isTraceDebug).to.be.false;
        const addedValue = error.trace?.quadsDiff.find((diff) => diff.added);
        expect(!!addedValue).to.be.true;
        expect(addedValue?.value)
          .to.include("<http://www.w3.org/1999/02/22-rdf-syntax-ns#type>")
          .and.to.include("addLiteral");
      }
    });
    it("Should trace correctly on error that occurs inside a forEach", async function () {
      const etl = new Etl();
      // @ts-expect-error this property is readonly
      etl["createErrorTrace"] = true;
      etl.use(fromJson(fooData));
      etl.use(
        when("fooo", addValue({ key: "newKey", content: "someInfo" })),
        when("fooo", forEach("bar", triple(a, a, literals(str("shoud throw an error"), xsd.string)))),
      );
      try {
        await etl.run();
      } catch (_e) {
        expect(_e instanceof EtlError).to.be.true;
        const error = _e as EtlError;
        expect(!!error.trace).to.be.true;
        expect(error.trace?.isTraceError).to.be.true;
        expect(error.trace?.isTraceDebug).to.be.false;
        expect(error.recordId).to.equal(Array.from(fooData).length);
        expect(error.message).to.equal("Expected array item to be an object");
      }
    });
  });
});
