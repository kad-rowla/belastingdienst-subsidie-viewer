import * as diff from "diff";
import { toJSON as toJsonFlatted } from "flatted";
import { Context } from "vm";
import { Middleware } from "../generic/index.js";
import { getErr, TraceInfo } from "../utils/Error.js";
import { addMwCallSiteToError, safeStringify } from "../utils/index.js";

// TODO @DocumentationTeam: add TS doc comment here
export default function traceEnd(): Middleware {
  return addMwCallSiteToError(
    async function _traceEnd(ctx) {
      if (!ctx["traceInfo"]) {
        throw new Error("No trace info found. Did you call traceEnd() without calling traceStart() first?");
      }
      if (ctx["traceInfo"].recordId !== ctx.recordId) {
        throw new Error(
          "The trace information seems to cover more than 1 record. Make sure you call traceStart and traceEnd for the same record",
        );
      }
      if (ctx.app["currentMwIndices"].length !== ctx["traceInfo"].fromMwIndex.length) {
        throw new Error(
          "It seems you use the 'traceStart' middleware at a different level than the 'traceEnd' middleware. This is not supported.",
        );
      }
      throw getErr().setMessage("TraceDebug").setTraceInfo(getTraceInfo(ctx, "debug"));
    },
    { sourceFuncName: "_traceEnd" },
  );
}

type GetTraceInfo<T extends "debug" | "error"> = T extends "debug" ? TraceInfo : TraceInfo | undefined;
export function getTraceInfo<T extends "debug" | "error">(ctx: Context, traceType: T): GetTraceInfo<T> {
  const traceProperty = traceType === "debug" ? "traceInfo" : "traceError";
  // The traceErrorInfo only exists if we run the ETL. Not all errors come from running the ETL.
  if (traceType === "error" && !ctx[traceProperty]) return undefined as GetTraceInfo<T>;
  const recordDiff = diff.diffJson(
    JSON.parse(safeStringify(ctx[traceProperty].record)),
    JSON.parse(safeStringify(ctx.record)),
  );
  const storeDiff = diff.diffLines(ctx[traceProperty].quads, ctx.store.toNquadsString());
  return {
    recordDiff: recordDiff,
    quadsDiff: storeDiff,
    fromMwIndex: ctx[traceProperty].fromMwIndex,
    recordAtStart: toJsonFlatted(ctx[traceProperty].record),
    quadsAtStart: ctx[traceProperty].quads,
    isTraceDebug: traceType === "debug",
    isTraceError: traceType === "error",
  };
}
