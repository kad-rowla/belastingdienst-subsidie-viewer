var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
import { Store, getFactory } from '@triplydb/data-factory';
import { newEngine } from '@triplydb/speedy-memory';
import { rdf, sh } from '@triplyetl/vocabularies';
import { Validator as ValidatorBase } from 'shacl-engine';
import Report from './Validator/Report.js';
import targetsRq from './Queries/targets.rq.js';
import SPARQLConstraints from './Validator/ConstraintComponent/SPARQLConstraint.js';
import DatatypeAnyURIRq from './Queries/DatatypeAnyURI.rq.js';
import sh_sh from './Utilities/shacl-shacl.ttl.js';
import Writer from './Validator/Report/Writer.js';
import loadSPARQLTargets from './Utilities/loadSPARQLTargets.js';
import { PathList } from 'grapoi';
import TermMap from '@rdfjs/term-map';
import getDataFactoryWithDataset from './Utilities/getDataFactoryWithDataset.js';
const $SIGNATURE = '@triplyetl/shacl/Validate';
export class ModelValidationError extends Error {
    constructor(message, writer) {
        super(message);
        this.writer = writer;
    }
}
export default class Validator extends ValidatorBase {
    /**
     * Constructor for the SHACL Validation Engine
     *
     * @param model a RdfJs compatible Store that holds the SHACL shapes (the model)
     * @param opts
     */
    constructor(model, opts) {
        var _a;
        const factory = (_a = opts === null || opts === void 0 ? void 0 : opts.factory) !== null && _a !== void 0 ? _a : getDataFactoryWithDataset();
        Validator.fixForIssue6223(model);
        super(model, { factory });
        this.model = model;
        this.opts = opts;
        this.$signature = $SIGNATURE;
        this.engine = opts === null || opts === void 0 ? void 0 : opts.engine;
    }
    rebuild() {
        this.shapesPtr = new PathList({ dataset: this.model, factory: this.factory });
        this.shapes = new TermMap();
        const shapePtrs = [
            ...this.shapesPtr.hasOut([sh.targetClass]),
            ...this.shapesPtr.hasOut([sh.targetNode]),
            ...this.shapesPtr.hasOut([sh.targetObjectsOf]),
            ...this.shapesPtr.hasOut([sh.targetSubjectsOf]),
            ...this.shapesPtr.hasOut([rdf.type], [sh.NodeShape]),
            ...this.shapesPtr.hasOut([rdf.type], [sh.PropertyShape])
        ];
        for (const shapePtr of shapePtrs) {
            this.shape(shapePtr);
        }
    }
    get data() {
        if (this._data === undefined) {
            throw new Error('Before accessing the internal dataset, you need to set it first.');
        }
        return this._data;
    }
    set data(data) {
        this._data = data;
    }
    /**
     * @see https://issues.triply.cc/issues/6223
     */
    static fixForIssue6223(dataset) {
        const factory = getFactory();
        dataset
            .getObjects(null, sh.path, null)
            .filter((node) => node.termType === 'NamedNode')
            .filter((node) => {
            return dataset.getObjects(node, sh.alternativePath, null).length > 0 || dataset.getObjects(node, sh.inversePath, null).length > 0 || dataset.getObjects(node, sh.oneOrMorePath, null).length > 0 || dataset.getObjects(node, sh.zeroOrMorePath, null).length > 0 || dataset.getObjects(node, sh.zeroOrOnePath, null).length > 0;
        })
            .forEach((node) => {
            const blankNode = factory.blankNode();
            dataset.getQuads({ subject: node }).forEach((quad) => {
                dataset.addQuad(factory.quad(blankNode, quad.predicate, quad.object, quad.graph));
            });
            dataset.getSubjects(sh.path, node, null).forEach((s) => {
                dataset.removeQuad(factory.quad(s, sh.path, node));
                dataset.addQuad(factory.quad(s, sh.path, blankNode));
            });
        });
    }
    /**
     * @param data The data must have the following structure:
     *  - dataset: An RDF/JS DatasetCore object that contains the quads. (required)
     *  - terms: An iterable object of RDF/JS Terms that will be used as initial focus nodes. (optional)
     * @param shapes The shapes object is optional, but if given must have the following structure:
     *  - terms: An iterable object of RDF/JS Terms that refers to the initial set of shapes. (optional) This doesn't limit the nested shapes.
     * @returns a SHACL Validation Report object
     */
    // @ts-expect-error Our validate method is not compatible with the super
    async validate(data, shapes) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (((_b = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.allowSPARQLTargets) !== null && _b !== void 0 ? _b : true) && (((_d = (_c = this.shapesPtr.in([sh.select])) === null || _c === void 0 ? void 0 : _c.ptrs.length) !== null && _d !== void 0 ? _d : 0) > 0)) {
            const size = this.model.size;
            await loadSPARQLTargets({ shapes: this.model, data: data.dataset });
            if (size !== this.model.size) {
                this.rebuild();
            }
        }
        if (!((_f = (_e = this.opts) === null || _e === void 0 ? void 0 : _e.skipShaclShaclValidaton) !== null && _f !== void 0 ? _f : false)) {
            await Validator.validateModel(this.model, this.factory);
        }
        if (data.dataset !== undefined) {
            this.data = data.dataset;
        }
        let terms;
        if (shapes !== undefined) {
            if (!Array.isArray(shapes))
                shapes = [shapes];
            terms = [{ terms: shapes }];
        }
        const report = new Report(await super.validate(Object.assign(Object.assign({}, data), { dataset: (_g = data.dataset) !== null && _g !== void 0 ? _g : this.model }), terms), { model: this.model });
        const store = new Store(this.model.getQuads({}));
        if (this._data !== undefined) {
            store.addQuads(this._data.getQuads({}));
        }
        const engine = (_j = (_h = this.opts) === null || _h === void 0 ? void 0 : _h.engine) !== null && _j !== void 0 ? _j : newEngine(store);
        await this.validateAnyURI(engine, report);
        report.SPARQLConstraintConforms = await SPARQLConstraints({ report, store, engine, factory: this.factory });
        return report;
    }
    /**
     * Validate models against Shacl-Shacl
     *
     * @param model a Store containing the shapes
     * @param factory an optional DataFactory
     * @throws ModelValidationError
     */
    static async validateModel(model, factory) {
        // first: validate the Shape itself:
        await (new ValidatorBase(sh_sh, { factory: factory !== null && factory !== void 0 ? factory : getDataFactoryWithDataset() })).validate({ dataset: model })
            .then(async (report) => {
            if (!report.conforms) {
                throw new ModelValidationError('The model is not a valid SHACL model.', Writer.fromValidationReport(report.dataset, model));
            }
        });
    }
    /**
     * @see https://git.triply.cc/triply/etl/-/issues/263
     */
    async validateAnyURI(engine, report) {
        var _a, e_1, _b, _c;
        var _d, _e;
        const rq = DatatypeAnyURIRq;
        try {
            for (var _f = true, _g = __asyncValues(await engine.select(rq)), _h; _h = await _g.next(), _a = _h.done, !_a; _f = true) {
                _c = _h.value;
                _f = false;
                const binding = _c;
                if (binding.anyURI !== undefined) {
                    try {
                        // eslint-disable-next-line no-new
                        new URL(binding.anyURI.value);
                    }
                    catch (e) {
                        report.addValidationResult({
                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                            focusNode: binding.focusNode,
                            resultMessages: [this.factory.literal(e.message)],
                            // @ts-expect-error we know this is always a correct value
                            resultSeverity: (_e = (_d = binding.resultSeverity) === null || _d === void 0 ? void 0 : _d.value) !== null && _e !== void 0 ? _e : 'Violation',
                            sourceConstraintComponent: sh.DatatypeConstraintComponent,
                            resultPath: binding.resultPath,
                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                            values: [binding.anyURI],
                            sourceShape: binding.propertyShape
                        });
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_f && !_a && (_b = _g.return)) await _b.call(_g);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    static async getTargets(opts) {
        var _a, e_2, _b, _c;
        const targets = new Set();
        const store = new Store(opts.shapes.getQuads({}).concat(opts.data === undefined ? [] : opts.data.getQuads({})));
        try {
            for (var _d = true, _e = __asyncValues(await newEngine(store).select(targetsRq)), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {
                _c = _f.value;
                _d = false;
                const binding = _c;
                if (binding.shape === undefined || binding.target === undefined) {
                    throw new Error("Expected a binding for 'shape' and for 'target'");
                }
                targets.add({ shape: binding.shape, node: binding.target });
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) await _b.call(_e);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return targets;
    }
    static isValidator(obj) {
        if (typeof obj !== 'object')
            return false;
        if (obj === null)
            return false;
        if (!Object.hasOwn(obj, '$signature'))
            return false;
        // @ts-expect-error we now know this property does exists
        return obj.$signature === $SIGNATURE;
    }
}
//# sourceMappingURL=Validator.js.map