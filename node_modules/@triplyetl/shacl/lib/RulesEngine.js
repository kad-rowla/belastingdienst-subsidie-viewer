/* eslint-disable @typescript-eslint/no-non-null-assertion */
// https://www.w3.org/TR/shacl-af/#rules
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
import { Store, getFactory } from '@triplydb/data-factory';
import { newEngine } from '@triplydb/speedy-memory';
import { sh } from '@triplyetl/vocabularies';
import { getQuery as getTargetsQuery } from './Queries/targets.rq.js';
import Validator from './Validator.js';
import shapesWithRulesRq from './Queries/shapesWithRules.rq.js';
import SPARQLRuleRq from './Queries/SPARQLRule.rq.js';
import { parseAndInjectVariablesIntoQuery } from '@triply/utils/sparqlVarUtils.js';
import loadSPARQLTargets from './Utilities/loadSPARQLTargets.js';
const defaultRulesEngineOptions = {
    maxIterations: 0,
    errorOnMaxIterations: 'none',
    data: new Store(),
    factory: getFactory(),
    debug: false
};
const $SIGNATURE = '@triplyetl/shacl/RulesEngine';
export default class RulesEngine {
    constructor(model, opts) {
        var _a, _b;
        this.model = model;
        this.$signature = $SIGNATURE;
        // The data graph
        this.data = new Store();
        this.opts = Object.assign(Object.assign({}, defaultRulesEngineOptions), (opts !== null && opts !== void 0 ? opts : {}));
        if ((opts === null || opts === void 0 ? void 0 : opts.data) !== undefined)
            this.data = opts.data;
        this.dataset = new Store(model.getQuads({}).concat((opts === null || opts === void 0 ? void 0 : opts.data) === undefined ? [] : opts.data.getQuads({})));
        const engineModel = (_a = opts === null || opts === void 0 ? void 0 : opts.engine) !== null && _a !== void 0 ? _a : newEngine(model);
        const engineCombined = (opts === null || opts === void 0 ? void 0 : opts.data) === undefined ? engineModel : newEngine(this.dataset);
        this.engine = {
            model: engineModel,
            combined: engineCombined
        };
        this.factory = (_b = opts === null || opts === void 0 ? void 0 : opts.factory) !== null && _b !== void 0 ? _b : getFactory();
    }
    /**
     * Execute rules and stores the result in the dataset
     *
     * @returns the new Quads
     */
    async execute() {
        if (this.opts.graph !== undefined) {
            return (await this.$execute()).map((quad) => this.factory.quad(quad.subject, quad.predicate, quad.object, this.opts.graph));
        }
        return await this.$execute();
    }
    async $execute(iteration = 0, SPARQLTargetNodes = new Store()) {
        if (SPARQLTargetNodes.size !== 0) {
            // this.model.removeQuads(SPARQLTargetNodes.getQuads({}))
        }
        if (iteration > 0) {
            // this.engine.combined = newEngine(new Store(this.model.getQuads({}).concat(this.data.getQuads({}))))
        }
        let size = this.data.size;
        // step 1: get all shapes that have rules:
        return await this.getShapesThatHaveRules()
            // step 2: get all focusNodes from those shapes and validate them against those shapes
            .then(async (shapesWithRules) => {
            const size = this.model.size + this.data.size;
            console.time('loadSPARQLTargets');
            await loadSPARQLTargets({ shapes: this.model, data: this.data });
            console.timeEnd('loadSPARQLTargets');
            // if the size has increaded we need to update the engine:
            if (size !== this.model.size + this.data.size) {
                this.engine.combined = newEngine(new Store(this.model.getQuads({}).concat(this.data.getQuads({}))));
            }
            await this.loadFocusnodesFromShapes(shapesWithRules);
            // await this.validateNodes(shapesWithRules)
            return shapesWithRules;
        })
            .then(async (shapesWithRules) => await this.applyRules(shapesWithRules))
            .then(async (quads) => {
            this.data.addQuads(quads);
            this.engine.combined = newEngine(new Store(this.model.getQuads({}).concat(this.data.getQuads({}))));
            if (this.opts.maxIterations > 0 && this.data.size > size) {
                size = this.data.size;
                if (iteration === this.opts.maxIterations) {
                    const error = new Error(`The SHACL Rule Engine reached the maximum iterations (${this.opts.maxIterations})`);
                    if (this.opts.errorOnMaxIterations === 'throw') {
                        throw error;
                    }
                    else if (this.opts.errorOnMaxIterations === 'warn') {
                        process.stderr.write(`WARNING: ${error.message}\n`);
                    }
                }
                else {
                    quads.push(...(await this.$execute(++iteration, SPARQLTargetNodes)));
                }
            }
            return quads;
        });
    }
    static isRulesEngine(obj) {
        if (typeof obj !== 'object')
            return false;
        if (obj === null)
            return false;
        if (!Object.hasOwn(obj, '$signature'))
            return false;
        // @ts-expect-error we now know this property does exists
        return obj.$signature === $SIGNATURE;
    }
    async getShapesThatHaveRules() {
        var _a, e_1, _b, _c;
        var _d, _e, _f, _g, _h;
        if ((_e = (_d = this.opts) === null || _d === void 0 ? void 0 : _d.debug) !== null && _e !== void 0 ? _e : false)
            console.time('RulesEngine::getShapesThatHaveRules::query');
        const shapes = {};
        try {
            for (var _j = true, _k = __asyncValues(await this.engine.model.select(shapesWithRulesRq)), _l; _l = await _k.next(), _a = _l.done, !_a; _j = true) {
                _c = _l.value;
                _j = false;
                const bindings = _c;
                const rule = {
                    node: ((_f = bindings.rule) === null || _f === void 0 ? void 0 : _f.termType) === 'BlankNode' ? bindings.rule : bindings.rule,
                    ruleType: bindings.ruleType
                };
                if (!Object.hasOwn(shapes, bindings.shape.value)) {
                    shapes[bindings.shape.value] = {
                        shape: bindings.shape,
                        rules: [rule],
                        focusNodes: []
                    };
                }
                else {
                    shapes[bindings.shape.value].rules.push(rule);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_j && !_a && (_b = _k.return)) await _b.call(_k);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if ((_h = (_g = this.opts) === null || _g === void 0 ? void 0 : _g.debug) !== null && _h !== void 0 ? _h : false)
            console.timeEnd('RulesEngine::getShapesThatHaveRules::query');
        return await Promise.resolve(shapes);
    }
    async loadFocusnodesFromShapes(shapes) {
        var _a, _b, _c, _d;
        // step 2: get all focusNodes from given shapes:
        for (const shape in shapes) {
            if ((_b = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.debug) !== null && _b !== void 0 ? _b : false)
                console.time(`RulesEngine::getFocusnodesFromShapes::query (${shape})`);
            const targets = (await (await this.engine.combined.select(getTargetsQuery(shapes[shape].shape))).toArray())
                .map((bindings) => bindings.target)
                .filter(target => target.termType === 'BlankNode' || target.termType === 'NamedNode');
            shapes[shape].focusNodes.push(...targets);
            if ((_d = (_c = this.opts) === null || _c === void 0 ? void 0 : _c.debug) !== null && _d !== void 0 ? _d : false)
                console.timeEnd(`RulesEngine::getFocusnodesFromShapes::query (${shape})`);
        }
    }
    async validateNode(focusNodes, conditions) {
        if (conditions.length === 0) {
            return focusNodes;
        }
        const model = new Store(this.model.getQuads({}));
        for (const condition of conditions) {
            for (const focusNode of focusNodes) {
                model.addQuad(this.factory.quad(condition.termType === 'BlankNode' ? condition : condition, sh.targetNode, focusNode));
            }
        }
        const validator = new Validator(model);
        const report = await validator.validate({ dataset: this.dataset, terms: focusNodes });
        const invalidNodes = report.dataset.getObjects(null, sh.focusNode, null);
        return focusNodes.filter((focusNode) => {
            let valid = true;
            for (const invalidNode of invalidNodes) {
                if (invalidNode.equals(focusNode)) {
                    valid = false;
                    break;
                }
            }
            return valid;
        });
    }
    /*
    from https://www.w3.org/TR/shacl-af/#rules-syntax:
    for each shape S in the shapes graph, ordered by execution order {
      for each non-deactivated rule R in the shape, ordered by execution order {
        for each target node T of S that conforms to all conditions of R {
          execute R using T as focus node following the execution instructions of its rule types
        }
      }
    }
    */
    async applyRules(shapesWithRules) {
        let engine = this.engine.combined;
        const quadsPerShape = [];
        for (const s in shapesWithRules) {
            const shape = shapesWithRules[s].shape;
            const quadsPerRule = [];
            for (const rule of shapesWithRules[s].rules) {
                const conditions = this.model.getObjects(rule.node, sh.condition, null).filter((node) => node.termType === 'BlankNode' || node.termType === 'NamedNode');
                const focusNodes = await this.validateNode(shapesWithRules[s].focusNodes, conditions);
                const quadsPerFocusNode = [];
                for (const focusNode of focusNodes) {
                    if (rule.ruleType.equals(sh.TripleRule)) {
                        quadsPerFocusNode.push(...this.applyTripleRule(rule.node, focusNode));
                    }
                    else if (rule.ruleType.equals(sh.SPARQLRule)) {
                        quadsPerFocusNode.push(...(await this.applySPARQLRule(shape, rule, focusNode, engine)));
                    }
                    else {
                        // eslint-disable-next-line @typescript-eslint/no-base-to-string
                        throw new Error(`Unsupported SHACL Ruletype '${rule.ruleType.value.replace(sh.toString(), '')}'`);
                    }
                }
                quadsPerRule.push(...quadsPerFocusNode);
                const store = new Store(this.model.getQuads({}).concat(this.data.getQuads({}).concat(quadsPerFocusNode)));
                engine = newEngine(store);
            }
            quadsPerShape.push(...quadsPerRule);
        }
        return quadsPerShape;
    }
    applyTripleRule(rule, focusNode) {
        var _a, _b, _c, _d;
        if ((_b = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.debug) !== null && _b !== void 0 ? _b : false)
            console.time('RulesEngine::applyTripleRule');
        const subjects = this.dataset.getObjects(rule, sh.subject, null);
        const predicates = this.dataset.getObjects(rule, sh.predicate, null);
        const objects = this.dataset.getObjects(rule, sh.object, null);
        if (subjects.length === 0)
            throw new Error('A SHACL TripleRule must have exactly 1 value for `sh:subject`.');
        if (predicates.length === 0)
            throw new Error('A SHACL TripleRule must have exactly 1 value for `sh:predicate`.');
        if (objects.length === 0)
            throw new Error('A SHACL TripleRule must have exactly 1 value for `sh:object`.');
        if (!subjects[0].equals(sh.this) && subjects[0].termType !== 'NamedNode')
            throw new Error('Our SHACL Rule Engine only supports `sh:this` or an Iri as value for `sh:subject`.');
        if (!predicates[0].equals(sh.this) && predicates[0].termType !== 'NamedNode')
            throw new Error('Our SHACL Rule Engine only supports `sh:this` or an Iri as value for `sh:predicate`.');
        if (!objects[0].equals(sh.this) && objects[0].termType !== 'NamedNode' && objects[0].termType !== 'Literal')
            throw new Error('Our SHACL Rule Engine only supports `sh:this`, an Iri or a Literal as value for `sh:object`.');
        const quads = [];
        const subject = subjects[0];
        const predicate = predicates[0];
        const object = objects[0].termType === 'Literal' ? objects[0] : objects[0];
        if (predicate.equals(sh.this) && focusNode.termType === 'BlankNode') {
            throw new Error('sh:this Should use the current focusnode, but that is a BlankNode which is not allowed as subject.');
        }
        quads.push(this.factory.quad(subject.equals(sh.this) ? focusNode : subject, predicate.equals(sh.this) ? focusNode : predicate, object.equals(sh.this) ? focusNode : object));
        if ((_d = (_c = this.opts) === null || _c === void 0 ? void 0 : _c.debug) !== null && _d !== void 0 ? _d : false)
            console.timeEnd('RulesEngine::applyripleRule');
        return quads;
    }
    async applySPARQLRule(shape, rule, focusNode, engine) {
        var _a, _b, _c;
        if ((_b = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.debug) !== null && _b !== void 0 ? _b : false)
            console.time('RulesEngine::execute::applySPARQLRule');
        if (shape.termType === 'BlankNode') {
            throw new Error('Encountered a rule in a NodeShape that is a BlankNode, this engine relies on the NodeShape to be an Iri. Please rewrite your model.');
        }
        // what to do when the rule is a blanknode?
        // This will go wrong when a shape has more than 1 rule defined by using 1 one or more blanknode
        const rq = SPARQLRuleRq(shape, rule.node.termType === 'NamedNode' ? rule.node : undefined);
        const prefixDeclarations = [];
        if (((_c = this.opts) === null || _c === void 0 ? void 0 : _c.prefix) !== undefined) {
            for (const [prefix, prefixer] of Object.entries(this.opts.prefix)) {
                const ns = typeof prefixer === 'function' ? prefixer('').value : typeof prefixer === 'string' ? this.factory.namedNode(prefixer).value : prefixer.value;
                prefixDeclarations.push(`prefix ${prefix}: <${ns}>`);
            }
        }
        const queries = (await (await this.engine.combined.select(rq)).toArray())
            .map(binding => binding.query);
        if (queries.length !== 1) {
            throw new Error(`Expected exactly 1 SPARQLRule with \`sh:construct\` found in shape <${shape.value}>.`);
        }
        const query = queries[0];
        const variableDefinitions = [{ name: 'this', termType: 'NamedNode' }];
        const constructQuery = prefixDeclarations.join('\n') + query.value;
        return await (await engine.construct(parseAndInjectVariablesIntoQuery(constructQuery, { variableDefinitions, variableValues: { this: focusNode.value } }))).quads();
    }
}
//# sourceMappingURL=RulesEngine.js.map