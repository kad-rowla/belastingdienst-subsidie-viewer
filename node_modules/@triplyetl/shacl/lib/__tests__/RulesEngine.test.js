/* eslint-disable @typescript-eslint/no-confusing-void-expression */
import chai from 'chai';
import getDatasetFromResource from '../Utilities/getDatasetFromResource.js';
import RulesEngine from '../RulesEngine.js';
import { Store, factory, getFactory as getDataFactory, getFactory } from '@triplydb/data-factory';
import { Factory } from '../index.js';
import { Iri, a, rdf, xsd } from '@triplyetl/vocabularies';
import chaiAsPromised from 'chai-as-promised';
import loadSPARQLTargets from '../Utilities/loadSPARQLTargets.js';
import { isomorphic } from 'rdf-isomorphic';
import { readFileSync } from 'fs';
import path from 'path';
chai.use(chaiAsPromised);
const assert = chai.assert;
const expect = chai.expect;
const dataFactory = getDataFactory();
const prefix = {
    ex: new Iri('http://example.org/'),
    def: new Iri('http://example.org/model/def/'),
    id: new Iri('http://example.org/id/')
};
const area = prefix.ex.concat('area');
describe('RulesEngine', () => {
    const debug = false;
    it('should infer 1 new triple using a sh:TripleRule', async () => {
        const subject = prefix.ex.concat('SquareRectangle');
        const object = prefix.ex.concat('Square');
        const model = getDatasetFromResource('example.shape.ttl', 'static', 'resources', 'Rules', '01');
        const data = getDatasetFromResource('example.data.ttl', 'static', 'resources', 'Rules', '01');
        let quads = data.getQuads({ subject, predicate: a, object });
        assert.equal(quads.length, 0);
        await new RulesEngine(model, { data, debug }).execute();
        quads = data.getQuads({ subject, predicate: a, object });
        assert.equal(quads.length, 1);
        assert.isTrue(quads[0].equals(dataFactory.quad(subject, a, object)));
    });
    describe('Should infer 1 new triple using a sh:SPARQLRule', () => {
        const areaLiteral = factory.literal('56', xsd.integer);
        const assertSquare = async (filename) => {
            const model = getDatasetFromResource(`${filename}.trig`, 'static', 'resources', 'Rules', '02');
            const engine = Factory.rulesEngine(model, { debug, prefix });
            await engine.execute();
            const areas = engine.data.getObjects(null, area, null);
            assert.equal(areas.length, 1);
            assert.isTrue(areas[0].equals(areaLiteral));
        };
        it('using sh:implicitTarget', async () => await assertSquare('implicitTarget'));
        it('using sh:targetClass', async () => await assertSquare('targetClass'));
        it('using sh:targetObjectsOf', async () => await assertSquare('targetObjectsOf'));
        it('using sh:targetSubjectsOf', async () => await assertSquare('targetSubjectsOf'));
    });
    it('should sucessfully run 2 rules of type sh:SPARQLRule', async () => {
        const model = getDatasetFromResource('model.trig', 'static', 'resources', 'Rules', '03');
        const data = getDatasetFromResource('data.trig', 'static', 'resources', 'Rules', '03');
        assert.equal(data.getObjects(prefix.id.concat('squareRectangle'), prefix.def.concat('area'), null).length, 0);
        assert.equal(data.getSubjects(a, prefix.def.concat('Square'), null).length, 0);
        const dataset = new Store(await new RulesEngine(model, { data, debug: false }).execute());
        assert.equal(dataset.size, 3);
        assert.equal(data.getObjects(null, prefix.def.concat('area'), null).length, 2);
        assert.equal(data.getObjects(prefix.id.concat('squareRectangle'), prefix.def.concat('area'), null).length, 1);
    });
    it('should work with medium complex example (iterative)', async () => {
        const shapes = getDatasetFromResource('model.ttl', 'static', 'resources', 'Rules', '04');
        const data = getDatasetFromResource('data.ttl', 'static', 'resources', 'Rules', '04');
        const engine = new RulesEngine(shapes, { data, debug: false, maxIterations: 6 });
        const quads = await engine.execute();
        assert.equal(quads.length, 21);
        // validate the result:
        const conforms = (await Factory.validator(getDatasetFromResource('validate.ttl', 'static', 'resources', 'Rules', '04')).validate({ dataset: new Store(quads) })).conforms;
        assert.isTrue(conforms);
        const infered = getDatasetFromResource('infered.ttl', 'static', 'resources', 'Rules', '04');
        assert.isTrue(isomorphic(quads, infered.getQuads({})), 'Expected infered quads to be isomporhic with static data.');
    });
    it('should throw when maximum iterations are reached', async () => {
        const shapes = getDatasetFromResource('model.ttl', 'static', 'resources', 'Rules', '04');
        const data = getDatasetFromResource('data.ttl', 'static', 'resources', 'Rules', '04');
        const engine = new RulesEngine(shapes, { data, debug: false, maxIterations: 2, errorOnMaxIterations: 'throw' });
        await expect(engine.execute()).to.eventually.be.rejectedWith('The SHACL Rule Engine reached the maximum iterations (2)');
    });
    it('should not throw when maximum iterations are reached', async () => {
        const shapes = getDatasetFromResource('model.ttl', 'static', 'resources', 'Rules', '04');
        const data = getDatasetFromResource('data.ttl', 'static', 'resources', 'Rules', '04');
        await loadSPARQLTargets({ shapes, data });
        const engine = new RulesEngine(shapes, { data, debug: false, maxIterations: 2, errorOnMaxIterations: 'none' });
        assert.equal((await engine.execute()).length, 18);
    });
    it('should not throw when maximum iterations = 0', async () => {
        const shapes = getDatasetFromResource('model.ttl', 'static', 'resources', 'Rules', '04');
        const data = getDatasetFromResource('data.ttl', 'static', 'resources', 'Rules', '04');
        await loadSPARQLTargets({ shapes, data });
        const engine = new RulesEngine(shapes, { data, debug: false, maxIterations: 0, errorOnMaxIterations: 'throw' });
        await expect(engine.execute()).to.eventually.be.fulfilled;
    });
    it('should work with Shacl website - SPARQLRule example)', async () => {
        const SquareRectangle = prefix.ex.concat('SquareRectangle');
        const NonSquareRectangle = prefix.ex.concat('NonSquareRectangle');
        const model = getDatasetFromResource('SPARQLRule.ttl', 'static', 'resources', 'Rules');
        const data = getDatasetFromResource('example.data.invalid.ttl', 'static', 'resources');
        let quads = data.getQuads({ predicate: area });
        assert.equal(quads.length, 0);
        await new RulesEngine(model, { data, debug: false }).execute();
        quads = data.getQuads({ predicate: area });
        assert.equal(quads.length, 2);
        let objects = data.getObjects(SquareRectangle, area, null);
        assert.equal(objects.length, 1);
        assert.isTrue(objects[0].equals(dataFactory.literal((4 * 4).toString(), xsd.integer)));
        objects = data.getObjects(NonSquareRectangle, area, null);
        assert.equal(objects.length, 1);
        assert.isTrue(objects[0].equals(dataFactory.literal((3 * 2).toString(), xsd.integer)));
    });
    it('Implement correct ordering per shape and rule ("connected" example)', async () => {
        const shapes = getDatasetFromResource('model.trig', 'static', 'resources', 'Rules', 'connected');
        const data = getDatasetFromResource('data.trig', 'static', 'resources', 'Rules', 'connected');
        const graph = getFactory().namedNode('https://data.triply.cc/example/');
        const engine = new RulesEngine(shapes, { data, debug, errorOnMaxIterations: 'warn', graph });
        const quads = await engine.execute();
        assert.equal(quads.length, 3);
        assert.isTrue(isomorphic(quads, getDatasetFromResource('infered.trig', 'static', 'resources', 'Rules', 'connected').getQuads({})), 'Expected infered quads to be isomporhic with static data.');
    });
    // let describeExpensive = describe.skip
    // if (process.env.EXPENSIVE !== undefined) {
    //   describeExpensive = describe
    // }
    describe.skip('Should work with advanced HTML examples using recursive runs', () => {
        it('HTML Table example', async function () {
            this.timeout('2 m');
            const shapes = getDatasetFromResource('html.trig', 'static', 'resources', 'Rules', '05');
            const data = getDatasetFromResource('HTML-table-template-example.trig', 'static', 'resources', 'Rules', '05');
            const engine = new RulesEngine(shapes, { data, debug: false, maxIterations: 20, errorOnMaxIterations: 'warn' });
            const quads = await engine.execute();
            const store = new Store(quads);
            assert.equal(store.size, 45);
            // this is currently not the case, which means quads are duplicated
            // assert.equal(quads.length, store.size)
            const html = store.getObjects(getFactory().namedNode('https://example.com/tutorial/id/doc/tutorial'), getFactory().namedNode('https://data.rijksfinancien.nl/html/model/def/fragment'), null);
            assert.equal(html.length, 1);
            assert.equal(html[0].termType, 'Literal');
            assert.isTrue(html[0].datatype.equals(rdf.HTML));
            assert.equal(html[0].value.trim(), readFileSync(path.join('static', 'resources', 'Rules', '05', 'table.html'), 'utf-8').trim());
        });
    });
});
//# sourceMappingURL=RulesEngine.test.js.map