import chai, { assert, expect } from 'chai';
import { Store, getFactory, getWriter, parse } from '@triplydb/data-factory';
import Validator from '../Validator.js';
import getDatasetFromResource from '../Utilities/getDatasetFromResource.js';
import { Iri, rdf, rdfs, sh, xsd } from '@triplyetl/vocabularies';
import loadSPARQLTargets from '../Utilities/loadSPARQLTargets.js';
import loadSPARQLTargetTypes from '../Utilities/loadSPARQLTargetTypes.js';
import chaiAsPromised from 'chai-as-promised';
import { Validator as ValidatorBase } from 'shacl-engine';
import sh_sh from '../Utilities/shacl-shacl.ttl.js';
import getDataFactoryWithDataset from '../Utilities/getDataFactoryWithDataset.js';
chai.use(chaiAsPromised);
describe('Validator', () => {
    it('work with an empty dataset', () => {
        const validator = new Validator(new Store());
        assert.isTrue(Validator.isValidator(validator));
        assert.equal(validator.model.size, 0);
    });
    it('fail with an non validating model dataset', async () => {
        const store = new Store(parse('prefix sh: <http://www.w3.org/ns/shacl#>\n[ sh:property [ sh:languageIn "nl" ] ].'));
        const validator = new Validator(store);
        await expect(validator.validate({})).to.eventually.be.rejectedWith(/The model is not a valid SHACL model/);
    });
    it('not fail with an non validating model dataset when validation is skipped', async () => {
        const store = new Store(parse('prefix sh: <http://www.w3.org/ns/shacl#>\n[ sh:property [ sh:languageIn "nl" ] ].'));
        const validator = new Validator(store, { skipShaclShaclValidaton: true });
        await expect(validator.validate({})).to.eventually.fulfilled;
    });
    describe('should validate instance data against a model', () => {
        const model = getDatasetFromResource('example.shape.ttl', 'static', 'resources');
        it('using non-conforming data', async () => {
            const validator = new Validator(model);
            const data = getDatasetFromResource('example.data.invalid.ttl', 'static', 'resources');
            const report = await validator.validate({ dataset: data });
            assert.isFalse(report.conforms);
            const focusnodes = report.focusNodes;
            assert.equal(focusnodes.length, 1);
            assert.isTrue(focusnodes[0].equals(getFactory().namedNode('http://example.org/InvalidRectangle')));
        });
        it('using non-conforming data but a specific shape that still allows it', async () => {
            const validator = new Validator(model);
            const data = getDatasetFromResource('example.data.invalid.ttl', 'static', 'resources');
            const report = await validator.validate({ dataset: data }, getFactory().namedNode('http://example.org/SimpleRectangleShape'));
            assert.isTrue(report.conforms);
        });
        it('using conforming data', async () => {
            const validator = new Validator(model);
            const data = getDatasetFromResource('example.data.valid.ttl', 'static', 'resources');
            const report = await validator.validate({ dataset: data });
            assert.isTrue(report.conforms);
        });
    });
    it('should load targets correctly', async () => {
        const shapes = getDatasetFromResource('targets.ttl', 'static', 'resources');
        const targets = await Validator.getTargets({ shapes });
        assert.equal(targets.size, 6);
        const prefixer = new Iri('http://example.org/');
        for (const name of ['Rick', 'Alice', 'Jane', 'John', 'Charly', 'Keith']) {
            assert.equal([...targets].filter((target) => target.node.equals(prefixer.concat(name))).length, 1);
        }
    });
    it('should validate SPARQL Targets correctly', async () => {
        // First test it without the SPARQL targets:
        const shapes = getDatasetFromResource('sparql-based-target.ttl', 'static', 'resources');
        let validator = new Validator(shapes, { allowSPARQLTargets: false });
        assert.isTrue((await validator.validate({})).conforms, 'expected data to conform according to the shapes');
        assert.equal(shapes.getObjects(null, sh.targetNode, null).length, 0);
        // Load SPARQL Targets and check again:
        await loadSPARQLTargets({ shapes });
        const prefixer = new Iri('http://example.org/');
        const targetNodes = shapes.getObjects(prefixer.concat('USCitizenShape'), sh.targetNode, null);
        assert.equal(targetNodes.length, 1);
        assert.isTrue(targetNodes[0].equals(prefixer.concat('John')));
        validator = new Validator(shapes);
        const report = await validator.validate({});
        assert.isFalse(report.conforms, 'expected data to not conform according to the shapes');
    });
    it('should validate SPARQL Target Types correctly', async () => {
        // First test it without the SPARQL targets:
        const shapes = getDatasetFromResource('sparql-based-target-types.ttl', 'static', 'resources');
        let validator = new Validator(shapes);
        assert.isTrue((await validator.validate({})).conforms, 'expected data to conform according to the shapes');
        assert.equal(shapes.getObjects(null, sh.targetNode, null).length, 0);
        // Load SPARQL Target Types and check again:
        await loadSPARQLTargetTypes({ shapes });
        validator = new Validator(shapes);
        const report = await validator.validate({});
        assert.isFalse(report.conforms, 'expected data to not conform according to the shapes');
    });
    it('should validate instance data using a SPARQL Constraint', async () => {
        var _a, _b, _c, _d;
        const shapes = getDatasetFromResource('sparql-constraint.ttl', 'static', 'resources');
        const validator = new Validator(shapes);
        const report = await validator.validate({});
        assert.isFalse(report.conforms);
        const components = report.dataset.getSubjects(sh.sourceConstraintComponent, sh.SPARQLConstraintComponent, null);
        assert.equal(components.length, 1);
        const ex = new Iri('http://example.org/');
        const message = getFactory().literal('Values are literals with German language tag (de).');
        assert.isTrue((_a = report.dataset.getObjects(components[0], sh.focusNode, null).pop()) === null || _a === void 0 ? void 0 : _a.equals(ex.concat('InvalidCountry')));
        assert.isTrue((_b = report.dataset.getObjects(components[0], sh.resultPath, null).pop()) === null || _b === void 0 ? void 0 : _b.equals(ex.concat('germanLabel')));
        assert.isTrue((_c = report.dataset.getObjects(components[0], sh.sourceShape, null).pop()) === null || _c === void 0 ? void 0 : _c.equals(ex.concat('LanguageExampleShape')));
        assert.isTrue((_d = report.dataset.getObjects(components[0], sh.resultMessage, null).pop()) === null || _d === void 0 ? void 0 : _d.equals(message));
    });
    describe('Test cases for reported issues', () => {
        it('https://git.triply.cc/triply/etl/-/issues/263', async () => {
            const shapes = getDatasetFromResource('shapes.ttl', 'static', 'resources', 'Validator', 'issues', '263');
            const dataset = getDatasetFromResource('data.ttl', 'static', 'resources', 'Validator', 'issues', '263');
            const validator = new Validator(shapes);
            const report = await validator.validate({ dataset });
            assert.isFalse(report.conforms);
        });
        it('https://issues.triply.cc/issues/6223', async () => {
            const shapes = getDatasetFromResource('data.ttl', 'static', 'resources', 'Validator', 'validationFiles');
            const dataset = getDatasetFromResource('sh_namedNodeInList.trig', 'static', 'resources', 'Validator', 'validationFiles');
            const validator = new Validator(shapes);
            await expect(validator.validate({ dataset })).to.eventually.fulfilled;
        });
    });
    it('should work with sh:target example', async () => {
        const shapes = getDatasetFromResource('shNode.ttl', 'static', 'resources', 'Validator');
        const validator = new Validator(shapes);
        const report = await validator.validate({});
        assert.isFalse(report.conforms);
    });
    it('should work with sh:not example', async () => {
        const shapes = getDatasetFromResource('not.ttl', 'static', 'resources', 'Validator');
        const validator = new Validator(shapes);
        const report = await validator.validate({});
        assert.isFalse(report.conforms);
    });
    it('should work with sh:and example', async () => {
        const shapes = getDatasetFromResource('and.ttl', 'static', 'resources', 'Validator');
        const validator = new Validator(shapes);
        const report = await validator.validate({});
        assert.isFalse(report.conforms);
    });
    it('should work with sh:or example', async () => {
        const shapes = getDatasetFromResource('or.ttl', 'static', 'resources', 'Validator');
        const validator = new Validator(shapes);
        const report = await validator.validate({});
        assert.isFalse(report.conforms);
    });
    it('should work with sh:xone example', async () => {
        const shapes = getDatasetFromResource('xone.ttl', 'static', 'resources', 'Validator');
        const validator = new Validator(shapes);
        const report = await validator.validate({});
        assert.isFalse(report.conforms);
    });
    it('should work with sh:pattern example', async () => {
        const shapes = getDatasetFromResource('shPattern.ttl', 'static', 'resources', 'Validator');
        const validator = new Validator(shapes);
        const report = await validator.validate({});
        assert.isFalse(report.conforms);
        // console.log(await writeQuads(report.dataset.getQuads({})))
    });
    it('should work with Annotation Properties', async () => {
        const shapes = getDatasetFromResource('annotation-properties.ttl', 'static', 'resources', 'Validator');
        const validator = new Validator(shapes);
        const report = await validator.validate({});
        assert.isFalse(report.conforms);
        const time = getFactory().literal('1970-02-09T10:12:14', xsd.dateTime);
        const nodes = report.dataset.getObjects(null, getFactory().namedNode('http://example.org/time'), null);
        assert.equal(nodes.length, 1);
        assert.isTrue(nodes[0].equals(time));
    });
    it('detects targets', async () => {
        const dataset = getDatasetFromResource('./static/resources/Validator/validationFiles/sparql-target-data.ttl');
        const shapes = getDatasetFromResource('./static/resources/Validator/validationFiles/sparql-target-shape.ttl');
        const validator = new Validator(shapes);
        const report = await validator.validate({ dataset });
        assert.isFalse(report.conforms);
    });
    it('detects targets (preloaded)', async () => {
        const dataset = getDatasetFromResource('./static/resources/Validator/validationFiles/sparql-target-data.ttl');
        const shapes = getDatasetFromResource('./static/resources/Validator/validationFiles/sparql-target-shape.ttl');
        await loadSPARQLTargets({ data: dataset, shapes });
        const validator = new Validator(shapes, { allowSPARQLTargets: false });
        const report = await validator.validate({ dataset });
        assert.isFalse(report.conforms);
    });
    it('skip detects targets when requested', async () => {
        const dataset = getDatasetFromResource('./static/resources/Validator/validationFiles/sparql-target-data.ttl');
        const shapes = getDatasetFromResource('./static/resources/Validator/validationFiles/sparql-target-shape.ttl');
        const validator = new Validator(shapes, { allowSPARQLTargets: false });
        const report = await validator.validate({ dataset });
        assert.isTrue(report.conforms);
    });
    describe.skip('Performance testing', function () {
        this.timeout('5 m');
        const data = getDatasetFromResource('static/resources/Etl/example.record.trig');
        const model = getDatasetFromResource('static/resources/Etl/generic.trig');
        model.addQuads(getDatasetFromResource('static/resources/Etl/thesaurus.trig').getQuads({}));
        const repeat = 2;
        it('using shacl-engine', async function () {
            console.time('using shacl-engine');
            for (let i = 0; i < repeat; i++) {
                console.time(`  ${i}`);
                const validator = new ValidatorBase(model, { factory: getDataFactoryWithDataset() });
                const report = await validator.validate({ dataset: data });
                assert.isFalse(report.conforms);
                if (i === 0) {
                    const validator2 = new ValidatorBase(sh_sh, { factory: getDataFactoryWithDataset() });
                    const report2 = await validator2.validate({ dataset: model });
                    assert.isTrue(report2.conforms);
                }
                console.timeEnd(`  ${i}`);
            }
            console.timeEnd('using shacl-engine');
        });
        it('using Triply SHACL', async function () {
            console.time('using Triply SHACL');
            for (let i = 0; i < repeat; i++) {
                console.time(`  ${i}`);
                const validator = new Validator(model, { skipShaclShaclValidaton: i > 0 });
                const report = await validator.validate({ dataset: data });
                assert.isFalse(report.conforms);
                console.timeEnd(`  ${i}`);
            }
            console.timeEnd('using Triply SHACL');
        });
    });
});
/**
 * Quick and dirty ttl writer
 *
 * @param quads
 * @param opts
 * @returns
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export const writeQuads = async (quads, opts) => await new Promise((resolve, reject) => {
    var _a;
    opts = opts !== null && opts !== void 0 ? opts : {};
    opts.prefixes = Object.assign({ sh: sh.toIri(), rdf: rdf.toIri(), rdfs: rdfs.toIri(), ex: getFactory().namedNode('http://example.org/') }, ((_a = opts === null || opts === void 0 ? void 0 : opts.prefixes) !== null && _a !== void 0 ? _a : {}));
    const writer = getWriter(opts);
    writer.addQuads(quads);
    writer.end(function (error, result) {
        if (error !== null)
            reject(new Error('failed to write quads'));
        else
            resolve(result);
    });
});
//# sourceMappingURL=Validator.test.js.map