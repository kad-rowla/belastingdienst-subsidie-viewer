import { sh, a, xsd, rdf, rdfs, sdo, owl } from '@triplyetl/vocabularies';
import chalk from 'chalk';
import Writer from './Report/Writer.js';
export const commonPrefixes = {
    rdf: rdf.toIri().value,
    rdfs: rdfs.toIri().value,
    sdo: sdo.toIri().value,
    owl: owl.toIri().value,
    sh: sh.toIri().value,
    xsd: xsd.toIri().value
};
export default class Report {
    constructor(report, opts) {
        this.report = report;
        this.opts = {};
        this.SPARQLConstraintConforms = true;
        this.$conforms = true;
        if ((opts === null || opts === void 0 ? void 0 : opts.prefixes) != null)
            opts.prefixes = Object.assign(Object.assign({}, commonPrefixes), opts.prefixes);
        else if (opts != null)
            opts.prefixes = commonPrefixes;
        this.opts = opts !== null && opts !== void 0 ? opts : { prefixes: commonPrefixes };
        this.$conforms = report.conforms;
    }
    addPrefixes(prefixes) {
        this.opts.prefixes = Object.assign(Object.assign({}, this.opts.prefixes), prefixes);
        return this;
    }
    get conforms() {
        return this.$conforms && this.report.conforms && this.SPARQLConstraintConforms;
    }
    set conforms(value) {
        if (this.$conforms !== value) {
            const conforms = this.factory.literal(value ? 'true' : 'false', xsd.boolean);
            this.report.dataset.getSubjects(a, sh.ValidationReport, null).forEach(report => {
                this.report.dataset.removeQuads(this.report.dataset.getQuads({ subject: report, predicate: sh.conforms }));
                this.report.dataset.addQuad(report, sh.conforms, conforms);
            });
            this.$conforms = value;
        }
    }
    addValidationResult(result) {
        this.conforms = false;
        const resultNode = this.factory.blankNode();
        this.dataset.getSubjects(a, sh.ValidationReport, null).forEach(r => {
            this.dataset.addQuad(r, sh.result, resultNode);
        });
        let severity;
        switch (result.resultSeverity) {
            case 'Info':
                severity = sh.Info;
                break;
            case 'Warning':
                severity = sh.Warning;
                break;
            default: severity = sh.Violation;
        }
        this.dataset.addQuads([
            this.factory.quad(resultNode, a, sh.ValidationResult),
            this.factory.quad(resultNode, sh.focusNode, result.focusNode),
            this.factory.quad(resultNode, sh.resultSeverity, severity),
            this.factory.quad(resultNode, sh.sourceConstraintComponent, result.sourceConstraintComponent)
        ]);
        if (result.resultPath !== undefined) {
            this.dataset.addQuad(this.factory.quad(resultNode, sh.resultPath, result.resultPath));
        }
        if (result.sourceShape !== undefined) {
            this.dataset.addQuad(this.factory.quad(resultNode, sh.sourceShape, result.sourceShape));
        }
        result.values.forEach(value => {
            this.dataset.addQuad(this.factory.quad(resultNode, sh.value, value));
        });
        result.resultMessages.forEach(msg => {
            this.dataset.addQuad(this.factory.quad(resultNode, sh.resultMessage, msg));
        });
    }
    get details() {
        return this.report.details;
    }
    get factory() {
        return this.report.factory;
    }
    get options() {
        return this.report.options;
    }
    get dataset() {
        return this.report.dataset;
    }
    get results() {
        return this.report.results;
    }
    get writer() {
        return Writer.fromReport(this, this.opts.model);
    }
    get severity() {
        if (this._severities == null) {
            const quads = this.report.dataset.getQuads({ predicate: sh.resultSeverity });
            this._severities = {
                warning: quads.filter((quad) => quad.object.equals(sh.Warning)),
                info: quads.filter((quad) => quad.object.equals(sh.Info)),
                violation: quads.filter((quad) => quad.object.equals(sh.Violation))
            };
        }
        return this._severities;
    }
    /**
     * Get all Focusnodes from the report
     *
     * @returns the focusnodes that are not valid
     */
    get focusNodes() {
        return this.dataset.getObjects(null, sh.focusNode, null);
    }
    get severityMessage() {
        const msg = [];
        if (this.countViolations() > 0) {
            msg.push(chalk.red(`${this.countViolations()} Violation${this.countViolations() > 1 ? 's' : ''}`));
        }
        if (this.countWarnings() > 0) {
            msg.push(chalk.yellow(`${this.countWarnings()} Warning${this.countWarnings() > 1 ? 's' : ''}`));
        }
        if (this.countInfos() > 0) {
            msg.push(chalk.blue(`${this.countInfos()} Info${this.countInfos() > 1 ? 's' : ''}`));
        }
        if (msg.length === 0)
            return '';
        else if (msg.length === 1)
            return msg[0];
        const lastMsg = msg.pop();
        return `${msg.join(', ')} and ${lastMsg !== null && lastMsg !== void 0 ? lastMsg : ''}`;
    }
    countWarnings() {
        return this.severity.warning.length;
    }
    countInfos() {
        return this.severity.info.length;
    }
    countViolations() {
        return this.severity.violation.length;
    }
}
//# sourceMappingURL=Report.js.map