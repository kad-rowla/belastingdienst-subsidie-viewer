import { shrink } from '@zazuko/prefixes/shrink';
import { formatWithOptions } from 'util';
const isTerm = (obj) => {
    return typeof obj === 'object' && Object.hasOwn(obj, 'termType');
};
const isNamedNode = (obj) => {
    return isTerm(obj) && obj.termType === 'NamedNode';
};
const isBlankNode = (obj) => {
    return isTerm(obj) && obj.termType === 'BlankNode';
};
const isLiteral = (obj) => {
    return isTerm(obj) && obj.termType === 'Literal';
};
export default class ConstraintComponent {
    constructor(result, engine, opts) {
        this.result = result;
        this.engine = engine;
        this.opts = opts;
    }
    format(template, ...parameters) {
        const parametersAsStrings = [];
        for (const parameter of parameters) {
            let stringValue = parameter;
            if (isNamedNode(parameter)) {
                stringValue = this.shrink(parameter);
            }
            else if (isBlankNode(parameter)) {
                stringValue = '_:' + parameter.value;
            }
            else if (isLiteral(parameter)) {
                stringValue = this.literalToString(parameter);
            }
            parametersAsStrings.push(stringValue);
        }
        return formatWithOptions({ colors: true }, template, ...parametersAsStrings);
    }
    shrink(term) {
        const shrinked = shrink(term.value, this.opts.prefixes);
        return shrinked === '' ? term.value : shrinked;
    }
    literalToString(term) {
        let str = term.value === '' ? '[empty string]' : term.value;
        if (term.language !== '')
            str += '@' + term.language;
        else
            str += '^^' + shrink(term.datatype.value, this.opts.prefixes);
        return str;
    }
    resultMessagesToString() {
        return this.result.resultMessages.map((l) => this.literalToString(l)).join('; ');
    }
    valuesToString(suffix = ' with value') {
        let value = '';
        if (this.result.values.length > 0) {
            value = suffix + (this.result.values.length > 1 ? 's' : '') + ' ';
            value += this.result.values
                .map((value) => {
                return this.format('%o', value.termType === 'Literal' ? this.literalToString(value) : this.shrink(value));
            })
                .join(', ');
        }
        return value;
    }
}
//# sourceMappingURL=ConstraintComponent.js.map