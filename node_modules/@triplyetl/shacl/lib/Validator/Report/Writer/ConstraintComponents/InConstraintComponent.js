import { rdf, sh } from '@triplyetl/vocabularies';
import ConstraintComponent from '../ConstraintComponent.js';
export default class InConstraintComponent extends ConstraintComponent {
    async toString() {
        var _a, _b, _c, _d;
        if (this.opts.model === undefined || this.opts.data === undefined || this.result.resultPath === undefined || this.result.sourceShape === undefined) {
            return await Promise.resolve(this.format('The node %o has a predicate %o%s; your shape %o reports the following: %s', this.result.focusNode, (_a = this.result.resultPath) !== null && _a !== void 0 ? _a : '[unknown sh:resultPath]', this.valuesToString(), (_b = this.result.sourceShape) !== null && _b !== void 0 ? _b : '[unknown SHACL SourceShape]', this.resultMessagesToString()));
        }
        let expectedInList = this.opts.model.getObjects(this.result.sourceShape, sh.in, null)[0];
        const expectedIn = [];
        while (true) {
            const shin = this.opts.model.getObjects(expectedInList, rdf.first, null)[0];
            expectedIn.push(this.format('%o', shin.termType === 'Literal' ? this.literalToString(shin) : shin.value));
            const rest = this.opts.model.getObjects(expectedInList, rdf.rest, null)[0];
            if (rest.equals(rdf.nil) || rest === undefined) {
                break;
            }
            expectedInList = rest;
        }
        return await Promise.resolve(this.format('The node %o has a predicate %o%s; your shape %o only allows value%s %s', this.result.focusNode, (_c = this.result.resultPath) !== null && _c !== void 0 ? _c : '[unknown sh:resultPath]', this.valuesToString(), (_d = this.result.sourceShape) !== null && _d !== void 0 ? _d : '[unknown SHACL SourceShape]', expectedIn.length === 1 ? '' : 's', expectedIn.join(', ')));
    }
}
//# sourceMappingURL=InConstraintComponent.js.map