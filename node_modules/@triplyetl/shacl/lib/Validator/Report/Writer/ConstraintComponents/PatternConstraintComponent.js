import { sh } from '@triplyetl/vocabularies';
import ConstraintComponent from '../ConstraintComponent.js';
export default class PatternConstraintComponent extends ConstraintComponent {
    async toString() {
        var _a, _b, _c, _d;
        let pattern = ((_b = (_a = this.result.resultMessages[0]) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : '[unknown]').replace(/Value does not match pattern /, '');
        if (this.opts.model !== undefined && this.result.sourceShape !== undefined) {
            const shPattern = this.opts.model.getObjects(this.result.sourceShape, sh.pattern, null)[0];
            const flags = this.opts.model.getObjects(this.result.sourceShape, sh.flags, null)[0];
            if (shPattern !== undefined)
                pattern = '/' + shPattern.value + '/';
            if (flags !== undefined)
                pattern += flags.value;
        }
        return await Promise.resolve(this.format('The node %o has a predicate %o%s which does not match the pattern %o defined in your shape %o.', this.result.focusNode, (_c = this.result.resultPath) !== null && _c !== void 0 ? _c : '[unknown sh:resultPath]', this.valuesToString(), pattern, (_d = this.result.sourceShape) !== null && _d !== void 0 ? _d : '[unknown SHACL SourceShape]'));
    }
}
//# sourceMappingURL=PatternConstraintComponent.js.map