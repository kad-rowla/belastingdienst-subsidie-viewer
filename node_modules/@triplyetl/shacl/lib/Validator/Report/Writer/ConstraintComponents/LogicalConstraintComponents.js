import { sh } from '@triplyetl/vocabularies';
import ConstraintComponent from '../ConstraintComponent.js';
export default class LogicalConstraintComponents extends ConstraintComponent {
    async toString() {
        var _a, _b, _c;
        let predicate = sh.xone;
        switch (this.result.sourceConstraintComponent.value) {
            case sh.XoneConstraintComponent.value:
                predicate = sh.xone;
                break;
            case sh.AndConstraintComponent.value:
                predicate = sh.and;
                break;
            case sh.OrConstraintComponent.value:
                predicate = sh.or;
                break;
            case sh.NotConstraintComponent.value:
                predicate = sh.not;
                break;
        }
        let shape = '';
        if (this.opts.model !== undefined && this.result.sourceShape !== undefined) {
            shape = this.format('does not have shape %o', (_b = (_a = this.opts.model) === null || _a === void 0 ? void 0 : _a.getObjects(this.result.sourceShape, predicate, null)[0]) !== null && _b !== void 0 ? _b : '[unknown]');
        }
        return await Promise.resolve(this.format('The node %o%s%s defined in shape %o.', this.result.focusNode, this.valuesToString(), shape, (_c = this.result.sourceShape) !== null && _c !== void 0 ? _c : '[unknown SHACL SourceShape]'));
    }
}
//# sourceMappingURL=LogicalConstraintComponents.js.map