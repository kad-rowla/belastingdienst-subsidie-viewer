import { sh } from '@triplyetl/vocabularies';
import ConstraintComponent from '../ConstraintComponent.js';
export default class ValueRangeConstraintComponents extends ConstraintComponent {
    async toString() {
        if (this.result.sourceShape === undefined || this.result.resultPath === undefined) {
            return await Promise.resolve(this.resultMessagesToString());
        }
        let predicate = sh.maxExclusive;
        let msg = 'less than';
        switch (this.result.sourceConstraintComponent.value) {
            case sh.MinExclusiveConstraintComponent.value:
                predicate = sh.minExclusive;
                msg = 'greater than';
                break;
            case sh.MaxExclusiveConstraintComponent.value:
                predicate = sh.maxExclusive;
                msg = 'less than';
                break;
            case sh.MinInclusiveConstraintComponent.value:
                predicate = sh.minInclusive;
                msg = 'less than or equal to';
                break;
            case sh.MaxInclusiveConstraintComponent.value:
                predicate = sh.maxInclusive;
                msg = 'greater than or equal to';
                break;
        }
        const rq = `select ?actual ?compare where { <${this.result.sourceShape.value}> <${predicate.value}> ?compare . <${this.result.focusNode.value}> <${this.result.resultPath.value}> ?actual . }`;
        return await this.engine
            .query(rq)
            .then(async (results) => await results.toArray())
            .then((bindings) => {
            var _a;
            return this.format('The node %o has a predicate %o%s, your shape %o defines that this value must be %s %o.', this.result.focusNode, this.result.resultPath, this.valuesToString(), this.result.sourceShape, msg, (_a = bindings[0].compare) !== null && _a !== void 0 ? _a : ['unknown']);
        });
    }
}
//# sourceMappingURL=ValueRangeConstraintComponents.js.map