import { sh } from '@triplyetl/vocabularies';
import ConstraintComponent from '../ConstraintComponent.js';
export default class HasValueConstraintComponent extends ConstraintComponent {
    async toString() {
        var _a, _b;
        let values = '';
        let constraintMessage = 'none of which';
        if (this.opts.data !== undefined && this.result.resultPath !== undefined) {
            const nodes = this.opts.data.getObjects(this.result.focusNode, this.result.resultPath, null);
            if (nodes.length > 0) {
                values = ' with value ' + (nodes.length === 1 ? '' : 's') + this.format(nodes.map((_) => '%o').join(', '), ...nodes);
                constraintMessage = nodes.length === 1 ? 'none of which' : 'which does not';
            }
        }
        let expectedValues = '';
        if (this.opts.model !== undefined && this.result.sourceShape !== undefined) {
            const nodes = this.opts.model.getObjects(this.result.sourceShape, sh.hasValue, null);
            expectedValues = ' ' + this.format(nodes.map((_) => '%o').join(', '), ...nodes);
        }
        return await Promise.resolve(this.format('The node %o has a predicate %o%s %s match the value%s defined in your shape %o.', this.result.focusNode, (_a = this.result.resultPath) !== null && _a !== void 0 ? _a : '[unknown sh:resultPath]', values, constraintMessage, expectedValues, (_b = this.result.sourceShape) !== null && _b !== void 0 ? _b : ['unknown SourceShape']));
    }
}
// export default async (validationResult: Term, _: Term, store: Store): Promise<Template> => {
//   const focusNode = store.getObjects(validationResult, sh.focusNode, null)[0]
//   const resultPath = store.getObjects(validationResult, sh.resultPath, null)[0]
//   const sourceShape = store.getObjects(validationResult, sh.sourceShape, null)[0]
//   const values = store.getObjects(focusNode, resultPath, null).map((v) => getFactory().literal(`"${v.value}"`))
//   const hasValue = store.getObjects(sourceShape, sh.hasValue, null)[0]
//   return await Promise.resolve({
//     template:
//       values.length !== 1
//         ? 'your node {{0}} has a predicate {{1}} with values {{3}}, none of which match the value "{{4}}" as defined in your shape {{2}}.'
//         : 'your node {{0}} has a predicate {{1}} with value {{3}}, which does not match the value "{{4}}" as defined in your shape {{2}}.',
//     nodes: [focusNode, resultPath, sourceShape, values, hasValue]
//   })
// }
//# sourceMappingURL=HasValueConstraintComponent.js.map