import ConstraintComponent from '../ConstraintComponent.js';
export default class UniqueLangConstraintComponent extends ConstraintComponent {
    async toString() {
        var _a, _b;
        if (this.opts.model === undefined || this.opts.data === undefined || this.result.resultPath === undefined) {
            return await Promise.resolve(this.resultMessagesToString());
        }
        const languageNodes = this.opts.data.getObjects(this.result.focusNode, this.result.resultPath, null);
        const template = languageNodes.map((_) => '%o').join(', ');
        const values = languageNodes.length > 0 ? ' with value' + (languageNodes.length === 1 ? ' ' : 's ') + this.format(template, ...languageNodes) : '';
        const allLanguages = languageNodes.map((value) => (value.termType === 'Literal' && value.language !== '' ? value.language : '')).filter((lang) => lang !== '');
        const countLanguages = new Map();
        for (const l of allLanguages) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            countLanguages.set(l, countLanguages.has(l) ? countLanguages.get(l) + 1 : 1);
        }
        const languages = [];
        for (const l of countLanguages.entries()) {
            if (l[1] > 1)
                languages.push(this.format('%o (%ix)', ...l));
        }
        return await Promise.resolve(this.format('The node %o has a predicate %o%s; your shape %o defines that each language must be unique, but we found %s %s', this.result.focusNode, (_a = this.result.resultPath) !== null && _a !== void 0 ? _a : '[unknown sh:resultPath]', values, (_b = this.result.sourceShape) !== null && _b !== void 0 ? _b : '[unknown SHACL SourceShape]', languages.length === 1 ? 'one duplicate language' : 'the following duplicate languages', languages.join(', ')));
    }
}
//# sourceMappingURL=UniqueLangConstraintComponent.js.map