import { a, sh } from '@triplyetl/vocabularies';
import ConstraintComponent from '../ConstraintComponent.js';
export default class ClassConstraintComponent extends ConstraintComponent {
    async toString() {
        var _a, _b, _c, _d, _e, _f;
        let expectedShClass = this.format('[unknown]');
        if (this.result.sourceShape !== undefined) {
            const classes = (_a = this.opts.model) === null || _a === void 0 ? void 0 : _a.getObjects(this.result.sourceShape, sh.class, null);
            expectedShClass = (_b = classes === null || classes === void 0 ? void 0 : classes.map((c) => this.format('%o', c)).join(', ')) !== null && _b !== void 0 ? _b : expectedShClass;
        }
        let actualShClass = this.format('[unknown]');
        if (this.result.values.length > 0) {
            const classes = (_c = this.opts.data) === null || _c === void 0 ? void 0 : _c.getObjects(this.result.values[0], a, null);
            actualShClass = (_d = classes === null || classes === void 0 ? void 0 : classes.map((c) => this.format('%o', c)).join(', ')) !== null && _d !== void 0 ? _d : actualShClass;
        }
        return await Promise.resolve(this.format('The node %o has a predicate %o%s of class %s, your shape %o only allows (sub)class %s.', this.result.focusNode, (_e = this.result.resultPath) !== null && _e !== void 0 ? _e : '[unknown sh:resultPath]', this.valuesToString(), actualShClass, (_f = this.result.sourceShape) !== null && _f !== void 0 ? _f : '[unknown SHACL SourceShape]', expectedShClass));
    }
}
//# sourceMappingURL=ClassConstraintComponent.js.map