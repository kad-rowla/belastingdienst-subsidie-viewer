var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
/* eslint-disable @typescript-eslint/no-non-null-assertion */
import { getFactory } from '@triplydb/data-factory';
import SPARQLTargetTypesRq from '../Queries/SPARQLTargetTypes.rq.js';
import { sh } from '@triplyetl/vocabularies';
import { getEngineFromOptions } from './loadSPARQLTargets.js';
import { parseAndInjectVariablesIntoQuery } from '@triply/utils/sparqlVarUtils.js';
/**
 * Use this function to preload you model with SPARQL Target types
 *
 * @param opts.shapes a RdfJs dataset/store containing the shapes
 * @param opts.data an optional RdfJs dataset/store containing the data
 * @param opts.engines a Speedy engine, use this if you want to re-use the engine for other usage
 * @param opts.factory an optional DataFactory
 * @see https://www.w3.org/TR/shacl-af/#SPARQLTargetType
 */
export default async function loadSPARQLTargetTypes(opts) {
    const engine = getEngineFromOptions(opts);
    await engine
        .select(SPARQLTargetTypesRq)
        .then(async (bindings) => {
        var _a, e_1, _b, _c;
        var _d, _e, _f, _g;
        // group the bindings by query:
        const queries = new Map();
        try {
            for (var _h = true, bindings_1 = __asyncValues(bindings), bindings_1_1; bindings_1_1 = await bindings_1.next(), _a = bindings_1_1.done, !_a; _h = true) {
                _c = bindings_1_1.value;
                _h = false;
                const binding = _c;
                if (((_d = binding.value) === null || _d === void 0 ? void 0 : _d.termType) === 'BlankNode') {
                    throw new Error('Can not use blanknodes in a SPARQL variable configuration.');
                }
                const target = binding.target.value;
                if (!queries.has(target)) {
                    queries.set(target, {
                        query: binding.query.value,
                        shape: ((_e = binding.shape) === null || _e === void 0 ? void 0 : _e.termType) === 'BlankNode' ? binding.shape : binding.shape,
                        variables: {
                            variableDefinitions: [],
                            variableValues: {}
                        }
                    });
                }
                let config;
                const varName = binding.varName.value;
                if (((_f = binding.value) === null || _f === void 0 ? void 0 : _f.termType) === 'Literal') {
                    config = {
                        name: varName,
                        termType: 'Literal',
                        datatype: binding.value.datatype.value,
                        language: binding.value.language
                    };
                }
                else {
                    config = { name: varName, termType: 'NamedNode' };
                }
                queries.get(target).variables.variableDefinitions.push(config);
                queries.get(target).variables.variableValues[varName] = (_g = binding.value) === null || _g === void 0 ? void 0 : _g.value;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_h && !_a && (_b = bindings_1.return)) await _b.call(bindings_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return Array.from(queries.values());
    })
        .then(async (queries) => {
        var _a;
        const factory = (_a = opts.factory) !== null && _a !== void 0 ? _a : getFactory();
        for (const query of queries) {
            const rq = parseAndInjectVariablesIntoQuery(query.query, query.variables);
            await engine
                .select(rq)
                .then(async (bindings) => {
                var _a, e_2, _b, _c;
                try {
                    for (var _d = true, bindings_2 = __asyncValues(bindings), bindings_2_1; bindings_2_1 = await bindings_2.next(), _a = bindings_2_1.done, !_a; _d = true) {
                        _c = bindings_2_1.value;
                        _d = false;
                        const binding = _c;
                        if (binding.this === undefined) {
                            return await Promise.reject(new Error("Expected the bound variable '$this' in the result."));
                        }
                        else if (binding.this.termType === 'Literal') {
                            return await Promise.reject(new Error("Expected the bound variable '$this' to be a NamedNode or Blanknode, got a Literal."));
                        }
                        else {
                            opts.shapes.addQuad(factory.quad(query.shape, sh.targetNode, binding.this));
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (!_d && !_a && (_b = bindings_2.return)) await _b.call(bindings_2);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            });
        }
    })
        .then((_) => { });
}
//# sourceMappingURL=loadSPARQLTargetTypes.js.map