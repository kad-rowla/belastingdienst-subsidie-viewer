import { Store, getFactory } from '@triplydb/data-factory'
import { type Term, type NamedNode, type BlankNode, type Literal } from '@triplydb/data-factory/Terms.js'
import { newEngine } from '@triplydb/speedy-memory'
import { rdf, sh } from '@triplyetl/vocabularies'
import { Validator as ValidatorBase } from 'shacl-engine'
import Report from './Validator/Report.js'
import targetsRq from './Queries/targets.rq.js'
import { type BlankNodeOrIRI, type Targets } from './Types.js'
import { type SparqlEngine } from '@triplydb/engine/SparqlEngine.js'
import SPARQLConstraints from './Validator/ConstraintComponent/SPARQLConstraint.js'
import DatatypeAnyURIRq from './Queries/DatatypeAnyURI.rq.js'
import sh_sh from './Utilities/shacl-shacl.ttl.js'
import Writer from './Validator/Report/Writer.js'
import loadSPARQLTargets from './Utilities/loadSPARQLTargets.js'
import { PathList } from 'grapoi'
import TermMap from '@rdfjs/term-map'
import getDataFactoryWithDataset, { type DefaultFactoryWithDataset } from './Utilities/getDataFactoryWithDataset.js'

const $SIGNATURE = '@triplyetl/shacl/Validate'

export interface ValidatorOptions {
  factory: DefaultFactoryWithDataset
  debug?: boolean
  details?: boolean
  trace?: boolean
  coverage?: boolean
  engine?: SparqlEngine
  allowSPARQLTargets?: boolean
  skipShaclShaclValidaton?: boolean
}

export class ModelValidationError extends Error {
  public constructor (message: string, public writer: Writer) {
    super(message)
  }
}

export default class Validator extends ValidatorBase {
  public $signature = $SIGNATURE

  protected _data: Store | undefined
  protected engine: SparqlEngine | undefined

  /**
   * Constructor for the SHACL Validation Engine
   *
   * @param model a RdfJs compatible Store that holds the SHACL shapes (the model)
   * @param opts
   */
  constructor (
    public model: Store,
    public opts?: Partial<ValidatorOptions>
  ) {
    const factory = opts?.factory ?? getDataFactoryWithDataset()

    Validator.fixForIssue6223(model)
    super(model, { factory })
    this.engine = opts?.engine
  }

  private rebuild (): void {
    this.shapesPtr = new PathList({ dataset: this.model, factory: this.factory })
    this.shapes = new TermMap()

    const shapePtrs = [
      ...this.shapesPtr.hasOut([sh.targetClass]),
      ...this.shapesPtr.hasOut([sh.targetNode]),
      ...this.shapesPtr.hasOut([sh.targetObjectsOf]),
      ...this.shapesPtr.hasOut([sh.targetSubjectsOf]),
      ...this.shapesPtr.hasOut([rdf.type], [sh.NodeShape]),
      ...this.shapesPtr.hasOut([rdf.type], [sh.PropertyShape])
    ]

    for (const shapePtr of shapePtrs) {
      this.shape(shapePtr)
    }
  }

  get data (): Store {
    if (this._data === undefined) {
      throw new Error('Before accessing the internal dataset, you need to set it first.')
    }
    return this._data
  }

  set data (data: Store) {
    this._data = data
  }

  /**
   * @see https://issues.triply.cc/issues/6223
   */
  private static fixForIssue6223 (dataset: Store): void {
    const factory = getFactory()
    dataset
      .getObjects(null, sh.path, null)
      .filter((node) => node.termType === 'NamedNode')
      .filter((node) => {
        return dataset.getObjects(node, sh.alternativePath, null).length > 0 || dataset.getObjects(node, sh.inversePath, null).length > 0 || dataset.getObjects(node, sh.oneOrMorePath, null).length > 0 || dataset.getObjects(node, sh.zeroOrMorePath, null).length > 0 || dataset.getObjects(node, sh.zeroOrOnePath, null).length > 0
      })
      .forEach((node) => {
        const blankNode = factory.blankNode()
        dataset.getQuads({ subject: node }).forEach((quad) => {
          dataset.addQuad(factory.quad(blankNode, quad.predicate, quad.object, quad.graph))
        })
        dataset.getSubjects(sh.path, node, null).forEach((s) => {
          dataset.removeQuad(factory.quad(s, sh.path, node))
          dataset.addQuad(factory.quad(s, sh.path, blankNode))
        })
      })
  }

  /**
   * @param data The data must have the following structure:
   *  - dataset: An RDF/JS DatasetCore object that contains the quads. (required)
   *  - terms: An iterable object of RDF/JS Terms that will be used as initial focus nodes. (optional)
   * @param shapes The shapes object is optional, but if given must have the following structure:
   *  - terms: An iterable object of RDF/JS Terms that refers to the initial set of shapes. (optional) This doesn't limit the nested shapes.
   * @returns a SHACL Validation Report object
   */
  // @ts-expect-error Our validate method is not compatible with the super
  public async validate (data: { dataset?: Store, terms?: Term[] }, shapes?: Term[] | Term): Promise<Report> {

    if ((this.opts?.allowSPARQLTargets ?? true) && ((this.shapesPtr.in([sh.select])?.ptrs.length ?? 0) > 0)) {
      const size = this.model.size
      await loadSPARQLTargets({ shapes: this.model, data: data.dataset })
      if (size !== this.model.size) {
        this.rebuild()
      }
    }
    if (!(this.opts?.skipShaclShaclValidaton ?? false)) {
      await Validator.validateModel(this.model, this.factory)
    }

    if (data.dataset !== undefined) {
      this.data = data.dataset
    }
    let terms: undefined | Array<{ terms: Term[] }>
    if (shapes !== undefined) {
      if (!Array.isArray(shapes)) shapes = [shapes]
      terms = [{ terms: shapes }]
    }
    const report = new Report(await super.validate({ ...data, dataset: data.dataset ?? this.model }, terms), { model: this.model })
    const store = new Store(this.model.getQuads({}))
    if (this._data !== undefined) {
      store.addQuads(this._data.getQuads({}))
    }
    const engine = this.opts?.engine ?? newEngine(store)
    await this.validateAnyURI(engine, report)
    report.SPARQLConstraintConforms = await SPARQLConstraints({ report, store, engine, factory: this.factory })
    return report
  }

  /**
   * Validate models against Shacl-Shacl
   *
   * @param model a Store containing the shapes
   * @param factory an optional DataFactory
   * @throws ModelValidationError
   */
  public static async validateModel (model: Store, factory?: DefaultFactoryWithDataset): Promise<void> {
    // first: validate the Shape itself:
    await (new ValidatorBase(sh_sh, { factory: factory ?? getDataFactoryWithDataset() })).validate({ dataset: model })
      .then(async report => {
        if (!report.conforms) {
          throw new ModelValidationError(
            'The model is not a valid SHACL model.',
            Writer.fromValidationReport(report.dataset, model)
          )
        }
      })
  }

  /**
   * @see https://git.triply.cc/triply/etl/-/issues/263
   */
  protected async validateAnyURI (engine: SparqlEngine, report: Report): Promise<void> {
    const rq = DatatypeAnyURIRq

    for await (const binding of await engine.select(rq)) {
      if (binding.anyURI !== undefined) {
        try {
          // eslint-disable-next-line no-new
          new URL(binding.anyURI.value)
        } catch (e) {
          report.addValidationResult({
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            focusNode: binding.focusNode! as BlankNodeOrIRI,
            resultMessages: [this.factory.literal((e as Error).message)],
            // @ts-expect-error we know this is always a correct value
            resultSeverity: binding.resultSeverity?.value ?? 'Violation',
            sourceConstraintComponent: sh.DatatypeConstraintComponent,
            resultPath: binding.resultPath as BlankNodeOrIRI,
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            values: [binding.anyURI! as Literal],
            sourceShape: binding.propertyShape as BlankNodeOrIRI
          })
        }
      }
    }
  }

  public static async getTargets (opts: { shapes: Store, data?: Store }): Promise<Targets> {
    const targets: Targets = new Set()
    const store = new Store(opts.shapes.getQuads({}).concat(opts.data === undefined ? [] : opts.data.getQuads({})))
    for await (const binding of await newEngine(store).select(targetsRq)) {
      if (binding.shape === undefined || binding.target === undefined) {
        throw new Error("Expected a binding for 'shape' and for 'target'")
      }
      targets.add({ shape: binding.shape as NamedNode, node: binding.target as NamedNode | BlankNode })
    }
    return targets
  }

  public static isValidator (obj: unknown): obj is Validator {
    if (typeof obj !== 'object') return false
    if (obj === null) return false
    if (!Object.hasOwn(obj, '$signature')) return false
    // @ts-expect-error we now know this property does exists
    return obj.$signature === $SIGNATURE
  }
}
