import { type DefaultFactory, type Store } from '@triplydb/data-factory'
import { type BlankNode, type NamedNode, type Quad } from '@triplydb/data-factory/Terms.js'
import { sh, a, xsd, rdf, rdfs, sdo, owl } from '@triplyetl/vocabularies'
import type ReportBase from 'shacl-engine/lib/Report.js'
import chalk from 'chalk'
import Writer from './Report/Writer.js'
import type ValidationResult from './Report/Writer/ValidationResult.js'

export interface ReportOptions {
  prefixes: Record<string, string>
  model: Store
}

export const commonPrefixes: Record<string, string> = {
  rdf: rdf.toIri().value,
  rdfs: rdfs.toIri().value,
  sdo: sdo.toIri().value,
  owl: owl.toIri().value,
  sh: sh.toIri().value,
  xsd: xsd.toIri().value
}

interface Severities {
  violation: Quad[]
  warning: Quad[]
  info: Quad[]
}

export default class Report {
  public opts: Partial<ReportOptions> = {}
  private _severities?: Severities
  public SPARQLConstraintConforms: boolean = true
  private $conforms: boolean = true

  public constructor (
    protected report: ReportBase,
    opts?: Partial<ReportOptions>
  ) {
    if (opts?.prefixes != null) opts.prefixes = { ...commonPrefixes, ...opts.prefixes }
    else if (opts != null) opts.prefixes = commonPrefixes
    this.opts = opts ?? { prefixes: commonPrefixes }
    this.$conforms = report.conforms
  }

  public addPrefixes (prefixes: Record<string, string>): Report {
    this.opts.prefixes = { ...this.opts.prefixes, ...prefixes }
    return this
  }

  get conforms (): boolean {
    return this.$conforms && this.report.conforms && this.SPARQLConstraintConforms
  }

  set conforms (value: boolean) {
    if (this.$conforms !== value) {
      const conforms = this.factory.literal(value ? 'true' : 'false', xsd.boolean)
      this.report.dataset.getSubjects(a, sh.ValidationReport, null).forEach(report => {
        this.report.dataset.removeQuads(this.report.dataset.getQuads({ subject: report, predicate: sh.conforms }))
        this.report.dataset.addQuad(report, sh.conforms, conforms)
      })
      this.$conforms = value
    }
  }

  addValidationResult (result: ValidationResult): void {
    this.conforms = false
    const resultNode = this.factory.blankNode()
    this.dataset.getSubjects(a, sh.ValidationReport, null).forEach(r => {
      this.dataset.addQuad(r, sh.result, resultNode)
    })
    let severity
    switch (result.resultSeverity) {
      case 'Info': severity = sh.Info; break
      case 'Warning': severity = sh.Warning; break
      default: severity = sh.Violation
    }
    this.dataset.addQuads([
      this.factory.quad(resultNode, a, sh.ValidationResult),
      this.factory.quad(resultNode, sh.focusNode, result.focusNode),
      this.factory.quad(resultNode, sh.resultSeverity, severity),
      this.factory.quad(resultNode, sh.sourceConstraintComponent, result.sourceConstraintComponent)
    ])

    if (result.resultPath !== undefined) {
      this.dataset.addQuad(this.factory.quad(resultNode, sh.resultPath, result.resultPath))
    }

    if (result.sourceShape !== undefined) {
      this.dataset.addQuad(this.factory.quad(resultNode, sh.sourceShape, result.sourceShape))
    }

    result.values.forEach(value => {
      this.dataset.addQuad(this.factory.quad(resultNode, sh.value, value))
    })

    result.resultMessages.forEach(msg => {
      this.dataset.addQuad(this.factory.quad(resultNode, sh.resultMessage, msg))
    })
  }

  get details (): boolean {
    return this.report.details
  }

  get factory (): DefaultFactory {
    return this.report.factory
  }

  get options (): any {
    return this.report.options
  }

  get dataset (): Store {
    return this.report.dataset
  }

  get results (): any[] {
    return this.report.results
  }

  get writer (): Writer {
    return Writer.fromReport(this, this.opts.model)
  }

  public get severity (): Severities {
    if (this._severities == null) {
      const quads: Quad[] = this.report.dataset.getQuads({ predicate: sh.resultSeverity })
      this._severities = {
        warning: quads.filter((quad) => quad.object.equals(sh.Warning)),
        info: quads.filter((quad) => quad.object.equals(sh.Info)),
        violation: quads.filter((quad) => quad.object.equals(sh.Violation))
      }
    }
    return this._severities
  }

  /**
   * Get all Focusnodes from the report
   *
   * @returns the focusnodes that are not valid
   */
  public get focusNodes (): Array<NamedNode | BlankNode> {
    return this.dataset.getObjects(null, sh.focusNode, null) as Array<NamedNode | BlankNode>
  }

  public get severityMessage (): string {
    const msg: string[] = []
    if (this.countViolations() > 0) {
      msg.push(chalk.red(`${this.countViolations()} Violation${this.countViolations() > 1 ? 's' : ''}`))
    }
    if (this.countWarnings() > 0) {
      msg.push(chalk.yellow(`${this.countWarnings()} Warning${this.countWarnings() > 1 ? 's' : ''}`))
    }
    if (this.countInfos() > 0) {
      msg.push(chalk.blue(`${this.countInfos()} Info${this.countInfos() > 1 ? 's' : ''}`))
    }

    if (msg.length === 0) return ''
    else if (msg.length === 1) return msg[0]
    const lastMsg = msg.pop()
    return `${msg.join(', ')} and ${lastMsg ?? ''}`
  }

  public countWarnings (): number {
    return this.severity.warning.length
  }

  public countInfos (): number {
    return this.severity.info.length
  }

  public countViolations (): number {
    return this.severity.violation.length
  }
}
