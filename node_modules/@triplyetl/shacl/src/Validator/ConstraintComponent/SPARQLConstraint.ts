import { type DefaultFactory, type Store, getFactory } from '@triplydb/data-factory'
import { type NamedNode, type BlankNode, type Literal } from '@triplydb/data-factory/Terms.js'
import { newEngine } from '@triplydb/speedy-memory'
import { a, rdf, sh, xsd } from '@triplyetl/vocabularies'
import type Report from '../Report.js'
import { type SparqlEngine } from '@triplydb/engine/SparqlEngine.js'
import SPARQLConstraintRq from '../../Queries/SPARQLConstraint.rq.js'
import SHACLAnnotationsRq from '../../Queries/SHACLAnnotations.rq.js'

/**
 * SHACL-SPARQL supports a constraint component that can be used to express restrictions based on a SPARQL SELECT query.
 *
 * This function modifies the validation report and adds new sh:result nodes when applicable
 *
 * @see https://www.w3.org/TR/shacl/#sparql-constraints
 * @param opts
 * @returns a boolean that indicates if non-conforming data is detected
 */
export default async function SPARQLConstraints (opts: {
  report: Report
  store: Store
  engine?: SparqlEngine
  factory?: DefaultFactory
}): Promise<boolean> {
  const $engine = opts.engine ?? newEngine(opts.store)
  const factory = opts.factory ?? getFactory()
  let conforms = true
  return await $engine
    .select(SPARQLConstraintRq)
    .then(async (bindings) => {
      for await (const binding of bindings) {
        if (binding.query === undefined) throw new Error("expected binding for 'query'")
        if (binding.shape === undefined) throw new Error("expected binding for 'shape'")
        if (binding.SPARQLConstraint === undefined) throw new Error("expected binding for 'SPARQLConstraint'")
        const shape = binding.shape
        const SPARQLConstraint = binding.SPARQLConstraint
        const shMessage = binding.message !== undefined ? (binding.message as Literal) : undefined
        await $engine
          .select(binding.query.value)
          .then(async (bindings) => {
            const results: BlankNode[] = []
            for await (const binding of bindings) {
              const result = factory.blankNode()
              results.push(result)
              conforms = false
              if (binding.this === undefined) throw new Error("expected binding for 'this'")
              // if (binding.path === undefined) throw new Error("expected binding for 'path'")
              opts.report.dataset.addQuads([
                factory.quad(result, rdf.type, sh.ValidationResult),
                factory.quad(result, sh.resultSeverity, binding.severity ?? sh.Violation),
                factory.quad(result, sh.focusNode, binding.this),
                factory.quad(result, sh.sourceConstraintComponent, sh.SPARQLConstraintComponent),
                factory.quad(result, sh.sourceShape, shape),
                factory.quad(result, sh.sourceConstraint, SPARQLConstraint)
              ])
              if (binding.path !== undefined) {
                opts.report.dataset.addQuad(
                  factory.quad(result, sh.resultPath, binding.path)
                )
              }

              // do we have Annotation Properties?
              const rq = SHACLAnnotationsRq(
                shape.termType === 'BlankNode' ? shape : shape as NamedNode,
                binding.this.termType === 'BlankNode' ? binding.this : binding.this as NamedNode
              )

              await $engine.select(rq)
                .then(async bindings => {
                  for await (const binding of bindings) {
                    let value: NamedNode | BlankNode | Literal | undefined
                    if (binding.value !== undefined) {
                      value = binding.value
                    } else if (binding.annotationVarName !== undefined && binding[binding.annotationVarName.value] !== undefined) {
                      value = binding[binding.annotationVarName.value]
                    }
                    if (value !== undefined) {
                      opts.report.dataset.addQuad(
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        factory.quad(result, binding.annotationProperty! as NamedNode, value)
                      )
                    }
                  }
                })

              let message: Literal
              if (binding.message !== undefined) {
                if (binding.message.termType !== 'Literal') {
                  throw new Error(`when a message is returned it must be a Literal, got a ${binding.message.termType}`)
                }
                message = binding.message
              } else if (shMessage !== undefined) {
                message = shMessage
              } else {
                message = factory.literal('SHACL Constraint violation')
              }
              let messageTemplate = message.value
              for (const b in binding) {
                messageTemplate = messageTemplate.replace(`{?${b}}`, binding[b]?.value ?? `{?${b}}`)
              }
              message = factory.literal(messageTemplate, message.language !== '' ? message.language : message.datatype)
              opts.report.dataset.addQuad(factory.quad(result, sh.resultMessage, message))
            }
            return results
          })
          .then((results) => {
            if (!conforms) {
              const reports = opts.report.dataset.getSubjects(a, sh.ValidationReport, null)
              if (reports.length > 0) {
                reports.forEach((subject) => {
                  opts.report.dataset.removeQuads(opts.report.dataset.getQuads({ subject, predicate: sh.conforms }))
                  opts.report.dataset.addQuad(factory.quad(subject, sh.conforms, factory.literal('false', xsd.boolean)))
                  for (const result of results) {
                    opts.report.dataset.addQuad(factory.quad(subject, sh.result, result))
                  }
                })
              } else {
                const bn = factory.blankNode()
                opts.report.dataset.addQuad(factory.quad(bn, a, sh.ValidationReport))
                opts.report.dataset.addQuad(factory.quad(bn, sh.conforms, factory.literal('false', xsd.boolean)))
                for (const result of results) {
                  opts.report.dataset.addQuad(factory.quad(bn, sh.result, result))
                }
              }
            }
          })
      }
      return conforms
    })
}
