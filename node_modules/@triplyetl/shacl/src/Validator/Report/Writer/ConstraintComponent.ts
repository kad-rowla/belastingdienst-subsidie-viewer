import type ValidationResult from './ValidationResult.js'
import { type SparqlEngine } from '@triplydb/engine/SparqlEngine.js'
import { type Options as WriterOptions } from '../Writer.js'
import { type Term, type NamedNode, type Literal, type BlankNode } from '@triplydb/data-factory/Terms.js'
import { shrink } from '@zazuko/prefixes/shrink'
import { formatWithOptions } from 'util'

const isTerm = (obj: any): obj is Term => {
  return typeof obj === 'object' && Object.hasOwn(obj, 'termType')
}

const isNamedNode = (obj: any): obj is NamedNode => {
  return isTerm(obj) && obj.termType === 'NamedNode'
}

const isBlankNode = (obj: any): obj is BlankNode => {
  return isTerm(obj) && obj.termType === 'BlankNode'
}

const isLiteral = (obj: any): obj is Literal => {
  return isTerm(obj) && obj.termType === 'Literal'
}

export default abstract class ConstraintComponent {
  constructor (
    protected readonly result: ValidationResult,
    protected readonly engine: SparqlEngine,
    protected readonly opts: WriterOptions
  ) {}

  protected format (template: string, ...parameters: any): string {
    const parametersAsStrings: string[] = []
    for (const parameter of parameters) {
      let stringValue = parameter
      if (isNamedNode(parameter)) {
        stringValue = this.shrink(parameter)
      } else if (isBlankNode(parameter)) {
        stringValue = '_:' + parameter.value
      } else if (isLiteral(parameter)) {
        stringValue = this.literalToString(parameter)
      }
      parametersAsStrings.push(stringValue)
    }
    return formatWithOptions({ colors: true }, template, ...parametersAsStrings)
  }

  protected shrink (term: NamedNode): string {
    const shrinked = shrink(term.value, this.opts.prefixes)
    return shrinked === '' ? term.value : shrinked
  }

  protected literalToString (term: Literal): string {
    let str = term.value === '' ? '[empty string]' : term.value
    if (term.language !== '') str += '@' + term.language
    else str += '^^' + shrink(term.datatype.value, this.opts.prefixes)
    return str
  }

  protected resultMessagesToString (): string {
    return this.result.resultMessages.map((l) => this.literalToString(l)).join('; ')
  }

  protected valuesToString (suffix: string = ' with value'): string {
    let value: string = ''
    if (this.result.values.length > 0) {
      value = suffix + (this.result.values.length > 1 ? 's' : '') + ' '
      value += this.result.values
        .map((value) => {
          return this.format('%o', value.termType === 'Literal' ? this.literalToString(value) : this.shrink(value))
        })
        .join(', ')
    }
    return value
  }

  public abstract toString (): Promise<string>
}
