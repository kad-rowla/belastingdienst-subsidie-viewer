import { type Term } from '@triplydb/data-factory/Terms.js'
import { sh } from '@triplyetl/vocabularies'
import ConstraintComponent from '../ConstraintComponent.js'
import { type BindingsResult } from '@triplydb/engine/QueryResults.js'

export default class ValueRangeConstraintComponents extends ConstraintComponent {
  public async toString (): Promise<string> {
    if (this.result.sourceShape === undefined || this.result.resultPath === undefined) {
      return await Promise.resolve(this.resultMessagesToString())
    }
    let predicate: Term = sh.maxExclusive
    let msg = 'less than'
    switch (this.result.sourceConstraintComponent.value) {
      case sh.MinExclusiveConstraintComponent.value:
        predicate = sh.minExclusive
        msg = 'greater than'
        break
      case sh.MaxExclusiveConstraintComponent.value:
        predicate = sh.maxExclusive
        msg = 'less than'
        break
      case sh.MinInclusiveConstraintComponent.value:
        predicate = sh.minInclusive
        msg = 'less than or equal to'
        break
      case sh.MaxInclusiveConstraintComponent.value:
        predicate = sh.maxInclusive
        msg = 'greater than or equal to'
        break
    }

    const rq = `select ?actual ?compare where { <${this.result.sourceShape.value}> <${predicate.value}> ?compare . <${this.result.focusNode.value}> <${this.result.resultPath.value}> ?actual . }`
    return await this.engine
      .query(rq)
      .then(async (results) => await (results as BindingsResult).toArray())
      .then((bindings) => {
        return this.format('The node %o has a predicate %o%s, your shape %o defines that this value must be %s %o.', this.result.focusNode, this.result.resultPath, this.valuesToString(), this.result.sourceShape, msg, bindings[0].compare ?? ['unknown'])
      })
  }
}
