import { rdf, sh } from '@triplyetl/vocabularies'
import ConstraintComponent from '../ConstraintComponent.js'

export default class InConstraintComponent extends ConstraintComponent {
  public async toString (): Promise<string> {
    if (this.opts.model === undefined || this.opts.data === undefined || this.result.resultPath === undefined || this.result.sourceShape === undefined) {
      return await Promise.resolve(this.format('The node %o has a predicate %o%s; your shape %o reports the following: %s', this.result.focusNode, this.result.resultPath ?? '[unknown sh:resultPath]', this.valuesToString(), this.result.sourceShape ?? '[unknown SHACL SourceShape]', this.resultMessagesToString()))
    }

    let expectedInList = this.opts.model.getObjects(this.result.sourceShape, sh.in, null)[0]
    const expectedIn: string[] = []
    while (true) {
      const shin = this.opts.model.getObjects(expectedInList, rdf.first, null)[0]
      expectedIn.push(this.format('%o', shin.termType === 'Literal' ? this.literalToString(shin) : shin.value))
      const rest = this.opts.model.getObjects(expectedInList, rdf.rest, null)[0]
      if (rest.equals(rdf.nil) || rest === undefined) {
        break
      }
      expectedInList = rest
    }

    return await Promise.resolve(this.format('The node %o has a predicate %o%s; your shape %o only allows value%s %s', this.result.focusNode, this.result.resultPath ?? '[unknown sh:resultPath]', this.valuesToString(), this.result.sourceShape ?? '[unknown SHACL SourceShape]', expectedIn.length === 1 ? '' : 's', expectedIn.join(', ')))
  }
}
