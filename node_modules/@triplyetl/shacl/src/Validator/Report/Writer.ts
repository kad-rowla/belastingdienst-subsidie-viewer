/* eslint-disable @typescript-eslint/no-base-to-string */
import { Store, getWriter, getFactory, type DefaultFactory } from '@triplydb/data-factory'
import { type WriterOptions } from '@triplydb/data-factory/serialize.js'
import { rdf, rdfs, sdo, sh } from '@triplyetl/vocabularies'
import type Report from '../Report.js'
import { type BlankNodeOrIRI } from '../../Types.js'
import assertIsSHACLValidationReport from './Writer/assertIsSHACLValidationReport.js'
import type ValidationResult from './Writer/ValidationResult.js'
import { newEngine } from '@triplydb/speedy-memory'
import SHACLValidationResultRq from '../../Queries/SHACLValidationResult.rq.js'
import { type NamedNode } from '@triplydb/data-factory/Terms.js'
import { type ResultSeverity } from './Writer/ValidationResult.js'
import ConstraintComponentFactory from './Writer/ConstraintComponents/Factory.js'
import chalk from 'chalk'
import wrap from 'word-wrap'
import { shrink } from '@zazuko/prefixes'
import { formatWithOptions } from 'util'
import { type PathLike, type WriteFileOptions, promises as fs } from 'fs'
const $SIGNATURE = '@triplyetl/shacl/Validator/Report/Writer'

export interface Options {
  factory: DefaultFactory
  prefixes: Record<string, string>
  model?: Store
  data?: Store
}

const standardPrefixes: Record<string, string> = {
  // eslint-disable-next-line @typescript-eslint/no-base-to-string
  sh: sh.toString(),
  // eslint-disable-next-line @typescript-eslint/no-base-to-string
  rdf: rdf.toString(),
  // eslint-disable-next-line @typescript-eslint/no-base-to-string
  rdfs: rdfs.toString(),
  // eslint-disable-next-line @typescript-eslint/no-base-to-string
  sdo: sdo.toString(),
  ex: 'http://example.org/',
  exs: 'https://example.org/',
  exc: 'http://example.con/',
  excs: 'https://example.con/',
  triply: 'http://triplydb.com/'
}

/**
 * The class that turns a SHACL Validation report into human readable messages
 */
export default class Writer {
  public $signature = $SIGNATURE

  private readonly report: BlankNodeOrIRI
  public conforms: boolean
  protected opts: Options
  public $results?: ValidationResult[]

  constructor (
    private readonly dataset: Store,
    opts?: Partial<Options>
  ) {
    const { report, conforms } = assertIsSHACLValidationReport(dataset)
    this.report = report
    this.conforms = conforms
    this.opts = {
      ...opts,
      factory: opts?.factory ?? getFactory(),
      prefixes: { ...standardPrefixes, ...opts?.prefixes }
    }
  }

  public static fromReport (report: Report, model?: Store): Writer {
    const writer = new Writer(report.dataset, { model })
    return writer
  }

  public static fromValidationReport (report: Store, model?: Store): Writer {
    const writer = new Writer(report, { model })
    return writer
  }

  /**
   * Turn the Results into a tree, grouped by result
   */
  public async getResults (): Promise<ValidationResult[]> {
    if (this.$results !== undefined) {
      return this.$results
    }
    // SHACL implementations may use other SHACL subclasses of sh:AbstractResult see https://w3c.github.io/data-shapes/shacl/#results-validation-result
    this.dataset.addQuad(this.opts.factory.quad(sh.ValidationResult, rdfs.subClassOf, sh.AbstractResult))
    const engine = newEngine(this.dataset)
    return await engine
      .select(SHACLValidationResultRq)
      .then(async (bindings) => {
        let i = 0
        const map = new Map<string, number>()
        const results: ValidationResult[] = []
        let ix: number | undefined
        for await (const binding of bindings) {
          ix = map.get(binding.result?.value ?? '<>')
          if (ix === undefined) {
            map.set(binding.result?.value ?? '<>', i)
            results[i] = {
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              resultNode: binding.result!,
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              focusNode: binding.focusNode! as NamedNode,
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              sourceConstraintComponent: binding.sourceConstraintComponent! as NamedNode,
              resultSeverity: (binding.resultSeverity?.value.replace(sh.toString(), '') ?? 'Violation') as ResultSeverity,
              resultMessages: [],
              values: []
            }
            ix = i
            i++
          }
          if (binding.resultMessage?.termType === 'Literal') {
            results[ix].resultMessages.push(binding.resultMessage)
          }

          if (binding.resultPath?.termType === 'NamedNode') {
            results[ix].resultPath = binding.resultPath
          }

          if (binding.detail?.termType === 'NamedNode') {
            results[ix].detail = binding.detail
          }

          if (binding.sourceShape?.termType === 'NamedNode' || binding.sourceShape?.termType === 'BlankNode') {
            results[ix].sourceShape = binding.sourceShape
          }

          if (binding.value?.termType === 'Literal' || binding.value?.termType === 'NamedNode') {
            results[ix].values.push(binding.value)
          }

          if (binding.sourceConstraint?.termType === 'BlankNode' || binding.sourceConstraint?.termType === 'NamedNode') {
            results[ix].sourceConstraint = binding.sourceConstraint
          }
        }
        this.$results = results
        return this.$results
      })
  }

  public async saveRdf (destination: fs.FileHandle | PathLike, options?: { rdf: WriterOptions, file: WriteFileOptions }): Promise<void> {
    await this.toRdf(options?.rdf)
      .then(async rdf => {
        await fs.writeFile(destination, rdf, options?.file)
      })
  }

  public async toRdf (options?: WriterOptions): Promise<string> {
    options = options ?? {}
    options.prefixes = {
      sh: sh.toIri(),
      rdf: rdf.toIri(),
      rdfs: rdfs.toIri(),
      ex: getFactory().namedNode('http://example.org/'),
      ...(options?.prefixes ?? {})
    }
    const writer = getWriter(options)
    writer.addQuads(this.dataset.getQuads({}))
    return await new Promise<string>((resolve, reject) => {
      writer.end(function (error: Error | undefined, result: string) {
        if (error !== null) reject(new Error('failed to write quads'))
        else resolve(result)
      })
    })
  }

  public async toString (): Promise<string> {
    const store = new Store(this.dataset.getQuads({}))
    if (this.opts.model !== undefined) store.addQuads(this.opts.model.getQuads({}))
    if (this.opts.data !== undefined) store.addQuads(this.opts.data.getQuads({}))
    const engine = newEngine(store)
    const resultMessages: string[] = []
    for (const result of await this.getResults()) {
      let indent = 'â–Œ '
      switch (result.resultSeverity) {
        case 'Info': indent = chalk.blue(indent); break
        case 'Warning': indent = chalk.cyan(indent); break
        case 'Violation': indent = chalk.red(indent); break
      }
      const label = shrink(result.sourceConstraintComponent.value, { sh: sh.toString() })
      let resultMessage = result.resultMessages.map(msg => msg.value).join('; ')
      const iris: string[] = []
      for (const m of resultMessage.matchAll(/<(.*?)>/g)) {
        resultMessage = resultMessage.replace(m[0], '%o')
        const shronken = shrink(m[1], this.opts.prefixes)
        iris.push(shronken === '' ? m[0] : shronken)
      }
      resultMessage = formatWithOptions({ colors: true }, resultMessage, ...iris)
      const width = (process.stdout.columns ?? 80) > 80 ? 80 : (process.stdout.columns ?? 80)
      try {
        const component = ConstraintComponentFactory.getConstraintComponent(result, engine, this.opts)
        const componentMessage = wrap(await component.toString(), { width, indent })
        resultMessages.push(componentMessage +
          chalk.gray(`\n   - ${chalk.italic('severity')}  : `) +
          (result.resultSeverity === 'Info' ? chalk.blue('Info') : '') +
          (result.resultSeverity === 'Warning' ? chalk.cyan('Warning') : '') +
          (result.resultSeverity === 'Violation' ? chalk.red('Violation') : '') +
          chalk.gray(`\n   - ${chalk.italic('component')} : ${label}`) +
          (result.resultMessages.length > 0 ? chalk.grey(`\n   - ${chalk.italic('message')}   : ${resultMessage}`) : '')
        )
      } catch (e) {
        resultMessages.push(
          wrap(resultMessage, { width, indent }) +
          chalk.gray(`\n   - ${chalk.italic('severity')}  : `) +
          (result.resultSeverity === 'Info' ? chalk.blue('Info') : '') +
          (result.resultSeverity === 'Warning' ? chalk.cyan('Warning') : '') +
          (result.resultSeverity === 'Violation' ? chalk.red('Violation') : '') +
          chalk.gray(`\n   - ${chalk.italic('component')} : ${label}`)
        )
      }
    }
    return resultMessages.join('\n\n')
  }

  public static isWriter (obj: unknown): obj is Writer {
    if (typeof obj !== 'object') return false
    if (obj === null) return false
    if (!Object.hasOwn(obj, '$signature')) return false
    // @ts-expect-error we now know this property does exists
    return obj.$signature === $SIGNATURE
  }
}
