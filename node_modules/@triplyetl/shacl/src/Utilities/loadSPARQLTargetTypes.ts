/* eslint-disable @typescript-eslint/no-non-null-assertion */
import { getFactory } from '@triplydb/data-factory'
import { type NamedNode, type BlankNode } from '@triplydb/data-factory/Terms.js'
import SPARQLTargetTypesRq from '../Queries/SPARQLTargetTypes.rq.js'
import { sh } from '@triplyetl/vocabularies'
import { type Options, getEngineFromOptions } from './loadSPARQLTargets.js'
import { parseAndInjectVariablesIntoQuery, type SparqlVariables } from '@triply/utils/sparqlVarUtils.js'
import { type VariableConfig, type LiteralConfig, type NamedNodeConfig } from '@triply/utils/Models.js'

/**
 * Use this function to preload you model with SPARQL Target types
 *
 * @param opts.shapes a RdfJs dataset/store containing the shapes
 * @param opts.data an optional RdfJs dataset/store containing the data
 * @param opts.engines a Speedy engine, use this if you want to re-use the engine for other usage
 * @param opts.factory an optional DataFactory
 * @see https://www.w3.org/TR/shacl-af/#SPARQLTargetType
 */
export default async function loadSPARQLTargetTypes (opts: Options): Promise<void> {
  const engine = getEngineFromOptions(opts)
  await engine
    .select(SPARQLTargetTypesRq)
    .then(async bindings => {
      // group the bindings by query:
      const queries = new Map<
      string,
      {
        query: string
        shape: NamedNode | BlankNode
        variables: SparqlVariables
      }
      >()
      for await (const binding of bindings) {
        if (binding.value?.termType === 'BlankNode') {
          throw new Error('Can not use blanknodes in a SPARQL variable configuration.')
        }
        const target = binding.target!.value
        if (!queries.has(target)) {
          queries.set(target, {
            query: binding.query!.value,
            shape: binding.shape?.termType === 'BlankNode' ? binding.shape : (binding.shape as NamedNode),
            variables: {
              variableDefinitions: [],
              variableValues: {}
            }
          })
        }

        let config: VariableConfig
        const varName = binding.varName!.value
        if (binding.value?.termType === 'Literal') {
          config = {
            name: varName,
            termType: 'Literal',
            datatype: binding.value.datatype.value,
            language: binding.value.language
          } satisfies LiteralConfig
        } else {
          config = { name: varName, termType: 'NamedNode' } satisfies NamedNodeConfig
        }

        queries.get(target)!.variables.variableDefinitions.push(config)
        queries.get(target)!.variables.variableValues[varName] = binding.value?.value
      }
      return Array.from(queries.values())
    })
    .then(async (queries) => {
      const factory = opts.factory ?? getFactory()
      for (const query of queries) {
        const rq = parseAndInjectVariablesIntoQuery(query.query, query.variables)
        await engine
          .select(rq)
          .then(async (bindings) => {
            for await (const binding of bindings) {
              if (binding.this === undefined) {
                return await Promise.reject(new Error("Expected the bound variable '$this' in the result."))
              } else if (binding.this.termType === 'Literal') {
                return await Promise.reject(new Error("Expected the bound variable '$this' to be a NamedNode or Blanknode, got a Literal."))
              } else {
                opts.shapes.addQuad(factory.quad(query.shape, sh.targetNode, binding.this))
              }
            }
          })
      }
    })
    .then((_) => {})
}
