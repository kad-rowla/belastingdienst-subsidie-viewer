import { type DefaultFactory, getFactory, Store } from '@triplydb/data-factory'
import { newEngine } from '@triplydb/speedy-memory'
import { type SparqlEngine } from '@triplydb/engine/SparqlEngine.js'
import { isEngine } from './isEngine.js'
import SPARQLTargetsRq from '../Queries/SPARQLTargets.rq.js'
import { sh } from '@triplyetl/vocabularies'
import { type BlankNodeOrIRI } from '../Types.js'

export interface Options {
  shapes: Store
  data?: Store
  engine?: SparqlEngine
  factory?: DefaultFactory
}

export const getEngineFromOptions = (opts: Options): SparqlEngine => {
  let engine: SparqlEngine
  if (opts.engine !== undefined) {
    engine = opts.engine
  } else {
    const store = new Store(opts.shapes.getQuads({}).concat(opts.data === undefined ? [] : opts.data.getQuads({})))
    engine = newEngine(store)
  }
  return engine
}

/**
 * Use this function to preload you model with SPARQL Targets
 *
 * @param opts.shapes a RdfJs dataset/store containing the shapes
 * @param opts.data an optional RdfJs dataset/store containing the data
 * @param opts.engines a Speedy engine, use this if you want to re-use the engine for other usage
 * @param opts.factory an optional DataFactory
 * @see https://www.w3.org/TR/shacl-af/#SPARQLTarget
 */
export default async function loadSPARQLTargets (opts: Options): Promise<Store> {
  const factory = opts.factory ?? getFactory()
  const dataset = await getSPARQLTargets(getEngineFromOptions(opts), factory)
  opts.shapes.addQuads(dataset.getQuads({}))
  return dataset
}

/**
 * 3.1 SPARQL-based Targets
 *
 * @see https://www.w3.org/TR/shacl-af/#SPARQLTarget
 */
export async function getSPARQLTargets (datasetOrEngine: Store, factory?: DefaultFactory): Promise<Store>
export async function getSPARQLTargets (datasetOrEngine: SparqlEngine, factory?: DefaultFactory): Promise<Store>
export async function getSPARQLTargets (datasetOrEngine: SparqlEngine | Store, factory?: DefaultFactory): Promise<Store> {
  const engine = isEngine(datasetOrEngine) ? datasetOrEngine : newEngine(datasetOrEngine)
  const $factory = factory ?? getFactory()
  const dataset = new Store()

  for await (const binding of await engine.select(SPARQLTargetsRq)) {
    if (binding.query !== undefined && binding.shape !== undefined) {
      for await (const targetBinding of await engine.select(binding.query.value)) {
        if (targetBinding.this === undefined) {
          return await Promise.reject(new Error("Expected the bound variable '$this' in the result."))
        } else if (targetBinding.this.termType === 'Literal') {
          return await Promise.reject(new Error("Expected the bound variable '$this' to be a NamedNode or Blanknode, got a Literal."))
        } else {
          dataset.addQuad($factory.quad(binding.shape as BlankNodeOrIRI, sh.targetNode, targetBinding.this))
        }
      }
    } else {
      console.error(SPARQLTargetsRq)
      throw new Error('There is probably something wrong with the SPARQL query that loads the sh:select queries.')
    }
  }

  return dataset
}
