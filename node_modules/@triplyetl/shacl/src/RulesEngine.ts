/* eslint-disable @typescript-eslint/no-non-null-assertion */
// https://www.w3.org/TR/shacl-af/#rules

import { type DefaultFactory, Store, getFactory } from '@triplydb/data-factory'
import { type NamedNode, type Quad, type Literal } from '@triplydb/data-factory/Terms.js'
import { type SparqlEngine } from '@triplydb/engine/SparqlEngine.js'
import { newEngine } from '@triplydb/speedy-memory'
import { sh } from '@triplyetl/vocabularies'
import { getQuery as getTargetsQuery } from './Queries/targets.rq.js'
import Validator from './Validator.js'
import shapesWithRulesRq from './Queries/shapesWithRules.rq.js'
import { type BlankNodeOrIRI } from './Types.js'
import SPARQLRuleRq from './Queries/SPARQLRule.rq.js'
import { parseAndInjectVariablesIntoQuery } from '@triply/utils/sparqlVarUtils.js'
import { type NamedNodeConfig } from '@triply/utils/Models.js'
import loadSPARQLTargets from './Utilities/loadSPARQLTargets.js'

export interface RulesEngineOptions {
  data: Store
  engine?: SparqlEngine
  factory: DefaultFactory
  maxIterations: number
  errorOnMaxIterations: 'throw' | 'warn' | 'none'
  debug?: boolean
  prefix?: Record<string, string | NamedNode | ReturnType<DefaultFactory['prefixer']>>
  graph?: NamedNode
}

const defaultRulesEngineOptions: RulesEngineOptions = {
  maxIterations: 0,
  errorOnMaxIterations: 'none',
  data: new Store(),
  factory: getFactory(),
  debug: false
}

interface Rule {
  node: BlankNodeOrIRI
  ruleType: NamedNode
}
type ShapesWithRules = Record<
string,
{
  shape: BlankNodeOrIRI
  rules: Rule[]
  focusNodes: BlankNodeOrIRI[]
}
>

const $SIGNATURE = '@triplyetl/shacl/RulesEngine'

export default class RulesEngine {
  public $signature = $SIGNATURE
  private readonly engine: {
    model: SparqlEngine
    combined: SparqlEngine
  }

  // The data graph
  public readonly data: Store = new Store()

  private readonly factory: DefaultFactory

  private readonly opts: RulesEngineOptions

  /**
   * The combined dataset of model and data (if provided)
   */
  private readonly dataset: Store

  constructor (
    public model: Store,
    opts?: Partial<RulesEngineOptions>
  ) {
    this.opts = { ...defaultRulesEngineOptions, ...(opts ?? {}) }
    if (opts?.data !== undefined) this.data = opts.data
    this.dataset = new Store(model.getQuads({}).concat(opts?.data === undefined ? [] : opts.data.getQuads({})))
    const engineModel = opts?.engine ?? newEngine(model)
    const engineCombined = opts?.data === undefined ? engineModel : newEngine(this.dataset)
    this.engine = {
      model: engineModel,
      combined: engineCombined
    }
    this.factory = opts?.factory ?? getFactory()
  }

  /**
   * Execute rules and stores the result in the dataset
   *
   * @returns the new Quads
   */
  public async execute (): Promise<Quad[]> {
    if (this.opts.graph !== undefined) {
      return (await this.$execute()).map((quad) => this.factory.quad(quad.subject, quad.predicate, quad.object, this.opts.graph))
    }
    return await this.$execute()
  }

  private async $execute (iteration: number = 0, SPARQLTargetNodes: Store = new Store()): Promise<Quad[]> {
    if (SPARQLTargetNodes.size !== 0) {
      // this.model.removeQuads(SPARQLTargetNodes.getQuads({}))
    }
    if (iteration > 0) {
      // this.engine.combined = newEngine(new Store(this.model.getQuads({}).concat(this.data.getQuads({}))))
    }
    let size = this.data.size
    // step 1: get all shapes that have rules:
    return await this.getShapesThatHaveRules()
      // step 2: get all focusNodes from those shapes and validate them against those shapes
      .then(async (shapesWithRules) => {
        const size = this.model.size + this.data.size
        console.time('loadSPARQLTargets')
        await loadSPARQLTargets({ shapes: this.model, data: this.data })
        console.timeEnd('loadSPARQLTargets')
        // if the size has increaded we need to update the engine:
        if (size !== this.model.size + this.data.size) {
          this.engine.combined = newEngine(new Store(this.model.getQuads({}).concat(this.data.getQuads({}))))
        }
        await this.loadFocusnodesFromShapes(shapesWithRules)
        // await this.validateNodes(shapesWithRules)
        return shapesWithRules
      })
      .then(async (shapesWithRules) => await this.applyRules(shapesWithRules))
      .then(async (quads) => {
        this.data.addQuads(quads)
        this.engine.combined = newEngine(new Store(this.model.getQuads({}).concat(this.data.getQuads({}))))
        if (this.opts.maxIterations > 0 && this.data.size > size) {
          size = this.data.size
          if (iteration === this.opts.maxIterations) {
            const error = new Error(`The SHACL Rule Engine reached the maximum iterations (${this.opts.maxIterations})`)
            if (this.opts.errorOnMaxIterations === 'throw') {
              throw error
            } else if (this.opts.errorOnMaxIterations === 'warn') {
              process.stderr.write(`WARNING: ${error.message}\n`)
            }
          } else {
            quads.push(...(await this.$execute(++iteration, SPARQLTargetNodes)))
          }
        }
        return quads
      })
  }

  public static isRulesEngine (obj: unknown): obj is RulesEngine {
    if (typeof obj !== 'object') return false
    if (obj === null) return false
    if (!Object.hasOwn(obj, '$signature')) return false
    // @ts-expect-error we now know this property does exists
    return obj.$signature === $SIGNATURE
  }

  private async getShapesThatHaveRules (): Promise<ShapesWithRules> {
    if (this.opts?.debug ?? false) console.time('RulesEngine::getShapesThatHaveRules::query')
    const shapes: ShapesWithRules = {}

    for await (const bindings of await this.engine.model.select(shapesWithRulesRq)) {
      const rule = {
        node: bindings.rule?.termType === 'BlankNode' ? bindings.rule : (bindings.rule as NamedNode),
        ruleType: bindings.ruleType as NamedNode
      }
      if (!Object.hasOwn(shapes, bindings.shape!.value)) {
        shapes[bindings.shape!.value] = {
          shape: bindings.shape! as NamedNode,
          rules: [rule],
          focusNodes: []
        }
      } else {
        shapes[bindings.shape!.value].rules.push(rule)
      }
    }
    if (this.opts?.debug ?? false) console.timeEnd('RulesEngine::getShapesThatHaveRules::query')
    return await Promise.resolve(shapes)
  }

  private async loadFocusnodesFromShapes (shapes: ShapesWithRules): Promise<void> {
    // step 2: get all focusNodes from given shapes:
    for (const shape in shapes) {
      if (this.opts?.debug ?? false) console.time(`RulesEngine::getFocusnodesFromShapes::query (${shape})`)
      const targets = (await (await this.engine.combined.select(getTargetsQuery(shapes[shape].shape))).toArray())
        .map((bindings) => bindings.target)
        .filter(target => target!.termType === 'BlankNode' || target!.termType === 'NamedNode')
      shapes[shape].focusNodes.push(...(targets as BlankNodeOrIRI[]))
      if (this.opts?.debug ?? false) console.timeEnd(`RulesEngine::getFocusnodesFromShapes::query (${shape})`)
    }
  }

  private async validateNode (focusNodes: BlankNodeOrIRI[], conditions: BlankNodeOrIRI[]): Promise<BlankNodeOrIRI[]> {
    if (conditions.length === 0) {
      return focusNodes
    }
    const model = new Store(this.model.getQuads({}))
    for (const condition of conditions) {
      for (const focusNode of focusNodes) {
        model.addQuad(this.factory.quad(condition.termType === 'BlankNode' ? condition : (condition as NamedNode), sh.targetNode, focusNode))
      }
    }
    const validator = new Validator(model)
    const report = await validator.validate({ dataset: this.dataset, terms: focusNodes })
    const invalidNodes = report.dataset.getObjects(null, sh.focusNode, null)
    return focusNodes.filter((focusNode) => {
      let valid = true
      for (const invalidNode of invalidNodes) {
        if (invalidNode.equals(focusNode)) {
          valid = false
          break
        }
      }
      return valid
    })
  }

  /*
  from https://www.w3.org/TR/shacl-af/#rules-syntax:
  for each shape S in the shapes graph, ordered by execution order {
    for each non-deactivated rule R in the shape, ordered by execution order {
      for each target node T of S that conforms to all conditions of R {
        execute R using T as focus node following the execution instructions of its rule types
      }
    }
  }
  */

  private async applyRules (shapesWithRules: ShapesWithRules): Promise<Quad[]> {
    let engine = this.engine.combined
    const quadsPerShape: Quad[] = []
    for (const s in shapesWithRules) {
      const shape = shapesWithRules[s].shape
      const quadsPerRule: Quad[] = []
      for (const rule of shapesWithRules[s].rules) {
        const conditions = this.model.getObjects(rule.node, sh.condition, null).filter((node) => node.termType === 'BlankNode' || node.termType === 'NamedNode')
        const focusNodes = await this.validateNode(shapesWithRules[s].focusNodes, conditions as BlankNodeOrIRI[])
        const quadsPerFocusNode: Quad[] = []
        for (const focusNode of focusNodes) {
          if (rule.ruleType.equals(sh.TripleRule)) {
            quadsPerFocusNode.push(...this.applyTripleRule(rule.node, focusNode))
          } else if (rule.ruleType.equals(sh.SPARQLRule)) {
            quadsPerFocusNode.push(...(await this.applySPARQLRule(shape, rule, focusNode, engine)))
          } else {
            // eslint-disable-next-line @typescript-eslint/no-base-to-string
            throw new Error(`Unsupported SHACL Ruletype '${rule.ruleType.value.replace(sh.toString(), '')}'`)
          }
        }
        quadsPerRule.push(...quadsPerFocusNode)
        const store = new Store(this.model.getQuads({}).concat(this.data.getQuads({}).concat(quadsPerFocusNode)))
        engine = newEngine(store)
      }
      quadsPerShape.push(...quadsPerRule)
    }
    return quadsPerShape
  }

  private applyTripleRule (rule: BlankNodeOrIRI, focusNode: BlankNodeOrIRI): Quad[] {
    if (this.opts?.debug ?? false) console.time('RulesEngine::applyTripleRule')
    const subjects = this.dataset.getObjects(rule, sh.subject, null)
    const predicates = this.dataset.getObjects(rule, sh.predicate, null)
    const objects = this.dataset.getObjects(rule, sh.object, null)
    if (subjects.length === 0) throw new Error('A SHACL TripleRule must have exactly 1 value for `sh:subject`.')
    if (predicates.length === 0) throw new Error('A SHACL TripleRule must have exactly 1 value for `sh:predicate`.')
    if (objects.length === 0) throw new Error('A SHACL TripleRule must have exactly 1 value for `sh:object`.')
    if (!subjects[0].equals(sh.this) && subjects[0].termType !== 'NamedNode') throw new Error('Our SHACL Rule Engine only supports `sh:this` or an Iri as value for `sh:subject`.')
    if (!predicates[0].equals(sh.this) && predicates[0].termType !== 'NamedNode') throw new Error('Our SHACL Rule Engine only supports `sh:this` or an Iri as value for `sh:predicate`.')
    if (!objects[0].equals(sh.this) && objects[0].termType !== 'NamedNode' && objects[0].termType !== 'Literal') throw new Error('Our SHACL Rule Engine only supports `sh:this`, an Iri or a Literal as value for `sh:object`.')
    const quads: Quad[] = []
    const subject = subjects[0] as NamedNode
    const predicate = predicates[0] as NamedNode
    const object = objects[0].termType === 'Literal' ? objects[0] : (objects[0] as NamedNode)
    if (predicate.equals(sh.this) && focusNode.termType === 'BlankNode') {
      throw new Error('sh:this Should use the current focusnode, but that is a BlankNode which is not allowed as subject.')
    }
    quads.push(this.factory.quad(subject.equals(sh.this) ? focusNode : subject, predicate.equals(sh.this) ? (focusNode as NamedNode) : predicate, object.equals(sh.this) ? focusNode : object))
    if (this.opts?.debug ?? false) console.timeEnd('RulesEngine::applyripleRule')
    return quads
  }

  private async applySPARQLRule (shape: BlankNodeOrIRI, rule: Rule, focusNode: BlankNodeOrIRI, engine: SparqlEngine): Promise<Quad[]> {
    if (this.opts?.debug ?? false) console.time('RulesEngine::execute::applySPARQLRule')
    if (shape.termType === 'BlankNode') {
      throw new Error('Encountered a rule in a NodeShape that is a BlankNode, this engine relies on the NodeShape to be an Iri. Please rewrite your model.')
    }
    // what to do when the rule is a blanknode?
    // This will go wrong when a shape has more than 1 rule defined by using 1 one or more blanknode
    const rq = SPARQLRuleRq(shape, rule.node.termType === 'NamedNode' ? rule.node : undefined)
    const prefixDeclarations: string[] = []
    if (this.opts?.prefix !== undefined) {
      for (const [prefix, prefixer] of Object.entries(this.opts.prefix)) {
        const ns = typeof prefixer === 'function' ? prefixer('').value : typeof prefixer === 'string' ? this.factory.namedNode(prefixer).value : prefixer.value
        prefixDeclarations.push(`prefix ${prefix}: <${ns}>`)
      }
    }

    const queries = (await (await this.engine.combined.select(rq)).toArray())
      .map(binding => binding.query as Literal)
    if (queries.length !== 1) {
      throw new Error(`Expected exactly 1 SPARQLRule with \`sh:construct\` found in shape <${shape.value}>.`)
    }
    const query = queries[0]
    const variableDefinitions = [{ name: 'this', termType: 'NamedNode' } satisfies NamedNodeConfig]
    const constructQuery = prefixDeclarations.join('\n') + query.value
    return await (await engine.construct(parseAndInjectVariablesIntoQuery(constructQuery, { variableDefinitions, variableValues: { this: focusNode.value } }))).quads()
  }
}
