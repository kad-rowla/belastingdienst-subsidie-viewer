{"version":3,"file":"slimdom.esm.js","sources":["../src/mutation-observer/RegisteredObserver.ts","../src/mutation-observer/RegisteredObservers.ts","../src/mutation-observer/NotifyList.ts","../src/context/WeakRef.ts","../src/context/Context.ts","../src/util/NodeType.ts","../src/util/treeHelpers.ts","../src/util/cloneNode.ts","../src/util/errorHelpers.ts","../src/mutation-observer/MutationRecord.ts","../src/mutation-observer/queueMutationRecord.ts","../src/mixins.ts","../src/util/treeMutations.ts","../src/util/mutationAlgorithms.ts","../src/util/typeHelpers.ts","../src/Node.ts","../src/util/attrMutations.ts","../src/Attr.ts","../src/CharacterData.ts","../src/Text.ts","../src/CDATASection.ts","../src/Comment.ts","../src/DocumentType.ts","../src/unsafe.ts","../src/util/namespaceHelpers.ts","../node_modules/prsc/src/parser-combinators.ts","../node_modules/prsc/src/streaming.ts","../src/dom-parsing/ParserStateMachine.ts","../src/dom-parsing/grammar.ts","../src/dom-parsing/parsingAlgorithms.ts","../src/dom-parsing/NamespacePrefixMap.ts","../src/dom-parsing/serializationAlgorithms.ts","../src/Element.ts","../src/util/createElementNS.ts","../src/DOMImplementation.ts","../src/Document.ts","../src/DocumentFragment.ts","../src/ProcessingInstruction.ts","../src/Range.ts","../src/XMLDocument.ts","../src/dom-parsing/DOMParser.ts","../src/dom-parsing/XMLSerializer.ts","../src/mutation-observer/MutationObserver.ts","../src/index.ts"],"sourcesContent":["import { MutationObserverInit, default as MutationObserver } from './MutationObserver';\nimport { MutationRecordInit, default as MutationRecord } from './MutationRecord';\nimport Node from '../Node';\n\n/**\n * A registered observer consists of an observer (a MutationObserver object) and options (a\n * MutationObserverInit dictionary).\n *\n * A transient registered observer is a registered observer that also consists of a source (a\n * registered observer).\n *\n * Transient registered observers are used to track mutations within a given node’s descendants\n * after node has been removed so they do not get lost when subtree is set to true on node’s parent.\n */\nexport default class RegisteredObserver {\n\t/**\n\t * The observer that is registered.\n\t */\n\tpublic observer: MutationObserver;\n\n\t/**\n\t * The Node that is being observed by the given observer.\n\t */\n\tpublic node: Node;\n\n\t/**\n\t * The options for the registered observer.\n\t */\n\tpublic options: MutationObserverInit;\n\n\t/**\n\t * A transient observer is an observer that has a source which is an observer.\n\t */\n\tpublic source: RegisteredObserver | null = null;\n\n\t/**\n\t * @param observer - The observer being registered\n\t * @param node     - The node being observed\n\t * @param options  - Options for the registration\n\t * @param source   - If non-null, creates a transient registered observer for the given\n\t *                   registered observer\n\t */\n\tconstructor(\n\t\tobserver: MutationObserver,\n\t\tnode: Node,\n\t\toptions: MutationObserverInit,\n\t\tsource?: RegisteredObserver\n\t) {\n\t\tthis.observer = observer;\n\t\tthis.node = node;\n\t\tthis.options = options;\n\t\tthis.source = source || null;\n\t\tif (source) {\n\t\t\tobserver._transients.push(this);\n\t\t}\n\t}\n\n\t/**\n\t * Adds the given mutationRecord to the NotifyList of the registered MutationObserver. It only\n\t * adds the record when it's type isn't blocked by one of the flags of this registered\n\t * MutationObserver options (formally the MutationObserverInit object).\n\t *\n\t * @param type                - The type of mutation record to queue\n\t * @param target              - The target node\n\t * @param data                - The data for the mutation record\n\t * @param interestedObservers - Array of mutation observer objects to append to\n\t * @param pairedStrings       - Paired strings for the mutation observer objects\n\t */\n\tpublic collectInterestedObservers(\n\t\ttype: string,\n\t\ttarget: Node,\n\t\tdata: MutationRecordInit,\n\t\tinterestedObservers: MutationObserver[],\n\t\tpairedStrings: (string | null | undefined)[]\n\t) {\n\t\t// (continued from RegisteredObservers#queueMutationRecord)\n\n\t\t// 3.1. Let options be registered's options.\n\t\t// 3.2. If none of the following are true\n\t\t// node is not target and options[\"subtree\"] is false\n\t\tif (this.node !== target && !this.options.subtree) {\n\t\t\treturn;\n\t\t}\n\n\t\t// type is \"attributes\" and options[\"attributes\"] is not true\n\t\tif (type === 'attributes' && !this.options.attributes) {\n\t\t\treturn;\n\t\t}\n\n\t\t// type is \"attributes\", options[\"attributeFilter\"] exists, and options[\"attributeFilter\"]\n\t\t// does not contain name or namespace is non-null\n\t\t// (attributeFilter not implemented)\n\n\t\t// type is \"characterData\" and options[\"characterData\"] is not true\n\t\tif (type === 'characterData' && !this.options.characterData) {\n\t\t\treturn;\n\t\t}\n\n\t\t// type is \"childList\" and options[\"childList\"] is false\n\t\tif (type === 'childList' && !this.options.childList) {\n\t\t\treturn;\n\t\t}\n\n\t\t// then:\n\n\t\t// 3.2.1. Let mo be registered's observer.\n\t\t// 3.2.2. If interestedObservers[mo] does not exist, then set interestedObservers[mo] to\n\t\t// null\n\t\tlet index = interestedObservers.indexOf(this.observer);\n\t\tif (index < 0) {\n\t\t\tindex = interestedObservers.length;\n\t\t\tinterestedObservers.push(this.observer);\n\t\t\tpairedStrings.push(undefined);\n\t\t}\n\n\t\t// 3.2.3. If either type is \"attributes\" and options[\"attributeOldValue\"] is true, or type\n\t\t// is \"characterData\" and options[\"characterDataOldValue\"] is true, then set\n\t\t// interestedObservers[mo] to oldValue.\n\t\tif (\n\t\t\t(type === 'attributes' && this.options.attributeOldValue) ||\n\t\t\t(type === 'characterData' && this.options.characterDataOldValue)\n\t\t) {\n\t\t\tpairedStrings[index] = data.oldValue;\n\t\t}\n\t}\n}\n","import { MutationObserverInit, default as MutationObserver } from './MutationObserver';\nimport { MutationRecordInit } from './MutationRecord';\nimport RegisteredObserver from './RegisteredObserver';\nimport Node from '../Node';\n\n/**\n * Each node has an associated list of registered observers.\n */\nexport default class RegisteredObservers {\n\t/**\n\t * The node for which this RegisteredObservers lists registered MutationObserver objects.\n\t */\n\tprivate _node: Node;\n\n\tprivate _registeredObservers: RegisteredObserver[] = [];\n\n\t/**\n\t * @param node - Node for which this instance holds RegisteredObserver instances.\n\t */\n\tconstructor(node: Node) {\n\t\tthis._node = node;\n\t}\n\n\t/**\n\t * Registers a given MutationObserver with the given options.\n\t *\n\t * @param observer - Observer to create a registration for\n\t * @param options  - Options for the registration\n\t */\n\tpublic register(observer: MutationObserver, options: MutationObserverInit) {\n\t\t// (continuing from MutationObserver#observe)\n\t\t// 7. For each registered registered of target’s registered observer list, if registered's\n\t\t// observer is this:\n\t\tconst registeredObservers = this._registeredObservers;\n\t\tlet hasRegisteredObserverForObserver = false;\n\t\tregisteredObservers.forEach((registered) => {\n\t\t\tif (registered.observer !== observer) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\thasRegisteredObserverForObserver = true;\n\n\t\t\t// 7.1. For each node of this's node list, remove all transient registered\n\t\t\t// observers whose source is registered from node's registered observer list.\n\t\t\tremoveTransientRegisteredObserversForSource(registered);\n\n\t\t\t// 7.2. Set registered’s options to options.\n\t\t\tregistered.options = options;\n\t\t});\n\n\t\t// 8. Otherwise:\n\t\tif (!hasRegisteredObserverForObserver) {\n\t\t\t// 8.1. Append a new registered observer whose observer is this and\n\t\t\t// options is options to target's registered observer list.\n\t\t\tthis._registeredObservers.push(new RegisteredObserver(observer, this._node, options));\n\t\t\t// 8.2. Append target to this's node list.\n\t\t\tobserver._nodes.push(this._node);\n\t\t}\n\t}\n\n\t/**\n\t * Removes the given transient registered observer.\n\t *\n\t * Transient registered observers never have a corresponding entry in the observer's list of\n\t * nodes. They are guaranteed to be present in the array, as MutationObserver#_transients and\n\t * RegisteredObservers#_registeredObservers are kept in sync.\n\t *\n\t * @param transientRegisteredObserver - The registered observer to remove\n\t */\n\tpublic removeTransientRegisteredObserver(\n\t\ttransientRegisteredObserver: RegisteredObserver\n\t): void {\n\t\tthis._registeredObservers.splice(\n\t\t\tthis._registeredObservers.indexOf(transientRegisteredObserver),\n\t\t\t1\n\t\t);\n\t}\n\n\t/**\n\t * Remove any registered observer on the associated node for which observer is the observer.\n\t *\n\t * As this only occurs for all nodes at once, it is the caller's responsibility to remove the\n\t * associated node from the observer's list of nodes.\n\t *\n\t * @param observer - Observer for which to remove the registration\n\t */\n\tpublic removeForObserver(observer: MutationObserver): void {\n\t\t// Filter the array in-place\n\t\tlet write = 0;\n\t\tfor (let read = 0, l = this._registeredObservers.length; read < l; ++read) {\n\t\t\tconst registered = this._registeredObservers[read];\n\t\t\tif (registered.observer === observer) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (read !== write) {\n\t\t\t\tthis._registeredObservers[write] = registered;\n\t\t\t}\n\t\t\t++write;\n\t\t}\n\t\tthis._registeredObservers.length = write;\n\t}\n\n\t/**\n\t * Determines interested observers for the given record.\n\t *\n\t * @param type                - The type of mutation record to queue\n\t * @param target              - The target node\n\t * @param data                - The data for the mutation record\n\t * @param interestedObservers - Array of mutation observer objects to append to\n\t * @param pairedStrings       - Paired strings for the mutation observer objects\n\t */\n\tpublic collectInterestedObservers(\n\t\ttype: string,\n\t\ttarget: Node,\n\t\tdata: MutationRecordInit,\n\t\tinterestedObservers: MutationObserver[],\n\t\tpairedStrings: (string | null | undefined)[]\n\t) {\n\t\t// (continuing from queueMutationRecord)\n\t\t// 3. ...and then for each registered of node's registered observer list:\n\t\tthis._registeredObservers.forEach((registeredObserver) => {\n\t\t\tregisteredObserver.collectInterestedObservers(\n\t\t\t\ttype,\n\t\t\t\ttarget,\n\t\t\t\tdata,\n\t\t\t\tinterestedObservers,\n\t\t\t\tpairedStrings\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Append transient registered observers for any registered observers whose options' subtree is\n\t * true.\n\t *\n\t * @param node - Node to append the transient registered observers to\n\t */\n\tpublic appendTransientRegisteredObservers(node: Node): void {\n\t\tthis._registeredObservers.forEach((registeredObserver) => {\n\t\t\tif (registeredObserver.options.subtree) {\n\t\t\t\tnode._registeredObservers.registerTransient(registeredObserver);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Appends a transient registered observer for the given registered observer.\n\t *\n\t * @param source - The source registered observer\n\t */\n\tpublic registerTransient(source: RegisteredObserver): void {\n\t\tthis._registeredObservers.push(\n\t\t\tnew RegisteredObserver(source.observer, this._node, source.options, source)\n\t\t);\n\t\t// Note that node is not added to the transient observer's observer's list of nodes.\n\t}\n}\n\n/**\n * Removes all transient registered observers whose observer is observer.\n *\n * @param observer - The mutation observer object to remove transient registered observers for\n */\nexport function removeTransientRegisteredObserversForObserver(observer: MutationObserver): void {\n\tobserver._transients.forEach((transientRegisteredObserver) => {\n\t\ttransientRegisteredObserver.node._registeredObservers.removeTransientRegisteredObserver(\n\t\t\ttransientRegisteredObserver\n\t\t);\n\t});\n\tobserver._transients.length = 0;\n}\n\n/**\n * Removes all transient registered observer whose source is source.\n *\n * @param source - The registered observer to remove transient registered observers for\n */\nexport function removeTransientRegisteredObserversForSource(source: RegisteredObserver): void {\n\tfor (let i = source.observer._transients.length - 1; i >= 0; --i) {\n\t\tconst transientRegisteredObserver = source.observer._transients[i];\n\t\tif (transientRegisteredObserver.source !== source) {\n\t\t\treturn;\n\t\t}\n\n\t\ttransientRegisteredObserver.node._registeredObservers.removeTransientRegisteredObserver(\n\t\t\ttransientRegisteredObserver\n\t\t);\n\t\tsource.observer._transients.splice(i, 1);\n\t}\n}\n","import { default as MutationObserver } from './MutationObserver';\nimport MutationRecord from './MutationRecord';\nimport { removeTransientRegisteredObserversForObserver } from './RegisteredObservers';\n\ntype AnyCallback = (...args: any[]) => void;\ndeclare const queueMicrotask: undefined | ((callback: AnyCallback) => void);\n\n/* istanbul ignore next */\nfunction queueMicrotaskWithAppropriateApi(\n\tcallback: AnyCallback,\n\tthisArg: NotifySet,\n\t...args: any[]\n): void {\n\tif (typeof queueMicrotask === 'function') {\n\t\tqueueMicrotask(() => callback.apply(thisArg, args));\n\t\treturn;\n\t}\n\n\t// Fall back to Promise.then callbacks - these run as microtasks, but handle errors differently\n\tPromise.resolve().then(() => callback.apply(thisArg, args));\n}\n\n/**\n * Tracks MutationObserver instances which have a non-empty record queue and schedules their\n * callbacks to be called.\n */\nexport default class NotifySet {\n\tprivate _notifySet: Set<MutationObserver> = new Set();\n\tprivate _mutationObserverMicrotaskQueued: boolean = false;\n\n\t/**\n\t * Appends a given MutationRecord to the recordQueue of the given MutationObserver and schedules\n\t * it for reporting.\n\t *\n\t * @param observer - The observer for which to enqueue the record\n\t * @param record   - The record to enqueue\n\t */\n\tappendRecord(observer: MutationObserver, record: MutationRecord) {\n\t\tobserver._recordQueue.push(record);\n\t\tthis._notifySet.add(observer);\n\t}\n\n\t/**\n\t * To queue a mutation observer microtask, run these steps:\n\t */\n\tpublic queueMutationObserverMicrotask() {\n\t\t// 1. If the surrounding agent's mutation observer microtask queued is true, then return.\n\t\tif (this._mutationObserverMicrotaskQueued) {\n\t\t\treturn;\n\t\t}\n\n\t\t// 2. Set the surrounding agent's mutation observer microtask queued to true.\n\t\tthis._mutationObserverMicrotaskQueued = true;\n\n\t\t// 3. Queue a microtask to notify mutation observers.\n\t\tqueueMicrotaskWithAppropriateApi(() => {\n\t\t\tthis._notifyMutationObservers();\n\t\t}, this);\n\t}\n\n\t/**\n\t * To notify mutation observers, run these steps:\n\t */\n\tprivate _notifyMutationObservers() {\n\t\t// 1. Set the surrounding agent's mutation observer microtask queued to false.\n\t\tthis._mutationObserverMicrotaskQueued = false;\n\n\t\t// 2. Let notifySet be a clone of the surrounding agent's mutation observers\n\t\tconst notifySet = Array.from(this._notifySet);\n\t\t// Clear the notify set - for efficiency this set only tracks observers that have a\n\t\t// non-empty queue\n\t\tthis._notifySet.clear();\n\n\t\t// 3. Let signalSet be a clone of the surrounding agent's signal slots.\n\t\t// 4. Empty the surrounding agent's signal slots.\n\t\t// (shadow dom not implemented)\n\n\t\t// 5. For each mo of notifySet:\n\t\t// [HTML]\n\t\tnotifySet.forEach((mo) => {\n\t\t\tqueueMicrotaskWithAppropriateApi(\n\t\t\t\t(mo: MutationObserver) => {\n\t\t\t\t\t// 5.1. Let records be a clone of mo’s record queue.\n\t\t\t\t\t// 5.2. Empty mo’s record queue.\n\t\t\t\t\tconst records = mo.takeRecords();\n\n\t\t\t\t\t// 5.3. For each node of mo's node list, remove all transient registered\n\t\t\t\t\t// observers whose observer is mo from node's registered observer list.\n\t\t\t\t\tremoveTransientRegisteredObserversForObserver(mo);\n\n\t\t\t\t\t// 5.4. If records is not empty, then invoke mo’s callback with « records, mo »,\n\t\t\t\t\t// and mo. If this throws an exception, catch it, and report the exception.\n\t\t\t\t\t// (A try/catch is not necessary here, as this microtask does nothing else and\n\t\t\t\t\t// letting the exception through will likely cause the environment to report it)\n\t\t\t\t\tif (records.length > 0) {\n\t\t\t\t\t\tmo._callback(records, mo);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tthis,\n\t\t\t\tmo\n\t\t\t);\n\t\t});\n\n\t\t// 6. For each slot of signalSet, fire an event named slotchange, with its bubbles attribute\n\t\t// set to true, at slot.\n\t\t// (shadow dom not implemented)\n\t}\n}\n","// TODO: remove when interface is included in dom.d.ts typings\nexport interface WeakRef<T> {\n\tderef(): T | undefined;\n}\ninterface WeakRefConstructor<T> {\n\tnew (target: T): WeakRef<T>;\n}\ndeclare var WeakRef: WeakRefConstructor<any>;\n\nclass FakeWeakRef<T> implements WeakRef<T> {\n\tprivate _target: T;\n\n\tconstructor(target: T) {\n\t\tthis._target = target;\n\t}\n\n\tpublic deref(): T {\n\t\treturn this._target;\n\t}\n}\n\nexport function createWeakRef<T>(target: T): WeakRef<T> {\n\tif (typeof WeakRef === 'function') {\n\t\treturn new WeakRef(target);\n\t}\n\n\treturn new FakeWeakRef(target);\n}\n","import Attr from '../Attr';\nimport CDATASection from '../CDATASection';\nimport Comment from '../Comment';\nimport Document from '../Document';\nimport DocumentFragment from '../DocumentFragment';\nimport DocumentType from '../DocumentType';\nimport DOMImplementation from '../DOMImplementation';\nimport Element from '../Element';\nimport Node from '../Node';\nimport ProcessingInstruction from '../ProcessingInstruction';\nimport Range from '../Range';\nimport Text from '../Text';\nimport XMLDocument from '../XMLDocument';\n\nimport NotifySet from '../mutation-observer/NotifyList';\n\nimport { createWeakRef, WeakRef } from './WeakRef';\n\nexport type AttrConstructor = new (\n\tnamespace: string | null,\n\tprefix: string | null,\n\tlocalName: string,\n\tvalue: string,\n\telement: Element | null\n) => Attr;\nexport type CDATASectionConstructor = new (data: string) => CDATASection;\nexport type CommentConstructor = new (data: string) => Comment;\nexport type DocumentConstructor = new () => Document;\nexport type DocumentFragmentConstructor = new () => DocumentFragment;\nexport type DocumentTypeConstructor = new (\n\tname: string,\n\tpublicId?: string,\n\tsystemId?: string\n) => DocumentType;\nexport type DOMImplementationConstructor = new (document: Document) => DOMImplementation;\nexport type ElementConstructor = new (\n\tnamespace: string | null,\n\tprefix: string | null,\n\tlocalName: string\n) => Element;\nexport type ProcessingInstructionConstructor = new (\n\ttarget: string,\n\tdata: string\n) => ProcessingInstruction;\nexport type RangeConstructor = new () => Range;\nexport type TextConstructor = new (data: string) => Text;\nexport type XMLDocumentConstructor = new () => XMLDocument;\n\nexport interface Context {\n\tdocument: Document;\n\n\t_notifySet: NotifySet;\n\n\tAttr: AttrConstructor;\n\tCDATASection: CDATASectionConstructor;\n\tComment: CommentConstructor;\n\tDocument: DocumentConstructor;\n\tDocumentFragment: DocumentFragmentConstructor;\n\tDocumentType: DocumentTypeConstructor;\n\tDOMImplementation: DOMImplementationConstructor;\n\tElement: ElementConstructor;\n\tProcessingInstruction: ProcessingInstructionConstructor;\n\tRange: RangeConstructor;\n\tText: TextConstructor;\n\tXMLDocument: XMLDocumentConstructor;\n\n\tforEachRange(cb: (range: Range) => void): void;\n\taddRange(range: Range): void;\n\tremoveRange(range: Range): void;\n}\n\n/**\n * The DefaultContext is comparable to the global object in that it tracks its associated document.\n * It also serves as a way to inject the constructors for the constructable types, avoiding cyclic\n * dependencies.\n */\nexport class DefaultContext implements Context {\n\tpublic document!: Document;\n\n\t/**\n\t * The NotifyList instance is shared between all MutationObserver objects. It holds references\n\t * to all MutationObserver instances that have collected records, and is responsible for\n\t * invoking their callbacks when control returns to the event loop.\n\t */\n\tpublic _notifySet: NotifySet = new NotifySet();\n\n\tpublic Attr!: AttrConstructor;\n\tpublic CDATASection!: CDATASectionConstructor;\n\tpublic Comment!: CommentConstructor;\n\tpublic Document!: DocumentConstructor;\n\tpublic DocumentFragment!: DocumentFragmentConstructor;\n\tpublic DocumentType!: DocumentTypeConstructor;\n\tpublic DOMImplementation!: DOMImplementationConstructor;\n\tpublic Element!: ElementConstructor;\n\tpublic ProcessingInstruction!: ProcessingInstructionConstructor;\n\tpublic Range!: RangeConstructor;\n\tpublic Text!: TextConstructor;\n\tpublic XMLDocument!: XMLDocumentConstructor;\n\n\tprivate _ranges: WeakRef<Range>[] = [];\n\tprivate _weakRangeSet: WeakSet<Range> = new WeakSet();\n\n\tpublic forEachRange(cb: (range: Range) => void): void {\n\t\tlet numRanges = this._ranges.length;\n\t\tfor (let i = numRanges - 1; i >= 0; --i) {\n\t\t\tconst weakref = this._ranges[i];\n\t\t\tconst r = weakref.deref();\n\t\t\t// Safari / webkit has a bug where deref can return null instead of undefined\n\t\t\tconst isLost = r === undefined || r === null;\n\t\t\tconst isManuallyRemoved = !isLost && !this._weakRangeSet.has(r);\n\t\t\tif (isLost || isManuallyRemoved) {\n\t\t\t\t// Weak ref lost, remove\n\t\t\t\tthis._ranges[i] = this._ranges[numRanges - 1];\n\t\t\t\tthis._ranges.pop();\n\t\t\t\tnumRanges -= 1;\n\t\t\t} else {\n\t\t\t\tcb(r);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic addRange(range: Range): void {\n\t\tconst weakref = createWeakRef(range);\n\t\tthis._ranges.push(weakref);\n\t\tthis._weakRangeSet.add(range);\n\t}\n\n\tpublic removeRange(range: Range): void {\n\t\tthis._weakRangeSet.delete(range);\n\t}\n}\n\n// TODO: make it possible to create multiple contexts by binding constructors to each instance\nexport const defaultContext = new DefaultContext();\n\nexport function getContext(_instance: Node | Range): Context {\n\treturn defaultContext;\n}\n","import Attr from '../Attr';\nimport CharacterData from '../CharacterData';\nimport Document from '../Document';\nimport DocumentFragment from '../DocumentFragment';\nimport DocumentType from '../DocumentType';\nimport Element from '../Element';\nimport Node from '../Node';\nimport Text from '../Text';\n\nexport const enum NodeType {\n\tELEMENT_NODE = 1,\n\tATTRIBUTE_NODE = 2,\n\tTEXT_NODE = 3,\n\tCDATA_SECTION_NODE = 4,\n\tENTITY_REFERENCE_NODE = 5, // legacy\n\tENTITY_NODE = 6, // legacy\n\tPROCESSING_INSTRUCTION_NODE = 7,\n\tCOMMENT_NODE = 8,\n\tDOCUMENT_NODE = 9,\n\tDOCUMENT_TYPE_NODE = 10,\n\tDOCUMENT_FRAGMENT_NODE = 11,\n\tNOTATION_NODE = 12, // legacy\n}\n\n/**\n * Checks whether the given node's nodeType is one of the specified values\n *\n * @param node  - The node to test\n * @param types - Possible nodeTypes for node\n *\n * @returns Whether node.nodeType is one of the specified values\n */\nexport function isNodeOfType(node: Node, ...types: NodeType[]): boolean {\n\treturn types.some((t) => node.nodeType === t);\n}\n\n/**\n * Checks whether node implements Attr\n *\n * @param node - The node to test\n *\n * @returns Whether node is an Attr\n */\nexport function isAttrNode(node: Node): node is Attr {\n\treturn node.nodeType === NodeType.ATTRIBUTE_NODE;\n}\n\n/**\n * Checks whether node implements CharacterData\n *\n * @param node - The node to test\n *\n * @returns Whether node is a CharacterData node\n */\nexport function isCharacterDataNode(node: Node): node is CharacterData {\n\treturn (\n\t\tnode.nodeType === NodeType.TEXT_NODE ||\n\t\tnode.nodeType === NodeType.CDATA_SECTION_NODE ||\n\t\tnode.nodeType === NodeType.COMMENT_NODE ||\n\t\tnode.nodeType === NodeType.PROCESSING_INSTRUCTION_NODE\n\t);\n}\n\n/**\n * Checks whether node implements Text\n *\n * @param node - The node to test\n *\n * @returns Whether node is a Text (or CDataSection) node\n */\nexport function isTextNode(node: Node): node is Text {\n\treturn node.nodeType === NodeType.TEXT_NODE || node.nodeType === NodeType.CDATA_SECTION_NODE;\n}\n\n/**\n * Checks whether node implements Element\n *\n * @param node - The node to test\n *\n * @returns Whether node is an Element node\n */\nexport function isElement(node: Node): node is Element {\n\treturn node.nodeType === NodeType.ELEMENT_NODE;\n}\n\n/**\n * Checks whether node implements Document\n *\n * @param node - The node to test\n *\n * @returns Whether node is a Document node\n */\nexport function isDocument(node: Node): node is Document {\n\treturn node.nodeType === NodeType.DOCUMENT_NODE;\n}\n\n/**\n * Checks whether node implements DocumentFragment\n *\n * @param node - The node to test\n *\n * @returns Whether node is a DocumentFragment node\n */\nexport function isDocumentFragment(node: Node): node is DocumentFragment {\n\treturn node.nodeType === NodeType.DOCUMENT_FRAGMENT_NODE;\n}\n\n/**\n * Checks whether node implements DocumentType\n *\n * @param node - The node to test\n *\n * @returns Whether node is a DocumentType node\n */\nexport function isDocumentType(node: Node): node is DocumentType {\n\treturn node.nodeType === NodeType.DOCUMENT_TYPE_NODE;\n}\n","import CharacterData from '../CharacterData';\nimport Document from '../Document';\nimport Element from '../Element';\nimport Node from '../Node';\nimport { NodeType, isNodeOfType } from './NodeType';\n\n/**\n * 3.2. Node Tree: to determine the length of a node, switch on node:\n *\n * @param node - The node to determine the length of\n *\n * @returns The length of the node\n */\nexport function determineLengthOfNode(node: Node): number {\n\tswitch (node.nodeType) {\n\t\t// DocumentType: Zero.\n\t\t// (not necessary, as doctypes never have children)\n\n\t\t// Text, ProcessingInstruction, Comment: The number of code units in its data.\n\t\tcase NodeType.TEXT_NODE:\n\t\tcase NodeType.PROCESSING_INSTRUCTION_NODE:\n\t\tcase NodeType.COMMENT_NODE:\n\t\t\treturn (node as CharacterData).data.length;\n\n\t\t// Any other node: Its number of children.\n\t\tdefault:\n\t\t\treturn node.childNodes.length;\n\t}\n}\n\n/**\n * Get inclusive ancestors of the given node.\n *\n * @param node - Node to get inclusive ancestors of\n *\n * @returns Node's inclusive ancestors, in tree order\n */\nexport function getInclusiveAncestors(node: Node): Node[] {\n\tlet ancestor: Node | null = node;\n\tlet ancestors: Node[] = [];\n\twhile (ancestor) {\n\t\tancestors.unshift(ancestor);\n\t\tancestor = ancestor.parentNode;\n\t}\n\n\treturn ancestors;\n}\n\n/**\n * Get the node document associated with the given node.\n *\n * @param node - The node to get the node document for\n *\n * @returns The node document for node\n */\nexport function getNodeDocument(node: Node): Document {\n\tif (isNodeOfType(node, NodeType.DOCUMENT_NODE)) {\n\t\treturn node as Document;\n\t}\n\n\treturn node.ownerDocument!;\n}\n\n/**\n * Determine the index of the given node among its siblings.\n *\n * @param node - Node to determine the index of\n *\n * @returns The index of node in its parent's children\n */\nexport function getNodeIndex(node: Node): number {\n\treturn node.parentNode!.childNodes.indexOf(node);\n}\n\n/**\n * The root of an object is itself, if its parent is null, or else it is the root of its parent.\n *\n * @param node - Node to get the root of\n *\n * @returns The root of node\n */\nexport function getRootOfNode(node: Node): Node {\n\twhile (node.parentNode) {\n\t\tnode = node.parentNode;\n\t}\n\n\treturn node;\n}\n\n/**\n * Invokes callback on each inclusive descendant of node, in tree order\n *\n * @param node     - Root of the subtree to process\n * @param callback - Callback to invoke for each descendant, should not modify node's position in\n *                   the tree\n */\nexport function forEachInclusiveDescendant(node: Node, callback: (node: Node) => void): void {\n\tcallback(node);\n\tfor (let child = node.firstChild; child; child = child.nextSibling) {\n\t\tforEachInclusiveDescendant(child, callback);\n\t}\n}\n\n/**\n * The list of elements with qualified name qualifiedName for a node root is the HTMLCollection\n * returned by the following algorithm:\n *\n * (this implementation returns a non-live array instead)\n *\n * @param qualifiedName - The qualifiedName of elements to return, or '*' to return all elements\n * @param root          - The root of the subtree from which to collect matching descendants\n */\nexport function getListOfElementsWithQualifiedName(qualifiedName: string, root: Node): Element[] {\n\tconst elements: Element[] = [];\n\tforEachInclusiveDescendant(root, (node) => {\n\t\t// Only matches descendant elements\n\t\tif (node === root || node.nodeType !== NodeType.ELEMENT_NODE) {\n\t\t\treturn;\n\t\t}\n\t\tconst element = node as Element;\n\n\t\tif (\n\t\t\t// 1. If qualifiedName is \"*\" (U+002A), return a HTMLCollection rooted at root, whose\n\t\t\t// filter matches only descendant elements.\n\t\t\tqualifiedName === '\\u002a' ||\n\t\t\t// 2. Otherwise, if root’s node document is an HTML document, return a HTMLCollection\n\t\t\t// rooted at root, whose filter matches the following descendant elements:\n\t\t\t//    - Whose namespace is the HTML namespace and whose qualified name is qualifiedName,\n\t\t\t//      in ASCII lowercase.\n\t\t\t//    - Whose namespace is not the HTML namespace and whose qualified name is\n\t\t\t//      qualifiedName.\n\t\t\t// (html documents not implemented)\n\n\t\t\t// 3. Otherwise, return a HTMLCollection rooted at root, whose filter matches descendant\n\t\t\t// elements whose qualified name is qualifiedName.\n\t\t\telement.nodeName === qualifiedName\n\t\t) {\n\t\t\telements.push(element);\n\t\t}\n\t});\n\n\treturn elements;\n}\n\n/**\n * The list of elements with namespace namespace and local name localName for a node root is the\n * HTMLCollection returned by the following algorithm:\n *\n * (this implementation returns a non-live array instead)\n *\n * @param namespace - The namespace of the elements to return, or '*' to match any namespace\n * @param localName - The local name of the elements to return, or '*' to match any local name\n * @param root      - The root of the subtree from which to collect matching descendants\n */\nexport function getListOfElementsWithNamespaceAndLocalName(\n\tnamespace: string | null,\n\tlocalName: string,\n\troot: Node\n): Element[] {\n\t// 1. If namespace is the empty string, set it to null.\n\tif (namespace === '') {\n\t\tnamespace = null;\n\t}\n\n\tconst elements: Element[] = [];\n\tforEachInclusiveDescendant(root, (node) => {\n\t\t// Only matches descendant elements\n\t\tif (node === root || node.nodeType !== NodeType.ELEMENT_NODE) {\n\t\t\treturn;\n\t\t}\n\t\tconst element = node as Element;\n\n\t\tif (\n\t\t\t// 2. If both namespace and localName are \"*\" (U+002A), return a HTMLCollection\n\t\t\t//    rooted at root, whose filter matches descendant elements.\n\t\t\t// 3. Otherwise, if namespace is \"*\" (U+002A), return a HTMLCollection rooted at\n\t\t\t//    root, whose filter matches descendant elements whose local name is localName.\n\t\t\t// 4. Otherwise, if localName is \"*\" (U+002A), return a HTMLCollection rooted at\n\t\t\t//    root, whose filter matches descendant elements whose namespace is namespace.\n\t\t\t// 5. Otherwise, return a HTMLCollection rooted at root, whose filter matches\n\t\t\t//    descendant elements whose namespace is namespace and local name is localName.\n\t\t\t(namespace === '\\u002a' || element.namespaceURI === namespace) &&\n\t\t\t(localName === '\\u002a' || element.localName === localName)\n\t\t) {\n\t\t\telements.push(element);\n\t\t}\n\t});\n\n\treturn elements;\n}\n","import Document from '../Document';\nimport Node from '../Node';\n\nimport { getNodeDocument } from './treeHelpers';\n\n// 3.4. Interface Node\n\n/**\n * To clone a node, with an optional document and clone children flag, run these steps:\n *\n * @param node          - The node to clone\n * @param cloneChildren - Whether to also clone node's descendants\n * @param document      - The document used to create the copy\n */\nexport default function cloneNode<TNode extends Node>(\n\tnode: TNode,\n\tcloneChildren: boolean,\n\tdocument?: Document\n): TNode {\n\t// 1. If document is not given, let document be node’s node document.\n\tif (!document) {\n\t\tdocument = getNodeDocument(node);\n\t}\n\n\t// 2. If node is an element, then:\n\t// 2.1. Let copy be the result of creating an element, given document, node’s local name, node’s\n\t// namespace, node’s namespace prefix, and node’s is value, with the synchronous custom elements\n\t// flag unset.\n\t// 2.2. For each attribute in node’s attribute list:\n\t// 2.2.1. Let copyAttribute be a clone of attribute.\n\t// 2.2.2. Append copyAttribute to copy.\n\t// 3. Otherwise, let copy be a node that implements the same interfaces as node, and fulfills\n\t// these additional requirements, switching on node:\n\t// Document: Set copy’s encoding, content type, URL, origin, type, and mode, to those of node.\n\t// DocumentType: Set copy’s name, public ID, and system ID, to those of node.\n\t// Attr: Set copy’s namespace, namespace prefix, local name, and value, to those of node.\n\t// Text, Comment: Set copy’s data, to that of node.\n\t// ProcessingInstruction: Set copy’s target and data to those of node.\n\t// Any other node: —\n\t// 4. Set copy’s node document and document to copy, if copy is a document, and set copy’s node\n\t// document to document otherwise.\n\t// (all handled by _copy method)\n\tlet copy = node._copy(document) as TNode;\n\n\t// 5. Run any cloning steps defined for node in other applicable specifications and pass copy,\n\t// node, document and the clone children flag if set, as parameters.\n\t// (cloning steps not implemented)\n\n\t// 6. If the clone children flag is set, clone all the children of node and append them to copy,\n\t// with document as specified and the clone children flag being set.\n\tif (cloneChildren) {\n\t\tfor (let child = node.firstChild; child; child = child.nextSibling) {\n\t\t\tcopy.appendChild(cloneNode(child, true, document));\n\t\t}\n\t}\n\n\t// 7. Return copy.\n\treturn copy;\n}\n","export function expectArity(args: IArguments, minArity: number): void {\n\t// According to WebIDL overload resolution semantics, only a lower bound applies to the number\n\t// of arguments provided\n\tif (args.length < minArity) {\n\t\tthrow new TypeError(`Function should be called with at least ${minArity} arguments`);\n\t}\n}\n\nexport function expectObject<T>(value: T, Constructor: Function): void {\n\tif (!(value instanceof Constructor)) {\n\t\tthrow new TypeError(`Value should be an instance of ${Constructor.name}`);\n\t}\n}\n\nconst codeByName: Record<string, number> = {\n\tIndexSizeError: 1,\n\tHierarchyRequestError: 3,\n\tWrongDocumentError: 4,\n\tInvalidCharacterError: 5,\n\tNotFoundError: 8,\n\tNotSupportedError: 9,\n\tInUseAttributeError: 10,\n\tInvalidStateError: 11,\n\tNamespaceError: 14,\n\tInvalidNodeTypeError: 24,\n};\n\n/**\n * Exception type used for DOM errors\n *\n * @public\n */\nexport class DOMException extends Error {\n\tpublic readonly name: string;\n\tpublic readonly message: string;\n\tpublic readonly code: number;\n\tpublic readonly stack: string | undefined;\n\n\tconstructor(message: string = '', name: string = 'Error') {\n\t\tsuper(message);\n\n\t\tthis.message = message;\n\t\tthis.name = name;\n\t\tthis.code = codeByName[name] || 0;\n\t\tthis.stack = new Error(message).stack;\n\t}\n}\n\nfunction createDOMException(name: string, message: string): Error {\n\treturn new DOMException(`${name}: ${message}`, name);\n}\n\nexport function throwHierarchyRequestError(message: string): never {\n\tthrow createDOMException('HierarchyRequestError', message);\n}\n\nexport function throwIndexSizeError(message: string): never {\n\tthrow createDOMException('IndexSizeError', message);\n}\n\nexport function throwInUseAttributeError(message: string): never {\n\tthrow createDOMException('InUseAttributeError', message);\n}\n\nexport function throwInvalidCharacterError(message: string): never {\n\tthrow createDOMException('InvalidCharacterError', message);\n}\n\nexport function throwInvalidNodeTypeError(message: string): never {\n\tthrow createDOMException('InvalidNodeTypeError', message);\n}\n\nexport function throwInvalidStateError(message: string): never {\n\tthrow createDOMException('InvalidStateError', message);\n}\n\nexport function throwNamespaceError(message: string): never {\n\tthrow createDOMException('NamespaceError', message);\n}\n\nexport function throwNotFoundError(message: string): never {\n\tthrow createDOMException('NotFoundError', message);\n}\n\nexport function throwNotSupportedError(message: string): never {\n\tthrow createDOMException('NotSupportedError', message);\n}\n\nexport function throwWrongDocumentError(message: string): never {\n\tthrow createDOMException('WrongDocumentError', message);\n}\n","import Node from '../Node';\n\nexport interface MutationRecordInit {\n\tname?: string;\n\tnamespace?: string | null;\n\toldValue?: string | null;\n\taddedNodes?: Node[];\n\tremovedNodes?: Node[];\n\tpreviousSibling?: Node | null;\n\tnextSibling?: Node | null;\n}\n\n/**\n * 3.3.3. Interface MutationRecord\n *\n * A helper class which describes a specific mutation as it is observed by a MutationObserver.\n *\n * @public\n */\nexport default class MutationRecord {\n\t/**\n\t * Returns \"attributes\" if it was an attribute mutation. \"characterData\" if it was a mutation to\n\t * a CharacterData node. And \"childList\" if it was a mutation to the tree of nodes.\n\t */\n\tpublic type: string;\n\n\t/**\n\t * Returns the node the mutation affected, depending on the type. For \"attributes\", it is the\n\t * element whose attribute changed. For \"characterData\", it is the CharacterData node. For\n\t * \"childList\", it is the node whose children changed.\n\t */\n\tpublic target: Node;\n\n\t/**\n\t * Children of target added in this mutation.\n\t *\n\t * (non-standard) According to the spec this should be a NodeList. This implementation uses an\n\t * array.\n\t */\n\tpublic addedNodes: Node[] = [];\n\n\t/**\n\t * Children of target removed in this mutation.\n\t *\n\t * (non-standard) According to the spec this should be a NodeList. This implementation uses an\n\t * array.\n\t */\n\tpublic removedNodes: Node[] = [];\n\n\t/**\n\t * The previous sibling of the added or removed nodes, or null otherwise.\n\t */\n\tpublic previousSibling: Node | null = null;\n\n\t/**\n\t * The next sibling Node of the added or removed nodes, or null otherwise.\n\t */\n\tpublic nextSibling: Node | null = null;\n\n\t/**\n\t * The local name of the changed attribute, or null otherwise.\n\t */\n\tpublic attributeName: string | null = null;\n\n\t/**\n\t * The namespace of the changed attribute, or null otherwise.\n\t */\n\tpublic attributeNamespace: string | null = null;\n\n\t/**\n\t * The return value depends on type. For \"attributes\", it is the value of the changed attribute\n\t * before the change. For \"characterData\", it is the data of the changed node before the change.\n\t * For \"childList\", it is null.\n\t */\n\tpublic oldValue: string | null = null;\n\n\t/**\n\t * (non-standard) Constructs a MutationRecord\n\t *\n\t * @param type   - The value for the type property\n\t * @param target - The value for the target property\n\t */\n\tconstructor(type: string, target: Node) {\n\t\tthis.type = type;\n\t\tthis.target = target;\n\t}\n}\n","import { getContext } from '../context/Context';\nimport MutationObserver from './MutationObserver';\nimport { MutationRecordInit, default as MutationRecord } from './MutationRecord';\nimport Node from '../Node';\n\n/**\n * 3.3.2. Queuing a mutation record\n *\n * To queue a mutation record of type for target with name, namespace, oldValue, addedNodes,\n * removedNodes, previousSibling and nextSibling, run these steps:\n * namespace namespace, oldValue oldValue, addedNodes addedNodes, removedNodes removedNodes,\n *\n * To queue a tree mutation record for target with addedNodes, removedNodes, previousSibling, and\n * nextSibling, run these steps:\n *  - Assert: either addedNodes or removedNodes is not empty.\n *  - Queue a mutation record of \"childList\" for target with null, null, null, addedNodes,\n *    removedNodes, previousSibling, and nextSibling.\n *\n * @param type   - The type of mutation record to queue\n * @param target - The target node\n * @param data   - The data for the mutation record\n */\nexport default function queueMutationRecord(type: string, target: Node, data: MutationRecordInit) {\n\t// 1. Let interested observers be an empty map\n\tconst interestedObservers: MutationObserver[] = [];\n\tconst pairedStrings: (string | null | undefined)[] = [];\n\n\t// 2. Let nodes be the inclusive ancestors of target.\n\t// 3. For each node in nodes, ...:\n\tfor (let node: Node | null = target; node; node = node.parentNode) {\n\t\tnode._registeredObservers.collectInterestedObservers(\n\t\t\ttype,\n\t\t\ttarget,\n\t\t\tdata,\n\t\t\tinterestedObservers,\n\t\t\tpairedStrings\n\t\t);\n\t}\n\n\tconst context = getContext(target);\n\n\t// 4. For each observer → mappedOldValue of interestedObservers:\n\tinterestedObservers.forEach((observer, index) => {\n\t\tconst mappedOldValue = pairedStrings[index];\n\n\t\t// 4.1. Let record be a new MutationRecord object with its type set to type and target set\n\t\t// to target,\n\t\tconst record = new MutationRecord(type, target);\n\n\t\t// ...attributeName set to to name, attributeNamespace set to namespace...\n\t\tif (data.name !== undefined && data.namespace !== undefined) {\n\t\t\trecord.attributeName = data.name;\n\t\t\trecord.attributeNamespace = data.namespace;\n\t\t}\n\n\t\t// ...oldValue set to mappedOldValue...\n\t\tif (mappedOldValue !== undefined) {\n\t\t\trecord.oldValue = mappedOldValue;\n\t\t}\n\n\t\t// ...addedNodes set to addedNodes...\n\t\tif (data.addedNodes !== undefined) {\n\t\t\trecord.addedNodes = data.addedNodes;\n\t\t}\n\n\t\t// ...removedNodes set to removedNodes...\n\t\tif (data.removedNodes !== undefined) {\n\t\t\trecord.removedNodes = data.removedNodes;\n\t\t}\n\n\t\t// ...previousSibling set to previousSibling...\n\t\tif (data.previousSibling !== undefined) {\n\t\t\trecord.previousSibling = data.previousSibling;\n\t\t}\n\n\t\t// ...and nextSibling set to nextSibling.\n\t\tif (data.nextSibling !== undefined) {\n\t\t\trecord.nextSibling = data.nextSibling;\n\t\t}\n\n\t\t// 4.2. Enqueue record to observer’s record queue.\n\t\tcontext._notifySet.appendRecord(observer, record);\n\t});\n\n\t// 5. Queue a mutation observer microtask.\n\tcontext._notifySet.queueMutationObserverMicrotask();\n}\n","import CharacterData from './CharacterData';\nimport Document from './Document';\nimport DocumentFragment from './DocumentFragment';\nimport Element from './Element';\nimport Node from './Node';\n\nimport { NodeType, isNodeOfType, isElement } from './util/NodeType';\n\n/**\n * 3.2.4. Mixin NonElementParentNode\n */\nexport interface NonElementParentNode {}\n// Document implements NonElementParentNode;\n// DocumentFragment implements NonElementParentNode;\n\n/**\n * 3.2.6. Mixin ParentNode\n */\nexport interface ParentNode {\n\treadonly children: Element[];\n\n\tfirstElementChild: Element | null;\n\tlastElementChild: Element | null;\n\tchildElementCount: number;\n\n\tprepend(...nodes: (Node | string)[]): void;\n\tappend(...nodes: (Node | string)[]): void;\n\treplaceChildren(...nodes: (Node | string)[]): void;\n}\n// Document implements ParentNode;\n// DocumentFragment implements ParentNode;\n// Element implements ParentNode;\n\nexport function asParentNode(node: Node): ParentNode | null {\n\t// This is only called from treeMutations.js, where node can never be anything other than these\n\t/* istanbul ignore else */\n\tif (\n\t\tisNodeOfType(\n\t\t\tnode,\n\t\t\tNodeType.ELEMENT_NODE,\n\t\t\tNodeType.DOCUMENT_NODE,\n\t\t\tNodeType.DOCUMENT_FRAGMENT_NODE\n\t\t)\n\t) {\n\t\treturn node as Element | Document | DocumentFragment;\n\t}\n\n\t/* istanbul ignore next */\n\treturn null;\n}\n\n/**\n * Returns the element children of node.\n *\n * (Non-standard) According to the spec, the children getter should return a live HTMLCollection.\n * This implementation returns a static array instead.\n *\n * @param node - The node to get element children of\n *\n * @returns The\n */\nexport function getChildren(node: ParentNode): Element[] {\n\tconst elements: Element[] = [];\n\tfor (let child = node.firstElementChild; child; child = child.nextElementSibling) {\n\t\telements.push(child);\n\t}\n\treturn elements;\n}\n\n/**\n * 3.2.7. Mixin NonDocumentTypeChildNode\n */\nexport interface NonDocumentTypeChildNode {\n\treadonly previousElementSibling: Element | null;\n\treadonly nextElementSibling: Element | null;\n}\n// Element implements NonDocumentTypeChildNode;\n// CharacterData implements NonDocumentTypeChildNode;\n\nexport function getPreviousElementSibling(node: Node): Element | null {\n\tfor (let sibling = node.previousSibling; sibling; sibling = sibling.previousSibling) {\n\t\tif (isElement(sibling)) {\n\t\t\treturn sibling;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nexport function getNextElementSibling(node: Node): Element | null {\n\tfor (let sibling = node.nextSibling; sibling; sibling = sibling.nextSibling) {\n\t\tif (isElement(sibling)) {\n\t\t\treturn sibling;\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * 3.2.8. Mixin ChildNode\n */\nexport interface ChildNode {\n\tbefore(...nodes: (Node | string)[]): void;\n\tafter(...nodes: (Node | string)[]): void;\n\treplaceWith(...nodes: (Node | string)[]): void;\n\tremove(): void;\n}\n// DocumentType implements ChildNode;\n// Element implements ChildNode;\n// CharacterData implements ChildNode;\n","import { asParentNode } from '../mixins';\nimport CharacterData from '../CharacterData';\nimport Document from '../Document';\nimport DocumentFragment from '../DocumentFragment';\nimport DocumentType from '../DocumentType';\nimport Element from '../Element';\nimport Node from '../Node';\n\nimport { NodeType, isNodeOfType, isElement, isDocument, isDocumentType } from './NodeType';\n\n/**\n * Insert node into parent's children before referenceNode.\n *\n * Updates the pointers that model the tree, as well as precomputing derived properties.\n *\n * @param node           - Node to insert\n * @param parent         - Parent to insert under\n * @param referenceChild - Child to insert before\n */\nexport function insertIntoChildren(node: Node, parent: Node, referenceChild: Node | null): void {\n\t// Node\n\tnode.parentNode = parent;\n\tconst previousSibling: Node | null =\n\t\treferenceChild === null ? parent.lastChild : referenceChild.previousSibling;\n\tconst nextSibling: Node | null = referenceChild === null ? null : referenceChild;\n\tnode.previousSibling = previousSibling;\n\tnode.nextSibling = nextSibling;\n\tif (previousSibling) {\n\t\tpreviousSibling.nextSibling = node;\n\t} else {\n\t\tparent.firstChild = node;\n\t}\n\tif (nextSibling) {\n\t\tnextSibling.previousSibling = node;\n\t\tparent.childNodes.splice(parent.childNodes.indexOf(nextSibling), 0, node);\n\t} else {\n\t\tparent.lastChild = node;\n\t\tparent.childNodes.push(node);\n\t}\n\n\t// ParentNode\n\tif (isElement(node)) {\n\t\t// Functions calling this will ensure parent is always a ParentNode\n\t\tconst parentNode = parent as Element | Document | DocumentFragment;\n\t\tlet previousElementSibling: Element | null = null;\n\t\tfor (let sibling = previousSibling; sibling; sibling = sibling.previousSibling) {\n\t\t\tif (isElement(sibling)) {\n\t\t\t\tpreviousElementSibling = sibling;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst siblingNonDocumentTypeChildNode = sibling as CharacterData | DocumentType;\n\t\t\tif (!isDocumentType(siblingNonDocumentTypeChildNode)) {\n\t\t\t\tpreviousElementSibling = siblingNonDocumentTypeChildNode.previousElementSibling;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tlet nextElementSibling: Element | null = null;\n\t\tfor (let sibling = nextSibling; sibling; sibling = sibling!.nextSibling) {\n\t\t\tif (isElement(sibling)) {\n\t\t\t\tnextElementSibling = sibling;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// An element can never be inserted before a doctype\n\t\t\tconst siblingNonDocumentTypeChildNode = sibling as CharacterData;\n\t\t\tnextElementSibling = siblingNonDocumentTypeChildNode.nextElementSibling;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!previousElementSibling) {\n\t\t\tparentNode.firstElementChild = node;\n\t\t}\n\t\tif (!nextElementSibling) {\n\t\t\tparentNode.lastElementChild = node;\n\t\t}\n\t\tparentNode.childElementCount += 1;\n\t}\n\n\t// Document\n\tif (isDocument(parent)) {\n\t\tif (isElement(node)) {\n\t\t\tparent.documentElement = node;\n\t\t} else if (isDocumentType(node)) {\n\t\t\tparent.doctype = node;\n\t\t}\n\t}\n}\n\n/**\n * Remove node from parent's children.\n *\n * Updates the pointers that model the tree, as well as precomputing derived properties.\n *\n * @param node   - Node to remove\n * @param parent - Parent to remove from\n */\nexport function removeFromChildren(node: Node, parent: Node) {\n\tconst previousSibling = node.previousSibling;\n\tconst nextSibling = node.nextSibling;\n\tconst isElement = isNodeOfType(node, NodeType.ELEMENT_NODE);\n\tconst previousElementSibling = isElement ? (node as Element).previousElementSibling : null;\n\tconst nextElementSibling = isElement ? (node as Element).nextElementSibling : null;\n\n\t// Node\n\tnode.parentNode = null;\n\tnode.previousSibling = null;\n\tnode.nextSibling = null;\n\tif (previousSibling) {\n\t\tpreviousSibling.nextSibling = nextSibling;\n\t} else {\n\t\tparent.firstChild = nextSibling;\n\t}\n\tif (nextSibling) {\n\t\tnextSibling.previousSibling = previousSibling;\n\t} else {\n\t\tparent.lastChild = previousSibling;\n\t}\n\tparent.childNodes.splice(parent.childNodes.indexOf(node), 1);\n\n\t// ParentNode\n\tif (isElement) {\n\t\tconst parentNode = asParentNode(parent);\n\t\t// Functions calling this will ensure parent is always a ParentNode\n\t\t/* istanbul ignore else */\n\t\tif (parentNode) {\n\t\t\tif (parentNode.firstElementChild === node) {\n\t\t\t\tparentNode.firstElementChild = nextElementSibling;\n\t\t\t}\n\t\t\tif (parentNode.lastElementChild === node) {\n\t\t\t\tparentNode.lastElementChild = previousElementSibling;\n\t\t\t}\n\t\t\tparentNode.childElementCount -= 1;\n\t\t}\n\t}\n\n\t// Document\n\tif (isNodeOfType(parent, NodeType.DOCUMENT_NODE)) {\n\t\tconst parentDocument = parent as Document;\n\t\tif (isNodeOfType(node, NodeType.ELEMENT_NODE)) {\n\t\t\tparentDocument.documentElement = null;\n\t\t} else if (isNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE)) {\n\t\t\tparentDocument.doctype = null;\n\t\t}\n\t}\n}\n","import { getContext } from '../context/Context';\nimport queueMutationRecord from '../mutation-observer/queueMutationRecord';\nimport { throwHierarchyRequestError, throwNotFoundError } from './errorHelpers';\nimport { NodeType, isNodeOfType, isTextNode, isDocumentFragment } from './NodeType';\nimport {\n\tgetNodeDocument,\n\tgetNodeIndex,\n\tforEachInclusiveDescendant,\n\tdetermineLengthOfNode,\n} from './treeHelpers';\nimport { insertIntoChildren, removeFromChildren } from './treeMutations';\nimport Document from '../Document';\nimport DocumentFragment from '../DocumentFragment';\nimport Element from '../Element';\nimport { ParentNode, ChildNode } from '../mixins';\nimport Node from '../Node';\nimport Range from '../Range';\nimport Text from '../Text';\n\n// 3.2.3. Mutation algorithms\n\n/**\n * To ensure pre-insertion validity of a node into a parent before a child, run these steps:\n */\nfunction ensurePreInsertionValidity(node: Node, parent: Node, child: Node | null): void {\n\t// 1. If parent is not a Document, DocumentFragment, or Element node, throw a\n\t// HierarchyRequestError.\n\tif (\n\t\t!isNodeOfType(\n\t\t\tparent,\n\t\t\tNodeType.DOCUMENT_NODE,\n\t\t\tNodeType.DOCUMENT_FRAGMENT_NODE,\n\t\t\tNodeType.ELEMENT_NODE\n\t\t)\n\t) {\n\t\tthrowHierarchyRequestError('parent must be a Document, DocumentFragment or Element node');\n\t}\n\n\t// 2. If node is a host-including inclusive ancestor of parent, throw a HierarchyRequestError.\n\tif (node.contains(parent)) {\n\t\tthrowHierarchyRequestError('node must not be an inclusive ancestor of parent');\n\t}\n\n\t// 3. If child is non-null and its parent is not parent, then throw a NotFoundError.\n\tif (child && child.parentNode !== parent) {\n\t\tthrowNotFoundError('child is not a child of parent');\n\t}\n\n\t// 4. If node is not a DocumentFragment, DocumentType, Element, Text, ProcessingInstruction, or\n\t// Comment node, throw a HierarchyRequestError.\n\tif (\n\t\t!isNodeOfType(\n\t\t\tnode,\n\t\t\tNodeType.DOCUMENT_FRAGMENT_NODE,\n\t\t\tNodeType.DOCUMENT_TYPE_NODE,\n\t\t\tNodeType.ELEMENT_NODE,\n\t\t\tNodeType.TEXT_NODE,\n\t\t\tNodeType.CDATA_SECTION_NODE,\n\t\t\tNodeType.PROCESSING_INSTRUCTION_NODE,\n\t\t\tNodeType.COMMENT_NODE\n\t\t)\n\t) {\n\t\tthrowHierarchyRequestError(\n\t\t\t'node must be a DocumentFragment, DocumentType, Element, Text, ProcessingInstruction ' +\n\t\t\t\t'or Comment node'\n\t\t);\n\t}\n\n\t// 5. If either node is a Text node and parent is a document, or node is a doctype and parent is\n\t// not a document, throw a HierarchyRequestError.\n\tif (isNodeOfType(node, NodeType.TEXT_NODE) && isNodeOfType(parent, NodeType.DOCUMENT_NODE)) {\n\t\tthrowHierarchyRequestError('can not insert a Text node under a Document');\n\t}\n\tif (\n\t\tisNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE) &&\n\t\t!isNodeOfType(parent, NodeType.DOCUMENT_NODE)\n\t) {\n\t\tthrowHierarchyRequestError('can only insert a DocumentType node under a Document');\n\t}\n\n\t// 6. If parent is a document, and any of the statements below, switched on node, are true,\n\t// throw a HierarchyRequestError.\n\tif (isNodeOfType(parent, NodeType.DOCUMENT_NODE)) {\n\t\tconst parentDocument = parent as Document;\n\t\tswitch (node.nodeType) {\n\t\t\t// DocumentFragment node\n\t\t\tcase NodeType.DOCUMENT_FRAGMENT_NODE:\n\t\t\t\t// If node has more than one element child or has a Text node child.\n\t\t\t\tconst fragment = node as DocumentFragment;\n\t\t\t\tif (fragment.firstElementChild !== fragment.lastElementChild) {\n\t\t\t\t\tthrowHierarchyRequestError(\n\t\t\t\t\t\t'can not insert more than one element under a Document'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tArray.from(fragment.childNodes).some((child) =>\n\t\t\t\t\t\tisNodeOfType(child, NodeType.TEXT_NODE)\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tthrowHierarchyRequestError('can not insert a Text node under a Document');\n\t\t\t\t}\n\t\t\t\t// Otherwise, if node has one element child and either parent has an element child,\n\t\t\t\t// child is a doctype, or child is non-null and a doctype is following child.\n\t\t\t\tif (\n\t\t\t\t\tfragment.firstElementChild &&\n\t\t\t\t\t(parentDocument.documentElement ||\n\t\t\t\t\t\t(child && isNodeOfType(child, NodeType.DOCUMENT_TYPE_NODE)) ||\n\t\t\t\t\t\t(child &&\n\t\t\t\t\t\t\tparentDocument.doctype &&\n\t\t\t\t\t\t\tgetNodeIndex(child) < getNodeIndex(parentDocument.doctype)))\n\t\t\t\t) {\n\t\t\t\t\tthrowHierarchyRequestError(\n\t\t\t\t\t\t'Document should contain at most one doctype, followed by at most one ' +\n\t\t\t\t\t\t\t'element'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// element\n\t\t\tcase NodeType.ELEMENT_NODE:\n\t\t\t\t// parent has an element child, child is a doctype, or child is non-null and a\n\t\t\t\t// doctype is following child.\n\t\t\t\tif (\n\t\t\t\t\tparentDocument.documentElement ||\n\t\t\t\t\t(child && isNodeOfType(child, NodeType.DOCUMENT_TYPE_NODE)) ||\n\t\t\t\t\t(child &&\n\t\t\t\t\t\tparentDocument.doctype &&\n\t\t\t\t\t\tgetNodeIndex(child) < getNodeIndex(parentDocument.doctype))\n\t\t\t\t) {\n\t\t\t\t\tthrowHierarchyRequestError(\n\t\t\t\t\t\t'Document should contain at most one doctype, followed by at most one ' +\n\t\t\t\t\t\t\t'element'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// doctype\n\t\t\tcase NodeType.DOCUMENT_TYPE_NODE:\n\t\t\t\t// parent has a doctype child, child is non-null and an element is preceding child,\n\t\t\t\t// or child is null and parent has an element child.\n\t\t\t\tif (\n\t\t\t\t\tparentDocument.doctype ||\n\t\t\t\t\t(child &&\n\t\t\t\t\t\tparentDocument.documentElement &&\n\t\t\t\t\t\tgetNodeIndex(parentDocument.documentElement) < getNodeIndex(child)) ||\n\t\t\t\t\t(!child && parentDocument.documentElement)\n\t\t\t\t) {\n\t\t\t\t\tthrowHierarchyRequestError(\n\t\t\t\t\t\t'Document should contain at most one doctype, followed by at most one ' +\n\t\t\t\t\t\t\t'element'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * To pre-insert a node into a parent before a child, run these steps:\n *\n * @param node   - Node to pre-insert\n * @param parent - Parent to insert under\n * @param child  - Child to insert before, or null to insert at the end of parent\n *\n * @returns The inserted node\n */\nexport function preInsertNode<TNode extends Node>(\n\tnode: TNode,\n\tparent: Node,\n\tchild: Node | null\n): TNode {\n\t// 1. Ensure pre-insertion validity of node into parent before child.\n\tensurePreInsertionValidity(node, parent, child);\n\n\t// 2. Let referenceChild be child.\n\tlet referenceChild = child;\n\n\t// 3. If referenceChild is node, set it to node’s next sibling.\n\tif (referenceChild === node) {\n\t\treferenceChild = node.nextSibling;\n\t}\n\n\t// 4. Adopt node into parent's node document.\n\tadoptNode(node, getNodeDocument(parent));\n\n\t// 5. Insert node into parent before referenceChild.\n\tinsertNode(node, parent, referenceChild);\n\n\t// 6. Return node.\n\treturn node;\n}\n\n/**\n * To insert a node into a parent before a child, with an optional suppress observers flag, run\n * these steps:\n *\n * @param node              - Node to insert\n * @param parent            - Parent to insert under\n * @param child             - Child to insert before, or null to insert at end of parent\n * @param suppressObservers - Whether to skip enqueueing a mutation record for this mutation\n */\nexport function insertNode(\n\tnode: Node,\n\tparent: Node,\n\tchild: Node | null,\n\tsuppressObservers: boolean = false\n): void {\n\t// 1. Let nodes be node’s children if node is a DocumentFragment node; otherwise « node ».\n\tconst isFragment = isDocumentFragment(node);\n\tconst nodes = isFragment ? Array.from(node.childNodes) : [node];\n\n\t// 2. Let count be nodes's size.\n\tconst count = nodes.length;\n\n\t// 3. If count is 0, then return.\n\tif (count === 0) {\n\t\treturn;\n\t}\n\n\t// 4. If node is a DocumentFragment node, then:\n\tif (isFragment) {\n\t\t// 4.1 Remove its children with the suppress observers flag set.\n\t\tnodes.forEach((n) => removeNode(n, true));\n\n\t\t// 4.2 Queue a tree mutation record for node with « », nodes, null, and null.\n\t\t// Note: This step intentionally does not pay attention to the suppress observers flag.\n\t\tqueueMutationRecord('childList', node, {\n\t\t\tremovedNodes: nodes,\n\t\t});\n\t}\n\n\t// 5. If child is non-null, then:\n\tif (child !== null) {\n\t\tconst childIndex = getNodeIndex(child);\n\t\tconst context = getContext(node);\n\t\tcontext.forEachRange((range) => {\n\t\t\t// 2.1. For each live range whose start node is parent and start offset is greater than\n\t\t\t// child’s index, increase its start offset by count.\n\t\t\tif (range.startContainer === parent && range.startOffset > childIndex) {\n\t\t\t\trange.startOffset += count;\n\t\t\t}\n\n\t\t\t// 2.2. For each live range whose end node is parent and end offset is greater than\n\t\t\t// child’s index, increase its end offset by count.\n\t\t\tif (range.endContainer === parent && range.endOffset > childIndex) {\n\t\t\t\trange.endOffset += count;\n\t\t\t}\n\t\t});\n\t}\n\n\t// 6. Let previousSibling be child’s previous sibling or parent’s last child if child is null.\n\tlet previousSibling = child === null ? parent.lastChild : child.previousSibling;\n\n\t// 7. For each node in nodes, in tree order:\n\tnodes.forEach((node) => {\n\t\t// 7.1. If child is null, then append node to parent’s children.\n\t\t// 7.2. Otherwise, insert node into parent’s children before child’s index.\n\t\tinsertIntoChildren(node, parent, child);\n\n\t\t// 7.3. If parent is a shadow host and node is a slottable, then assign a slot for node.\n\t\t// (shadow dom not implemented)\n\n\t\t// 7.4. If parent's root is a shadow root, and parent is a slot whose assigned nodes is the\n\t\t// empty list, then run signal a slot change for parent.\n\t\t// 7.5. Run assign slottables for a tree with node’s tree.\n\t\t// (shadow dom not implemented)\n\n\t\t// 7.6. For each shadow-including inclusive descendant inclusiveDescendant of node, in\n\t\t// shadow-including tree order:\n\t\t// 7.6.1. Run the insertion steps with inclusiveDescendant.\n\t\t// (insertion steps not implemented)\n\n\t\t// 7.6.2. If inclusiveDescendant is connected, then:\n\t\t// 7.6.2.1. If inclusiveDescendant is custom, then enqueue a custom element callback\n\t\t// reaction with inclusiveDescendant, callback name \"connectedCallback\", and an empty\n\t\t// argument list.\n\t\t// 7.6.2.2. Otherwise, try to upgrade inclusiveDescendant. If this successfully upgrades\n\t\t// inclusiveDescendant, its connectedCallback will be enqueued automatically during the\n\t\t// upgrade an element algorithm.\n\t\t// (custom elements not implemented)\n\t});\n\n\t// 8. If suppress observers flag is unset, queue a tree mutation record for parent with nodes,\n\t// « », previousSibling and child.\n\tif (!suppressObservers) {\n\t\tqueueMutationRecord('childList', parent, {\n\t\t\taddedNodes: nodes,\n\t\t\tnextSibling: child,\n\t\t\tpreviousSibling: previousSibling,\n\t\t});\n\t}\n\n\t// 9. Run the children changed steps for parent\n\t// (children changed steps not implemented)\n}\n\n/**\n * To append a node to a parent\n *\n * @param node   - Node to append\n * @param parent - Parent to append to\n *\n * @returns The appended node\n */\nexport function appendNode<TNode extends Node>(node: TNode, parent: Node): TNode {\n\t// pre-insert node into parent before null.\n\treturn preInsertNode(node, parent, null);\n}\n\n/**\n * To replace a child with node within a parent, run these steps:\n *\n * @param child  - The child node to replace\n * @param node   - The node to replace child with\n * @param parent - The parent to replace under\n *\n * @returns The old child node\n */\nexport function replaceChildWithNode<TChild extends Node>(\n\tchild: TChild,\n\tnode: Node,\n\tparent: Node\n): TChild {\n\t// 1. If parent is not a Document, DocumentFragment, or Element node, throw a\n\t// HierarchyRequestError.\n\tif (\n\t\t!isNodeOfType(\n\t\t\tparent,\n\t\t\tNodeType.DOCUMENT_NODE,\n\t\t\tNodeType.DOCUMENT_FRAGMENT_NODE,\n\t\t\tNodeType.ELEMENT_NODE\n\t\t)\n\t) {\n\t\tthrowHierarchyRequestError('Can not replace under a non-parent node');\n\t}\n\n\t// 2. If node is a host-including inclusive ancestor of parent, throw a HierarchyRequestError.\n\tif (node.contains(parent)) {\n\t\tthrowHierarchyRequestError('Can not insert a node under its own descendant');\n\t}\n\n\t// 3. If child’s parent is not parent, then throw a NotFoundError.\n\tif (child.parentNode !== parent) {\n\t\tthrowNotFoundError('child is not a child of parent');\n\t}\n\n\t// 4. If node is not a DocumentFragment, DocumentType, Element, Text, ProcessingInstruction, or\n\t// Comment node, throw a HierarchyRequestError.\n\tif (\n\t\t!isNodeOfType(\n\t\t\tnode,\n\t\t\tNodeType.DOCUMENT_FRAGMENT_NODE,\n\t\t\tNodeType.DOCUMENT_TYPE_NODE,\n\t\t\tNodeType.ELEMENT_NODE,\n\t\t\tNodeType.TEXT_NODE,\n\t\t\tNodeType.CDATA_SECTION_NODE,\n\t\t\tNodeType.PROCESSING_INSTRUCTION_NODE,\n\t\t\tNodeType.COMMENT_NODE\n\t\t)\n\t) {\n\t\tthrowHierarchyRequestError(\n\t\t\t\"Can not insert a node that isn't a DocumentFragment, DocumentType, Element, Text, \" +\n\t\t\t\t'ProcessingInstruction or Comment'\n\t\t);\n\t}\n\n\t// 5. If either node is a Text node and parent is a document, or node is a doctype and parent is\n\t// not a document, throw a HierarchyRequestError.\n\tif (isNodeOfType(node, NodeType.TEXT_NODE) && isNodeOfType(parent, NodeType.DOCUMENT_NODE)) {\n\t\tthrowHierarchyRequestError('can not insert a Text node under a Document');\n\t}\n\tif (\n\t\tisNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE) &&\n\t\t!isNodeOfType(parent, NodeType.DOCUMENT_NODE)\n\t) {\n\t\tthrowHierarchyRequestError('can only insert a DocumentType node under a Document');\n\t}\n\n\t// 6. If parent is a document, and any of the statements below, switched on node, are true,\n\t// throw a HierarchyRequestError.\n\tif (isNodeOfType(parent, NodeType.DOCUMENT_NODE)) {\n\t\tconst parentDocument = parent as Document;\n\t\tswitch (node.nodeType) {\n\t\t\t// DocumentFragment node\n\t\t\tcase NodeType.DOCUMENT_FRAGMENT_NODE:\n\t\t\t\t// If node has more than one element child or has a Text node child.\n\t\t\t\tconst fragment = node as DocumentFragment;\n\t\t\t\tif (fragment.firstElementChild !== fragment.lastElementChild) {\n\t\t\t\t\tthrowHierarchyRequestError(\n\t\t\t\t\t\t'can not insert more than one element under a Document'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tArray.from(fragment.childNodes).some((child) =>\n\t\t\t\t\t\tisNodeOfType(child, NodeType.TEXT_NODE)\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tthrowHierarchyRequestError('can not insert a Text node under a Document');\n\t\t\t\t}\n\t\t\t\t// Otherwise, if node has one element child and either parent has an element child\n\t\t\t\t// that is not child or a doctype is following child.\n\t\t\t\tif (\n\t\t\t\t\tfragment.firstElementChild &&\n\t\t\t\t\t((parentDocument.documentElement &&\n\t\t\t\t\t\tparentDocument.documentElement !== (child as Node)) ||\n\t\t\t\t\t\t(child &&\n\t\t\t\t\t\t\tparentDocument.doctype &&\n\t\t\t\t\t\t\tgetNodeIndex(child) < getNodeIndex(parentDocument.doctype)))\n\t\t\t\t) {\n\t\t\t\t\tthrowHierarchyRequestError(\n\t\t\t\t\t\t'Document should contain at most one doctype, followed by at most one ' +\n\t\t\t\t\t\t\t'element'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// element\n\t\t\tcase NodeType.ELEMENT_NODE:\n\t\t\t\t// parent has an element child that is not child or a doctype is following child.\n\t\t\t\tif (\n\t\t\t\t\t(parentDocument.documentElement &&\n\t\t\t\t\t\tparentDocument.documentElement !== (child as Node)) ||\n\t\t\t\t\t(parentDocument.doctype &&\n\t\t\t\t\t\tgetNodeIndex(child) < getNodeIndex(parentDocument.doctype))\n\t\t\t\t) {\n\t\t\t\t\tthrowHierarchyRequestError(\n\t\t\t\t\t\t'Document should contain at most one doctype, followed by at most one ' +\n\t\t\t\t\t\t\t'element'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// doctype\n\t\t\tcase NodeType.DOCUMENT_TYPE_NODE:\n\t\t\t\t// parent has a doctype child that is not child, or an element is preceding child.\n\t\t\t\tif (\n\t\t\t\t\t(parentDocument.doctype && parentDocument.doctype !== (child as Node)) ||\n\t\t\t\t\t(parentDocument.documentElement &&\n\t\t\t\t\t\tgetNodeIndex(parentDocument.documentElement) < getNodeIndex(child))\n\t\t\t\t) {\n\t\t\t\t\tthrowHierarchyRequestError(\n\t\t\t\t\t\t'Document should contain at most one doctype, followed by at most one ' +\n\t\t\t\t\t\t\t'element'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\t// The above statements differ from the pre-insert algorithm.\n\t}\n\n\t// 7. Let referenceChild be child’s next sibling.\n\tlet referenceChild = child.nextSibling;\n\n\t// 8. If referenceChild is node, set it to node’s next sibling.\n\tif (referenceChild === node) {\n\t\treferenceChild = node.nextSibling;\n\t}\n\n\t// 9. Let previousSibling be child’s previous sibling.\n\tconst previousSibling = child.previousSibling;\n\n\t// 10. Adopt node into parent's node document\n\tadoptNode(node, getNodeDocument(parent));\n\n\t// 11. Let removedNodes be the empty set.\n\tlet removedNodes: Node[] = [];\n\n\t// 12. If child’s parent is non-null, then:\n\tif (child.parentNode !== null) {\n\t\t// 11.1. Set removedNodes to « child ».\n\t\tremovedNodes.push(child);\n\n\t\t// 11.2. Remove child with the suppress observers flag set.\n\t\tremoveNode(child, true);\n\t}\n\t// The above can only be false if child is node.\n\n\t// 13. Let nodes be node’s children if node is a DocumentFragment node; otherwise « node ».\n\tconst nodes = isNodeOfType(node, NodeType.DOCUMENT_FRAGMENT_NODE)\n\t\t? Array.from(node.childNodes)\n\t\t: [node];\n\n\t// 14. Insert node into parent before referenceChild with the suppress observers flag set.\n\tinsertNode(node, parent, referenceChild, true);\n\n\t// 15. Queue a tree mutation record for parent with nodes, removedNodes, previousSibling and\n\t// referenceChild.\n\tqueueMutationRecord('childList', parent, {\n\t\taddedNodes: nodes,\n\t\tremovedNodes: removedNodes,\n\t\tnextSibling: referenceChild,\n\t\tpreviousSibling: previousSibling,\n\t});\n\n\t// 16. Return child.\n\treturn child;\n}\n\n/**\n * To replace all with a node within a parent, run these steps:\n *\n * @param node   New node to insert, or null to remove all nodes under parent\n * @param parent Parent to replace under\n */\nexport function replaceAllWithNode(node: Node | null, parent: Node): void {\n\t// 1. If node is non-null, then adopt node into parent's node document\n\tif (node !== null) {\n\t\tadoptNode(node, getNodeDocument(parent));\n\t}\n\n\t// 2. Let removedNodes be parent’s children.\n\tconst removedNodes = Array.from(parent.childNodes);\n\n\t// 3. Let addedNodes be the empty set.\n\tlet addedNodes: Node[] = [];\n\n\tif (node !== null) {\n\t\t// 4. If node is a DocumentFragment node, then set addedNodes to node's children.\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_FRAGMENT_NODE)) {\n\t\t\tnode.childNodes.forEach((child) => {\n\t\t\t\taddedNodes.push(child);\n\t\t\t});\n\t\t} else {\n\t\t\t// 5. Otherwise, if node is non-null, set addedNodes to « node ».\n\t\t\taddedNodes.push(node);\n\t\t}\n\t}\n\n\t// 6. Remove all parent’s children, in tree order, with the suppress observers flag set.\n\tremovedNodes.forEach((child) => {\n\t\tremoveNode(child, true);\n\t});\n\n\t// 7. If node is non-null, then insert node into parent before null with the suppress observers\n\t// flag set.\n\tif (node !== null) {\n\t\tinsertNode(node, parent, null, true);\n\t}\n\n\t// 8. If either addedNodes or removedNodes is not empty, then queue a tree mutation record for\n\t// parent with addedNodes, removedNodes, null, and null.\n\tif (addedNodes.length > 0 || removedNodes.length > 0) {\n\t\tqueueMutationRecord('childList', parent, {\n\t\t\taddedNodes,\n\t\t\tremovedNodes,\n\t\t});\n\t}\n\n\t// This algorithm does not make any checks with regards to the node tree constraints.\n\t// Specification authors need to use it wisely.\n}\n\n/**\n * To pre-remove a child from a parent, run these steps:\n *\n * @param child  - Child node to remove\n * @param parent - Parent under which to remove child\n *\n * @returns The removed child\n */\nexport function preRemoveChild<TChild extends Node>(child: TChild, parent: Node): TChild {\n\t// 1. If child’s parent is not parent, then throw a NotFoundError.\n\tif (child.parentNode !== parent) {\n\t\tthrowNotFoundError('child is not a child of parent');\n\t}\n\n\t// 2. Remove child.\n\tremoveNode(child);\n\n\t// 3. Return child.\n\treturn child;\n}\n\n/**\n * To remove a node, with an optional suppress observers flag, run these steps:\n *\n * @param node              - Child to remove\n * @param suppressObservers - Whether to skip enqueueing a mutation record for this mutation\n */\nexport function removeNode(node: Node, suppressObservers: boolean = false): void {\n\t// 1. Let parent be node's parent\n\t// 2. Assert: parent is non-null.\n\tconst parent = node.parentNode!;\n\n\t// 3. Let index be node’s index.\n\tconst index = getNodeIndex(node);\n\n\tconst context = getContext(node);\n\tcontext.forEachRange((range) => {\n\t\t// 4. For each live range whose start node is an inclusive descendant of node, set its start\n\t\t// to (parent, index).\n\t\tif (node.contains(range.startContainer)) {\n\t\t\trange.startContainer = parent;\n\t\t\trange.startOffset = index;\n\t\t}\n\n\t\t// 5. For each live range whose end node is an inclusive descendant of node, set its end to\n\t\t// (parent, index).\n\t\tif (node.contains(range.endContainer)) {\n\t\t\trange.endContainer = parent;\n\t\t\trange.endOffset = index;\n\t\t}\n\n\t\t// 6. For each live range whose start node is parent and start offset is greater than index,\n\t\t// decrease its start offset by one.\n\t\tif (range.startContainer === parent && range.startOffset > index) {\n\t\t\trange.startOffset -= 1;\n\t\t}\n\n\t\t// 7. For each live range whose end node is parent and end offset is greater than index,\n\t\t// decrease its end offset by one.\n\t\tif (range.endContainer === parent && range.endOffset > index) {\n\t\t\trange.endOffset -= 1;\n\t\t}\n\t});\n\n\t// 8. For each NodeIterator object iterator whose root’s node document is node’s node document,\n\t// run the NodeIterator pre-removing steps given node and iterator.\n\t// (NodeIterator not implemented)\n\n\t// 9. Let oldPreviousSibling be node’s previous sibling.\n\tconst oldPreviousSibling = node.previousSibling;\n\n\t// 10. Let oldNextSibling be node’s next sibling.\n\tconst oldNextSibling = node.nextSibling;\n\n\t// 11. Remove node from its parent’s children.\n\tremoveFromChildren(node, parent);\n\n\t// 12. If node is assigned, then run assign slottables for node’s assigned slot.\n\t// (shadow dom not implemented)\n\n\t// 13. If parent's root is a shadow root, and parent is a slot whose assigned nodes is the empty\n\t// list, then run signal a slot change for parent.\n\t// (shadow dom not implemented)\n\n\t// 14. If node has an inclusive descendant that is a slot, then:\n\t// 14.1. Run assign slottables for a tree with parent’s tree.\n\t// 14.2. Run assign slottables for a tree with node’s tree.\n\t// (shadow dom not implemented)\n\n\t// 15. Run the removing steps with node and parent.\n\t// (removing steps not implemented)\n\n\t// 16. Let isParentConnected be parent's connected.\n\t// 17. If node is custom and isParentConnected is true, then enqueue a custom element callback\n\t// reaction with node, callback name \"disconnectedCallback\", and an empty argument list.\n\t// It is intentional for now that custom elements do not get parent passed. This might change in\n\t// the future if there is a need.\n\t// (custom elements not implemented)\n\n\t// 18. For each shadow-including descendant descendant of node, in shadow-including tree order,\n\t// then:\n\t// 18.1. Run the removing steps with descendant.\n\t// (shadow dom not implemented)\n\n\t// 18.2. If descendant is custom and isParentConnected is true, then enqueue a custom element\n\t// callback reaction with descendant, callback name \"disconnectedCallback\", and an empty\n\t// argument list.\n\t// (custom elements not implemented)\n\n\t// 19. For each inclusive ancestor inclusiveAncestor of parent, and then for each registered of\n\t// inclusiveAncestor's registered observer list, if registered's options's subtree is true, then\n\t// append a new transient registered observer whose observer is registered's observer, options\n\t// is registered's options, and source is registered to node's registered observer list.\n\tfor (\n\t\tlet inclusiveAncestor: Node | null = parent;\n\t\tinclusiveAncestor;\n\t\tinclusiveAncestor = inclusiveAncestor.parentNode\n\t) {\n\t\tinclusiveAncestor._registeredObservers.appendTransientRegisteredObservers(node);\n\t}\n\n\t// 20. If suppress observers flag is unset, queue a tree mutation record for parent with « »,\n\t// « node », oldPreviousSibling, and oldNextSibling\n\tif (!suppressObservers) {\n\t\tqueueMutationRecord('childList', parent, {\n\t\t\tremovedNodes: [node],\n\t\t\tnextSibling: oldNextSibling,\n\t\t\tpreviousSibling: oldPreviousSibling,\n\t\t});\n\t}\n\n\t// 21. Run the children changed steps for parent\n\t// (children changed steps not implemented)\n}\n\n/**\n * 3.5. Interface Document\n *\n * To adopt a node into a document, with an optional forceDocumentFragmentAdoption, run these steps:\n *\n * (forceDocumentFragmentAdoption is only set to true for HTML template, so is not implemented here)\n *\n * @param node     - Node to adopt\n * @param document - Document to adopt node into\n */\nexport function adoptNode(node: Node, document: Document): void {\n\t// 1. If forceDocumentFragmentAdoption is not given, then set it false.\n\t// (value unused)\n\n\t// 2. Let oldDocument be node’s node document.\n\tconst oldDocument = getNodeDocument(node);\n\n\t// 2. If node’s parent is non-null, remove node.\n\tif (node.parentNode) {\n\t\tremoveNode(node);\n\t}\n\n\t// 3. If document is not oldDocument, then:\n\tif (document === oldDocument) {\n\t\treturn;\n\t}\n\n\t// 3.1. For each inclusiveDescendant in node’s shadow-including inclusive descendants:\n\tforEachInclusiveDescendant(node, (inclusiveDescendant) => {\n\t\t// 3.1.1. If forceDocumentFragmentAdoption is false, inclusiveDescendant is a\n\t\t// DocumentFragment node, inclusiveDescendant is node, and node's host is non-null, then\n\t\t// continue\n\t\t// Note: this is only reasonable as long as all adopt callers remove the children of node.\n\t\t// (shadow dom and HTML templates not implemented)\n\n\t\t// 3.1.2. Set inclusiveDescendant’s node document to document.\n\t\t// (calling code ensures that node is never a Document)\n\t\tinclusiveDescendant.ownerDocument = document;\n\n\t\t// 3.1.3. If inclusiveDescendant is an element, then set the node document of each attribute\n\t\t// in inclusiveDescendant’s attribute list to document.\n\t\tif (isNodeOfType(inclusiveDescendant, NodeType.ELEMENT_NODE)) {\n\t\t\tfor (const attr of (inclusiveDescendant as Element).attributes) {\n\t\t\t\tattr.ownerDocument = document;\n\t\t\t}\n\t\t}\n\t});\n\n\t// 3.2. For each inclusiveDescendant in node’s shadow-including inclusive descendants that is\n\t// custom, enqueue a custom element callback reaction with inclusiveDescendant, callback name\n\t// \"adoptedCallback\", and an argument list containing oldDocument and document.\n\t// (custom element support has not been implemented)\n\n\t// 3.3. For each inclusiveDescendant in node’s shadow-including inclusive descendants, in\n\t// shadow-including tree order, run the adopting steps with inclusiveDescendant and oldDocument.\n\t// (adopting steps not implemented)\n}\n\n/**\n * The descendant text content of a node node is the concatenation of the data of all the Text node\n * descendants of node, in tree order.\n *\n * @param node Root node\n *\n * @returns  The concatenation of data of all the Text node descendants of the given node, in tree\n *           order\n */\nexport function getDescendantTextContent(node: Node): string {\n\tconst data: string[] = [];\n\tforEachInclusiveDescendant(node, (descendant) => {\n\t\t// CDATASection is a subtype of Text\n\t\tif (!isNodeOfType(descendant, NodeType.TEXT_NODE, NodeType.CDATA_SECTION_NODE)) {\n\t\t\treturn;\n\t\t}\n\n\t\tdata.push((descendant as Text).data);\n\t});\n\treturn data.join('');\n}\n\n/**\n * Implementation of the textContent setter for DocumentFragment and Element\n *\n * @param parent    Node for which to set textContent\n * @param newValue  New textContent value\n */\nexport function stringReplaceAll(parent: Node, newValue: string): void {\n\t// 1. Let node be null.\n\tlet node = null;\n\n\t// 2. If the given value is not the empty string, then set node to a new Text node whose data is\n\t// the given value and node document is parent’s node document.\n\tif (newValue !== '') {\n\t\tconst context = getContext(parent);\n\t\tnode = new context.Text(newValue);\n\t}\n\n\t// 3. Replace all with node within the this.\n\treplaceAllWithNode(node, parent);\n}\n\n/**\n * To convert nodes into a node, given nodes and document, run these steps:\n *\n * @param nodes    Nodes and/or strings to convert\n * @param document Document used to create new nodes\n *\n * @returns A single node representing nodes\n */\nfunction convertNodesIntoNode(nodes: (Node | string)[], document: Document): Node {\n\t// 1. Let node be null.\n\t// (created as needed in branches below)\n\n\t// 2. Replace each string in nodes with a new Text node whose data is the string and node\n\t// document is document.\n\tconst actualNodes: Node[] = nodes.map((nodeOrString) => {\n\t\t// IDL actually coerces every non-node (e.g., null) into a string here\n\t\tif (nodeOrString instanceof Node) {\n\t\t\treturn nodeOrString;\n\t\t}\n\t\treturn document.createTextNode(String(nodeOrString));\n\t});\n\n\t// 3. If nodes contains one node, set node to that node.\n\tif (actualNodes.length === 1) {\n\t\treturn actualNodes[0];\n\t} else {\n\t\t// 4. Otherwise, set node to a new DocumentFragment whose node document is document, and then\n\t\t// append each node in nodes, if any, to it.\n\t\tconst node = document.createDocumentFragment();\n\t\tactualNodes.forEach((child) => {\n\t\t\tnode.appendChild(child);\n\t\t});\n\t\treturn node;\n\t}\n\n\t// 5. Return node.\n\t// (done in branches above)\n}\n\n/**\n * The prepend(nodes) method, when invoked, must run these steps:\n *\n * @param thisObject - The ParentNode on which the method is invoked\n * @param nodes      - The nodes (and/or strings) to prepend\n */\nexport function prependNodes(thisObject: Node & ParentNode, nodes: (Node | string)[]): void {\n\t// 1. Let node be the result of converting nodes into a node given nodes and this’s node\n\t// document.\n\tconst node = convertNodesIntoNode(nodes, getNodeDocument(thisObject));\n\n\t// 2. Pre-insert node into this before the this’s first child.\n\tpreInsertNode(node, thisObject, thisObject.firstChild);\n}\n\n/**\n * The append(nodes) method, when invoked, must run these steps:\n *\n * @param thisObject - The ParentNode on which the method is invoked\n * @param nodes      - The nodes (and/or strings) to append\n */\nexport function appendNodes(thisObject: Node & ParentNode, nodes: (Node | string)[]): void {\n\t// 1. Let node be the result of converting nodes into a node given nodes and this’s node\n\t// document.\n\tconst node = convertNodesIntoNode(nodes, getNodeDocument(thisObject));\n\n\t// 2. Append node to this\n\tappendNode(node, thisObject);\n}\n\n/**\n * The replaceChildren(nodes) method, when invoked, must run these steps:\n *\n * @param thisObject - The ParentNode on which the method is invoked\n * @param nodes      - The nodes (and/or strings) to replace the children with\n */\nexport function replaceChildren(thisObject: Node & ParentNode, nodes: (Node | string)[]): void {\n\t// 1. Let node be the result of converting nodes into a node given nodes and this's node\n\t// document.\n\tconst node = convertNodesIntoNode(nodes, getNodeDocument(thisObject));\n\n\t// 2. Ensure pre-insertion validity of node into this before null.\n\tensurePreInsertionValidity(node, thisObject, null);\n\n\t// 3. Replace all with node within this.\n\treplaceAllWithNode(node, thisObject);\n}\n\n/**\n * The before(nodes) method, when invoked, must run these steps:\n *\n * @param thisObject - The ChildNode on which the method is invoked\n * @param nodes        The nodes (and/or strings) to insert\n */\nexport function insertNodesBefore(thisObject: Node & ChildNode, nodes: (Node | string)[]): void {\n\t// 1. Let parent be this’s parent.\n\tconst parent = thisObject.parentNode;\n\n\t// 2. If parent is null, then return.\n\tif (parent === null) {\n\t\treturn;\n\t}\n\n\t// 3. Let viablePreviousSibling be this’s first preceding sibling not in nodes, and\n\t// null otherwise.\n\tlet viablePreviousSibling = thisObject.previousSibling;\n\twhile (viablePreviousSibling !== null && nodes.indexOf(viablePreviousSibling) >= 0) {\n\t\tviablePreviousSibling = viablePreviousSibling.previousSibling;\n\t}\n\n\t// 4. Let node be the result of converting nodes into a node, given nodes and this’s\n\t// node document.\n\tconst node = convertNodesIntoNode(nodes, getNodeDocument(thisObject));\n\n\t// 5. If viablePreviousSibling is null, set it to parent’s first child, and to\n\t// viablePreviousSibling’s next sibling otherwise.\n\t// (it makes more sense to rename this as it will no longer be a previous sibling to the\n\t// inserted nodes)\n\tconst referenceNode =\n\t\tviablePreviousSibling === null ? parent.firstChild : viablePreviousSibling.nextSibling;\n\n\t// 6. Pre-insert node into parent before viablePreviousSibling.\n\tpreInsertNode(node, parent, referenceNode);\n}\n\n/**\n * The after(nodes) method, when invoked, must run these steps:\n *\n * @param thisObject - The ChildNode on which the method is invoked\n * @param nodes      - The nodes (and/or strings) to insert\n */\nexport function insertNodesAfter(thisObject: Node & ChildNode, nodes: (Node | string)[]): void {\n\t// 1. Let parent be this’s parent.\n\tconst parent = thisObject.parentNode;\n\n\t// 2. If parent is null, then return.\n\tif (parent === null) {\n\t\treturn;\n\t}\n\n\t// 3. Let viableNextSibling be this’s first following sibling not in nodes, and null\n\t// otherwise.\n\tlet viableNextSibling = thisObject.nextSibling;\n\twhile (viableNextSibling !== null && nodes.indexOf(viableNextSibling) >= 0) {\n\t\tviableNextSibling = viableNextSibling.nextSibling;\n\t}\n\n\t// 4. Let node be the result of converting nodes into a node, given nodes and this’s\n\t// node document.\n\tconst node = convertNodesIntoNode(nodes, getNodeDocument(thisObject));\n\n\t// 5. Pre-insert node into parent before viableNextSibling.\n\tpreInsertNode(node, parent, viableNextSibling);\n}\n\n/**\n * The replaceWith(nodes) method, when invoked, must run these steps:\n *\n * @param thisObject - The ChildNode on which the method is invoked\n * @param nodes      - The nodes (and/or strings) to insert\n */\nexport function replaceWithNodes(thisObject: Node & ChildNode, nodes: (Node | string)[]): void {\n\t// 1. Let parent be this’s parent.\n\tconst parent = thisObject.parentNode;\n\n\t// 2. If parent is null, then return.\n\tif (parent === null) {\n\t\treturn;\n\t}\n\n\t// 3. Let viableNextSibling be this’s first following sibling not in nodes, and null\n\t// otherwise.\n\tlet viableNextSibling = thisObject.nextSibling;\n\twhile (viableNextSibling !== null && nodes.indexOf(viableNextSibling) >= 0) {\n\t\tviableNextSibling = viableNextSibling.nextSibling;\n\t}\n\n\t// 4. Let node be the result of converting nodes into a node, given nodes and this’s\n\t// node document.\n\tconst node = convertNodesIntoNode(nodes, getNodeDocument(thisObject));\n\n\t// 5. If this’s parent is parent, replace the this with node within parent.\n\t// Note: this could have been inserted into node.\n\tif (thisObject.parentNode === parent) {\n\t\treplaceChildWithNode(thisObject, node, parent);\n\t} else {\n\t\t// 6. Otherwise, pre-insert node into parent before viableNextSibling.\n\t\tpreInsertNode(node, parent, viableNextSibling);\n\t}\n}\n\n/**\n * The remove() method, when invoked, must run these steps:\n *\n * @param thisObject The ChildNode on which the method is invoked\n */\nexport function removeFromParent(thisObject: Node & ChildNode): void {\n\t// 1. If this’s parent is null, then return.\n\tif (thisObject.parentNode === null) {\n\t\treturn;\n\t}\n\n\t// 2. Remove the this.\n\tremoveNode(thisObject);\n}\n\n/**\n * To insert a node node into a live range range, run these steps:\n *\n * @param node  - the node to insert\n * @param range - the live range to insert into\n */\nexport function insertNodeIntoRange(node: Node, range: Range): void {\n\t// 1. If range's start node is a ProcessingInstruction or Comment node, is a Text node whose\n\t// parent is null, or is node, then throw a \"HierarchyRequestError\" DOMException.\n\tconst startContainer = range.startContainer;\n\tif (isNodeOfType(startContainer, NodeType.PROCESSING_INSTRUCTION_NODE)) {\n\t\tthrowHierarchyRequestError('Can not insert into a processing instruction');\n\t}\n\tif (isNodeOfType(startContainer, NodeType.COMMENT_NODE)) {\n\t\tthrowHierarchyRequestError('Can not insert into a comment');\n\t}\n\tif (isTextNode(startContainer) && startContainer.parentNode === null) {\n\t\tthrowHierarchyRequestError('Can not insert into a text node without a parent');\n\t}\n\n\t// 2. Let referenceNode be null.\n\tlet referenceNode: Node | null = null;\n\n\t// 3. If range's start node is a Text node, set referenceNode to that Text node.\n\tif (isTextNode(startContainer)) {\n\t\treferenceNode = startContainer;\n\t} else {\n\t\t// 4. Otherwise, set referenceNode to the child of start node whose index is start offset,\n\t\t// and null if there is no such child.\n\t\treferenceNode = startContainer.childNodes[range.startOffset] || null;\n\t}\n\n\t// 5. Let parent be range's start node if referenceNode is null, and referenceNode's parent\n\t// otherwise.\n\tconst parent = referenceNode === null ? startContainer : referenceNode.parentNode!;\n\n\t// 6. Ensure pre-insertion validity of node into parent before referenceNode.\n\tensurePreInsertionValidity(node, parent, referenceNode);\n\n\t// 7. If range's start node is a Text node, set referenceNode to the result of splitting it with\n\t// offset range's start offset.\n\tif (isTextNode(startContainer)) {\n\t\treferenceNode = startContainer.splitText(range.startOffset);\n\t}\n\n\t// 8. If node is referenceNode, set referenceNode to its next sibling.\n\tif (node === referenceNode) {\n\t\treferenceNode = referenceNode.nextSibling;\n\t}\n\n\t// 9. If node's parent is non-null, then remove node.\n\tif (node.parentNode !== null) {\n\t\tremoveNode(node);\n\t}\n\n\t// 10. Let newOffset be parent's length if referenceNode is null, and referenceNode's index\n\t// otherwise.\n\tlet newOffset =\n\t\treferenceNode === null ? determineLengthOfNode(parent) : getNodeIndex(referenceNode);\n\n\t// 11. Increase newOffset by node's length if node is a DocumentFragment node, and one\n\t// otherwise.\n\tif (isNodeOfType(node, NodeType.DOCUMENT_FRAGMENT_NODE)) {\n\t\tnewOffset += determineLengthOfNode(node);\n\t} else {\n\t\tnewOffset += 1;\n\t}\n\n\t// 12. Pre-insert node into parent before referenceNode.\n\tpreInsertNode(node, parent, referenceNode);\n\n\t// 13. If range is collapsed, then set range’s end to (parent, newOffset).\n\tif (range.collapsed) {\n\t\trange.setEnd(parent, newOffset);\n\t}\n}\n","import { expectObject } from './errorHelpers';\n\nexport function asUnsignedLong(number: number): number {\n\treturn number >>> 0;\n}\n\nexport function legacyNullToEmptyString(value: string | null): string {\n\t// Treat null as empty string\n\tif (value === null) {\n\t\treturn '';\n\t}\n\n\t// Coerce other values to string\n\treturn String(value);\n}\n\nexport function ifNullActAsIfEmptyString(value: string | null | undefined): string {\n\t// Treat both undefined and null as empty string\n\tif (value === undefined || value === null) {\n\t\treturn '';\n\t}\n\n\t// Coerce other values to string\n\treturn String(value);\n}\n\nexport function asObject<T>(value: T, Constructor: any): T {\n\texpectObject(value, Constructor);\n\n\treturn value;\n}\n\nexport function asNullableObject<T>(value: T | null | undefined, Constructor: any): T | null {\n\tif (value === undefined || value === null) {\n\t\treturn null;\n\t}\n\n\treturn asObject(value, Constructor);\n}\n\nexport function asNullableString(value: string | null | undefined): string | null {\n\t// Treat undefined as null\n\tif (value === undefined) {\n\t\treturn null;\n\t}\n\n\treturn value;\n}\n","import Attr from './Attr';\nimport Element from './Element';\nimport Document from './Document';\nimport Text from './Text';\nimport { getContext } from './context/Context';\nimport RegisteredObservers from './mutation-observer/RegisteredObservers';\nimport cloneNode from './util/cloneNode';\nimport { expectArity } from './util/errorHelpers';\nimport {\n\tpreInsertNode,\n\tappendNode,\n\treplaceChildWithNode,\n\tpreRemoveChild,\n\tremoveNode,\n} from './util/mutationAlgorithms';\nimport { NodeType, isNodeOfType, isAttrNode } from './util/NodeType';\nimport {\n\tgetInclusiveAncestors,\n\tgetNodeDocument,\n\tgetNodeIndex,\n\tgetRootOfNode,\n} from './util/treeHelpers';\nimport { asNullableObject, asNullableString, asObject } from './util/typeHelpers';\n\nconst orderKeyByNode = new WeakMap<Node, number>();\n\n/**\n * Get an implementation-dependent integer value that can be used to consistently determine an\n * ordering between unrelated nodes.\n *\n * @param node - The node to compare ordering for\n */\nfunction getOrderKey(node: Node): number {\n\tlet orderKey = orderKeyByNode.get(node);\n\tif (orderKey === undefined) {\n\t\torderKey = Math.random();\n\t\torderKeyByNode.set(node, orderKey);\n\t}\n\treturn orderKey;\n}\n\n/**\n * 3.4. Interface Node\n *\n * @public\n */\nexport default abstract class Node {\n\t// Node types are exposed as properties of the constructor\n\tstatic ELEMENT_NODE: number = NodeType.ELEMENT_NODE;\n\tstatic ATTRIBUTE_NODE: number = NodeType.ATTRIBUTE_NODE;\n\tstatic TEXT_NODE: number = NodeType.TEXT_NODE;\n\tstatic CDATA_SECTION_NODE: number = NodeType.CDATA_SECTION_NODE;\n\tstatic ENTITY_REFERENCE_NODE: number = NodeType.ENTITY_REFERENCE_NODE; // legacy\n\tstatic ENTITY_NODE: number = NodeType.ENTITY_NODE; // legacy\n\tstatic PROCESSING_INSTRUCTION_NODE: number = NodeType.PROCESSING_INSTRUCTION_NODE;\n\tstatic COMMENT_NODE: number = NodeType.COMMENT_NODE;\n\tstatic DOCUMENT_NODE: number = NodeType.DOCUMENT_NODE;\n\tstatic DOCUMENT_TYPE_NODE: number = NodeType.DOCUMENT_TYPE_NODE;\n\tstatic DOCUMENT_FRAGMENT_NODE: number = NodeType.DOCUMENT_FRAGMENT_NODE;\n\tstatic NOTATION_NODE: number = NodeType.NOTATION_NODE; // legacy\n\n\t// Node types also exist as instance properties, assigned to the prototype below\n\tpublic ELEMENT_NODE!: number;\n\tpublic ATTRIBUTE_NODE!: number;\n\tpublic TEXT_NODE!: number;\n\tpublic CDATA_SECTION_NODE!: number;\n\tpublic ENTITY_REFERENCE_NODE!: number; // legacy\n\tpublic ENTITY_NODE!: number; // legacy\n\tpublic PROCESSING_INSTRUCTION_NODE!: number;\n\tpublic COMMENT_NODE!: number;\n\tpublic DOCUMENT_NODE!: number;\n\tpublic DOCUMENT_TYPE_NODE!: number;\n\tpublic DOCUMENT_FRAGMENT_NODE!: number;\n\tpublic NOTATION_NODE!: number; // legacy\n\n\t/**\n\t * Returns the type of node, represented by a number.\n\t */\n\tpublic abstract get nodeType(): number;\n\n\t/**\n\t * Returns a string appropriate for the type of node.\n\t */\n\tpublic abstract get nodeName(): string;\n\n\t/**\n\t * A reference to the Document node in which the current node resides.\n\t */\n\tpublic ownerDocument: Document | null = null;\n\n\t/**\n\t * The parent node of the current node.\n\t */\n\tpublic parentNode: Node | null = null;\n\n\t/**\n\t * The parent if it is an element, or null otherwise.\n\t */\n\tpublic get parentElement(): Element | null {\n\t\treturn this.parentNode && isNodeOfType(this.parentNode, NodeType.ELEMENT_NODE)\n\t\t\t? (this.parentNode as Element)\n\t\t\t: null;\n\t}\n\n\t/**\n\t * Returns true if this has children, and false otherwise.\n\t */\n\tpublic hasChildNodes(): boolean {\n\t\treturn !!this.childNodes.length;\n\t}\n\n\t/**\n\t * The node's children.\n\t *\n\t * Non-standard: implemented as an array rather than a NodeList.\n\t */\n\tpublic childNodes: Node[] = [];\n\n\t/**\n\t * The first child node of the current node, or null if it has no children.\n\t */\n\tpublic firstChild: Node | null = null;\n\n\t/**\n\t * The last child node of the current node, or null if it has no children.\n\t */\n\tpublic lastChild: Node | null = null;\n\n\t/**\n\t * The first preceding sibling of the current node, or null if it has none.\n\t */\n\tpublic previousSibling: Node | null = null;\n\n\t/**\n\t * The first following sibling of the current node, or null if it has none.\n\t */\n\tpublic nextSibling: Node | null = null;\n\n\t/**\n\t * The value of the node.\n\t */\n\tpublic abstract get nodeValue(): string | null;\n\tpublic abstract set nodeValue(value: string | null);\n\n\t/**\n\t * The textContent of the node.\n\t */\n\tpublic abstract get textContent(): string | null;\n\tpublic abstract set textContent(value: string | null);\n\n\t/**\n\t * (non-standard)\n\t * Each node has a registered observer list of zero or more registered observers, which is\n\t * initially empty.\n\t */\n\tpublic _registeredObservers: RegisteredObservers = new RegisteredObservers(this);\n\n\t/**\n\t * Puts the specified node and all of its subtree into a \"normalized\" form. In a normalized\n\t * subtree, no text nodes in the subtree are empty and there are no adjacent text nodes.\n\t */\n\tpublic normalize(): void {\n\t\t// for each descendant exclusive Text node node of this:\n\t\tlet node = this.firstChild;\n\t\tlet index = 0;\n\t\tconst document = getNodeDocument(this);\n\t\twhile (node) {\n\t\t\tlet nextNode = node.nextSibling;\n\t\t\tif (!isNodeOfType(node, NodeType.TEXT_NODE)) {\n\t\t\t\t// Process descendants\n\t\t\t\tnode.normalize();\n\t\t\t\tnode = nextNode;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst textNode = node as Text;\n\t\t\t// 1. Let length be node’s length.\n\t\t\tlet length = textNode.length;\n\n\t\t\t// 2. If length is zero, then remove node and continue with the next exclusive Text\n\t\t\t// node, if any.\n\t\t\tif (length === 0) {\n\t\t\t\tremoveNode(node);\n\t\t\t\t--index;\n\t\t\t\tnode = nextNode;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// 3. Let data be the concatenation of the data of node’s contiguous exclusive Text\n\t\t\t// nodes (excluding itself), in tree order.\n\t\t\tlet data = '';\n\t\t\tconst siblingsToRemove = [];\n\t\t\tfor (\n\t\t\t\tlet sibling = textNode.nextSibling;\n\t\t\t\tsibling && isNodeOfType(sibling, NodeType.TEXT_NODE);\n\t\t\t\tsibling = sibling.nextSibling\n\t\t\t) {\n\t\t\t\tdata += (sibling as Text).data;\n\t\t\t\tsiblingsToRemove.push(sibling);\n\t\t\t}\n\n\t\t\t// 4. Replace data with node node, offset length, count 0, and data data.\n\t\t\tif (data) {\n\t\t\t\ttextNode.replaceData(length, 0, data);\n\t\t\t}\n\n\t\t\t// 5. Let currentNode be node’s next sibling.\n\t\t\t// 6. While currentNode is an exclusive Text node:\n\t\t\tconst context = getContext(this);\n\t\t\tfor (let i = 0, l = siblingsToRemove.length; i < l; ++i) {\n\t\t\t\tconst currentNode = siblingsToRemove[i];\n\t\t\t\tconst currentNodeIndex = index + i + 1;\n\n\t\t\t\tcontext.forEachRange((range) => {\n\t\t\t\t\t// 6.1. For each live range whose start node is currentNode, add length to its\n\t\t\t\t\t// start offset and set its start node to node.\n\t\t\t\t\tif (range.startContainer === currentNode) {\n\t\t\t\t\t\trange.startOffset += length;\n\t\t\t\t\t\trange.startContainer = textNode;\n\t\t\t\t\t}\n\n\t\t\t\t\t// 6.2. For each live range whose end node is currentNode, add length to its end\n\t\t\t\t\t// offset and set its end node to node.\n\t\t\t\t\tif (range.endContainer === currentNode) {\n\t\t\t\t\t\trange.endOffset += length;\n\t\t\t\t\t\trange.endContainer = textNode;\n\t\t\t\t\t}\n\n\t\t\t\t\t// 6.3. For each live range whose start node is currentNode’s parent and start\n\t\t\t\t\t// offset is currentNode’s index, set its start node to node and its start\n\t\t\t\t\t// offset to length.\n\t\t\t\t\tif (range.startContainer === this && range.startOffset === currentNodeIndex) {\n\t\t\t\t\t\trange.startContainer = textNode;\n\t\t\t\t\t\trange.startOffset = length;\n\t\t\t\t\t}\n\n\t\t\t\t\t// 6.4. For each live range whose end node is currentNode’s parent and end\n\t\t\t\t\t// offset is currentNode’s index, set its end node to node and its end offset to\n\t\t\t\t\t// length.\n\t\t\t\t\tif (range.endContainer === this && range.endOffset === currentNodeIndex) {\n\t\t\t\t\t\trange.endContainer = textNode;\n\t\t\t\t\t\trange.endOffset = length;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// 6.5. Add currentNode’s length to length.\n\t\t\t\tlength += (currentNode as Text).length;\n\n\t\t\t\t// 6.6. Set currentNode to its next sibling.\n\t\t\t\t// (see for-loop increment)\n\t\t\t}\n\n\t\t\t// 7. Remove node’s contiguous exclusive Text nodes (excluding itself), in tree order.\n\t\t\twhile (siblingsToRemove.length) {\n\t\t\t\tremoveNode(siblingsToRemove.shift() as Node);\n\t\t\t}\n\n\t\t\t// Move to next node\n\t\t\tnode = node.nextSibling;\n\t\t\t++index;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a copy of the current node.\n\t *\n\t * @param deep - Whether to also clone the node's descendants\n\t *\n\t * @returns A copy of the current node\n\t */\n\tpublic cloneNode(deep: boolean = false): this {\n\t\treturn cloneNode(this, deep);\n\t}\n\n\tstatic DOCUMENT_POSITION_DISCONNECTED = 0x1;\n\tstatic DOCUMENT_POSITION_PRECEDING = 0x2;\n\tstatic DOCUMENT_POSITION_FOLLOWING = 0x4;\n\tstatic DOCUMENT_POSITION_CONTAINS = 0x8;\n\tstatic DOCUMENT_POSITION_CONTAINED_BY = 0x10;\n\tstatic DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;\n\n\t/**\n\t * Compare the position of this node with the given one.\n\t *\n\t * @param other - Node to compare with\n\t *\n\t * @returns a combination of the DOCUMENT_POSITION_* flags\n\t */\n\tpublic compareDocumentPosition(other: Node): number {\n\t\texpectArity(arguments, 1);\n\t\tother = asObject(other, Node);\n\n\t\t// 1. If this is other, then return zero.\n\t\tif (this === other) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// 2. Let node1 be other and node2 be this.\n\t\tlet node1: Node | null = other;\n\t\tlet node2: Node | null = this;\n\n\t\t// 3. Let attr1 and attr2 be null.\n\t\tlet attr1: Attr | null = null;\n\t\tlet attr2: Attr | null = null;\n\n\t\t// 4. If node1 is an attribute, then set attr1 to node1 and node1 to attr1's element.\n\t\tif (isAttrNode(node1)) {\n\t\t\tattr1 = node1;\n\t\t\tnode1 = attr1.ownerElement;\n\t\t}\n\n\t\t// 5. If node2 is an attribute, then:\n\t\tif (isAttrNode(node2)) {\n\t\t\t// 5.1. Set attr2 to node2 and node2 to attr2's element.\n\t\t\tattr2 = node2;\n\t\t\tnode2 = attr2.ownerElement;\n\n\t\t\t// 5.2. If attr1 and node1 are non-null, and node2 is node1, then:\n\t\t\tif (attr1 !== null && node1 !== null && node2 === node1) {\n\t\t\t\t// 5.2.1. For each attr in node2’s attribute list:\n\t\t\t\tfor (const attr of (node2 as Element).attributes) {\n\t\t\t\t\t// 5.2.1.1. If attr equals attr1, then return the result of adding\n\t\t\t\t\t// DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC and DOCUMENT_POSITION_PRECEDING.\n\t\t\t\t\tif (attr === attr1) {\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\tNode.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |\n\t\t\t\t\t\t\tNode.DOCUMENT_POSITION_PRECEDING\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\t// 5.2.1.2. If attr equals attr2, then return the result of adding\n\t\t\t\t\t// DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC and DOCUMENT_POSITION_FOLLOWING.\n\t\t\t\t\tif (attr === attr2) {\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\tNode.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |\n\t\t\t\t\t\t\tNode.DOCUMENT_POSITION_FOLLOWING\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 6. If node1 or node2 is null, or node1's root is not node2's root, then return the result\n\t\t// of adding DOCUMENT_POSITION_DISCONNECTED, DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and\n\t\t// either DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING, with the constraint\n\t\t// that this is to be consistent, together.\n\t\t// Note: Whether to return DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING is\n\t\t// typically implemented via pointer comparison. In JavaScript implementations a cached\n\t\t// Math.random() value can be used.\n\t\tif (node1 === null || node2 === null) {\n\t\t\treturn (\n\t\t\t\tNode.DOCUMENT_POSITION_DISCONNECTED |\n\t\t\t\tNode.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |\n\t\t\t\t(getOrderKey(node1 || attr1!) > getOrderKey(node2 || attr2!)\n\t\t\t\t\t? Node.DOCUMENT_POSITION_FOLLOWING\n\t\t\t\t\t: Node.DOCUMENT_POSITION_PRECEDING)\n\t\t\t);\n\t\t}\n\t\tconst ancestors1 = getInclusiveAncestors(node1);\n\t\tconst ancestors2 = getInclusiveAncestors(node2);\n\t\tif (ancestors1[0] !== ancestors2[0]) {\n\t\t\treturn (\n\t\t\t\tNode.DOCUMENT_POSITION_DISCONNECTED |\n\t\t\t\tNode.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |\n\t\t\t\t(getOrderKey(ancestors1[0]) > getOrderKey(ancestors2[0])\n\t\t\t\t\t? Node.DOCUMENT_POSITION_FOLLOWING\n\t\t\t\t\t: Node.DOCUMENT_POSITION_PRECEDING)\n\t\t\t);\n\t\t}\n\n\t\t// 7. If node1 is an ancestor of node2 and attr1 is null, or node1 is node2 and attr2 is\n\t\t// non-null, then return the result of adding DOCUMENT_POSITION_CONTAINS to\n\t\t// DOCUMENT_POSITION_PRECEDING.\n\t\tlet firstDistinctAncestorIndex = 0;\n\t\twhile (\n\t\t\tfirstDistinctAncestorIndex < ancestors1.length &&\n\t\t\tfirstDistinctAncestorIndex < ancestors2.length\n\t\t) {\n\t\t\tif (ancestors1[firstDistinctAncestorIndex] !== ancestors2[firstDistinctAncestorIndex]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++firstDistinctAncestorIndex;\n\t\t}\n\t\tconst node1ContainsNode2 =\n\t\t\tnode1 !== node2 && firstDistinctAncestorIndex === ancestors1.length;\n\t\tconst node2ContainsNode1 =\n\t\t\tnode1 !== node2 && firstDistinctAncestorIndex === ancestors2.length;\n\t\tif ((node1ContainsNode2 && attr1 === null) || (node1 === node2 && attr2 !== null)) {\n\t\t\treturn Node.DOCUMENT_POSITION_CONTAINS | Node.DOCUMENT_POSITION_PRECEDING;\n\t\t}\n\n\t\t// 8. If node1 is a descendant of node2 and attr2 is null, or node1 is node2 and attr1 is\n\t\t// non-null, then return the result of adding DOCUMENT_POSITION_CONTAINED_BY to\n\t\t// DOCUMENT_POSITION_FOLLOWING.\n\t\tif ((node2ContainsNode1 && attr2 === null) || (node1 === node2 && attr1 !== null)) {\n\t\t\treturn Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_FOLLOWING;\n\t\t}\n\n\t\t// 9. If node1 is preceding node2, then return DOCUMENT_POSITION_PRECEDING.\n\t\t// Note: Due to the way attributes are handled in this algorithm this results in a node's\n\t\t// attributes counting as preceding that node's children, despite attributes not\n\t\t// participating in the same tree.\n\t\tif (\n\t\t\tnode1ContainsNode2 ||\n\t\t\tgetNodeIndex(ancestors1[firstDistinctAncestorIndex]) <\n\t\t\t\tgetNodeIndex(ancestors2[firstDistinctAncestorIndex])\n\t\t) {\n\t\t\treturn Node.DOCUMENT_POSITION_PRECEDING;\n\t\t}\n\n\t\t// 10. Return DOCUMENT_POSITION_FOLLOWING.\n\t\treturn Node.DOCUMENT_POSITION_FOLLOWING;\n\t}\n\n\t/**\n\t * Returns true if other is an inclusive descendant of this, and false otherwise\n\t * (including when other is null).\n\t *\n\t * @param childNode - Node to check\n\t *\n\t * @returns Whether childNode is an inclusive descendant of the current node\n\t */\n\tpublic contains(other: Node | null): boolean {\n\t\texpectArity(arguments, 1);\n\t\tother = asNullableObject(other, Node);\n\n\t\twhile (other && other != this) {\n\t\t\tother = other.parentNode;\n\t\t}\n\t\treturn other === this;\n\t}\n\n\t/**\n\t *\n\t *\n\t * @param namespace - The namespace to look up\n\t *\n\t * @returns The prefix for the given namespace, or null if none was found\n\t */\n\tpublic abstract lookupPrefix(namespace: string | null): string | null;\n\n\t/**\n\t * Returns the namespace for the given prefix.\n\t *\n\t * @param prefix - The prefix to look up\n\t *\n\t * @returns The namespace for the given prefix, or null if the prefix is not defined\n\t */\n\tpublic abstract lookupNamespaceURI(prefix: string | null): string | null;\n\n\t/**\n\t * Return true if defaultNamespace is the same as namespace, and false otherwise.\n\t *\n\t * @param namespace - The namespace to check\n\t *\n\t * @returns Whether namespace is the default namespace\n\t */\n\tpublic isDefaultNamespace(namespace: string | null): boolean {\n\t\texpectArity(arguments, 1);\n\t\tnamespace = asNullableString(namespace);\n\n\t\t// 1. If namespace is the empty string, then set it to null.\n\t\tif (namespace === '') {\n\t\t\tnamespace = null;\n\t\t}\n\n\t\t// 2. Let defaultNamespace be the result of running locate a namespace for this\n\t\t// using null.\n\t\tconst defaultNamespace = this.lookupNamespaceURI(null);\n\n\t\t// 3. Return true if defaultNamespace is the same as namespace, and false otherwise.\n\t\treturn defaultNamespace === namespace;\n\t}\n\n\t/**\n\t * Inserts the specified node before child within this.\n\t *\n\t * If child is null, the new node is appended after the last child node of the current node.\n\t *\n\t * @param node  - Node to insert\n\t * @param child - Childnode of the current node before which to insert, or null to append\n\t *                newNode at the end\n\t *\n\t * @returns The node that was inserted\n\t */\n\tpublic insertBefore<TNode extends Node>(node: TNode, child: Node | null): TNode {\n\t\texpectArity(arguments, 2);\n\t\tnode = asObject(node, Node);\n\t\tchild = asNullableObject(child, Node);\n\n\t\treturn preInsertNode(node, this, child);\n\t}\n\n\t/**\n\t * Adds node to the end of the list of children of this.\n\t *\n\t * If the node already exists it is removed from its current parent node, then added.\n\t *\n\t * @param node - Node to append\n\t *\n\t * @returns The node that was inserted\n\t */\n\tpublic appendChild<TNode extends Node>(node: TNode): TNode {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\treturn appendNode(node, this);\n\t}\n\n\t/**\n\t * Replaces child with node within this and returns child.\n\t *\n\t * @param node  - Node to insert\n\t * @param child - Node to remove\n\t *\n\t * @returns The node that was removed\n\t */\n\tpublic replaceChild<TChild extends Node>(node: Node, child: TChild): TChild {\n\t\texpectArity(arguments, 2);\n\t\tnode = asObject(node, Node);\n\t\tchild = asObject(child, Node);\n\n\t\treturn replaceChildWithNode(child, node, this);\n\t}\n\n\t/**\n\t * Removes child from this and returns the removed node.\n\t *\n\t * @param child - Child of the current node to remove\n\t *\n\t * @returns The node that was removed\n\t */\n\tpublic removeChild<TChild extends Node>(child: TChild): TChild {\n\t\texpectArity(arguments, 1);\n\t\tchild = asObject(child, Node);\n\n\t\treturn preRemoveChild(child, this);\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic abstract _copy(document: Document): Node;\n}\n\nNode.prototype.ELEMENT_NODE = NodeType.ELEMENT_NODE;\nNode.prototype.ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE;\nNode.prototype.TEXT_NODE = NodeType.TEXT_NODE;\nNode.prototype.CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE;\nNode.prototype.ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE; // legacy\nNode.prototype.ENTITY_NODE = NodeType.ENTITY_NODE; // legacy\nNode.prototype.PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE;\nNode.prototype.COMMENT_NODE = NodeType.COMMENT_NODE;\nNode.prototype.DOCUMENT_NODE = NodeType.DOCUMENT_NODE;\nNode.prototype.DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE;\nNode.prototype.DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE;\nNode.prototype.NOTATION_NODE = NodeType.NOTATION_NODE; // legacy\n","import Attr from '../Attr';\nimport Element from '../Element';\nimport queueMutationRecord from '../mutation-observer/queueMutationRecord';\n\n/**\n * To handle attribute changes for an attribute attribute with element, oldValue, and newValue, run\n * these steps:\n *\n * @param attribute - The attribute that is being changed\n * @param element   - The element that has the attribute\n * @param oldValue  - The old value for the attribute\n * @param newValue  - The new value for the attribute\n */\nexport function handleAttributeChanges(\n\tattribute: Attr,\n\telement: Element,\n\toldValue: string | null,\n\tnewValue: string | null\n): void {\n\t// 1. Queue a mutation record of \"attributes\" for element with attribute’s local name,\n\t// attribute's namespace, oldValue, « », « », null, and null.\n\tqueueMutationRecord('attributes', element, {\n\t\tname: attribute.localName,\n\t\tnamespace: attribute.namespaceURI,\n\t\toldValue,\n\t});\n\n\t// 2. If element is custom, then enqueue a custom element callback reaction with element,\n\t// callback name \"attributeChangedCallback\", and an argument list containing attribute’s local\n\t// name, attribute’s value, value, and attribute’s namespace.\n\t// (custom elements not implemented)\n\n\t// 3. Run the attribute change steps with element, attribute’s local name, oldValue, newValue,\n\t// and attribute’s namespace.\n\t// (attribute change steps not implemented)\n}\n\n/**\n * To change an attribute attribute to value, run these steps:\n *\n * @param attribute - The attribute to change\n * @param value     - The new value for the attribute\n */\nexport function changeAttribute(attribute: Attr, value: string): void {\n\t// 1. Handle attribute changes for attribute with attribute’s element, attribute’s value, and\n\t// value.\n\thandleAttributeChanges(attribute, attribute.ownerElement!, attribute.value, value);\n\n\t// 2. Set attribute’s value to value.\n\t(attribute as any)._value = value;\n}\n\n/**\n * To append an attribute attribute to an element element, run these steps:\n *\n * @param attribute         - The attribute to append\n * @param element           - The element to append attribute to\n * @param suppressObservers - Set to true to not queue a mutation observer event for this change\n */\nexport function appendAttribute(\n\tattribute: Attr,\n\telement: Element,\n\tsuppressObservers: boolean = false\n): void {\n\t// 1. Handle attribute changes for attribute with element, null and attribute's value.\n\tif (!suppressObservers) {\n\t\thandleAttributeChanges(attribute, element, null, attribute.value);\n\t}\n\n\t// 2. Append attribute to element’s attribute list.\n\telement.attributes.push(attribute);\n\n\t// 3. Set attribute’s element to element.\n\tattribute.ownerElement = element;\n}\n\n/**\n * To remove an attribute attribute, run these steps:\n *\n * @param attribute - The attribute to remove\n */\nexport function removeAttribute(attribute: Attr): void {\n\tconst attributeElement = attribute.ownerElement!;\n\t// 1. Handle attribute changes for attribute with attribute’s element, attribute’s value, and\n\t// null.\n\thandleAttributeChanges(attribute, attributeElement, attribute.value, null);\n\n\t// 2. Remove attribute from attribute's element’s attribute list.\n\tattributeElement.attributes.splice(attributeElement.attributes.indexOf(attribute), 1);\n\n\t// 3. Set attribute’s element to null.\n\tattribute.ownerElement = null;\n}\n\n/**\n * To replace an attribute oldAttr with an attribute newAttr, run these steps:\n *\n * @param oldAttr - The attribute to replace\n * @param newAttr - The attribute to replace oldAttr with\n */\nexport function replaceAttribute(oldAttr: Attr, newAttr: Attr): void {\n\tconst oldAttrElement = oldAttr.ownerElement!;\n\t// 1. Handle attribute changes for oldAttr with oldAttr’s element, oldAttr’s value,\n\t// and newAttr’s value.\n\thandleAttributeChanges(oldAttr, oldAttrElement, oldAttr.value, newAttr.value);\n\n\t// 4. Replace oldAttr by newAttr in element’s attribute list.\n\toldAttrElement.attributes.splice(oldAttrElement.attributes.indexOf(oldAttr), 1, newAttr);\n\n\t// 5. Set newAttr’s element to oldAttr's element.\n\tnewAttr.ownerElement = oldAttrElement;\n\n\t// 6. Set oldAttr’s element to null.\n\toldAttr.ownerElement = null;\n}\n","import Document from './Document';\nimport Element from './Element';\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport { changeAttribute } from './util/attrMutations';\nimport { expectArity } from './util/errorHelpers';\nimport { NodeType } from './util/NodeType';\nimport { ifNullActAsIfEmptyString } from './util/typeHelpers';\n\n/**\n * 3.9.2. Interface Attr\n *\n * @public\n */\nexport default class Attr extends Node {\n\t// Node\n\n\tpublic get nodeType(): number {\n\t\treturn NodeType.ATTRIBUTE_NODE;\n\t}\n\n\tpublic get nodeName(): string {\n\t\t// Return the qualified name\n\t\treturn this.name;\n\t}\n\n\tpublic get nodeValue(): string | null {\n\t\treturn this._value;\n\t}\n\n\tpublic set nodeValue(newValue: string | null) {\n\t\tnewValue = ifNullActAsIfEmptyString(newValue);\n\n\t\t// Set an existing attribute value with this and new value.\n\t\tsetExistingAttributeValue(this, newValue);\n\t}\n\n\tpublic get textContent(): string | null {\n\t\treturn this._value;\n\t}\n\n\tpublic set textContent(newValue: string | null) {\n\t\tnewValue = ifNullActAsIfEmptyString(newValue);\n\n\t\t// Set an existing attribute value with this and new value.\n\t\tsetExistingAttributeValue(this, newValue);\n\t}\n\n\tpublic lookupPrefix(namespace: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If namespace is null or the empty string, then return null.\n\t\t// (not necessary due to recursion)\n\n\t\t// 2. Switch on this:\n\t\t// Attr - Return the result of locating a namespace prefix for its element, if its element\n\t\t// is non-null, and null otherwise.\n\t\tif (this.ownerElement !== null) {\n\t\t\treturn this.ownerElement.lookupPrefix(namespace);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic lookupNamespaceURI(prefix: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If prefix is the empty string, then set it to null.\n\t\t// (not necessary due to recursion)\n\n\t\t// 2. Return the result of running locate a namespace for this using prefix.\n\n\t\t// To locate a namespace for a node using prefix, switch on node: Attr\n\t\t// 1. If its element is null, then return null.\n\t\tif (this.ownerElement === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// 2. Return the result of running locate a namespace on its element using prefix.\n\t\treturn this.ownerElement.lookupNamespaceURI(prefix);\n\t}\n\n\t// Attr\n\n\tpublic readonly namespaceURI: string | null;\n\tpublic readonly prefix: string | null;\n\tpublic readonly localName: string;\n\tpublic readonly name: string;\n\n\tprivate _value: string;\n\n\tpublic get value(): string {\n\t\treturn this._value;\n\t}\n\n\tpublic set value(value: string) {\n\t\tsetExistingAttributeValue(this, value);\n\t}\n\n\tpublic ownerElement: Element | null;\n\n\t/**\n\t * (non-standard) use Document#createAttribute(NS) or Element#setAttribute(NS) to create\n\t * attribute nodes\n\t *\n\t * @param namespace - The namespace URI for the attribute\n\t * @param prefix    - The prefix for the attribute\n\t * @param localName - The local name for the attribute\n\t * @param value     - The value for the attribute\n\t * @param element   - The element for the attribute, or null if the attribute is not attached to\n\t *                    an element\n\t */\n\tconstructor(\n\t\tnamespace: string | null,\n\t\tprefix: string | null,\n\t\tlocalName: string,\n\t\tvalue: string,\n\t\telement: Element | null\n\t) {\n\t\tsuper();\n\n\t\tthis.namespaceURI = namespace;\n\t\tthis.prefix = prefix;\n\t\tthis.localName = localName;\n\t\tthis.name = prefix === null ? localName : `${prefix}:${localName}`;\n\t\tthis._value = value;\n\t\tthis.ownerElement = element;\n\t\tthis.ownerDocument = element ? element.ownerDocument : getContext(this).document;\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic _copy(document: Document): Attr {\n\t\t// Set copy’s namespace, namespace prefix, local name, and value, to those of node.\n\t\tconst context = getContext(document);\n\t\tconst copy = new context.Attr(\n\t\t\tthis.namespaceURI,\n\t\t\tthis.prefix,\n\t\t\tthis.localName,\n\t\t\tthis.value,\n\t\t\tnull\n\t\t);\n\t\tcopy.ownerDocument = document;\n\t\treturn copy;\n\t}\n}\n\n/**\n * To set an existing attribute value, given an attribute attribute and string value, run these\n * steps:\n *\n * @param attribute - The attribute to set the value of\n * @param value     - The new value for attribute\n */\nfunction setExistingAttributeValue(attribute: Attr, value: string) {\n\tvalue = String(value);\n\n\t// 1. If attribute’s element is null, then set attribute’s value to value.\n\tconst element = attribute.ownerElement;\n\tif (element === null) {\n\t\t(attribute as any)._value = value;\n\t} else {\n\t\t// 2. Otherwise, change attribute to value.\n\t\tchangeAttribute(attribute, value);\n\t}\n}\n","import {\n\tNonDocumentTypeChildNode,\n\tChildNode,\n\tgetNextElementSibling,\n\tgetPreviousElementSibling,\n} from './mixins';\nimport Element from './Element';\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport queueMutationRecord from './mutation-observer/queueMutationRecord';\nimport { expectArity, throwIndexSizeError } from './util/errorHelpers';\nimport {\n\tasUnsignedLong,\n\tifNullActAsIfEmptyString,\n\tlegacyNullToEmptyString,\n} from './util/typeHelpers';\nimport {\n\tinsertNodesBefore,\n\tinsertNodesAfter,\n\treplaceWithNodes,\n\tremoveFromParent,\n} from './util/mutationAlgorithms';\n\n/**\n * 3.10. Interface CharacterData\n *\n * @public\n */\nexport default abstract class CharacterData\n\textends Node\n\timplements NonDocumentTypeChildNode, ChildNode\n{\n\t// Node\n\n\tpublic get nodeValue(): string | null {\n\t\treturn this._data;\n\t}\n\n\tpublic set nodeValue(newValue: string | null) {\n\t\tnewValue = ifNullActAsIfEmptyString(newValue);\n\n\t\t// Set an existing attribute value with this and new value.\n\t\treplaceData(this, 0, this.length, newValue);\n\t}\n\n\tpublic get textContent(): string | null {\n\t\treturn this._data;\n\t}\n\n\tpublic set textContent(newValue: string | null) {\n\t\tnewValue = ifNullActAsIfEmptyString(newValue);\n\n\t\t// Set an existing attribute value with this and new value.\n\t\treplaceData(this, 0, this.length, newValue);\n\t}\n\n\tpublic lookupPrefix(namespace: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If namespace is null or the empty string, then return null.\n\t\t// (not necessary due to recursion)\n\n\t\t// 2. Switch on this:\n\t\t// Any other node - Return the result of locating a namespace prefix for its parent element,\n\t\t// if its parent element is non-null, and null otherwise.\n\t\tconst parentElement = this.parentElement;\n\t\tif (parentElement !== null) {\n\t\t\treturn parentElement.lookupPrefix(namespace);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic lookupNamespaceURI(prefix: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If prefix is the empty string, then set it to null.\n\t\t// (not necessary due to recursion)\n\n\t\t// 2. Return the result of running locate a namespace for this using prefix.\n\n\t\t// To locate a namespace for a node using prefix, switch on node: Any other node\n\t\t// 1. If its parent element is null, then return null.\n\t\tconst parentElement = this.parentElement;\n\t\tif (parentElement === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// 2. Return the result of running locate a namespace on its parent element using prefix.\n\t\treturn parentElement.lookupNamespaceURI(prefix);\n\t}\n\n\t// ChildNode\n\n\tpublic before(...nodes: (Node | string)[]): void {\n\t\tinsertNodesBefore(this, nodes);\n\t}\n\n\tpublic after(...nodes: (Node | string)[]): void {\n\t\tinsertNodesAfter(this, nodes);\n\t}\n\n\tpublic replaceWith(...nodes: (Node | string)[]): void {\n\t\treplaceWithNodes(this, nodes);\n\t}\n\n\tpublic remove(): void {\n\t\tremoveFromParent(this);\n\t}\n\n\t// NonDocumentTypeChildNode\n\n\tpublic get previousElementSibling(): Element | null {\n\t\treturn getPreviousElementSibling(this);\n\t}\n\n\tpublic get nextElementSibling(): Element | null {\n\t\treturn getNextElementSibling(this);\n\t}\n\n\t// CharacterData\n\n\t/**\n\t * Each node inheriting from the CharacterData interface has an associated mutable string called\n\t * data.\n\t */\n\tprotected _data: string;\n\n\tpublic get data(): string {\n\t\treturn this._data;\n\t}\n\n\tpublic set data(newValue: string) {\n\t\t// [LegacyNullToEmptyString]\n\t\tnewValue = legacyNullToEmptyString(newValue);\n\n\t\t// replace data with node this, offset 0, count this’s length, and data\n\t\t// new value.\n\t\treplaceData(this, 0, this.length, newValue);\n\t}\n\n\tpublic get length(): number {\n\t\treturn this.data.length;\n\t}\n\n\t/**\n\t * (non-standard) CharacterData should never be instantiated directly.\n\t *\n\t * @param data - The data to associate with the node\n\t */\n\tprotected constructor(data: string) {\n\t\tsuper();\n\t\tthis._data = String(data);\n\t}\n\n\t/**\n\t * Returns a substring of the node's data.\n\t *\n\t * @param offset - Offset at which to start the substring\n\t * @param count  - The number of code units to return\n\t *\n\t * @returns The specified substring\n\t */\n\tpublic substringData(offset: number, count: number): string {\n\t\texpectArity(arguments, 2);\n\t\treturn substringData(this, offset, count);\n\t}\n\n\t/**\n\t * Appends data to the node's data.\n\t *\n\t * @param data - Data to append\n\t */\n\tpublic appendData(data: string): void {\n\t\texpectArity(arguments, 1);\n\t\treplaceData(this, this.length, 0, data);\n\t}\n\n\t/**\n\t * Inserts data at the specified position in the node's data.\n\t *\n\t * @param offset - Offset at which to insert\n\t * @param data   - Data to insert\n\t */\n\tpublic insertData(offset: number, data: string): void {\n\t\texpectArity(arguments, 1);\n\t\treplaceData(this, offset, 0, data);\n\t}\n\n\t/**\n\t * Deletes data from the specified position.\n\t *\n\t * @param offset - Offset at which to delete\n\t * @param count  - Number of code units to delete\n\t */\n\tpublic deleteData(offset: number, count: number): void {\n\t\texpectArity(arguments, 2);\n\t\treplaceData(this, offset, count, '');\n\t}\n\n\t/**\n\t * Replaces data at the specified position.\n\t *\n\t * @param offset - Offset at which to replace\n\t * @param count  - Number of code units to remove\n\t * @param data   - Data to insert\n\t */\n\tpublic replaceData(offset: number, count: number, data: string): void {\n\t\texpectArity(arguments, 3);\n\t\treplaceData(this, offset, count, data);\n\t}\n}\n\n/**\n * To replace data of node node with offset offset, count count, and data data, run these steps:\n *\n * @param node   - The node to replace data on\n * @param offset - The offset at which to start replacing\n * @param count  - The number of code units to replace\n * @param data   - The data to insert in place of the removed data\n */\nexport function replaceData(\n\tnode: CharacterData,\n\toffset: number,\n\tcount: number,\n\tdata: string\n): void {\n\t// Match spec data types\n\toffset = asUnsignedLong(offset);\n\tcount = asUnsignedLong(count);\n\n\t// 1. Let length be node’s length.\n\tconst length = node.length;\n\n\t// 2. If offset is greater than length, then throw an IndexSizeError.\n\tif (offset > length) {\n\t\tthrowIndexSizeError(\"can not replace data past the node's length\");\n\t}\n\n\t// 3. If offset plus count is greater than length, then set count to length minus offset.\n\tif (offset + count > length) {\n\t\tcount = length - offset;\n\t}\n\n\t// 4. Queue a mutation record of \"characterData\" for node with null, null, node's data, « »,\n\t// « », null, and null.\n\tqueueMutationRecord('characterData', node, {\n\t\toldValue: node.data,\n\t});\n\n\t// 5. Insert data into node’s data after offset code units.\n\t// 6. Let delete offset be offset + data's length.\n\t// 7. Starting from delete offset code units, remove count code units from node’s data.\n\tconst nodeData = node.data;\n\tconst newData = nodeData.substring(0, offset) + data + nodeData.substring(offset + count);\n\t(node as any)._data = newData;\n\n\tconst context = getContext(node);\n\tcontext.forEachRange((range) => {\n\t\t// 8. For each live range whose start node is node and start offset is greater than offset\n\t\t// but less than or equal to offset plus count, set its start offset to offset.\n\t\tif (\n\t\t\trange.startContainer === node &&\n\t\t\trange.startOffset > offset &&\n\t\t\trange.startOffset <= offset + count\n\t\t) {\n\t\t\trange.startOffset = offset;\n\t\t}\n\n\t\t// 9. For each live range whose end node is node and end offset is greater than offset but\n\t\t// less than or equal to offset plus count, set its end offset to offset.\n\t\tif (\n\t\t\trange.endContainer === node &&\n\t\t\trange.endOffset > offset &&\n\t\t\trange.endOffset <= offset + count\n\t\t) {\n\t\t\trange.endOffset = offset;\n\t\t}\n\n\t\t// 10. For each live range whose start node is node and start offset is greater than offset\n\t\t// plus count, increase its start offset by data's length and decrease it by count.\n\t\tif (range.startContainer === node && range.startOffset > offset + count) {\n\t\t\trange.startOffset = range.startOffset + data.length - count;\n\t\t}\n\n\t\t// 11. For each live range whose end node is node and end offset is greater than offset plus\n\t\t// count, increase its end offset by data's length and decrease it by count.\n\t\tif (range.endContainer === node && range.endOffset > offset + count) {\n\t\t\trange.endOffset = range.endOffset + data.length - count;\n\t\t}\n\t});\n\n\t// 12. If node's parent is non-null, then run the children changed steps for node’s parent.\n\t// (children changed steps not implemented)\n}\n\n/**\n * To substring data with node node, offset offset, and count count, run these steps:\n *\n * @param node   - The node to get data from\n * @param offset - The offset at which to start the substring\n * @param count  - The number of code units to include in the substring\n *\n * @returns The requested substring\n */\nexport function substringData(node: CharacterData, offset: number, count: number): string {\n\t// Match spec data types\n\toffset = asUnsignedLong(offset);\n\tcount = asUnsignedLong(count);\n\n\t// 1. Let length be node’s length.\n\tconst length = node.length;\n\n\t// 2. If offset is greater than length, then throw an IndexSizeError.\n\tif (offset > length) {\n\t\tthrowIndexSizeError(\"can not substring data past the node's length\");\n\t}\n\n\t// 3. If offset plus count is greater than length, return a string whose value is the code units\n\t// from the offsetth code unit to the end of node’s data, and then return.\n\tif (offset + count > length) {\n\t\treturn node.data.substring(offset);\n\t}\n\n\t// 4. Return a string whose value is the code units from the offsetth code unit to the\n\t// offset+countth code unit in node’s data.\n\treturn node.data.substring(offset, offset + count);\n}\n","import { replaceData, substringData, default as CharacterData } from './CharacterData';\nimport Document from './Document';\nimport { getContext } from './context/Context';\nimport { expectArity, throwIndexSizeError } from './util/errorHelpers';\nimport { insertNode } from './util/mutationAlgorithms';\nimport { NodeType, isNodeOfType } from './util/NodeType';\nimport { getNodeIndex } from './util/treeHelpers';\nimport { asUnsignedLong } from './util/typeHelpers';\n\n/**\n * 3.11. Interface Text\n *\n * @public\n */\nexport default class Text extends CharacterData {\n\t// Node\n\n\tpublic get nodeType(): number {\n\t\treturn NodeType.TEXT_NODE;\n\t}\n\n\tpublic get nodeName(): string {\n\t\treturn '#text';\n\t}\n\n\t// Text\n\n\t/**\n\t * Returns a new Text node whose data is data and node document is current global object’s\n\t * associated Document.\n\t *\n\t * @param data - The data for the new text node\n\t */\n\tconstructor(data: string = '') {\n\t\tsuper(data);\n\n\t\tconst context = getContext(this);\n\t\tthis.ownerDocument = context.document;\n\t}\n\n\t/**\n\t * Splits data at the given offset and returns the remainder as Text node.\n\t *\n\t * @param offset - The offset at which to split\n\t *\n\t * @returns a text node containing the second half of the split node's data\n\t */\n\tpublic splitText(offset: number): Text {\n\t\texpectArity(arguments, 1);\n\t\toffset = asUnsignedLong(offset);\n\n\t\treturn splitText(this, offset);\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic _copy(document: Document): Text {\n\t\t// Set copy’s data, to that of node.\n\t\tconst context = getContext(document);\n\t\tconst copy = new context.Text(this.data);\n\t\tcopy.ownerDocument = document;\n\t\treturn copy;\n\t}\n\n\t/**\n\t * Returns the combined data of all direct Text node siblings.\n\t *\n\t * @returns the concatenation of the data of the contiguous Text nodes of this, in\n\t *          tree order.\n\t */\n\tpublic get wholeText(): string {\n\t\tconst allData: string[] = [this.data];\n\n\t\tlet previousSibling = this.previousSibling;\n\t\twhile (\n\t\t\tpreviousSibling !== null &&\n\t\t\tisNodeOfType(previousSibling, NodeType.TEXT_NODE, NodeType.CDATA_SECTION_NODE)\n\t\t) {\n\t\t\tconst data = (previousSibling as Text).data;\n\t\t\tallData.unshift(data);\n\t\t\tpreviousSibling = previousSibling.previousSibling;\n\t\t}\n\n\t\tlet nextSibling = this.nextSibling;\n\t\twhile (\n\t\t\tnextSibling !== null &&\n\t\t\tisNodeOfType(nextSibling, NodeType.TEXT_NODE, NodeType.CDATA_SECTION_NODE)\n\t\t) {\n\t\t\tconst data = (nextSibling as Text).data;\n\t\t\tallData.push(data);\n\t\t\tnextSibling = nextSibling.nextSibling;\n\t\t}\n\n\t\treturn allData.join('');\n\t}\n}\n\n/**\n * To split a Text node node with offset offset, run these steps:\n *\n * @param node   - The text node to split\n * @param offset - The offset to split at\n *\n * @returns a text node containing the second half of the split node's data\n */\nfunction splitText(node: Text, offset: number): Text {\n\t// 1. Let length be node’s length.\n\tconst length = node.length;\n\n\t// 2. If offset is greater than length, then throw an IndexSizeError.\n\tif (offset > length) {\n\t\tthrowIndexSizeError(\"can not split past the node's length\");\n\t}\n\n\t// 3. Let count be length minus offset.\n\tconst count = length - offset;\n\n\t// 4. Let new data be the result of substringing data with node node, offset offset, and count\n\t// count.\n\tconst newData = substringData(node, offset, count);\n\n\t// 5. Let new node be a new Text node, with the same node document as node. Set new node’s data\n\t// to new data.\n\tconst context = getContext(node);\n\tconst newNode = new context.Text(newData);\n\tnewNode.ownerDocument = node.ownerDocument;\n\n\t// 6. Let parent be node’s parent.\n\tconst parent = node.parentNode;\n\n\t// 7. If parent is non-null, then:\n\tif (parent !== null) {\n\t\t// 7.1. Insert new node into parent before node’s next sibling.\n\t\tinsertNode(newNode, parent, node.nextSibling);\n\n\t\tconst indexOfNodePlusOne = getNodeIndex(node) + 1;\n\t\tconst context = getContext(node);\n\t\tcontext.forEachRange((range) => {\n\t\t\t// 7.2. For each live range whose start node is node and start offset is greater than\n\t\t\t// offset, set its start node to new node and decrease its start offset by offset.\n\t\t\tif (range.startContainer === node && range.startOffset > offset) {\n\t\t\t\trange.startContainer = newNode;\n\t\t\t\trange.startOffset -= offset;\n\t\t\t}\n\n\t\t\t// 7.3. For each live range whose end node is node and end offset is greater than\n\t\t\t// offset, set its end node to new node and decrease its end offset by offset.\n\t\t\tif (range.endContainer === node && range.endOffset > offset) {\n\t\t\t\trange.endContainer = newNode;\n\t\t\t\trange.endOffset -= offset;\n\t\t\t}\n\n\t\t\t// 7.4. For each live range whose start node is parent and start offset is equal to the\n\t\t\t// index of node + 1, increase its start offset by one.\n\t\t\tif (range.startContainer === parent && range.startOffset === indexOfNodePlusOne) {\n\t\t\t\trange.startOffset += 1;\n\t\t\t}\n\n\t\t\t// 7.5. For each live range whose end node is parent and end offset is equal to the\n\t\t\t// index of node + 1, increase its end offset by one.\n\t\t\tif (range.endContainer === parent && range.endOffset === indexOfNodePlusOne) {\n\t\t\t\trange.endOffset += 1;\n\t\t\t}\n\t\t});\n\t}\n\n\t// 8. Replace data with node node, offset offset, count count, and data the empty string.\n\treplaceData(node, offset, count, '');\n\n\t// 9. Return new node.\n\treturn newNode;\n}\n","import Document from './Document';\nimport Text from './Text';\nimport { getContext } from './context/Context';\nimport { NodeType } from './util/NodeType';\n\n/**\n * @public\n */\nexport default class CDATASection extends Text {\n\t// Node\n\n\tpublic get nodeType(): number {\n\t\treturn NodeType.CDATA_SECTION_NODE;\n\t}\n\n\tpublic get nodeName(): string {\n\t\treturn '#cdata-section';\n\t}\n\n\t// CDATASection\n\n\t/**\n\t * (non-standard) use Document#createCDATASection to create a CDATA section.\n\t *\n\t * @param data - The data for the node\n\t */\n\tconstructor(data: string) {\n\t\tsuper(data);\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic _copy(document: Document): CDATASection {\n\t\t// Set copy’s data, to that of node.\n\t\tconst context = getContext(document);\n\t\tconst copy = new context.CDATASection(this.data);\n\t\tcopy.ownerDocument = document;\n\t\treturn copy;\n\t}\n}\n","import CharacterData from './CharacterData';\nimport Document from './Document';\nimport { getContext } from './context/Context';\nimport { NodeType } from './util/NodeType';\n\n/**\n * @public\n */\nexport default class Comment extends CharacterData {\n\t// Node\n\n\tpublic get nodeType(): number {\n\t\treturn NodeType.COMMENT_NODE;\n\t}\n\n\tpublic get nodeName(): string {\n\t\treturn '#comment';\n\t}\n\n\t// Comment\n\n\t/**\n\t * Returns a new Comment node whose data is data and node document is current global object’s\n\t * associated Document.\n\t *\n\t * @param data - The data for the new comment\n\t */\n\tconstructor(data: string = '') {\n\t\tsuper(data);\n\n\t\tconst context = getContext(this);\n\t\tthis.ownerDocument = context.document;\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic _copy(document: Document): Comment {\n\t\t// Set copy’s data, to that of node.\n\t\tconst context = getContext(document);\n\t\tconst copy = new context.Comment(this.data);\n\t\tcopy.ownerDocument = document;\n\t\treturn copy;\n\t}\n}\n","import { ChildNode } from './mixins';\nimport Document from './Document';\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport { expectArity } from './util/errorHelpers';\nimport { NodeType } from './util/NodeType';\nimport {\n\tinsertNodesBefore,\n\tinsertNodesAfter,\n\treplaceWithNodes,\n\tremoveFromParent,\n} from './util/mutationAlgorithms';\n\n/**\n * @public\n */\nexport default class DocumentType extends Node implements ChildNode {\n\t// Node\n\n\tpublic get nodeType(): number {\n\t\treturn NodeType.DOCUMENT_TYPE_NODE;\n\t}\n\n\tpublic get nodeName(): string {\n\t\treturn this.name;\n\t}\n\n\tpublic get nodeValue(): string | null {\n\t\treturn null;\n\t}\n\n\tpublic set nodeValue(_newValue: string | null) {\n\t\t// Do nothing.\n\t}\n\n\tpublic get textContent(): string | null {\n\t\treturn null;\n\t}\n\n\tpublic set textContent(_newValue: string | null) {\n\t\t// Do nothing.\n\t}\n\n\tpublic lookupPrefix(namespace: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If namespace is null or the empty string, then return null.\n\t\t// (not necessary due to return value)\n\n\t\t// 2. Switch on this:\n\t\t// DocumentType - Return null\n\t\treturn null;\n\t}\n\n\tpublic lookupNamespaceURI(prefix: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If prefix is the empty string, then set it to null.\n\t\t// (not necessary due to return value)\n\n\t\t// 2. Return the result of running locate a namespace for this using prefix.\n\n\t\t// To locate a namespace for a node using prefix, switch on node: DocumentType\n\t\t// Return null.\n\t\treturn null;\n\t}\n\n\t// ChildNode\n\n\tpublic before(...nodes: (Node | string)[]): void {\n\t\tinsertNodesBefore(this, nodes);\n\t}\n\n\tpublic after(...nodes: (Node | string)[]): void {\n\t\tinsertNodesAfter(this, nodes);\n\t}\n\n\tpublic replaceWith(...nodes: (Node | string)[]): void {\n\t\treplaceWithNodes(this, nodes);\n\t}\n\n\tpublic remove(): void {\n\t\tremoveFromParent(this);\n\t}\n\n\t// DocumentType\n\n\t/**\n\t * The name of the doctype.\n\t */\n\tpublic name: string;\n\n\t/**\n\t * The public ID of the doctype.\n\t */\n\tpublic publicId: string;\n\n\t/**\n\t * The system ID of the doctype.\n\t */\n\tpublic systemId: string;\n\n\t/**\n\t * (non-standard) Use DOMImplementation#createDocumentType instead.\n\t *\n\t * @param name     - The name of the doctype\n\t * @param publicId - The public ID of the doctype\n\t * @param systemId - The system ID of the doctype\n\t */\n\tconstructor(name: string, publicId: string = '', systemId: string = '') {\n\t\tsuper();\n\n\t\tthis.name = name;\n\t\tthis.publicId = publicId;\n\t\tthis.systemId = systemId;\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic _copy(document: Document): DocumentType {\n\t\t// Set copy’s name, public ID, and system ID, to those of node.\n\t\tconst context = getContext(document);\n\t\tconst copy = new context.DocumentType(this.name, this.publicId, this.systemId);\n\t\tcopy.ownerDocument = document;\n\t\treturn copy;\n\t}\n}\n","import Attr from './Attr';\nimport Document from './Document';\nimport { createElement, default as Element } from './Element';\nimport { appendAttribute } from './util/attrMutations';\n\n/**\n * Create an Attr node without the usual validation of the given names.\n *\n * @public\n *\n * @param namespace - The namespace URI for the new node\n * @param prefix    - The prefix for the new node\n * @param localName - The local name for the new node\n * @param value     - The value for the new node\n * @param element   - The owner element for the new node\n *\n * @returns A new Attr node with the given values\n */\nexport function unsafeCreateAttribute(\n\tnamespace: string | null,\n\tprefix: string | null,\n\tlocalName: string,\n\tvalue: string,\n\townerElement: Element | null\n): Attr {\n\treturn new Attr(namespace, prefix, localName, value, ownerElement);\n}\n\n/**\n * Create an Element node without the usual validation of the given names.\n *\n * @public\n *\n * @param document  - The node document for the new element\n * @param localName - The local name for the new element\n * @param namespace - The namespace URI for the new element, or null for the null namespace\n * @param prefix    - The prefix for the new element, or null for no prefix\n *\n * @returns The new element\n */\nexport function unsafeCreateElement(\n\tdocument: Document,\n\tlocalName: string,\n\tnamespace: string | null,\n\tprefix: string | null = null\n): Element {\n\treturn createElement(document, localName, namespace, prefix);\n}\n\n/**\n * Append an attribute attribute to an element without the usual checks.\n *\n * @public\n *\n * @param attribute - The attribute to append\n * @param element   - The element to append attribute to\n */\nexport function unsafeAppendAttribute(attribute: Attr, element: Element): void {\n\tappendAttribute(attribute, element);\n}\n","import { matchesNameProduction } from '../dom-parsing/parsingAlgorithms';\nimport Element from '../Element';\nimport { throwInvalidCharacterError, throwNamespaceError } from './errorHelpers';\n\n// 1.5. Namespaces\n\nexport const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\nexport const XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';\nexport const XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';\n\n/**\n * @param name - The name to check\n *\n * @returns True if the name is a valid QName, provided it is also a valid Name, otherwise false\n */\nfunction isValidQName(name: string): boolean {\n\t// (QName is basically NCName | (NCName ':' NCName) where NCName is Name without ':', so here we\n\t// check that name contains at most a single colon, and that the other parts are valid Names)\n\tconst parts = name.split(':');\n\tif (parts.length > 2) {\n\t\t// Too many colons\n\t\treturn false;\n\t}\n\t// Each part should be a valid Name - we already know they don't contain ':', so a valid Name\n\t// here also means a valid NCName\n\treturn parts.every((part) => matchesNameProduction(part));\n}\n\n/**\n * To validate a qualifiedName,\n *\n * @param qualifiedName - Qualified name to validate\n */\nexport function validateQualifiedName(qualifiedName: string): void {\n\t// throw an InvalidCharacterError if qualifiedName does not match the QName production.\n\tif (!isValidQName(qualifiedName)) {\n\t\tthrowInvalidCharacterError('The qualified name is not a valid QName');\n\t}\n}\n\n/**\n * To validate and extract a namespace and qualifiedName, run these steps:\n *\n * @param namespace     - Namespace for the qualified name\n * @param qualifiedName - Qualified name to validate and extract the components of\n *\n * @returns Namespace, prefix and localName\n */\nexport function validateAndExtract(\n\tnamespace: string | null,\n\tqualifiedName: string\n): { namespace: string | null; prefix: string | null; localName: string } {\n\t// 1. If namespace is the empty string, set it to null.\n\tif (namespace === '') {\n\t\tnamespace = null;\n\t}\n\n\t// 2. Validate qualifiedName.\n\tvalidateQualifiedName(qualifiedName);\n\n\t// 3. Let prefix be null.\n\tlet prefix: string | null = null;\n\n\t// 4.  Let localName be qualifiedName.\n\tlet localName = qualifiedName;\n\n\t// 5. If qualifiedName contains a \":\" (U+003A), then split the string on it and set prefix to\n\t// the part before and localName to the part after.\n\tconst index = qualifiedName.indexOf(':');\n\tif (index >= 0) {\n\t\tprefix = qualifiedName.substring(0, index);\n\t\tlocalName = qualifiedName.substring(index + 1);\n\t}\n\n\t// 6. If prefix is non-null and namespace is null, then throw a NamespaceError.\n\tif (prefix !== null && namespace === null) {\n\t\tthrowNamespaceError('Qualified name with prefix can not have a null namespace');\n\t}\n\n\t// 7. If prefix is \"xml\" and namespace is not the XML namespace, then throw a NamespaceError.\n\tif (prefix === 'xml' && namespace !== XML_NAMESPACE) {\n\t\tthrowNamespaceError('xml prefix can only be used for the XML namespace');\n\t}\n\n\t// 8. If either qualifiedName or prefix is \"xmlns\" and namespace is not the XMLNS namespace,\n\t// then throw a NamespaceError.\n\tif ((qualifiedName === 'xmlns' || prefix === 'xmlns') && namespace !== XMLNS_NAMESPACE) {\n\t\tthrowNamespaceError('xmlns prefix or qualifiedName must use the XMLNS namespace');\n\t}\n\n\t// 9. If namespace is the XMLNS namespace and neither qualifiedName nor prefix is \"xmlns\", then\n\t// throw a NamespaceError.\n\tif (namespace === XMLNS_NAMESPACE && qualifiedName !== 'xmlns' && prefix !== 'xmlns') {\n\t\tthrowNamespaceError('xmlns prefix or qualifiedName must be used for the XMLNS namespace');\n\t}\n\n\t// 10. Return namespace, prefix, and localName.\n\treturn { namespace, prefix, localName };\n}\n\n/**\n * To locate a namespace prefix for an element using namespace, run these steps:\n *\n * @param element    - The element at which to start the lookup\n * @param namespace  - Namespace for which to look up the prefix\n *\n * @returns The prefix, or null if there isn't one\n */\nexport function locateNamespacePrefix(element: Element, namespace: string | null): string | null {\n\t// 1. If element’s namespace is namespace and its namespace prefix is non-null, then return its\n\t// namespace prefix.\n\tif (element.namespaceURI === namespace && element.prefix !== null) {\n\t\treturn element.prefix;\n\t}\n\n\t// 2. If element has an attribute whose namespace prefix is \"xmlns\" and value is namespace, then\n\t// return element’s first such attribute’s local name.\n\tconst attr = Array.from(element.attributes).find(\n\t\t(attr) => attr.prefix === 'xmlns' && attr.value === namespace\n\t);\n\tif (attr) {\n\t\treturn attr.localName;\n\t}\n\n\t// 3. If element’s parent element is non-null, then return the result of running locate a\n\t// namespace prefix on that element using namespace.\n\tif (element.parentElement !== null) {\n\t\treturn locateNamespacePrefix(element.parentElement, namespace);\n\t}\n\n\t// 4. Return null.\n\treturn null;\n}\n","/**\n * The result of parsing - either success (with an offset at which to resume parsing the next thing)\n * or failure. If a failure is fatal, parsing should not continue to try alternative options.\n *\n * A ParseResult may contain a value that represents the parsed input.\n *\n * @public\n */\nexport type ParseResult<T> =\n\t| { success: true; offset: number; value: T }\n\t| { success: false; offset: number; expected: string[]; fatal: boolean };\n\n/**\n * A parser is a function that tries to match whatever it expects at the given offset in the input\n * string. Returns a ParseResult.\n *\n * @public\n */\nexport type Parser<T> = (input: string, offset: number) => ParseResult<T>;\n\n/**\n * Creates a successful ParseResult containing the given value.\n *\n * @public\n *\n * @param offset - The offset in the input at which to continue parsing\n * @param value  - The value resulting from applying the parser\n */\nexport function okWithValue<T>(offset: number, value: T): ParseResult<T> {\n\treturn { success: true, offset, value };\n}\n\n/**\n * Creates a successful ParseResult with an undefined value. Use this to signal success in cases\n * where no value is required.\n *\n * @public\n *\n * @param offset - The offset in the input at which to continue parsing\n */\nexport function ok(offset: number): ParseResult<undefined> {\n\treturn okWithValue(offset, undefined);\n}\n\n/**\n * Creates an unsuccessful ParseResult (parse error) at the given offset.\n *\n * @public\n *\n * @param offset   - The offset in the input at which matching failed\n * @param expected - An array of strings indicating things that were expected at offset\n * @param fatal    - If true, no other branches should be tried as a result of this error\n */\nexport function error<T>(\n\toffset: number,\n\texpected: string[],\n\tfatal: boolean = false\n): ParseResult<T> {\n\treturn { success: false, offset, expected, fatal };\n}\n\n/**\n * Creates a Parser that matches the given string.\n *\n * @public\n *\n * @param token - The expected string\n */\nexport function token(token: string): Parser<string> {\n\treturn (input, offset) => {\n\t\tconst offsetAfter = offset + token.length;\n\t\tif (input.slice(offset, offsetAfter) === token) {\n\t\t\treturn okWithValue(offsetAfter, token);\n\t\t}\n\t\treturn error(offset, [token]);\n\t};\n}\n\nfunction lengthFromCodePoint(cp: number): number {\n\treturn cp > 0xffff ? 2 : 1;\n}\n\n/**\n * Creates a Parser that skips the next code point if the given predicate returns true.\n *\n * This counts in unicode characters (code points), not UTF-16 code units.\n *\n * To match a sequence of code points, consider using `codepoints` instead.\n *\n * @public\n *\n * @param isMatch  - callback called with the next codepoint, should return whether that matches\n * @param expected - expected strings to return if the codepoint does not match\n */\nexport function codepoint(\n\tisMatch: (codepoint: number) => boolean,\n\texpected: string[]\n): Parser<void> {\n\treturn (input: string, offset: number) => {\n\t\tconst cp = input.codePointAt(offset);\n\t\tif (cp === undefined || !isMatch(cp)) {\n\t\t\treturn error(offset, expected);\n\t\t}\n\t\treturn ok(offset + lengthFromCodePoint(cp));\n\t};\n}\n\n/**\n * Creates a Parser that skips code points while the given predicate returns true.\n *\n * This counts in unicode characters (code points), not UTF-16 code units.\n *\n * This acts like `starConsumed(codepoint(isMatch, []))` if expected is not set, or as\n * `plusConsumed(codepoint(isMatch, expected))` if it is, but is much more efficient than either of\n * those combinations.\n *\n * @public\n *\n * @param isMatch  - callback called for each codepoint, should return whether that matches\n * @param expected - expected strings to return if the first codepoint does not match\n */\nexport function codepoints(\n\tisMatch: (codepoint: number) => boolean,\n\texpected?: string[]\n): Parser<void> {\n\treturn (input: string, offset: number) => {\n\t\tconst startOffset = offset;\n\t\twhile (true) {\n\t\t\tconst cp = input.codePointAt(offset);\n\t\t\tif (cp === undefined) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!isMatch(cp)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toffset += cp > 0xffff ? 2 : 1;\n\t\t}\n\t\tif (expected !== undefined && offset === startOffset) {\n\t\t\treturn error(offset, expected);\n\t\t}\n\t\treturn ok(offset);\n\t};\n}\n\n/**\n * Creates a Parser that matches a single character from a range of codepoints.\n *\n * Use `recognize` if you need the character that was matched.\n *\n * @public\n *\n * @param firstCodePoint - The first code point to accept\n * @param lastCodePoint  - The last code point to accept (inclusive)\n */\nexport function range(\n\tfirstCodePoint: number,\n\tlastCodePoint: number,\n\texpected?: string[]\n): Parser<void> {\n\treturn codepoint(\n\t\t(cp) => firstCodePoint <= cp && cp <= lastCodePoint,\n\t\texpected || [\n\t\t\t`${String.fromCodePoint(firstCodePoint)}-${String.fromCodePoint(lastCodePoint)}`,\n\t\t]\n\t);\n}\n\n/**\n * Creates a Parser that skips the given number of characters.\n *\n * This counts in unicode characters (code points), not UTF-16 code units.\n *\n * @public\n *\n * @param nCodepoints - number of characters to skip\n */\nexport function skipChars(nCodepoints: number): Parser<void> {\n\treturn (input: string, offset: number) => {\n\t\tlet i = nCodepoints;\n\t\twhile (i > 0) {\n\t\t\tconst cp = input.codePointAt(offset);\n\t\t\tif (cp === undefined) {\n\t\t\t\treturn error(offset, ['any character']);\n\t\t\t}\n\t\t\toffset += lengthFromCodePoint(cp);\n\t\t\ti -= 1;\n\t\t}\n\t\treturn ok(offset);\n\t};\n}\n\n/**\n * Creates a Parser that applies the given function to each value generated by the given parser.\n *\n * @public\n *\n * @param parser - Parser to map over\n * @param map    - Function to transform values generated by parser\n */\nexport function map<T, U>(parser: Parser<T>, map: (v: T) => U): Parser<U> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(res.offset, map(res.value));\n\t};\n}\n\n/**\n * Creates a Parser that applies the given parser but discards the resulting value.\n *\n * @public\n *\n * @param parser - Parser to apply\n */\nexport function consume<T>(parser: Parser<T>): Parser<void> {\n\treturn map(parser, () => undefined);\n}\n\n/**\n * Creates a Parser that uses the given filter predicate to check values generated by the given\n * parser. Values that pass the predicate are passed through, those that don't return a parse error\n * instead.\n *\n * @public\n *\n * @param parser   - Parser to filter\n * @param filter   - Predicate function over the inner parser's values\n * @param expected - Expected values for parse errors generated when the filter rejects a value\n * @param fatal    - Whether the error returned when the filter rejects should be fatal\n */\nexport function filter<T>(\n\tparser: Parser<T>,\n\tfilter: (v: T) => boolean,\n\texpected: string[],\n\tfatal?: boolean\n): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\tif (!filter(res.value)) {\n\t\t\treturn error(offset, expected, fatal);\n\t\t}\n\t\treturn res;\n\t};\n}\n\n/**\n * Creates a Parser that applies each of the given parsers in turn until one matches, then returns\n * that parser's result. If no parser matches, an error is returned reflecting the furthest offset\n * reached in the input string. If any parser returns a fatal error, no further branches are tried.\n *\n * @public\n *\n * @param parsers  - Parsers to attempt to apply\n * @param expected - Overrides the expected value used if none of the inner parsers match\n */\nexport function or<T>(parsers: Parser<T>[], expected?: string[]): Parser<T> {\n\treturn (input, offset) => {\n\t\tlet lastError: ParseResult<T> | null = null;\n\t\tfor (const parser of parsers) {\n\t\t\tconst res = parser(input, offset);\n\t\t\tif (res.success) {\n\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (lastError === null || res.offset > lastError.offset) {\n\t\t\t\tlastError = res;\n\t\t\t} else if (res.offset === lastError.offset && expected === undefined) {\n\t\t\t\tlastError.expected = lastError.expected.concat(res.expected);\n\t\t\t}\n\t\t\tif (res.fatal) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\texpected = expected || lastError?.expected || [];\n\t\tif (lastError) {\n\t\t\tlastError.expected = expected;\n\t\t}\n\t\treturn lastError || error(offset, expected);\n\t};\n}\n\n/**\n * Creates a Parser that tries to apply the given parser optionally. It returns the inner parser's\n * result if succesful, and otherwise indicates success at the starting offset with a `null` value.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - Parser to attempt to apply\n */\nexport function optional<T>(parser: Parser<T>): Parser<T | null> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success && !res.fatal) {\n\t\t\treturn okWithValue(offset, null);\n\t\t}\n\n\t\treturn res;\n\t};\n}\n\n/**\n * Creates a Parser that tries to apply the given parser zero or more times in sequence. Values for\n * successful matches are collected in an array. Once the inner parser no longer matches, success is\n * returned at the offset reached with the accumulated values.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - Parser to apply repeatedly\n */\nexport function star<T>(parser: Parser<T>): Parser<T[]> {\n\treturn (input, offset) => {\n\t\tlet ts: T[] = [];\n\t\tlet nextOffset = offset;\n\t\twhile (true) {\n\t\t\tconst res = parser(input, nextOffset);\n\t\t\tif (!res.success) {\n\t\t\t\tif (res.fatal) {\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tts.push(res.value);\n\t\t\tif (res.offset === nextOffset) {\n\t\t\t\t// Did not advance\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnextOffset = res.offset;\n\t\t}\n\n\t\treturn okWithValue(nextOffset, ts);\n\t};\n}\n\n/**\n * Creates a Parser that tries to apply the given parser zero or more times in sequence. Values for\n * successful matches are discarded. Once the inner parser no longer matches, success is returned at\n * the offset reached.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - Parser to apply repeatedly\n */\nexport function starConsumed<T>(parser: Parser<T>): Parser<void> {\n\treturn (input, offset) => {\n\t\tlet nextOffset = offset;\n\t\twhile (true) {\n\t\t\tconst res = parser(input, nextOffset);\n\t\t\tif (!res.success) {\n\t\t\t\tif (res.fatal) {\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (res.offset === nextOffset) {\n\t\t\t\t// Did not advance\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnextOffset = res.offset;\n\t\t}\n\n\t\treturn ok(nextOffset);\n\t};\n}\n\n/**\n * Creates a parser that discards undefined values from the array produced by the\n * given parser.\n *\n * Useful in combination with `star`, `or` and `consume`:\n *\n * ```\n * const a: Parser<string> = token('a');\n * const b: Parser<void> = consume(token('b'));\n * const abs: Parser<(string | void)[]> = star(or<string | void>([a, b]));\n * const as: Parser<string[]> = filterUndefined(abs);\n * ```\n *\n * @public\n *\n * @param parser - Parser to apply, should produce an array that may contain undefined entries.\n */\nexport function filterUndefined<T>(parser: Parser<(T | void)[]>): Parser<T[]> {\n\treturn map(parser, (vs) => vs.filter((v) => v !== undefined) as T[]);\n}\n\n/**\n * Creates a Parser that applies the given two parsers in sequence, returning success only if both\n * succeed. The given join function is used to combine the values from both parsers into the single\n * value to return. If either parser fails, the failure is returned as-is.\n *\n * @public\n *\n * @param parser1 - First parser to apply\n * @param parser2 - Parser to apply after the first one is successful\n * @param join    - Function used to combine the values of both parsers\n */\nexport function then<T1, T2, T>(\n\tparser1: Parser<T1>,\n\tparser2: Parser<T2>,\n\tjoin: (value1: T1, value2: T2) => T\n): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst r1 = parser1(input, offset);\n\t\tif (!r1.success) {\n\t\t\treturn r1;\n\t\t}\n\t\tconst r2 = parser2(input, r1.offset);\n\t\tif (!r2.success) {\n\t\t\treturn r2;\n\t\t}\n\t\treturn okWithValue(r2.offset, join(r1.value, r2.value));\n\t};\n}\n\n/**\n * Creates a parser that applies the given parsers in sequence, returning a tuple of the\n * corresponding values if all of them accept.\n *\n * This can be slightly less efficient than nesting `then` and its variations, but may be a lot more\n * readable. If you don't care about any of the values produced, consider using `sequenceConsumed`\n * instead.\n *\n * @public\n *\n * @param parsers - Parsers to apply one after the other\n */\nexport function sequence<Ts extends unknown[]>(\n\t...parsers: { [key in keyof Ts]: Parser<Ts[key]> }\n): Parser<Ts> {\n\treturn (input, offset) => {\n\t\tconst values: Ts = [] as unknown[] as Ts;\n\t\tfor (const parser of parsers) {\n\t\t\tconst res = parser(input, offset);\n\t\t\tif (!res.success) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\toffset = res.offset;\n\t\t\tvalues.push(res.value);\n\t\t}\n\t\treturn okWithValue(offset, values);\n\t};\n}\n\n/**\n * Creates a parser that applies the given parsers in sequence, discarding all of the values\n * produced.\n *\n * @public\n *\n * @param parsers - Parsers to apply one after the other\n */\nexport function sequenceConsumed(...parsers: Parser<unknown>[]): Parser<void> {\n\treturn (input, offset) => {\n\t\tfor (const parser of parsers) {\n\t\t\tconst res = parser(input, offset);\n\t\t\tif (!res.success) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\toffset = res.offset;\n\t\t}\n\t\treturn ok(offset);\n\t};\n}\n\n/**\n * Creates a Parser that tries to apply the given parser one or more times in sequence. Values for\n * successful matches are collected in an array. Once the inner parser no longer matches, success is\n * returned at the offset reached with the accumulated values. The parser is required to match at\n * least once, so an initial failure is returned as-is.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - The parser to apply repeatedly\n */\nexport function plus<T>(parser: Parser<T>): Parser<T[]> {\n\treturn then(parser, star(parser), (v, vs) => [v].concat(vs));\n}\n\n/**\n * Returns the first of the given two arguments. Useful as a `join` function for `then`. See also\n * `followed`.\n *\n * @public\n *\n * @param x - Argument to return\n * @param y - Argument to ignore\n */\nexport function first<T1, T2>(x: T1, y: T2): T1 {\n\treturn x;\n}\n\n/**\n * Returns the second of the given two arguments. Useful as a `join` function for `then`. See also\n * `preceded`.\n *\n * @public\n *\n * @param x - Argument to ignore\n * @param y - Argument to return\n */\nexport function second<T1, T2>(x: T1, y: T2): T2 {\n\treturn y;\n}\n\n/**\n * Creates a Parser that tries to apply the given parser one or more times in sequence. Values for\n * successful matches are discarded. Once the inner parser no longer matches, success is returned at\n * the offset reached. The parser is required to match at least once, so an initial failure is\n * returned as-is.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - The parser to apply repeatedly\n */\nexport function plusConsumed<T>(parser: Parser<T>): Parser<void> {\n\treturn then(parser, starConsumed(parser), second);\n}\n\n/**\n * Creates a Parser that applies the given two parsers in sequence, returning the result of the\n * second if the first succeeds.\n *\n * Equivalent to `then(before, parser, second)`.\n *\n * @public\n *\n * @param before - First parser to apply, value is discarded\n * @param parser - Second parser to apply, value is kept\n */\nexport function preceded<TBefore, T>(before: Parser<TBefore>, parser: Parser<T>): Parser<T> {\n\treturn then(before, parser, second);\n}\n\n/**\n * Creates a Parser that applies the given two parsers in sequence, returning the result value of\n * the first at the offset of the second if both succeed. If either parser fails the error is\n * returned as-is.\n *\n * Equivalent to `then(parser, after, first)`.\n *\n * @public\n *\n * @param parser - First parser to apply, value is kept\n * @param before - Second parser to apply, value is discarded\n */\nexport function followed<T, TAfter>(parser: Parser<T>, after: Parser<TAfter>): Parser<T> {\n\treturn then(parser, after, first);\n}\n\n/**\n * Creates a Parser that applies the given parsers in sequence, returning the result value of the\n * middle parser at the offset of the third if all are successful. If any parser fails, the error is\n * returned as-is.\n *\n * Optionally makes errors by the second and third parsers fatal if `cutAfterOpen` is `true`.\n *\n * @public\n *\n * @param open         - First parser to apply, value is discarded\n * @param inner        - Second parser to apply, value is kept\n * @param close        - Third parser to apply, value is discarded\n * @param cutAfterOpen - If `true`, errors returned by the second and third parsers are considered\n *                       fatal, causing parsers using this to stop trying other branches.\n */\nexport function delimited<TOpen, T, TClose>(\n\topen: Parser<TOpen>,\n\tinner: Parser<T>,\n\tclose: Parser<TClose>,\n\tcutAfterOpen: boolean = false\n): Parser<T> {\n\tconst rest = cutAfterOpen ? cut(followed(inner, close)) : followed(inner, close);\n\treturn preceded(open, rest);\n}\n\n/**\n * Creates a Parser that applies the given parser. If successful, the inner parser's value is\n * discarded and the substring that was consumed from the input is returned as value instead. Errors\n * are returned as-is.\n *\n * When using this in combination with `star` or `plus`, consider using `starConsumed` or\n * `plusConsumed` instead for efficiency.\n *\n * @public\n *\n * @param parser - The parser to apply, value is discarded and replaced by the consumed input.\n */\nexport function recognize<T>(parser: Parser<T>): Parser<string> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(res.offset, input.slice(offset, res.offset));\n\t};\n}\n\n/**\n * Creates a Parser that applies the given parser without consuming any input. That is, if the inner\n * parser is successful, success is returned (with the resulting value) at the starting offset,\n * effectively making the parser consume no input.\n *\n * Errors returned by the inner parser are returned as-is.\n *\n * @public\n *\n * @param parser - The parser to apply, value is discarded and any progress made in input is reset.\n */\nexport function peek<T>(parser: Parser<T>): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(offset, res.value);\n\t};\n}\n\n/**\n * Creates a Parser that succeeds at the starting offset if the given parser fails and vice-versa.\n *\n * @public\n *\n * @param parser   - The parser to apply\n * @param expected - Expected values for parse errors generated when the inner parser succeeds\n */\nexport function not<T>(parser: Parser<T>, expected: string[]): Parser<void> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn ok(offset);\n\t\t}\n\t\treturn error(offset, expected);\n\t};\n}\n\n/**\n * Creates a Parser that matches only if the first Parser matches input at the starting position,\n * but the second Parser does not.\n *\n * @public\n *\n * @param match    - Parser that should match\n * @param except   - Parser that should not match\n * @param expected - Expected values for parse errors generated when the except parser succeeds\n */\nexport function except<T, U>(match: Parser<T>, except: Parser<U>, expected: string[]): Parser<T> {\n\treturn preceded(not(except, expected), match);\n}\n\n/**\n * Creates a parser that looks at a single codepoint to determine which parser to invoke. Can be\n * used as an alternative to large `or` parsers if looking ahead can narrow down the options.\n *\n * Can optionally look ahead further than the current codepoint, which is useful when nesting\n * several `dispatch` parsers.\n *\n * @public\n *\n * @param mapping     - Object mapping code points to parsers\n * @param otherwise   - Parser to use when the code point is not found in the mapping, or undefined\n *                      to reject in that situation.\n * @param extraOffset - How far ahead to look for the codepoint, defaults to 0\n * @param expected    - Expected values for parse errors generated when there is no codepoint or\n *                      when the codepoint is not in the mapping and there is no `otherwise` parser\n */\nexport function dispatch<T>(\n\tmapping: { [codepoint: number]: Parser<T> },\n\totherwise: Parser<T> | undefined,\n\textraOffset: number = 0,\n\texpected: string[] = []\n): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst cp = input.codePointAt(offset + extraOffset);\n\t\tif (cp === undefined) {\n\t\t\treturn error(offset, expected);\n\t\t}\n\t\tconst parser = mapping[cp];\n\t\tif (parser === undefined) {\n\t\t\tif (otherwise === undefined) {\n\t\t\t\treturn error(offset, expected);\n\t\t\t}\n\t\t\treturn otherwise(input, offset);\n\t\t}\n\t\treturn parser(input, offset);\n\t};\n}\n\n/**\n * Creates a Parser that turns errors returned by the inner parser into fatal errors. Parsers such\n * as `or` and `star` will not continue to attempt additional matches if a parser returns a fatal\n * error, and will usually return the error instead.\n *\n * @public\n *\n * @param parser - The parser to wrap\n */\nexport function cut<T>(parser: Parser<T>): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn error(res.offset, res.expected, true);\n\t\t}\n\t\treturn res;\n\t};\n}\n\n/**\n * A parser that only succeeds at the start of the input string.\n *\n * @public\n *\n * @param input  - The input to match in\n * @param offset - The offset in `input` at which to start matching\n */\nexport const start: Parser<void> = (_input, offset) =>\n\toffset === 0 ? ok(offset) : error(offset, ['start of input']);\n\n/**\n * A parser that only succeeds if the end of the input string is reached.\n *\n * @public\n *\n * @param input  - The input to match in\n * @param offset - The offset in `input` at which to start matching\n */\nexport const end: Parser<void> = (input, offset) =>\n\tinput.length === offset ? ok(offset) : error(offset, ['end of input']);\n\n/**\n * Creates a Parser that applies the given parser and only succeeds (returning the inner parser's\n * result) if parsing concludes at the end of the input string.\n *\n * @public\n *\n * @param parser - The parser to wrap\n */\nexport function complete<T>(parser: Parser<T>): Parser<T> {\n\treturn then(parser, end, first);\n}\n","import { end, ok, Parser, ParseResult } from './parser-combinators';\n\n/**\n * Helper to collect both the yielded values and the returned value from a generator.\n *\n * @public\n *\n * @param gen - Generator to collect from\n */\nexport function collect<T, R>(gen: Generator<T, R>): [T[], R] {\n\tconst values: T[] = [];\n\tlet it = gen.next();\n\twhile (!it.done) {\n\t\tvalues.push(it.value);\n\t\tit = gen.next();\n\t}\n\treturn [values, it.value];\n}\n\n/**\n * A StreamingParser is similar to a Parser, but instead of returning a value when parsing is\n * complete it can parse incrementally and yield values as they are produced. The generator returns\n * a ParseResult when iteration is done which indicates whether parsing was successful.\n *\n * @public\n */\nexport type StreamingParser<T> = (\n\tinput: string,\n\toffset: number\n) => Generator<T, ParseResult<unknown>>;\n\n/**\n * Creates a StreamingParser which applies the given Parser and yields the value produced if it\n * matches.\n *\n * @public\n *\n * @param parser - The Parser to apply\n */\nexport function streaming<T>(parser: Parser<T>): StreamingParser<T> {\n\treturn function* (input: string, offset: number) {\n\t\tconst res = parser(input, offset);\n\t\tif (res.success) {\n\t\t\tyield res.value;\n\t\t}\n\t\treturn res;\n\t};\n}\n\n/**\n * Creates a StreamingParser which applies the given two StreamingParsers in sequence.\n *\n * Unlike `then`, this does not combine values using a function, but instead simply yields the\n * values produced by both parsers as they produce them.\n *\n * @public\n *\n * @param parser1 - First StreamingParser to apply\n * @param parser2 - StreamingParser to apply if the first one is successful\n */\nexport function streamingThen<T, U>(\n\tparser1: StreamingParser<T>,\n\tparser2: StreamingParser<U>\n): StreamingParser<T | U> {\n\treturn function* (input: string, offset: number) {\n\t\tconst res1 = yield* parser1(input, offset);\n\t\tif (!res1.success) {\n\t\t\treturn res1;\n\t\t}\n\t\treturn yield* parser2(input, res1.offset);\n\t};\n}\n\n/**\n * Creates a StreamingParser which discards undefined values yielded by the given StreamingParser.\n *\n * @public\n *\n * @param parser - The StreamingParser to filter\n */\nexport function streamingFilterUndefined<T>(parser: StreamingParser<T | void>): StreamingParser<T> {\n\treturn function* (input: string, offset: number) {\n\t\tconst gen = parser(input, offset);\n\t\tlet it = gen.next();\n\t\twhile (!it.done) {\n\t\t\tconst value = it.value;\n\t\t\tif (value !== undefined) {\n\t\t\t\tyield value;\n\t\t\t}\n\t\t\tit = gen.next();\n\t\t}\n\t\treturn it.value;\n\t};\n}\n\n/**\n * Creates a StreamingParser that tries to apply the given StreamingParser zero or more times in\n * sequence. Values produced during each iteration are only yielded whenever the inner parser\n * matches successfully.\n *\n * @public\n *\n * @param parser - StreamingParser to apply repeatedly\n */\nexport function streamingStar<T>(parser: StreamingParser<T>): StreamingParser<T> {\n\treturn function* (input: string, offset: number) {\n\t\twhile (true) {\n\t\t\tconst [values, result] = collect(parser(input, offset));\n\t\t\tif (!result.success) {\n\t\t\t\tif (result.fatal) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\treturn ok(offset);\n\t\t\t}\n\n\t\t\tyield* values;\n\n\t\t\tif (offset === result.offset) {\n\t\t\t\t// Did not advance\n\t\t\t\treturn ok(offset);\n\t\t\t}\n\t\t\toffset = result.offset;\n\t\t}\n\t};\n}\n\n/**\n * Creates a StreamingParser that tries to apply the given parser optionally. It only yields the\n * values produced by the inner parser if it matches successfully, and does not yield anything\n * otherwise.\n *\n * @public\n *\n * @param parser - StreamingParser to attempt to apply\n */\nexport function streamingOptional<T>(parser: StreamingParser<T>): StreamingParser<T> {\n\treturn function* (input: string, offset: number) {\n\t\tconst [values, result] = collect(parser(input, offset));\n\t\tif (!result.success) {\n\t\t\tif (result.fatal) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\treturn ok(offset);\n\t\t}\n\n\t\tyield* values;\n\n\t\treturn result;\n\t};\n}\n\n/**\n * Creates a StreamingParser that applies the given parser and directly yields values produced by\n * it, and then only succeeds if parsing concludes at the end of the input string.\n *\n * @public\n *\n * @param parser - StreamingParser to apply\n */\nexport function streamingComplete<T>(parser: StreamingParser<T>): StreamingParser<T> {\n\treturn function* (input: string, offset: number) {\n\t\tconst res = yield* parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn end(input, res.offset);\n\t};\n}\n","import { end, Parser, ParseResult } from 'prsc';\n\nexport const enum ParserStateType {\n\tone,\n\tstar,\n\toptional,\n}\n\nexport type ParserState<T> = {\n\tparser: Parser<T | void>;\n\ttype: ParserStateType;\n};\n\nexport default class ParserStateMachine<T> implements Iterator<T> {\n\tprivate _states: ParserState<T>[];\n\tprivate _state = 0;\n\n\tprivate _input: string;\n\tprivate _offset = 0;\n\n\tconstructor(input: string, states: ParserState<T>[]) {\n\t\tthis._input = input;\n\t\tthis._states = states;\n\t}\n\n\tpublic next(): IteratorResult<T, ParseResult<unknown>> {\n\t\tif (this._state >= this._states.length) {\n\t\t\treturn { done: true, value: end(this._input, this._offset) };\n\t\t}\n\n\t\tconst { parser, type } = this._states[this._state];\n\t\tconst res = parser(this._input, this._offset);\n\t\tif (!res.success) {\n\t\t\tif (type === ParserStateType.one || res.fatal) {\n\t\t\t\treturn { done: true, value: res };\n\t\t\t}\n\t\t\tthis._state += 1;\n\t\t\treturn this.next();\n\t\t}\n\t\tthis._offset = res.offset;\n\t\tif (type !== ParserStateType.star) {\n\t\t\tthis._state += 1;\n\t\t}\n\t\tif (res.value === undefined) {\n\t\t\treturn this.next();\n\t\t}\n\t\treturn { done: false, value: res.value };\n\t}\n}\n","import {\n\tcodepoint,\n\tcodepoints,\n\tcomplete,\n\tconsume,\n\tcut,\n\tdelimited,\n\tdispatch,\n\texcept,\n\tfilter,\n\tfilterUndefined,\n\tfollowed,\n\tmap,\n\tnot,\n\tokWithValue,\n\toptional,\n\tor,\n\tParser,\n\tParseResult,\n\tpeek,\n\tplusConsumed,\n\tpreceded,\n\trange,\n\trecognize,\n\tsequence,\n\tsequenceConsumed,\n\tstar,\n\tstarConsumed,\n\tthen,\n\ttoken,\n} from 'prsc';\nimport {\n\tAttDefEvent,\n\tAttlistDeclEvent,\n\tAttributeEvent,\n\tAttValueEvent,\n\tCDSectEvent,\n\tCharRefEvent,\n\tCommentEvent,\n\tDefaultDeclEvent,\n\tDefaultDeclType,\n\tDoctypedeclEvent,\n\tDocumentParseEvent,\n\tEmptyElemTagEvent,\n\tEntityDeclEvent,\n\tEntityRefEvent,\n\tEntityValueEvent,\n\tETagEvent,\n\tExternalEntityEvent,\n\tExternalIDEvent,\n\tMarkupdeclEvent,\n\tMarkupdeclEventType,\n\tParserEventType,\n\tPEReferenceEvent,\n\tPIEvent,\n\tReferenceEvent,\n\tSTagEvent,\n\tTextEvent,\n\tWithPosition,\n\tXMLDeclEvent,\n} from './parserEvents';\nimport ParserStateMachine, { ParserState, ParserStateType } from './ParserStateMachine';\n\nfunction withPosition<T>(parser: Parser<T>): Parser<WithPosition<T>> {\n\treturn (input: string, offset: number) => {\n\t\tconst start = offset;\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(res.offset, { input, start, end: res.offset, ...res.value });\n\t};\n}\n\nconst UNDERSCORE = token('_');\nconst DASH = token('-');\nconst PERIOD = token('.');\nconst DOUBLE_QUOTE = token('\"');\nconst SINGLE_QUOTE = token(\"'\");\nconst ANGLE_BRACKET_OPEN = token('<');\nconst ANGLE_BRACKET_CLOSE = token('>');\nconst AMPERSAND = token('&');\nconst EQUALS = token('=');\nconst SQUARE_BRACKET_OPEN = token('[');\nconst SQUARE_BRACKET_CLOSE = token(']');\nconst SEMICOLON = token(';');\nconst PERCENT = token('%');\nconst PARENTHESIS_OPEN = token('(');\nconst PARENTHESIS_CLOSE = token(')');\nconst PLUS = token('+');\nconst COMMA = token(',');\nconst QUESTION_MARK = token('?');\nconst ASTERISK = token('*');\nconst VERTICAL_BAR = token('|');\n\nconst SECT_END = token(']]>');\nconst COMMENT_START = token('<!--');\nconst COMMENT_END = token('-->');\nconst PI_START = token('<?');\nconst PI_END = token('?>');\nconst ONE_POINT = token('1.');\nconst VERSION = token('version');\nconst ENCODING = token('encoding');\nconst STANDALONE = token('standalone');\nconst YES = token('yes');\nconst NO = token('no');\nconst XML_DECL_START = token('<?xml');\nconst DOCTYPE_START = token('<!DOCTYPE');\nconst SYSTEM = token('SYSTEM');\nconst PUBLIC = token('PUBLIC');\nconst ETAG_START = token('</');\nconst EMPTY_ELEMENT_END = token('/>');\nconst CHARREF_START = token('&#');\nconst CHARREF_HEX_START = token('&#x');\nconst ELEMENT_DECL_START = token('<!ELEMENT');\nconst EMPTY = token('EMPTY');\nconst ANY = token('ANY');\nconst PCDATA = token('#PCDATA');\nconst ATTLIST_DECL_START = token('<!ATTLIST');\nconst NOTATION = token('NOTATION');\nconst REQUIRED = token('#REQUIRED');\nconst IMPLIED = token('#IMPLIED');\nconst FIXED = token('#FIXED');\n// const CONDITIONAL_SECT_START = token('<![');\n// const INCLUDE = token('INCLUDE');\n// const IGNORE = token('IGNORE');\nconst ENTITY_DECL_START = token('<!ENTITY');\nconst NDATA = token('NDATA');\nconst NOTATION_DECL_START = token('<!NOTATION');\n\n// A-Z\nconst UPPER_A_CP = 0x41;\nconst UPPER_Z_CP = 0x5a;\nconst UPPER_ALPHA = range(UPPER_A_CP, UPPER_Z_CP);\n\n// a-z\nconst LOWER_A_CP = 0x61;\nconst LOWER_Z_CP = 0x7a;\nconst LOWER_ALPHA = range(LOWER_A_CP, LOWER_Z_CP);\n\n// 0-9\nconst ZERO_CP = 0x30;\nconst NINE_CP = 0x39;\nconst DIGIT = range(ZERO_CP, NINE_CP);\n\nconst HEX_DIGIT = or([DIGIT, range(0x41, 0x46), range(0x61, 0x66)], ['hexadecimal digit']);\n\n// [2] Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]\nfunction isValidChar(cp: number): boolean {\n\treturn (\n\t\tcp === 0x9 ||\n\t\tcp === 0xa ||\n\t\tcp === 0xd ||\n\t\t(0x20 <= cp && cp <= 0xd7ff) ||\n\t\t(0xe000 <= cp && cp <= 0xfffd) ||\n\t\t(0x10000 <= cp && cp <= 0x10ffff)\n\t);\n}\n// const Char = codepoint(isValidChar, ['valid character']);\n\nexport const CompleteChars = complete(codepoints(isValidChar));\n\n// [3] S ::= (#x20 | #x9 | #xD | #xA)+\nfunction isValidWhitespace(cp: number): boolean {\n\treturn cp === 0x20 || cp === 0x9 || cp === 0xd || cp === 0xa;\n}\nconst S = codepoints(isValidWhitespace, ['whitespace']);\n\nexport const CompleteWhitespace = complete(codepoints(isValidWhitespace));\n\n// [4] NameStartChar ::= \":\" | [A-Z] | \"_\" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF]\n//     | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF]\n//     | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\nconst COLON_CP = 0x3a;\nconst UNDERSCORE_CP = 0x5f;\nfunction isValidNameStartChar(cp: number): boolean {\n\treturn (\n\t\tcp === COLON_CP ||\n\t\t(UPPER_A_CP <= cp && cp <= UPPER_Z_CP) ||\n\t\tcp === UNDERSCORE_CP ||\n\t\t(LOWER_A_CP <= cp && cp <= LOWER_Z_CP) ||\n\t\t(0xc0 <= cp && cp <= 0xd6) ||\n\t\t(0xd8 <= cp && cp <= 0xf6) ||\n\t\t(0xf8 <= cp && cp <= 0x2ff) ||\n\t\t(0x370 <= cp && cp <= 0x37d) ||\n\t\t(0x37f <= cp && cp <= 0x1fff) ||\n\t\t(0x200c <= cp && cp <= 0x200d) ||\n\t\t(0x2070 <= cp && cp <= 0x218f) ||\n\t\t(0x2c00 <= cp && cp <= 0x2fef) ||\n\t\t(0x3001 <= cp && cp <= 0xd7ff) ||\n\t\t(0xf900 <= cp && cp <= 0xfdcf) ||\n\t\t(0xfdf0 <= cp && cp <= 0xfffd) ||\n\t\t(0x10000 <= cp && cp <= 0xeffff)\n\t);\n}\nconst NameStartChar = codepoint(isValidNameStartChar, ['valid name start character']);\n\n// [4a] NameChar ::= NameStartChar | \"-\" | \".\" | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]\nconst DASH_CP = 0x2d;\nconst PERIOD_CP = 0x2e;\nfunction isValidNameChar(cp: number): boolean {\n\treturn (\n\t\tisValidNameStartChar(cp) ||\n\t\tcp === DASH_CP ||\n\t\tcp === PERIOD_CP ||\n\t\t(ZERO_CP <= cp && cp <= NINE_CP) ||\n\t\tcp === 0xb7 ||\n\t\t(0x0300 <= cp && cp <= 0x036f) ||\n\t\t(0x203f <= cp && cp <= 0x2040)\n\t);\n}\n// const NameChar = codepoint(isValidNameChar, ['valid name character']);\n\n// [5] Name ::= NameStartChar (NameChar)*\nconst Name = recognize(preceded(NameStartChar, codepoints(isValidNameChar)));\n\nexport const CompleteName = complete(Name);\n\nconst NCName = filter(Name, (name) => !name.includes(':'), ['name must not contain colon'], true);\n\n// [6] Names ::= Name (#x20 Name)*\n// const Names = then(Name, star(preceded(SPACE, Name)), (first, next) => [first, ...next]);\n\n// [7] Nmtoken ::= (NameChar)+\nconst Nmtoken = recognize(codepoints(isValidNameChar, ['valid name character']));\n\n// [8] Nmtokens ::= Nmtoken (#x20 Nmtoken)*\n// const NmTokens = then(Nmtoken, star(preceded(SPACE, Nmtoken)), (first, next) => [first, ...next]);\n\n// [66] CharRef ::= '&#' [0-9]+ ';'\n//      | '&#x' [0-9a-fA-F]+ ';'\nconst CharRef: Parser<CharRefEvent> = withPosition(\n\tmap(\n\t\tfilter(\n\t\t\tor([\n\t\t\t\tmap(\n\t\t\t\t\tdelimited(\n\t\t\t\t\t\tCHARREF_HEX_START,\n\t\t\t\t\t\trecognize(plusConsumed(HEX_DIGIT)),\n\t\t\t\t\t\tSEMICOLON,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t),\n\t\t\t\t\t(n) => parseInt(n, 16)\n\t\t\t\t),\n\t\t\t\tmap(\n\t\t\t\t\tdelimited(CHARREF_START, recognize(plusConsumed(DIGIT)), SEMICOLON, true),\n\t\t\t\t\t(n) => parseInt(n, 10)\n\t\t\t\t),\n\t\t\t]),\n\t\t\t(cp) => isValidChar(cp),\n\t\t\t['character reference must reference a valid character'],\n\t\t\ttrue\n\t\t),\n\t\t(cp) => ({ type: ParserEventType.CharRef, cp })\n\t)\n);\n\n// [68] EntityRef ::= '&' Name ';'\n// Namespaces spec makes this an NCName\nconst EntityRef: Parser<EntityRefEvent> = withPosition(\n\tmap(delimited(AMPERSAND, NCName, cut(SEMICOLON)), (name) => ({\n\t\ttype: ParserEventType.EntityRef,\n\t\tname,\n\t}))\n);\n\n// [67] Reference ::= EntityRef | CharRef\nconst Reference: Parser<ReferenceEvent> = or<ReferenceEvent>([EntityRef, CharRef]);\n\n// [69] PEReference ::= '%' Name ';'\n// Namespaces spec makes this an NCName\nconst PEReference: Parser<PEReferenceEvent> = withPosition(\n\tmap(delimited(PERCENT, NCName, SEMICOLON), (name) => ({\n\t\ttype: ParserEventType.PEReference,\n\t\tname,\n\t}))\n);\n\n// [9] EntityValue ::= '\"' ([^%&\"] | PEReference | Reference)* '\"'\n//     | \"'\" ([^%&'] | PEReference | Reference)* \"'\"\nconst PERCENT_CP = 0x25;\nconst AMPERSAND_CP = 0x26;\nconst EntityValue = or([\n\tdelimited(\n\t\tDOUBLE_QUOTE,\n\t\tstar(\n\t\t\tor<EntityValueEvent>([\n\t\t\t\trecognize(\n\t\t\t\t\tcodepoints(\n\t\t\t\t\t\t(cp) =>\n\t\t\t\t\t\t\tcp !== PERCENT_CP &&\n\t\t\t\t\t\t\tcp !== AMPERSAND_CP &&\n\t\t\t\t\t\t\tcp !== DOUBLE_QUOTE_CP &&\n\t\t\t\t\t\t\tisValidChar(cp),\n\t\t\t\t\t\t[]\n\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\tPEReference,\n\t\t\t\tReference,\n\t\t\t])\n\t\t),\n\t\tDOUBLE_QUOTE,\n\t\ttrue\n\t),\n\tdelimited(\n\t\tSINGLE_QUOTE,\n\t\tstar(\n\t\t\tor<EntityValueEvent>([\n\t\t\t\trecognize(\n\t\t\t\t\tcodepoints(\n\t\t\t\t\t\t(cp) =>\n\t\t\t\t\t\t\tcp !== PERCENT_CP &&\n\t\t\t\t\t\t\tcp !== AMPERSAND_CP &&\n\t\t\t\t\t\t\tcp !== SINGLE_QUOTE_CP &&\n\t\t\t\t\t\t\tisValidChar(cp),\n\t\t\t\t\t\t[]\n\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\tPEReference,\n\t\t\t\tReference,\n\t\t\t])\n\t\t),\n\t\tSINGLE_QUOTE,\n\t\ttrue\n\t),\n]);\n\n// [10] AttValue ::= '\"' ([^<&\"] | Reference)* '\"'\n//      | \"'\" ([^<&'] | Reference)* \"'\"\nconst DOUBLE_QUOTE_CP = 0x22;\nconst SINGLE_QUOTE_CP = 0x27;\nconst AttValue: Parser<AttValueEvent[]> = dispatch(\n\t{\n\t\t[DOUBLE_QUOTE_CP]: delimited(\n\t\t\tDOUBLE_QUOTE,\n\t\t\tstar(\n\t\t\t\tdispatch<AttValueEvent>(\n\t\t\t\t\t{\n\t\t\t\t\t\t[AMPERSAND_CP]: Reference,\n\t\t\t\t\t},\n\t\t\t\t\trecognize(\n\t\t\t\t\t\tcodepoints(\n\t\t\t\t\t\t\t(cp) =>\n\t\t\t\t\t\t\t\tcp !== ANGLE_BRACKET_OPEN_CP &&\n\t\t\t\t\t\t\t\tcp !== AMPERSAND_CP &&\n\t\t\t\t\t\t\t\tcp !== DOUBLE_QUOTE_CP &&\n\t\t\t\t\t\t\t\tisValidChar(cp),\n\t\t\t\t\t\t\t[]\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t),\n\t\t\tDOUBLE_QUOTE,\n\t\t\ttrue\n\t\t),\n\t\t[SINGLE_QUOTE_CP]: delimited(\n\t\t\tSINGLE_QUOTE,\n\t\t\tstar(\n\t\t\t\tdispatch<AttValueEvent>(\n\t\t\t\t\t{\n\t\t\t\t\t\t[AMPERSAND_CP]: Reference,\n\t\t\t\t\t},\n\t\t\t\t\trecognize(\n\t\t\t\t\t\tcodepoints(\n\t\t\t\t\t\t\t(cp) =>\n\t\t\t\t\t\t\t\tcp !== ANGLE_BRACKET_OPEN_CP &&\n\t\t\t\t\t\t\t\tcp !== AMPERSAND_CP &&\n\t\t\t\t\t\t\t\tcp !== SINGLE_QUOTE_CP &&\n\t\t\t\t\t\t\t\tisValidChar(cp),\n\t\t\t\t\t\t\t[]\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t),\n\t\t\tSINGLE_QUOTE,\n\t\t\ttrue\n\t\t),\n\t},\n\tundefined,\n\t0,\n\t['quoted attribute value']\n);\n\nexport const EntityReplacementTextInLiteral = complete(\n\tstar(\n\t\tor<AttValueEvent>([\n\t\t\trecognize(\n\t\t\t\tcodepoints(\n\t\t\t\t\t(cp) => cp !== ANGLE_BRACKET_OPEN_CP && cp !== AMPERSAND_CP && isValidChar(cp),\n\t\t\t\t\t[]\n\t\t\t\t)\n\t\t\t),\n\t\t\tReference,\n\t\t])\n\t)\n);\n\n// [11] SystemLiteral ::= ('\"' [^\"]* '\"') | (\"'\" [^']* \"'\")\nconst SystemLiteral = filter(\n\tor([\n\t\tdelimited(\n\t\t\tDOUBLE_QUOTE,\n\t\t\trecognize(codepoints((cp) => cp !== DOUBLE_QUOTE_CP && isValidChar(cp))),\n\t\t\tDOUBLE_QUOTE\n\t\t),\n\t\tdelimited(\n\t\t\tSINGLE_QUOTE,\n\t\t\trecognize(codepoints((cp) => cp !== SINGLE_QUOTE_CP && isValidChar(cp))),\n\t\t\tSINGLE_QUOTE\n\t\t),\n\t]),\n\t(systemId) => !systemId.includes('#'),\n\t['system identifier must not contain a fragment identifier'],\n\ttrue\n);\n\n// [13] PubidChar ::= #x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]\nfunction isValidPubidChar(cp: number): boolean {\n\treturn (\n\t\tcp === 0x20 ||\n\t\tcp === 0xd ||\n\t\tcp === 0xa ||\n\t\t(LOWER_A_CP <= cp && cp <= LOWER_Z_CP) ||\n\t\t(UPPER_A_CP <= cp && cp <= UPPER_Z_CP) ||\n\t\t(ZERO_CP <= cp && cp <= NINE_CP) ||\n\t\t(0x21 <= cp && cp <= 0x2f && cp !== 0x22 && cp !== 0x26) ||\n\t\t(0x3a <= cp && cp <= 0x40 && cp !== 0x3c && cp !== 0x3e) ||\n\t\tcp === 0x5f\n\t);\n}\n// const PubidChar = codepoint(isValidPubidChar, ['valid public ID character']);\n\nexport const CompletePubidChars = complete(codepoints(isValidPubidChar));\n\n// [12] PubidLiteral ::= '\"' PubidChar* '\"' | \"'\" (PubidChar - \"'\")* \"'\"\nconst PubidLiteral = or([\n\tdelimited(\n\t\tDOUBLE_QUOTE,\n\t\trecognize(codepoints((cp) => cp !== DOUBLE_QUOTE_CP && isValidPubidChar(cp))),\n\t\tDOUBLE_QUOTE,\n\t\ttrue\n\t),\n\tdelimited(\n\t\tSINGLE_QUOTE,\n\t\trecognize(codepoints((cp) => cp !== SINGLE_QUOTE_CP && isValidPubidChar(cp))),\n\t\tSINGLE_QUOTE,\n\t\ttrue\n\t),\n]);\n\n// [14] CharData ::= [^<&]* - ([^<&]* ']]>' [^<&]*)\n// CharData is only ever used as optional, it doesn't make sense to have it accept the empty string\n// For efficiency, hardcode the disallowed codepoints\nconst ANGLE_BRACKET_OPEN_CP = 0x3c;\nconst SQUARE_BRACKET_CLOSE_CP = 0x5d;\nconst CharData: Parser<TextEvent> = recognize(\n\tplusConsumed(\n\t\tor(\n\t\t\t[\n\t\t\t\t// Fast path: filtered codepoints\n\t\t\t\tcodepoints(\n\t\t\t\t\t(cp) =>\n\t\t\t\t\t\tcp !== ANGLE_BRACKET_OPEN_CP &&\n\t\t\t\t\t\tcp !== AMPERSAND_CP &&\n\t\t\t\t\t\tcp !== SQUARE_BRACKET_CLOSE_CP &&\n\t\t\t\t\t\tisValidChar(cp),\n\t\t\t\t\t[]\n\t\t\t\t),\n\t\t\t\t// Square bracket is allowed if it's not a SECT_END\n\t\t\t\texcept(consume(SQUARE_BRACKET_CLOSE), SECT_END, []),\n\t\t\t],\n\t\t\t['character data']\n\t\t)\n\t)\n);\n\n// [15] Comment ::= '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->'\nconst Comment: Parser<CommentEvent> = map(\n\tdelimited(\n\t\tCOMMENT_START,\n\t\trecognize(\n\t\t\tstarConsumed(\n\t\t\t\tor([\n\t\t\t\t\t// Fast path - any Char except \"-\"\n\t\t\t\t\tcodepoints((cp) => cp !== DASH_CP && isValidChar(cp), []),\n\t\t\t\t\t// Dash may not be followed by another dash\n\t\t\t\t\tfollowed(consume(DASH), not(DASH, ['comment content may not contain --'])),\n\t\t\t\t])\n\t\t\t)\n\t\t),\n\t\tCOMMENT_END,\n\t\ttrue\n\t),\n\t(data) => ({ type: ParserEventType.Comment, data })\n);\n// [17] PITarget ::= Name - (('X' | 'x') ('M' | 'm') ('L' | 'l'))\n// Namespaces spec makes this an NCName\nconst PITarget = filter(\n\tNCName,\n\t(target) => target.toLowerCase() !== 'xml',\n\t['processing instruction target must not be \"xml\"'],\n\ttrue\n);\n\n// [16] PI ::= '<?' PITarget (S (Char* - (Char* '?>' Char*)))? '?>'\nconst QUESTION_MARK_CP = 0x3f;\nconst PI: Parser<PIEvent> = delimited(\n\tPI_START,\n\tthen(\n\t\tPITarget,\n\t\toptional(\n\t\t\tpreceded(\n\t\t\t\tS,\n\t\t\t\trecognize(\n\t\t\t\t\tstarConsumed(\n\t\t\t\t\t\tor([\n\t\t\t\t\t\t\t// Fast path - any Char except \"?\"\n\t\t\t\t\t\t\tcodepoints((cp) => cp !== QUESTION_MARK_CP && isValidChar(cp), []),\n\t\t\t\t\t\t\t// Question mark must not be part of \"?>\"\n\t\t\t\t\t\t\tfollowed(consume(QUESTION_MARK), not(ANGLE_BRACKET_CLOSE, ['PI data'])),\n\t\t\t\t\t\t])\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t(target, data) => ({ type: ParserEventType.PI, target, data })\n\t),\n\tPI_END,\n\ttrue\n);\n\n// [19] CDStart ::= '<![CDATA['\nconst CDStart = token('<![CDATA[');\n\n// [20] CData ::= (Char* - (Char* ']]>' Char*))\nconst CData = recognize(\n\tstarConsumed(\n\t\tor([\n\t\t\t// Fast path - any Char except ]\n\t\t\tcodepoints((cp) => cp !== SQUARE_BRACKET_CLOSE_CP && isValidChar(cp), []),\n\t\t\texcept(consume(SQUARE_BRACKET_CLOSE), SECT_END, ['CData']),\n\t\t])\n\t)\n);\n\n// [21] CDEnd ::= ']]>'\nconst CDEnd = SECT_END;\n\n// [18] CDSect ::= CDStart CData CDEnd\nconst CDSect: Parser<CDSectEvent> = withPosition(\n\tmap(delimited(CDStart, CData, CDEnd, true), (data) => ({\n\t\ttype: ParserEventType.CDSect,\n\t\tdata,\n\t}))\n);\n\n// [25] Eq ::= S? '=' S?\nconst Eq = delimited(optional(S), EQUALS, optional(S));\n\n// [26] VersionNum ::= '1.' [0-9]+\nconst VersionNum = recognize(preceded(ONE_POINT, plusConsumed(DIGIT)));\n\n// [24] VersionInfo ::= S 'version' Eq (\"'\" VersionNum \"'\" | '\"' VersionNum '\"')\nconst VersionInfo = preceded(\n\tS,\n\tpreceded(\n\t\tVERSION,\n\t\tpreceded(\n\t\t\tEq,\n\t\t\tor([\n\t\t\t\tdelimited(DOUBLE_QUOTE, VersionNum, DOUBLE_QUOTE, true),\n\t\t\t\tdelimited(SINGLE_QUOTE, VersionNum, SINGLE_QUOTE, true),\n\t\t\t])\n\t\t)\n\t)\n);\n\n// [81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*\nconst EncName = recognize(\n\tpreceded(\n\t\tor([UPPER_ALPHA, LOWER_ALPHA]),\n\t\tstarConsumed(\n\t\t\tor([\n\t\t\t\tUPPER_ALPHA,\n\t\t\t\tLOWER_ALPHA,\n\t\t\t\tDIGIT,\n\t\t\t\tconsume(PERIOD),\n\t\t\t\tconsume(UNDERSCORE),\n\t\t\t\tconsume(DASH),\n\t\t\t])\n\t\t)\n\t)\n);\n\n// [80] EncodingDecl ::= S 'encoding' Eq ('\"' EncName '\"' | \"'\" EncName \"'\" )\nconst EncodingDecl = preceded(\n\tS,\n\tpreceded(\n\t\tENCODING,\n\t\tpreceded(\n\t\t\tEq,\n\t\t\tor([\n\t\t\t\tdelimited(DOUBLE_QUOTE, EncName, DOUBLE_QUOTE, true),\n\t\t\t\tdelimited(SINGLE_QUOTE, EncName, SINGLE_QUOTE, true),\n\t\t\t])\n\t\t)\n\t)\n);\n\n// [32] SDDecl ::= S 'standalone' Eq ((\"'\" ('yes' | 'no') \"'\") | ('\"' ('yes' | 'no') '\"'))\nconst YesOrNo = or([map(YES, () => true), map(NO, () => false)]);\nconst SDDecl = preceded(\n\tS,\n\tpreceded(\n\t\tSTANDALONE,\n\t\tcut(\n\t\t\tpreceded(\n\t\t\t\tEq,\n\t\t\t\tor([\n\t\t\t\t\tdelimited(DOUBLE_QUOTE, YesOrNo, DOUBLE_QUOTE, true),\n\t\t\t\t\tdelimited(SINGLE_QUOTE, YesOrNo, SINGLE_QUOTE, true),\n\t\t\t\t])\n\t\t\t)\n\t\t)\n\t)\n);\n\n// [23] XMLDecl ::= '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'\nconst XMLDecl: Parser<XMLDeclEvent> = delimited(\n\t// PIs may also start with <?xml, but may never have their target be just 'xml'\n\t// We can therefore consider it a fatal error if parsing fails after the space\n\tfollowed(XML_DECL_START, peek(S)),\n\tfollowed(\n\t\tthen(\n\t\t\tVersionInfo,\n\t\t\tthen(optional(EncodingDecl), optional(SDDecl), (e, s) => [e, s] as const),\n\t\t\t(version, [encoding, standalone]) => ({\n\t\t\t\ttype: ParserEventType.XMLDecl,\n\t\t\t\tversion,\n\t\t\t\tencoding,\n\t\t\t\tstandalone,\n\t\t\t})\n\t\t),\n\t\toptional(S)\n\t),\n\tPI_END,\n\ttrue\n);\n\nconst NameWithPosition = withPosition(map(Name, (name) => ({ name })));\n\n// [41] Attribute ::= Name Eq AttValue\nconst Attribute: Parser<AttributeEvent> = then(\n\tNameWithPosition,\n\tpreceded(cut(Eq), cut(AttValue)),\n\t(name, value) => ({\n\t\tname,\n\t\tvalue,\n\t})\n);\n\n// [40] STag ::= '<' Name (S Attribute)* S? '>'\n// [44] EmptyElemTag ::= '<' Name (S Attribute)* S? '/>'\n// Combined to avoid reparsing all of the attributes when a tag turns out to be empty\nconst Attributes = followed(star(preceded(S, Attribute)), optional(S));\n\nconst SOLIDUS_CP = 0x2f;\nconst STagOrEmptyElemTag: Parser<STagEvent | EmptyElemTagEvent> = map(\n\tsequence(\n\t\tANGLE_BRACKET_OPEN,\n\t\tNameWithPosition,\n\t\tcut(Attributes),\n\t\tcut(\n\t\t\tdispatch(\n\t\t\t\t{ [SOLIDUS_CP]: map(EMPTY_ELEMENT_END, () => true) },\n\t\t\t\tmap(ANGLE_BRACKET_CLOSE, () => false),\n\t\t\t\t0,\n\t\t\t\t['>', '/>']\n\t\t\t)\n\t\t)\n\t),\n\t([_, name, attributes, isEmpty]) => ({\n\t\ttype: isEmpty ? ParserEventType.EmptyElemTag : ParserEventType.STag,\n\t\tname,\n\t\tattributes,\n\t})\n);\n\n// [42] ETag ::= '</' Name S? '>'\nconst ETag: Parser<ETagEvent> = withPosition(\n\tmap(delimited(ETAG_START, followed(Name, optional(S)), ANGLE_BRACKET_CLOSE, true), (name) => ({\n\t\ttype: ParserEventType.ETag,\n\t\tname,\n\t}))\n);\n\nconst Multiplicity = or([QUESTION_MARK, ASTERISK, PLUS]);\n\n// [48] cp ::= (Name | choice | seq) ('?' | '*' | '+')?\nconst cp = followed(\n\tor([consume(Name), choiceIndirect, seqIndirect]),\n\tconsume(optional(Multiplicity))\n);\n\n// [49] choice ::= '(' S? cp ( S? '|' S? cp )+ S? ')'\nconst choice = sequenceConsumed(\n\tPARENTHESIS_OPEN,\n\toptional(S),\n\tcp,\n\tplusConsumed(sequence(optional(S), VERTICAL_BAR, optional(S), cut(cp))),\n\toptional(S),\n\tPARENTHESIS_CLOSE\n);\n\nfunction choiceIndirect(input: string, offset: number): ParseResult<void> {\n\treturn choice(input, offset);\n}\n\n// [50] seq ::= '(' S? cp ( S? ',' S? cp )* S? ')'\nconst seq = sequenceConsumed(\n\tPARENTHESIS_OPEN,\n\toptional(S),\n\tcp,\n\tstarConsumed(sequence(optional(S), COMMA, optional(S), cut(cp))),\n\toptional(S),\n\tPARENTHESIS_CLOSE\n);\n\nfunction seqIndirect(input: string, offset: number): ParseResult<void> {\n\treturn seq(input, offset);\n}\n\n// [47] children ::= (choice | seq) ('?' | '*' | '+')?\nconst children = followed(or([choice, seq]), optional(Multiplicity));\n\n// [51] Mixed ::= '(' S? '#PCDATA' (S? '|' S? Name)* S? ')*'\n//      | '(' S? '#PCDATA' S? ')'\nconst Mixed = sequenceConsumed(\n\tPARENTHESIS_OPEN,\n\toptional(S),\n\tPCDATA,\n\tor([\n\t\tsequenceConsumed(\n\t\t\tstarConsumed(sequenceConsumed(optional(S), VERTICAL_BAR, optional(S), Name)),\n\t\t\toptional(S),\n\t\t\tPARENTHESIS_CLOSE,\n\t\t\tASTERISK\n\t\t),\n\t\tconsume(followed(optional(S), PARENTHESIS_CLOSE)),\n\t])\n);\n\n// [46] contentspec ::= 'EMPTY' | 'ANY' | Mixed | children\nconst contentspec = or([consume(EMPTY), consume(ANY), consume(Mixed), consume(children)]);\n\n// [45] elementdecl ::= '<!ELEMENT' S Name S contentspec S? '>'\nconst elementdecl = followed(\n\tELEMENT_DECL_START,\n\tcut(sequenceConsumed(S, Name, S, contentspec, optional(S), ANGLE_BRACKET_CLOSE))\n);\n\n// [55] StringType ::= 'CDATA'\nconst StringType = token('CDATA');\n\n// [56] TokenizedType ::= 'ID'\n//      | 'IDREF'\n//      | 'IDREFS'\n//      | 'ENTITY'\n//      | 'ENTITIES'\n//      | 'NMTOKEN'\n//      | 'NMTOKENS'\n// Ordering is important here as some tokens are prefixes of others and we want the longest match\nconst TokenizedType = or([\n\ttoken('IDREFS'),\n\ttoken('IDREF'),\n\ttoken('ID'),\n\ttoken('ENTITY'),\n\ttoken('ENTITIES'),\n\ttoken('NMTOKENS'),\n\ttoken('NMTOKEN'),\n]);\n\n// [58] NotationType ::= 'NOTATION' S '(' S? Name (S? '|' S? Name)* S? ')'\n// Namespaces spec makes this use NCName\nconst NotationType = followed(\n\tNOTATION,\n\tcut(\n\t\tsequenceConsumed(\n\t\t\tS,\n\t\t\tPARENTHESIS_OPEN,\n\t\t\toptional(S),\n\t\t\tNCName,\n\t\t\tstarConsumed(sequenceConsumed(optional(S), VERTICAL_BAR, optional(S), NCName)),\n\t\t\toptional(S),\n\t\t\tPARENTHESIS_CLOSE\n\t\t)\n\t)\n);\n\n// [59] Enumeration ::= '(' S? Nmtoken (S? '|' S? Nmtoken)* S? ')'\nconst Enumeration = followed(\n\tPARENTHESIS_OPEN,\n\tcut(\n\t\tsequenceConsumed(\n\t\t\toptional(S),\n\t\t\tNmtoken,\n\t\t\tstarConsumed(sequenceConsumed(optional(S), VERTICAL_BAR, optional(S), Nmtoken)),\n\t\t\toptional(S),\n\t\t\tPARENTHESIS_CLOSE\n\t\t)\n\t)\n);\n\n// [57] EnumeratedType ::= NotationType | Enumeration\nconst EnumeratedType = or([NotationType, Enumeration]);\n\n// [54] AttType ::= StringType | TokenizedType | EnumeratedType\n// We only need to know whether the attribute's type is 'CDATA'\nconst AttType = or([\n\tmap(StringType, () => true),\n\tmap(TokenizedType, () => false),\n\tmap(EnumeratedType, () => false),\n]);\n\n// [60] DefaultDecl ::= '#REQUIRED' | '#IMPLIED'\n//      | (('#FIXED' S)? AttValue)\nconst DefaultDecl = or<DefaultDeclEvent>([\n\tmap(REQUIRED, () => ({ type: DefaultDeclType.REQUIRED })),\n\tmap(IMPLIED, () => ({ type: DefaultDeclType.IMPLIED })),\n\tthen(\n\t\tmap(optional(followed(FIXED, S)), (v) => v !== null),\n\t\tAttValue,\n\t\t(fixed, value) => ({ type: DefaultDeclType.VALUE, fixed, value })\n\t),\n]);\n\n// [53] AttDef ::= S Name S AttType S DefaultDecl\nconst AttDef: Parser<AttDefEvent> = then(\n\tpreceded(S, NameWithPosition),\n\tcut(then(preceded(S, AttType), preceded(S, DefaultDecl), (isCData, def) => ({ isCData, def }))),\n\t(name, { isCData, def }) => ({ name, isCData, def })\n);\n\n// [52] AttlistDecl ::= '<!ATTLIST' S Name AttDef* S? '>'\nconst AttlistDecl: Parser<AttlistDeclEvent> = delimited(\n\tfollowed(ATTLIST_DECL_START, S),\n\tthen(Name, cut(star(AttDef)), (name, attdefs) => ({\n\t\ttype: MarkupdeclEventType.AttlistDecl,\n\t\tname,\n\t\tattdefs,\n\t})),\n\tpreceded(optional(S), ANGLE_BRACKET_CLOSE),\n\ttrue\n);\n\n// [62] includeSect ::= '<![' S? 'INCLUDE' S? '[' extSubsetDecl ']]>'\n// const includeSect = delimited(\n// \tdelimited(\n// \t\tCONDITIONAL_SECT_START,\n// \t\tdelimited(optional(S), INCLUDE, optional(S)),\n// \t\tSQUARE_BRACKET_OPEN\n// \t),\n// \textSubsetDeclIndirect,\n// \tSECT_END\n// );\n\n// [65] Ignore ::= Char* - (Char* ('<![' | ']]>') Char*)\n// const Ignore = star(except(Char, or([CONDITIONAL_SECT_START, SECT_END]), ['ignore sect contents']));\n\n// [64] ignoreSectContents ::= Ignore ('<![' ignoreSectContents ']]>' Ignore)*\n// const ignoreSectContents = then(\n// \tIgnore,\n// \tstar(\n// \t\tthen(\n// \t\t\tdelimited(CONDITIONAL_SECT_START, ignoreSectContentsIndirect, SECT_END),\n// \t\t\tIgnore,\n// \t\t\t() => undefined\n// \t\t)\n// \t),\n// \t() => undefined\n// );\n\n// function ignoreSectContentsIndirect(input: string, offset: number): ParseResult<void> {\n// \treturn ignoreSectContents(input, offset);\n// }\n\n// [63] ignoreSect ::= '<![' S? 'IGNORE' S? '[' ignoreSectContents* ']]>'\n// const ignoreSect = delimited(\n// \tdelimited(\n// \t\tCONDITIONAL_SECT_START,\n// \t\tdelimited(optional(S), IGNORE, optional(S)),\n// \t\tSQUARE_BRACKET_OPEN\n// \t),\n// \tstar(ignoreSectContents),\n// \tSECT_END\n// );\n\n// [61] conditionalSect ::= includeSect | ignoreSect\n// const conditionalSect = or([consume(includeSect), consume(ignoreSect)]);\n\n// [75] ExternalID ::= 'SYSTEM' S SystemLiteral\n//      | 'PUBLIC' S PubidLiteral S SystemLiteral\nconst ExternalID: Parser<ExternalIDEvent> = or<ExternalIDEvent>([\n\tmap(preceded(SYSTEM, cut(preceded(S, SystemLiteral))), (systemId) => ({\n\t\tpublicId: null,\n\t\tsystemId,\n\t})),\n\tpreceded(\n\t\tPUBLIC,\n\t\tthen(cut(preceded(S, PubidLiteral)), preceded(S, SystemLiteral), (publicId, systemId) => ({\n\t\t\tpublicId,\n\t\t\tsystemId,\n\t\t}))\n\t),\n]);\n\n// [76] NDataDecl ::= S 'NDATA' S Name\n// Namespaces spec makes this an NCName\nconst NDataDecl = preceded(delimited(S, NDATA, S), NCName);\n\n// [73] EntityDef ::= EntityValue | (ExternalID NDataDecl?)\nconst EntityDef = or<EntityValueEvent[] | ExternalEntityEvent>([\n\tEntityValue,\n\tthen(ExternalID, optional(NDataDecl), (ids, ndata) => ({\n\t\tids,\n\t\tndata,\n\t})),\n]);\n\n// [71] GEDecl ::= '<!ENTITY' S Name S EntityDef S? '>'\n// Namespaces spec makes this an NCName\nconst GEDecl: Parser<EntityDeclEvent | void> = delimited(\n\tENTITY_DECL_START,\n\tthen(preceded(S, NCName), cut(preceded(S, EntityDef)), (name, value) => ({\n\t\ttype: MarkupdeclEventType.GEDecl,\n\t\tname,\n\t\tvalue,\n\t})),\n\tpreceded(optional(S), ANGLE_BRACKET_CLOSE)\n);\n\n// [74] PEDef ::= EntityValue | ExternalID\nconst PEDef = or<EntityValueEvent[] | void>([EntityValue, consume(ExternalID)]);\n\n// [72] PEDecl ::= '<!ENTITY' S '%' S Name S PEDef S? '>'\n// Namespaces spec makes this an NCName\nconst PEDecl: Parser<EntityDeclEvent | void> = delimited(\n\tfollowed(ENTITY_DECL_START, preceded(S, PERCENT)),\n\tthen(preceded(S, NCName), cut(preceded(S, PEDef)), (name, value) =>\n\t\tvalue\n\t\t\t? {\n\t\t\t\t\ttype: MarkupdeclEventType.PEDecl,\n\t\t\t\t\tname,\n\t\t\t\t\tvalue,\n\t\t\t  }\n\t\t\t: undefined\n\t),\n\tpreceded(optional(S), ANGLE_BRACKET_CLOSE),\n\ttrue\n);\n\n// [70] EntityDecl ::= GEDecl | PEDecl\nconst EntityDecl = preceded(peek(ENTITY_DECL_START), cut(or([GEDecl, PEDecl])));\n\n// [77] TextDecl ::= '<?xml' VersionInfo? EncodingDecl S? '?>'\nconst TextDecl: Parser<XMLDeclEvent> = delimited(\n\t// PIs may also start with <?xml, but may never have their target be just 'xml'\n\t// We can therefore consider it a fatal error if parsing fails after the space\n\tfollowed(XML_DECL_START, peek(S)),\n\tfollowed(\n\t\tthen(optional(VersionInfo), EncodingDecl, (version, encoding) => ({\n\t\t\ttype: ParserEventType.XMLDecl,\n\t\t\tversion,\n\t\t\tencoding,\n\t\t\tstandalone: null,\n\t\t})),\n\t\toptional(S)\n\t),\n\tPI_END,\n\ttrue\n);\n\n// [83] PublicID ::= 'PUBLIC' S PubidLiteral\nconst PublicID: Parser<ExternalIDEvent> = map(\n\tfollowed(followed(PUBLIC, S), cut(PubidLiteral)),\n\t(publicId) => ({ publicId, systemId: null })\n);\n\n// [82] NotationDecl ::= '<!NOTATION' S Name S (ExternalID | PublicID) S? '>'\n// Namespaces spec makes this an NCName\nconst NotationDecl = delimited(\n\tNOTATION_DECL_START,\n\tthen(delimited(S, NCName, S), or([consume(ExternalID), consume(PublicID)]), () => undefined),\n\tpreceded(optional(S), ANGLE_BRACKET_CLOSE),\n\ttrue\n);\n\n// [29] markupdecl ::= elementdecl | AttlistDecl | EntityDecl | NotationDecl | PI | Comment\nconst markupdecl = or<MarkupdeclEvent | void>([\n\tconsume(elementdecl),\n\tAttlistDecl,\n\tEntityDecl,\n\tconsume(NotationDecl),\n\tconsume(PI),\n\tconsume(Comment),\n]);\n\n// [28a] DeclSep ::= PEReference | S\nconst DeclSep = or([consume(PEReference), consume(S)]);\n\n// [28b] intSubset ::= (markupdecl | DeclSep)*\nconst intSubset: Parser<MarkupdeclEvent[]> = filterUndefined(\n\tstar(or<MarkupdeclEvent | void>([markupdecl, DeclSep]))\n);\n\n// [31] extSubsetDecl ::= ( markupdecl | conditionalSect | DeclSep)*\n// const extSubsetDecl = star(or([consume(markupdecl), consume(conditionalSect), consume(DeclSep)]));\n\n// function extSubsetDeclIndirect(input: string, offset: number): ParseResult<void> {\n// \treturn extSubset(input, offset);\n// }\n\n// [30] extSubset ::= TextDecl? extSubsetDecl\n// TODO: productions for the external subset apply after parameter entity references are included\n// const extSubset = then(optional(TextDecl), extSubsetDecl, () => undefined);\n\n// [28] doctypedecl ::= '<!DOCTYPE' S Name (S ExternalID)? S? ('[' intSubset ']' S?)? '>'\nconst doctypedecl: Parser<DoctypedeclEvent> = preceded(\n\tDOCTYPE_START,\n\tcut(\n\t\tmap(\n\t\t\tsequence(\n\t\t\t\tS,\n\t\t\t\tName,\n\t\t\t\toptional(preceded(S, ExternalID)),\n\t\t\t\toptional(S),\n\t\t\t\toptional(\n\t\t\t\t\tfollowed(\n\t\t\t\t\t\tdelimited(SQUARE_BRACKET_OPEN, intSubset, SQUARE_BRACKET_CLOSE, true),\n\t\t\t\t\t\toptional(S)\n\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\tANGLE_BRACKET_CLOSE\n\t\t\t),\n\t\t\t([_1, name, ids, _2, intSubset, _3]) => ({\n\t\t\t\ttype: ParserEventType.Doctypedecl,\n\t\t\t\tname,\n\t\t\t\tids,\n\t\t\t\tintSubset,\n\t\t\t})\n\t\t)\n\t)\n);\n\n// [43] content ::= CharData? ((element | Reference | CDSect | PI | Comment) CharData?)*\n// Here's where we deviate a little from the spec grammar in order to avoid the recursion around\n// elements. Instead, consider start and end tags as separate events and handle / check nesting in\n// the caller. CharData is already greedy, so we can include it into the big or.\nconst EXCLAMATION_MARK_CP = 0x21;\nconst contentEvent = dispatch<DocumentParseEvent>(\n\t{\n\t\t[ANGLE_BRACKET_OPEN_CP]: dispatch<DocumentParseEvent>(\n\t\t\t{\n\t\t\t\t[SOLIDUS_CP]: ETag,\n\t\t\t\t[EXCLAMATION_MARK_CP]: or<CommentEvent | CDSectEvent>([Comment, CDSect]),\n\t\t\t\t[QUESTION_MARK_CP]: PI,\n\t\t\t},\n\t\t\tSTagOrEmptyElemTag,\n\t\t\t1\n\t\t),\n\t\t[AMPERSAND_CP]: Reference,\n\t},\n\tCharData\n);\n\nconst content: ParserState<DocumentParseEvent> = {\n\tparser: contentEvent,\n\ttype: ParserStateType.star,\n};\n\nexport function parseContent(input: string): Iterator<DocumentParseEvent> {\n\treturn new ParserStateMachine(input, [content]);\n}\n\n// [27] Misc ::= Comment | PI | S\nconst Misc = or<CommentEvent | PIEvent | void>([Comment, PI, S]);\n\n// [22] prolog ::= XMLDecl? Misc* (doctypedecl Misc*)?\nconst prolog: ParserState<DocumentParseEvent>[] = [\n\t{ parser: XMLDecl, type: ParserStateType.optional },\n\t{ parser: Misc, type: ParserStateType.star },\n\t{ parser: doctypedecl, type: ParserStateType.optional },\n\t{ parser: Misc, type: ParserStateType.star },\n];\n\n// [39] element ::= EmptyElemTag\n//      | STag content ETag\n// Simplified a bit, balancing of tags is checked in the parse loop\nconst element: ParserState<DocumentParseEvent>[] = [\n\t{ parser: STagOrEmptyElemTag, type: ParserStateType.one },\n\tcontent,\n];\n\n// [1] document ::= prolog element Misc*\n// As element leads to content, which is a superset of Misc*, we can omit the last Misc*\nconst document: ParserState<DocumentParseEvent>[] = [...prolog, ...element];\n\nexport function parseDocument(input: string): Iterator<DocumentParseEvent> {\n\treturn new ParserStateMachine(input, document);\n}\n\n// [78] extParsedEnt ::= TextDecl? content\nconst extParsedEnt: ParserState<DocumentParseEvent>[] = [\n\t{ parser: TextDecl, type: ParserStateType.optional },\n\tcontent,\n];\n\nexport function parseFragment(input: string): Iterator<DocumentParseEvent> {\n\treturn new ParserStateMachine(input, extParsedEnt);\n}\n","import Document from '../Document';\nimport DocumentFragment from '../DocumentFragment';\nimport Node from '../Node';\nimport { unsafeCreateAttribute, unsafeCreateElement } from '../unsafe';\nimport { appendAttribute } from '../util/attrMutations';\nimport { insertNode } from '../util/mutationAlgorithms';\nimport { XMLNS_NAMESPACE, XML_NAMESPACE } from '../util/namespaceHelpers';\nimport { isElement } from '../util/NodeType';\nimport { getNodeDocument } from '../util/treeHelpers';\nimport {\n\tCompleteChars,\n\tCompleteName,\n\tCompletePubidChars,\n\tCompleteWhitespace,\n\tEntityReplacementTextInLiteral,\n\tparseContent,\n\tparseDocument,\n\tparseFragment,\n} from './grammar';\nimport {\n\tAttDefEvent,\n\tAttValueEvent,\n\tDefaultDeclType,\n\tDoctypedeclEvent,\n\tDocumentParseEvent,\n\tEmptyElemTagEvent,\n\tEntityRefEvent,\n\tEntityValueEvent,\n\tMarkupdeclEventType,\n\tParserEventType,\n\tSTagEvent,\n\tWithPosition,\n} from './parserEvents';\n\nfunction offsetToCoords(input: string, offset: number): { line: number; char: number } {\n\t// Assumes normalized line endings\n\tlet line = 1;\n\tlet char = 1;\n\tlet i = 0;\n\twhile (i < offset) {\n\t\tconst cp = input.codePointAt(i)!;\n\t\tconst l = cp > 0xffff ? 2 : 1;\n\t\tchar++;\n\t\ti += l;\n\t\tif (cp === 0xa) {\n\t\t\tline++;\n\t\t\tchar = 1;\n\t\t}\n\t}\n\treturn { line, char };\n}\n\nfunction replaceInvalidCharacters(input: string): string {\n\treturn Array.from(input, (char) =>\n\t\tmatchesCharProduction(char) ? char : '[invalid character]'\n\t).join('');\n}\n\nconst enum TruncateSide {\n\tStart,\n\tEnd,\n\tInside,\n}\n\nfunction truncate(input: string, side: TruncateSide, max: number): string {\n\tconst ELLIPSIS = '\\u{2026}';\n\tconst chars = Array.from(input);\n\tif (chars.length < max) {\n\t\treturn input;\n\t}\n\tswitch (side) {\n\t\tcase TruncateSide.Start:\n\t\t\treturn ELLIPSIS + chars.slice(-max).join('');\n\t\tcase TruncateSide.End:\n\t\t\treturn chars.slice(0, max).join('') + ELLIPSIS;\n\t}\n\tconst halfLength = Math.min(chars.length / 2, max / 2) | 0;\n\treturn chars.slice(0, halfLength).join('') + ELLIPSIS + chars.slice(-halfLength).join('');\n}\n\nfunction highlightError(input: string, start: number, end: number): string {\n\tconst inside = truncate(\n\t\treplaceInvalidCharacters(input.substring(start, end)),\n\t\tTruncateSide.Inside,\n\t\t30\n\t);\n\tconst newlineIndexBefore = input.lastIndexOf('\\n', start);\n\tconst lineBefore = truncate(\n\t\treplaceInvalidCharacters(input.substring(newlineIndexBefore + 1, start)),\n\t\tTruncateSide.Start,\n\t\t55 - inside.length\n\t);\n\tconst newlineIndexAfter = input.indexOf('\\n', end);\n\tconst lineAfter = truncate(\n\t\treplaceInvalidCharacters(\n\t\t\tnewlineIndexAfter > 0 ? input.substring(end, newlineIndexAfter) : input.substring(end)\n\t\t),\n\t\tTruncateSide.End,\n\t\t80 - inside.length - lineBefore.length\n\t);\n\tconst indent = Array.from(lineBefore, (c) => (isWhitespace(c) ? c : ' ')).join('');\n\tconst squiggle = '^'.repeat(Math.max(Array.from(inside).length, 1));\n\treturn `${lineBefore}${inside}${lineAfter}\\n${indent}${squiggle}`;\n}\n\nexport function throwErrorWithContext(message: string, event: WithPosition<unknown>): never {\n\tconst { line, char } = offsetToCoords(event.input, event.start);\n\tconst location = `At line ${line}, character ${char}:`;\n\tthrow new Error(\n\t\t`${message}\\n${location}\\n\\n${highlightError(event.input, event.start, event.end)}`\n\t);\n}\n\nfunction throwParseError(what: string, input: string, expected: string[], offset: number): never {\n\tconst quoted = Array.from(new Set(expected), (str) =>\n\t\tstr.includes('\"') ? `'${str}'` : `\"${str}\"`\n\t);\n\tconst cp = input.codePointAt(offset);\n\tconst actual = cp ? String.fromCodePoint(cp) : '';\n\tthrowErrorWithContext(\n\t\t`Parsing ${what} failed, expected ${\n\t\t\tquoted.length > 1 ? 'one of ' + quoted.join(', ') : quoted[0]\n\t\t}`,\n\t\t{ input, start: offset, end: offset + Math.max(actual.length, 1) }\n\t);\n}\n\n/**\n * Returns true if all characters in value match the Char production.\n *\n * @param value - The string to check\n *\n * @returns true if all characters in value match Char, otherwise false\n */\nexport function matchesCharProduction(value: string): boolean {\n\treturn CompleteChars(value, 0).success;\n}\n\n/**\n * Returns true if name matches the Name production.\n *\n * @param name - The name to check\n *\n * @returns true if name matches Name, otherwise false\n */\nexport function matchesNameProduction(name: string): boolean {\n\treturn CompleteName(name, 0).success;\n}\n\n/**\n * Returns true if all characters in value match the PubidChar production.\n *\n * @param value - The string to check\n *\n * @returns true if all characters in value match PubidChar, otherwise false\n */\nexport function matchesPubidCharProduction(value: string): boolean {\n\treturn CompletePubidChars(value, 0).success;\n}\n\n/**\n * Returns true if all characters in value match the S production.\n *\n * @param value - The string to check\n *\n * @returns true if all characters in value match S, otherwise false\n */\nfunction isWhitespace(value: string): boolean {\n\treturn CompleteWhitespace(value, 0).success;\n}\n\nfunction constructReplacementText(value: EntityValueEvent[]): string {\n\tconst replacementText: string[] = [];\n\tfor (const event of value) {\n\t\tif (typeof event === 'string') {\n\t\t\treplacementText.push(event);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (event.type) {\n\t\t\tcase ParserEventType.CharRef:\n\t\t\t\t// Include\n\t\t\t\treplacementText.push(String.fromCodePoint(event.cp));\n\t\t\t\tbreak;\n\t\t\tcase ParserEventType.EntityRef:\n\t\t\t\t// Bypass\n\t\t\t\treplacementText.push(`&${event.name};`);\n\t\t\t\tbreak;\n\t\t\tcase ParserEventType.PEReference:\n\t\t\t\tthrowErrorWithContext(\n\t\t\t\t\t`reference to parameter entity \"${event.name}\" must not occur in an entity declaration in the internal subset`,\n\t\t\t\t\tevent\n\t\t\t\t);\n\t\t}\n\t}\n\n\treturn replacementText.join('');\n}\n\nclass Dtd {\n\tprivate _attlistByName = new Map<string, Map<string, AttDefEvent>>();\n\n\tprivate _entityReplacementTextByName = new Map<string, string>();\n\n\tprivate _externalEntityNames = new Set<string>();\n\n\tprivate _unparsedEntityNames = new Set<string>();\n\n\tconstructor(dtd: DoctypedeclEvent) {\n\t\tif (!dtd.intSubset) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const decl of dtd.intSubset) {\n\t\t\tswitch (decl.type) {\n\t\t\t\tcase MarkupdeclEventType.AttlistDecl: {\n\t\t\t\t\t// Check if no entity is referenced before it is defined\n\t\t\t\t\tfor (const attr of decl.attdefs) {\n\t\t\t\t\t\tif (attr.def.type === DefaultDeclType.VALUE) {\n\t\t\t\t\t\t\tfor (const event of attr.def.value) {\n\t\t\t\t\t\t\t\tif (typeof event === 'string') {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (event.type === ParserEventType.EntityRef) {\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!this._entityReplacementTextByName.has(event.name) &&\n\t\t\t\t\t\t\t\t\t\t!this._externalEntityNames.has(event.name) &&\n\t\t\t\t\t\t\t\t\t\t!this._unparsedEntityNames.has(event.name)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tthrowErrorWithContext(\n\t\t\t\t\t\t\t\t\t\t\t`default value of attribute \"${attr.name.name}\" contains reference to undefined entity \"${event.name}\"`,\n\t\t\t\t\t\t\t\t\t\t\tevent\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (this._externalEntityNames.has(event.name)) {\n\t\t\t\t\t\t\t\t\t\tthrowErrorWithContext(\n\t\t\t\t\t\t\t\t\t\t\t`default value of attribute \"${attr.name.name}\" must not contain reference to external entity \"${event.name}\"`,\n\t\t\t\t\t\t\t\t\t\t\tevent\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Multiple attlist for the same element are merged\n\t\t\t\t\tlet defByName = this._attlistByName.get(decl.name);\n\t\t\t\t\tif (defByName === undefined) {\n\t\t\t\t\t\tdefByName = new Map<string, AttDefEvent>();\n\t\t\t\t\t\tthis._attlistByName.set(decl.name, defByName);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const attr of decl.attdefs) {\n\t\t\t\t\t\t// First declaration is binding\n\t\t\t\t\t\tif (defByName.has(attr.name.name)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefByName.set(attr.name.name, attr);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase MarkupdeclEventType.PEDecl: {\n\t\t\t\t\t// We don't support these, but still need to validate well-formedness\n\t\t\t\t\tif (Array.isArray(decl.value)) {\n\t\t\t\t\t\tfor (const event of decl.value) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\ttypeof event !== 'string' &&\n\t\t\t\t\t\t\t\tevent.type === ParserEventType.PEReference\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tthrowErrorWithContext(\n\t\t\t\t\t\t\t\t\t`reference to parameter entity \"${event.name}\" must not occur in an entity declaration in the internal subset`,\n\t\t\t\t\t\t\t\t\tevent\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase MarkupdeclEventType.GEDecl: {\n\t\t\t\t\t// First declaration is binding\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis._entityReplacementTextByName.has(decl.name) ||\n\t\t\t\t\t\tthis._externalEntityNames.has(decl.name)\n\t\t\t\t\t) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (Array.isArray(decl.value)) {\n\t\t\t\t\t\tthis._entityReplacementTextByName.set(\n\t\t\t\t\t\t\tdecl.name,\n\t\t\t\t\t\t\tconstructReplacementText(decl.value)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (decl.value.ndata === null) {\n\t\t\t\t\t\t// External parsed entity may be skipped\n\t\t\t\t\t\tthis._externalEntityNames.add(decl.name);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// External unparsed entity\n\t\t\t\t\t\tthis._unparsedEntityNames.add(decl.name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic getAttlist(nameEvent: { name: string }): Map<string, AttDefEvent> | undefined {\n\t\treturn this._attlistByName.get(nameEvent.name);\n\t}\n\n\tpublic getEntityReplacementText(\n\t\tevent: EntityRefEvent,\n\t\tallowExternal: boolean\n\t): string | undefined {\n\t\tconst value = this._entityReplacementTextByName.get(event.name);\n\t\tif (value === undefined) {\n\t\t\tif (this._unparsedEntityNames.has(event.name)) {\n\t\t\t\tthrowErrorWithContext(\n\t\t\t\t\t`reference to binary entity \"${event.name}\" is not allowed`,\n\t\t\t\t\tevent\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (this._externalEntityNames.has(event.name)) {\n\t\t\t\tif (allowExternal) {\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t\tthrowErrorWithContext(\n\t\t\t\t\t`reference to external entity \"${event.name}\" is not allowed in attribute value`,\n\t\t\t\t\tevent\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}\n}\n\nconst predefinedEntitiesReplacementText = new Map([\n\t['lt', '&#60;'],\n\t['gt', '>'],\n\t['amp', '&#38;'],\n\t['apos', \"'\"],\n\t['quot', '\"'],\n]);\n\nfunction normalizeAndIncludeEntities(\n\tnormalized: string[],\n\tvalue: AttValueEvent[],\n\tdtd: Dtd | null,\n\tancestorEntities: string[] | null\n) {\n\tfor (const event of value) {\n\t\tif (typeof event === 'string') {\n\t\t\tnormalized.push(event.replace(/[\\r\\n\\t]/g, ' '));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (event.type === ParserEventType.CharRef) {\n\t\t\tnormalized.push(String.fromCodePoint(event.cp));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ancestorEntities !== null && ancestorEntities.includes(event.name)) {\n\t\t\tthrowErrorWithContext(\n\t\t\t\t`reference to entity \"${event.name}\" must not be recursive`,\n\t\t\t\tevent\n\t\t\t);\n\t\t}\n\t\tlet replacementText = predefinedEntitiesReplacementText.get(event.name);\n\t\tif (replacementText === undefined && dtd !== null) {\n\t\t\treplacementText = dtd.getEntityReplacementText(event, false);\n\t\t}\n\t\tif (replacementText === undefined) {\n\t\t\tthrowErrorWithContext(\n\t\t\t\t`reference to unknown entity \"${event.name}\" in attribute value`,\n\t\t\t\tevent\n\t\t\t);\n\t\t}\n\t\tconst result = EntityReplacementTextInLiteral(replacementText, 0);\n\t\tif (!result.success) {\n\t\t\tthrowParseError(\n\t\t\t\t`replacement text for entity \"${event.name}\"`,\n\t\t\t\treplacementText,\n\t\t\t\tresult.expected,\n\t\t\t\tresult.offset\n\t\t\t);\n\t\t}\n\t\t// Recursively normalize replacement text\n\t\tnormalizeAndIncludeEntities(\n\t\t\tnormalized,\n\t\t\tresult.value,\n\t\t\tdtd,\n\t\t\tancestorEntities ? [event.name, ...ancestorEntities] : [event.name]\n\t\t);\n\t}\n}\n\nfunction normalizeAttributeValue(\n\tvalue: AttValueEvent[],\n\tattDef: AttDefEvent | undefined,\n\tdtd: Dtd | null\n): string {\n\tconst normalized: string[] = [];\n\tnormalizeAndIncludeEntities(normalized, value, dtd, null);\n\tif (attDef && !attDef.isCData) {\n\t\treturn normalized\n\t\t\t.join('')\n\t\t\t.replace(/[ ]+/g, ' ')\n\t\t\t.replace(/^[ ]+|[ ]+$/g, '');\n\t}\n\treturn normalized.join('');\n}\n\ntype QualifiedNameParts = { prefix: string | null; localName: string };\ntype QualifiedNameCache = Map<string, QualifiedNameParts>;\n\nfunction splitQualifiedName(\n\tevent: WithPosition<{ name: string }>,\n\tcache: QualifiedNameCache\n): QualifiedNameParts {\n\tconst qualifiedName = event.name;\n\tconst fromCache = cache.get(qualifiedName);\n\tif (fromCache !== undefined) {\n\t\treturn fromCache;\n\t}\n\n\t// 3. Let prefix be null.\n\tlet prefix: string | null = null;\n\n\t// 4.  Let localName be qualifiedName.\n\tlet localName = qualifiedName;\n\n\t// 5. If qualifiedName contains a \":\" (U+003A), then split the string on it and set prefix to\n\t// the part before and localName to the part after.\n\tconst index = qualifiedName.indexOf(':');\n\tif (index >= 0) {\n\t\tprefix = qualifiedName.substring(0, index);\n\t\tlocalName = qualifiedName.substring(index + 1);\n\t}\n\n\t// We already know (from the grammar) that qualifiedName is a valid Name, so only check if there\n\t// aren't too many colons and that both parts are not empty\n\tif (prefix === '' || localName === '' || localName.includes(':')) {\n\t\tthrowErrorWithContext(`the name \"${qualifiedName}\" is not a valid qualified name`, event);\n\t}\n\n\tconst parts = { prefix, localName };\n\tcache.set(qualifiedName, parts);\n\treturn parts;\n}\n\nclass Namespaces {\n\tprivate readonly _parent: Namespaces | null;\n\tprivate readonly _byPrefix: Map<string | null, string | null> = new Map();\n\tprivate readonly _resolve: ((prefix: string) => string | undefined) | null = null;\n\n\tprivate constructor(\n\t\tparent: Namespaces | null,\n\t\tresolve: ((prefix: string) => string | undefined) | null = null\n\t) {\n\t\tthis._parent = parent;\n\t\tthis._resolve = resolve ?? parent?._resolve ?? null;\n\t}\n\n\tpublic getForElement(prefix: string | null, event: WithPosition<unknown>): string | null {\n\t\tif (prefix === 'xmlns') {\n\t\t\tthrowErrorWithContext('element names must not have the prefix \"xmlns\"', event);\n\t\t}\n\t\tfor (let ns: Namespaces | null = this; ns !== null; ns = ns._parent) {\n\t\t\tconst namespace = ns._byPrefix.get(prefix);\n\t\t\tif (namespace !== undefined) {\n\t\t\t\treturn namespace;\n\t\t\t}\n\t\t}\n\t\tif (prefix !== null && this._resolve) {\n\t\t\tconst namespace = this._resolve(prefix);\n\t\t\tif (namespace !== undefined) {\n\t\t\t\treturn namespace;\n\t\t\t}\n\t\t}\n\t\tthrowErrorWithContext(`use of undeclared element prefix \"${prefix}\"`, event);\n\t}\n\n\tpublic getForAttribute(\n\t\tprefix: string | null,\n\t\tlocalName: string,\n\t\tevent: WithPosition<unknown>\n\t): string | null {\n\t\tif (prefix === null) {\n\t\t\t// Default namespace doesn't apply to attributes\n\t\t\treturn localName === 'xmlns' ? XMLNS_NAMESPACE : null;\n\t\t}\n\t\tfor (let ns: Namespaces | null = this; ns !== null; ns = ns._parent) {\n\t\t\tconst namespace = ns._byPrefix.get(prefix);\n\t\t\tif (namespace !== undefined) {\n\t\t\t\treturn namespace;\n\t\t\t}\n\t\t}\n\t\tif (this._resolve) {\n\t\t\tconst namespace = this._resolve(prefix);\n\t\t\tif (namespace !== undefined) {\n\t\t\t\treturn namespace;\n\t\t\t}\n\t\t}\n\t\tthrowErrorWithContext(`use of undeclared attribute prefix ${prefix}`, event);\n\t}\n\n\tpublic static fromAttrs(\n\t\tparent: Namespaces,\n\t\tevent: STagEvent | EmptyElemTagEvent,\n\t\tattlist: Map<string, AttDefEvent> | undefined,\n\t\tdtd: Dtd | null,\n\t\tqualifiedNameCache: QualifiedNameCache\n\t): Namespaces {\n\t\tlet ns = parent;\n\t\tlet hasDeclarations = false;\n\n\t\tconst add = (\n\t\t\tprefix: string | null,\n\t\t\tnamespace: string | null,\n\t\t\tevent: WithPosition<unknown>\n\t\t) => {\n\t\t\tif (prefix === null && (namespace === XML_NAMESPACE || namespace === XMLNS_NAMESPACE)) {\n\t\t\t\tthrowErrorWithContext(\n\t\t\t\t\t`the namespace \"${namespace}\" must not be used as the default namespace`,\n\t\t\t\t\tevent\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (namespace === XMLNS_NAMESPACE) {\n\t\t\t\tthrowErrorWithContext(\n\t\t\t\t\t`the namespace \"${XMLNS_NAMESPACE}\" must not be bound to a prefix`,\n\t\t\t\t\tevent\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (namespace === XML_NAMESPACE && prefix !== 'xml') {\n\t\t\t\tthrowErrorWithContext(\n\t\t\t\t\t`the namespace \"${XML_NAMESPACE}\" must be bound only to the prefix \"xml\"`,\n\t\t\t\t\tevent\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (namespace !== XML_NAMESPACE && prefix === 'xml') {\n\t\t\t\tthrowErrorWithContext(\n\t\t\t\t\t`the xml namespace prefix must not be bound to any namespace other than \"${XML_NAMESPACE}\"`,\n\t\t\t\t\tevent\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (prefix !== null && namespace === null) {\n\t\t\t\tthrowErrorWithContext(`the prefix \"${prefix}\" must not be undeclared`, event);\n\t\t\t}\n\t\t\tif (!hasDeclarations) {\n\t\t\t\tns = new Namespaces(parent);\n\t\t\t\thasDeclarations = true;\n\t\t\t}\n\t\t\tns._byPrefix.set(prefix, namespace);\n\t\t};\n\n\t\tconst checkAttr = (nameEvent: WithPosition<{ name: string }>, value: AttValueEvent[]) => {\n\t\t\tconst { prefix, localName } = splitQualifiedName(nameEvent, qualifiedNameCache);\n\t\t\tconst def = attlist?.get(nameEvent.name);\n\t\t\tif (\n\t\t\t\tprefix === null &&\n\t\t\t\tlocalName === 'xmlns' &&\n\t\t\t\t(!hasDeclarations || !ns._byPrefix.has(null))\n\t\t\t) {\n\t\t\t\tconst namespace = normalizeAttributeValue(value, def, dtd) || null;\n\t\t\t\tadd(null, namespace, nameEvent);\n\t\t\t} else if (prefix === 'xmlns' && (!hasDeclarations || !ns._byPrefix.has(localName))) {\n\t\t\t\tif (localName === 'xmlns') {\n\t\t\t\t\tthrowErrorWithContext(\n\t\t\t\t\t\t'the \"xmlns\" namespace prefix must not be declared',\n\t\t\t\t\t\tnameEvent\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst namespace = normalizeAttributeValue(value, def, dtd) || null;\n\t\t\t\tadd(localName, namespace, nameEvent);\n\t\t\t}\n\t\t};\n\n\t\tfor (const attr of event.attributes) {\n\t\t\tcheckAttr(attr.name, attr.value);\n\t\t}\n\t\tif (attlist) {\n\t\t\tfor (const attr of attlist.values()) {\n\t\t\t\tconst def = attr.def;\n\t\t\t\tif (def.type !== DefaultDeclType.VALUE) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcheckAttr(attr.name, def.value);\n\t\t\t}\n\t\t}\n\n\t\treturn ns;\n\t}\n\n\tpublic static default(resolve: ((prefix: string) => string | undefined) | null): Namespaces {\n\t\tconst ns = new Namespaces(null, resolve);\n\t\tns._byPrefix.set(null, null);\n\t\tns._byPrefix.set('xml', XML_NAMESPACE);\n\t\tns._byPrefix.set('xmlns', XMLNS_NAMESPACE);\n\t\treturn ns;\n\t}\n}\n\nconst ROOT_NAMESPACES = Namespaces.default(null);\n\nfunction normalizeLineEndings(input: string): string {\n\treturn input.replace(/\\r\\n?/g, '\\n');\n}\n\nfunction appendParsedNode(parent: Node, child: Node): void {\n\t// We can bypass all of the pre-insertion checks as the parser guarantees that we won't try any\n\t// invalid combinations of node types here, that there is at most a single doctype and that that\n\t// doctype is parsed before any elements. Other constraints, such as not having text at the root\n\t// and not having more than one root element, are covered in the parse loop. We can also bypass\n\t// adoption, as all nodes are created from our document. Finally, no observers can possibly be\n\t// interested in our new document, so we don't need to look for those.\n\tinsertNode(child, parent, null, true);\n}\n\ntype DomContext = {\n\tparent: DomContext | null;\n\troot: Node;\n\tnamespaces: Namespaces;\n\tentityRoot: boolean;\n};\n\ntype EntityContext = {\n\tparent: EntityContext | null;\n\tentity: string | null;\n\titerator: Iterator<DocumentParseEvent>;\n};\n\n/**\n * Options that control parsing.\n *\n * @public\n */\nexport type ParseOptions = Partial<{\n\t/**\n\t * To guard against entity expansion attacks, this controls the maximum amplification factor\n\t * allowed when expanding entities. This is calculated as the ratio between the length of the\n\t * initial input and that of the processed input, which is the initial input plus the length of\n\t * the replacement text corresponding to each processed named entity reference.\n\t *\n\t * As high amplification factors may occur for normal documents, this is only enforced after the\n\t * length of the processed input exceeds the `entityExpansionThreshold`.\n\t *\n\t * Defaults to 100.\n\t *\n\t * Please file an issue if you ever need to adjust this value for a non-attack input.\n\t *\n\t * @public\n\t */\n\tentityExpansionMaxAmplification: number;\n\n\t/**\n\t * To guard against entity expansion attacks, this controls the threshold after which the\n\t * `entityExpansionMaxAmplification` limit is enforced. The threshold is applied against the\n\t * length of the processed input, which is the initial input plus the length of the replacement\n\t * text corresponding to each processed named entity reference.\n\t *\n\t * Defaults to 2^22 characters, which equates (assuming UCS-2 encoding) to 8MiB of input data.\n\t *\n\t * Please file an issue if you ever need to adjust this value for a non-attack input.\n\t *\n\t * @public\n\t */\n\tentityExpansionThreshold: number;\n\n\t/**\n\t * If set to true, any CDATA sections in the parsed document are converted to normal text.\n\t * Defaults to false, which means CDATA sections are represented in the DOM by CDataSection\n\t * nodes.\n\t *\n\t * @public\n\t */\n\ttreatCDataAsText: boolean;\n}>;\n\nconst DEFAULT_ENTITY_EXPANSION_MAX_AMPLIFICATION = 100.0;\n\n// 8MiB / 2 bytes per char (UCS-2) = 4MiB (2^22)\nconst DEFAULT_ENTITY_EXPANSION_THRESHOLD = 4_194_304;\n\nexport function parseXml(\n\tinput: string,\n\tgenerator: (input: string) => Iterator<DocumentParseEvent>,\n\tnamespaces: Namespaces,\n\tinto: Node,\n\t{\n\t\tentityExpansionMaxAmplification = DEFAULT_ENTITY_EXPANSION_MAX_AMPLIFICATION,\n\t\tentityExpansionThreshold = DEFAULT_ENTITY_EXPANSION_THRESHOLD,\n\t\ttreatCDataAsText = false,\n\t}: ParseOptions\n): void {\n\tconst doc = getNodeDocument(into);\n\tlet domContext: DomContext = {\n\t\tparent: null,\n\t\troot: into,\n\t\tnamespaces,\n\t\tentityRoot: true,\n\t};\n\tlet dtd: Dtd | null = null;\n\tconst qualifiedNameCache: QualifiedNameCache = new Map();\n\tlet collectedText: string[] = [];\n\n\tfunction flushCollectedText() {\n\t\tif (collectedText.length > 0) {\n\t\t\tconst text = collectedText.join('');\n\t\t\tif (domContext.root === doc) {\n\t\t\t\t// Ignore whitespace at document root\n\t\t\t\tif (!isWhitespace(text)) {\n\t\t\t\t\tthrow new Error('document must not contain text outside of elements');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tappendParsedNode(domContext.root, doc.createTextNode(collectedText.join('')));\n\t\t\t}\n\t\t\tcollectedText.length = 0;\n\t\t}\n\t}\n\n\t// Remove BOM if there is one and normalize line endings to lf\n\tinput = input.replace(/^\\ufeff/, '');\n\tinput = normalizeLineEndings(input);\n\n\t// Guard against entity expansion attacks by keeping track of the initial input length vs. the\n\t// expanded input length. The latter includes the length of the replacement text for each\n\t// processed entity reference. An attack is likely if the ratio between the two exceeds the\n\t// maximum amplification factor AND the expanded input length exceeds a threshold. This approach\n\t// and defaults are taken from libexpat's billion laughs attack protection.\n\tconst initialInputLength = input.length;\n\tlet expandedInputLength = initialInputLength;\n\tlet topLevelEntityRef: EntityRefEvent | null = null;\n\n\tlet entityContext: EntityContext | null = {\n\t\tparent: null,\n\t\tentity: null,\n\t\titerator: generator(input),\n\t};\n\twhile (entityContext) {\n\t\tlet it: IteratorResult<DocumentParseEvent> = entityContext.iterator.next();\n\t\tfor (; !it.done; it = entityContext.iterator.next()) {\n\t\t\tconst event: DocumentParseEvent = it.value;\n\t\t\tif (typeof event === 'string') {\n\t\t\t\tcollectedText.push(event);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (event.type) {\n\t\t\t\tcase ParserEventType.CharRef:\n\t\t\t\t\tif (domContext.root === doc && doc.documentElement !== null) {\n\t\t\t\t\t\tthrowErrorWithContext(\n\t\t\t\t\t\t\t'character reference must not appear after the document element',\n\t\t\t\t\t\t\tevent\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tcollectedText.push(String.fromCodePoint(event.cp));\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcase ParserEventType.EntityRef: {\n\t\t\t\t\tif (domContext.root === doc && doc.documentElement !== null) {\n\t\t\t\t\t\tthrowErrorWithContext(\n\t\t\t\t\t\t\t`reference to entity \"${event.name}\" must not appear after the document element`,\n\t\t\t\t\t\t\tevent\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tfor (let ctx: EntityContext | null = entityContext; ctx; ctx = ctx.parent) {\n\t\t\t\t\t\tif (ctx.entity === event.name) {\n\t\t\t\t\t\t\tthrowErrorWithContext(\n\t\t\t\t\t\t\t\t`reference to entity \"${event.name}\" must not be recursive`,\n\t\t\t\t\t\t\t\tevent\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlet replacementText = predefinedEntitiesReplacementText.get(event.name);\n\t\t\t\t\tif (replacementText === undefined && dtd !== null) {\n\t\t\t\t\t\treplacementText = dtd.getEntityReplacementText(event, true);\n\t\t\t\t\t}\n\t\t\t\t\tif (replacementText === undefined) {\n\t\t\t\t\t\tthrowErrorWithContext(\n\t\t\t\t\t\t\t`reference to unknown entity \"${event.name}\" in content`,\n\t\t\t\t\t\t\tevent\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (topLevelEntityRef === null) {\n\t\t\t\t\t\ttopLevelEntityRef = event;\n\t\t\t\t\t}\n\t\t\t\t\texpandedInputLength += replacementText.length;\n\t\t\t\t\tif (expandedInputLength > entityExpansionThreshold) {\n\t\t\t\t\t\tconst amplification = expandedInputLength / initialInputLength;\n\t\t\t\t\t\tif (amplification > entityExpansionMaxAmplification) {\n\t\t\t\t\t\t\tthrowErrorWithContext('too much entity expansion', topLevelEntityRef);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdomContext = {\n\t\t\t\t\t\tparent: domContext,\n\t\t\t\t\t\troot: domContext.root,\n\t\t\t\t\t\tnamespaces: domContext.namespaces,\n\t\t\t\t\t\tentityRoot: true,\n\t\t\t\t\t};\n\t\t\t\t\tentityContext = {\n\t\t\t\t\t\tparent: entityContext,\n\t\t\t\t\t\tentity: event.name,\n\t\t\t\t\t\titerator: parseContent(replacementText),\n\t\t\t\t\t};\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tcase ParserEventType.CDSect:\n\t\t\t\t\tif (treatCDataAsText) {\n\t\t\t\t\t\tcollectedText.push(event.data);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tflushCollectedText();\n\n\t\t\tswitch (event.type) {\n\t\t\t\tcase ParserEventType.CDSect:\n\t\t\t\t\tif (domContext.root === doc && doc.documentElement !== null) {\n\t\t\t\t\t\tthrowErrorWithContext(\n\t\t\t\t\t\t\t'CData section must not appear after the document element',\n\t\t\t\t\t\t\tevent\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tappendParsedNode(domContext.root, doc.createCDATASection(event.data));\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcase ParserEventType.Comment:\n\t\t\t\t\tappendParsedNode(domContext.root, doc.createComment(event.data));\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcase ParserEventType.Doctypedecl:\n\t\t\t\t\t// Grammar guarantees this happens before the document element\n\t\t\t\t\tdtd = new Dtd(event);\n\t\t\t\t\tappendParsedNode(\n\t\t\t\t\t\tdomContext.root,\n\t\t\t\t\t\tdoc.implementation.createDocumentType(\n\t\t\t\t\t\t\tevent.name,\n\t\t\t\t\t\t\tevent.ids?.publicId || '',\n\t\t\t\t\t\t\tevent.ids?.systemId || ''\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcase ParserEventType.PI:\n\t\t\t\t\tappendParsedNode(\n\t\t\t\t\t\tdomContext.root,\n\t\t\t\t\t\tdoc.createProcessingInstruction(event.target, event.data || '')\n\t\t\t\t\t);\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcase ParserEventType.STag:\n\t\t\t\tcase ParserEventType.EmptyElemTag: {\n\t\t\t\t\tif (domContext.root === doc && doc.documentElement !== null) {\n\t\t\t\t\t\tthrowErrorWithContext(\n\t\t\t\t\t\t\t`document must contain a single root element, but found \"${doc.documentElement.nodeName}\" and \"${event.name.name}\"`,\n\t\t\t\t\t\t\tevent.name\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tconst attlist = dtd ? dtd.getAttlist(event.name) : undefined;\n\t\t\t\t\tconst namespaces = Namespaces.fromAttrs(\n\t\t\t\t\t\tdomContext.namespaces,\n\t\t\t\t\t\tevent,\n\t\t\t\t\t\tattlist,\n\t\t\t\t\t\tdtd,\n\t\t\t\t\t\tqualifiedNameCache\n\t\t\t\t\t);\n\t\t\t\t\tconst { prefix, localName } = splitQualifiedName(\n\t\t\t\t\t\tevent.name,\n\t\t\t\t\t\tqualifiedNameCache\n\t\t\t\t\t);\n\t\t\t\t\tconst namespace = namespaces.getForElement(prefix, event.name);\n\t\t\t\t\t// We can skip the usual name validity checks\n\t\t\t\t\tconst element = unsafeCreateElement(doc, localName, namespace, prefix);\n\t\t\t\t\tfor (const attr of event.attributes) {\n\t\t\t\t\t\tconst { prefix, localName } = splitQualifiedName(\n\t\t\t\t\t\t\tattr.name,\n\t\t\t\t\t\t\tqualifiedNameCache\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst namespace = namespaces.getForAttribute(prefix, localName, attr.name);\n\t\t\t\t\t\tconst def = attlist?.get(attr.name.name);\n\t\t\t\t\t\tif (element.hasAttributeNS(namespace, localName)) {\n\t\t\t\t\t\t\tthrowErrorWithContext(\n\t\t\t\t\t\t\t\t`attribute \"${attr.name.name}\" must not appear multiple times on element \"${event.name.name}\"`,\n\t\t\t\t\t\t\t\tattr.name\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// We can skip validation of names and duplicates\n\t\t\t\t\t\tconst attrNode = unsafeCreateAttribute(\n\t\t\t\t\t\t\tnamespace,\n\t\t\t\t\t\t\tprefix,\n\t\t\t\t\t\t\tlocalName,\n\t\t\t\t\t\t\tnormalizeAttributeValue(attr.value, def, dtd),\n\t\t\t\t\t\t\telement\n\t\t\t\t\t\t);\n\t\t\t\t\t\tappendAttribute(attrNode, element, true);\n\t\t\t\t\t}\n\t\t\t\t\t// Add default attributes from the DTD\n\t\t\t\t\tif (attlist) {\n\t\t\t\t\t\tfor (const attr of attlist.values()) {\n\t\t\t\t\t\t\tconst def = attr.def;\n\t\t\t\t\t\t\tif (def.type !== DefaultDeclType.VALUE) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst { prefix, localName } = splitQualifiedName(\n\t\t\t\t\t\t\t\tattr.name,\n\t\t\t\t\t\t\t\tqualifiedNameCache\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst namespace = namespaces.getForAttribute(\n\t\t\t\t\t\t\t\tprefix,\n\t\t\t\t\t\t\t\tlocalName,\n\t\t\t\t\t\t\t\tattr.name\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (element.hasAttributeNS(namespace, localName)) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// We can skip validation of names and duplicates\n\t\t\t\t\t\t\tconst attrNode = unsafeCreateAttribute(\n\t\t\t\t\t\t\t\tnamespace,\n\t\t\t\t\t\t\t\tprefix,\n\t\t\t\t\t\t\t\tlocalName,\n\t\t\t\t\t\t\t\tnormalizeAttributeValue(def.value, attr, dtd),\n\t\t\t\t\t\t\t\telement\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tappendAttribute(attrNode, element, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tappendParsedNode(domContext.root, element);\n\t\t\t\t\tif (event.type === ParserEventType.STag) {\n\t\t\t\t\t\tdomContext = {\n\t\t\t\t\t\t\tparent: domContext,\n\t\t\t\t\t\t\troot: element,\n\t\t\t\t\t\t\tnamespaces,\n\t\t\t\t\t\t\tentityRoot: false,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tcase ParserEventType.ETag:\n\t\t\t\t\tif (!isElement(domContext.root) || domContext.root.nodeName !== event.name) {\n\t\t\t\t\t\tthrowErrorWithContext(\n\t\t\t\t\t\t\t`non-well-formed element: found end tag \"${event.name}\" but expected ${\n\t\t\t\t\t\t\t\tisElement(domContext.root)\n\t\t\t\t\t\t\t\t\t? `\"${domContext.root.nodeName}\"`\n\t\t\t\t\t\t\t\t\t: 'no such tag'\n\t\t\t\t\t\t\t}`,\n\t\t\t\t\t\t\tevent\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\t// The check above means we never leave the document DomContext\n\t\t\t\t\tdomContext = domContext.parent!;\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!it.value.success) {\n\t\t\tthrowParseError(\n\t\t\t\tentityContext.entity\n\t\t\t\t\t? `replacement text for entity ${entityContext.entity}`\n\t\t\t\t\t: into === doc\n\t\t\t\t\t? 'document'\n\t\t\t\t\t: 'fragment',\n\t\t\t\tinput,\n\t\t\t\tit.value.expected,\n\t\t\t\tit.value.offset\n\t\t\t);\n\t\t}\n\n\t\tif (!domContext.entityRoot) {\n\t\t\tthrow new Error(\n\t\t\t\t`${\n\t\t\t\t\tentityContext.entity\n\t\t\t\t\t\t? `replacement text for entity \"${entityContext.entity}\"`\n\t\t\t\t\t\t: into === doc\n\t\t\t\t\t\t? 'document'\n\t\t\t\t\t\t: 'fragment'\n\t\t\t\t} is not well-formed - element \"${\n\t\t\t\t\tdomContext.root.nodeName\n\t\t\t\t}\" is missing a closing tag`\n\t\t\t);\n\t\t}\n\n\t\tentityContext = entityContext.parent;\n\t\tif (entityContext) {\n\t\t\tdomContext = domContext.parent!;\n\t\t\tif (entityContext.entity === null) {\n\t\t\t\ttopLevelEntityRef = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tflushCollectedText();\n}\n\n/**\n * Parse an XML fragment\n *\n * This accepts the same format as specified for external parsed entities, except that it does not\n * support parameter entities. That means it accepts an optional text declaration (similar to the\n * XML version declaration) followed by any content that may be found between an element's start and\n * end tags. That does not include doctype nodes.\n *\n * This parser is non-validating, and therefore does not support an external DTD or external parsed\n * entities. During parsing, any referenced entities are included, default attribute values are\n * materialized and the DTD internal subset is discarded. References to external entities are\n * replaced with nothing. References to parameter entities are also ignored.\n *\n * @public\n *\n * @param input   - the string to parse\n * @param options - allows specifying context missing from the fragment text\n */\nexport function parseXmlFragment(\n\tinput: string,\n\toptions: Partial<{\n\t\t/**\n\t\t * Called to resolve the namespace for any prefix that is not defined in the context of the\n\t\t * content currently being parsed. Should return the namespace URI, or undefined if a\n\t\t * namespace could not be resolved for the given prefix.\n\t\t *\n\t\t * @public\n\t\t *\n\t\t * @param prefix - the prefix that could not be resolved\n\t\t */\n\t\tresolveNamespacePrefix(prefix: string): string | undefined;\n\n\t\t/**\n\t\t * If set to true, any CDATA sections in the parsed document are converted to normal text.\n\t\t * Defaults to false, which means CDATA sections are represented in the DOM by CDataSection\n\t\t * nodes.\n\t\t *\n\t\t * @public\n\t\t */\n\t\ttreatCDataAsText: boolean;\n\t}> = {}\n): DocumentFragment {\n\tconst doc = new Document();\n\tconst fragment = doc.createDocumentFragment();\n\tparseXml(\n\t\tinput,\n\t\tparseFragment,\n\t\toptions.resolveNamespacePrefix\n\t\t\t? Namespaces.default(options.resolveNamespacePrefix)\n\t\t\t: ROOT_NAMESPACES,\n\t\tfragment,\n\t\toptions\n\t);\n\treturn fragment;\n}\n\n/**\n * Parse an XML document\n *\n * This parser is non-validating, and therefore does not support an external DTD or external parsed\n * entities. During parsing, any referenced entities are included, default attribute values are\n * materialized and the DTD internal subset is discarded. References to external entities are\n * replaced with nothing. References to parameter entities are also ignored.\n *\n * @public\n *\n * @param input   - the string to parse\n * @param options - optionally adjust protection against entity expansion attacks\n */\nexport function parseXmlDocument(input: string, options: ParseOptions = {}): Document {\n\tconst doc = new Document();\n\tparseXml(input, parseDocument, ROOT_NAMESPACES, doc, options);\n\treturn doc;\n}\n","import Attr from '../Attr';\nimport Element from '../Element';\nimport { isAttrNode } from '../util/NodeType';\nimport { XML_NAMESPACE, XMLNS_NAMESPACE } from '../util/namespaceHelpers';\n\nexport type PrefixIndex = { value: number };\n\n// 3.2.1.1.2 The Namespace Prefix Map\n\n/**\n * A namespace prefix map is a map that associates namespaceURI and namespace\n * prefix lists.\n *\n * This deviates from the specification to fix a number of bugs in the spec that\n * can cause it to otherwise produce non-well-formed markup or markup that does\n * not capture the author's intent.\n *\n * Instead of only tracking candidate prefixes by namespace, this also tracks\n * the current prefix to namespace mapping so we can properly detect when\n * prefixes have been redefined. This implementation also tracks maps as a tree\n * to avoid copying as well as the need to separately track locally defined\n * prefixes.\n */\nexport class NamespacePrefixMap {\n\tprivate _parent: NamespacePrefixMap | null;\n\n\tprivate _nsByPrefix = new Map<string | null, string | null>();\n\n\tprivate _prefixCandidatesByNs: Map<string | null, (string | null)[]> = new Map();\n\n\tprivate constructor(parent: NamespacePrefixMap | null) {\n\t\tthis._parent = parent;\n\t}\n\n\tpublic static new(): NamespacePrefixMap {\n\t\tconst map = new NamespacePrefixMap(null);\n\t\t// Register implicitly declared namespaces\n\t\tmap.add(null, null);\n\t\tmap.add('xml', XML_NAMESPACE);\n\t\tmap.add('xmlns', XMLNS_NAMESPACE);\n\t\treturn map;\n\t}\n\n\t/**\n\t * To add a prefix string prefix to the namespace prefix map map given a\n\t * namespace ns, the user agent should:\n\t *\n\t * @param prefix - The prefix to add\n\t * @param ns     - The namespace to add for prefix\n\t */\n\tpublic add(prefix: string | null, ns: string | null): void {\n\t\t// 1. Let candidates list be the result of retrieving a list from map where there exists a\n\t\t// key in map that matches the value of ns or if there is no such key, then let candidates\n\t\t// list be null.\n\t\t// (undefined used instead of null for convenience)\n\t\tconst candidatesList = this._prefixCandidatesByNs.get(ns);\n\n\t\t// 2. If candidates list is null, then create a new list with prefix as the only item in the\n\t\t// list, and associate that list with a new key ns in map.\n\t\tif (candidatesList === undefined) {\n\t\t\tthis._prefixCandidatesByNs.set(ns, [prefix]);\n\t\t} else {\n\t\t\t// 3. Otherwise, append prefix to the end of candidates list.\n\t\t\tcandidatesList.push(prefix);\n\t\t}\n\n\t\t// NOTE: The steps in retrieve a preferred prefix string use the list to track the most\n\t\t// recently used (MRU) prefix associated with a given namespace, which will be the prefix at\n\t\t// the end of the list. This list may contain duplicates of the same prefix value seen\n\t\t// earlier (and that's OK).\n\n\t\tthis._nsByPrefix.set(prefix, ns);\n\t}\n\n\tpublic recordNamespaceInformation(element: Element): NamespacePrefixMap {\n\t\tconst map = new NamespacePrefixMap(this);\n\t\tfor (const attr of element.attributes) {\n\t\t\tif (attr.namespaceURI !== XMLNS_NAMESPACE) {\n\t\t\t\t// Not a namespace declaration attribute\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst namespaceUri = attr.value === '' ? null : attr.value;\n\t\t\tconst definedPrefix = attr.prefix === null ? null : attr.localName;\n\t\t\tmap.add(definedPrefix, namespaceUri);\n\t\t}\n\t\treturn map;\n\t}\n\n\tprivate _localPrefixToNamespace(prefix: string | null): string | null | undefined {\n\t\treturn this._nsByPrefix.get(prefix);\n\t}\n\n\tprivate _inheritedPrefixToNamespace(prefix: string | null): string | null | undefined {\n\t\treturn this._parent?.prefixToNamespace(prefix);\n\t}\n\n\tpublic prefixToNamespace(prefix: string | null): string | null | undefined {\n\t\tconst ns = this._localPrefixToNamespace(prefix);\n\t\tif (ns !== undefined) {\n\t\t\treturn ns;\n\t\t}\n\t\treturn this._inheritedPrefixToNamespace(prefix);\n\t}\n\n\tpublic shouldSerializeDeclaration(prefix: string | null, ns: string | null): boolean {\n\t\t// An existing declaration attribute should be skipped if it doesn't\n\t\t// match the local scope. It can be skipped if it doesn't change the\n\t\t// inherited value.\n\t\treturn (\n\t\t\tthis.prefixToNamespace(prefix) === ns && this._inheritedPrefixToNamespace(prefix) !== ns\n\t\t);\n\t}\n\n\tprivate _getCandidatePrefix(\n\t\tnamespaceUri: string | null,\n\t\tallowDefault: boolean\n\t): string | null | undefined {\n\t\tlet ancestor: NamespacePrefixMap | null = this;\n\t\twhile (ancestor) {\n\t\t\tconst candidates = ancestor._prefixCandidatesByNs.get(namespaceUri);\n\t\t\tif (candidates !== undefined) {\n\t\t\t\tfor (let i = candidates.length - 1; i >= 0; --i) {\n\t\t\t\t\tconst candidate = candidates[i];\n\t\t\t\t\tif (!allowDefault && candidate === null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// Check if this candidate prefix is valid in the current scope\n\t\t\t\t\tif (this.prefixToNamespace(candidate) === namespaceUri) {\n\t\t\t\t\t\treturn candidate;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tancestor = ancestor._parent;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic getPreferredPrefix(node: Element | Attr, prefixIndex: PrefixIndex): string | null {\n\t\t// XML namespace must use the \"xml\" prefix\n\t\tif (node.namespaceURI === XML_NAMESPACE) {\n\t\t\treturn 'xml';\n\t\t}\n\n\t\t// XMLNS namespace must use \"xmlns\", except for default namespace\n\t\t// declarations, which use no prefix\n\t\tconst isAttr = isAttrNode(node);\n\t\tif (node.namespaceURI === XMLNS_NAMESPACE) {\n\t\t\tif (isAttr && node.prefix === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn 'xmlns';\n\t\t}\n\n\t\t// attributes in the null namespace don't have a prefix\n\t\tif (isAttr && node.namespaceURI === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// elements use no prefix if their namespace is the inherited default\n\t\t// namespace\n\t\tif (!isAttr) {\n\t\t\tlet inheritedNs = this._inheritedPrefixToNamespace(null) ?? null;\n\t\t\tif (node.namespaceURI === inheritedNs) {\n\t\t\t\t// The caller should add this to the map to ensure that any\n\t\t\t\t// current default namespace declaration is ignored.\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// If the authored prefix resolves to the requested namespace in scope,\n\t\t// we can use it, except that attributes in a namespace can't use an\n\t\t// empty prefix.\n\t\tif (\n\t\t\t(!isAttr || node.prefix !== null) &&\n\t\t\tthis.prefixToNamespace(node.prefix) === node.namespaceURI\n\t\t) {\n\t\t\treturn node.prefix;\n\t\t}\n\n\t\t// If any prefixes in scope resolve to the requested namespace, use the\n\t\t// most recent one.\n\t\tconst candidatePrefix = this._getCandidatePrefix(node.namespaceURI, !isAttr);\n\t\tif (candidatePrefix !== undefined) {\n\t\t\treturn candidatePrefix;\n\t\t}\n\n\t\t// No suitable existing declaration, try to use the authored prefix\n\n\t\t// Attributes can't use the authored prefix if it is null or conflicts\n\t\t// with an existing local declaration\n\t\tif (isAttr) {\n\t\t\tconst namespaceForPrefix = this._localPrefixToNamespace(node.prefix);\n\t\t\tconst isValidPrefix =\n\t\t\t\tnode.prefix !== null &&\n\t\t\t\t(namespaceForPrefix === undefined || namespaceForPrefix === node.namespaceURI);\n\n\t\t\tif (!isValidPrefix) {\n\t\t\t\t// Collision - generate a new prefix\n\t\t\t\twhile (true) {\n\t\t\t\t\tconst generatedPrefix = `ns${prefixIndex.value}`;\n\t\t\t\t\tprefixIndex.value += 1;\n\t\t\t\t\tif (this._localPrefixToNamespace(generatedPrefix) === undefined) {\n\t\t\t\t\t\treturn generatedPrefix;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn node.prefix;\n\t}\n}\n","import CDATASection from '../CDATASection';\nimport Comment from '../Comment';\nimport Document from '../Document';\nimport DocumentType from '../DocumentType';\nimport Element from '../Element';\nimport Node from '../Node';\nimport ProcessingInstruction from '../ProcessingInstruction';\nimport Text from '../Text';\nimport {\n\tmatchesCharProduction,\n\tmatchesNameProduction,\n\tmatchesPubidCharProduction,\n} from '../dom-parsing/parsingAlgorithms';\nimport { throwInvalidStateError } from '../util/errorHelpers';\nimport { HTML_NAMESPACE, XML_NAMESPACE, XMLNS_NAMESPACE } from '../util/namespaceHelpers';\nimport { NodeType } from '../util/NodeType';\nimport { NamespacePrefixMap, PrefixIndex } from './NamespacePrefixMap';\n\nconst HTML_VOID_ELEMENTS = [\n\t'area',\n\t'base',\n\t'basefont',\n\t'bgsound',\n\t'br',\n\t'col',\n\t'embed',\n\t'frame',\n\t'hr',\n\t'img',\n\t'input',\n\t'keygen',\n\t'link',\n\t'menuitem',\n\t'meta',\n\t'param',\n\t'source',\n\t'track',\n\t'wbr',\n];\n\n// 3.2. Serializing\n\n/**\n * The following steps form the fragment serializing algorithm:\n *\n * @param node                - The node to serialize\n * @param requireWellFormed   - Determines whether the result needs to be well-formed\n * @param withFictionalParent - Whether to treat node as a fictional parent with node as its only\n *                              child\n *\n * @returns A string representing the serialization of node\n */\nexport function serializeFragment(\n\tnode: Node,\n\trequireWellFormed: boolean,\n\twithFictionalParent: boolean = false\n): string {\n\t// 1. Let context document be the value of node's node document.\n\t// 2. If context document is an HTML document, return an HTML serialization of node.\n\t// (HTML documents not implemented)\n\n\t// 3. Otherwise, context document is an XML document; return an XML serialization of node\n\t// passing the flag require well-formed.\n\t// Note: if implemented as stated in the spec, this would make innerHTML return the outerHTML\n\t// and make outerHTML trigger undefined behavior (the spec doesn't state the type of the\n\t// fictional node that acts as a parent). Instead, serialize the children only\n\tconst childNodes = withFictionalParent ? [node] : node.childNodes;\n\tconst result: string[] = [];\n\tfor (const child of childNodes) {\n\t\tproduceXmlSerialization(child, requireWellFormed, result);\n\t}\n\treturn result.join('');\n\n\t// NOTE: The XML serialization defined in this document conforms to the requirements of the XML\n\t// fragment serialization algorithm defined in [HTML5].\n}\n\n// 3.2.1. XML Serialization\n\n/**\n * To produce an XML serialization of a Node node given a flag require well-formed, run the\n * following steps:\n *\n * @param node              - The node to serialize\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n */\nexport function produceXmlSerialization(\n\tnode: Node,\n\trequireWellFormed: boolean,\n\tresult: string[]\n): void {\n\t// 2. Let prefix map be a new namespace prefix map.\n\tconst prefixMap = NamespacePrefixMap.new();\n\n\t// 3. Add the XML namespace with prefix value \"xml\" to prefix map.\n\t// (handled above)\n\n\t// 4. Let prefix index be a generated namespace prefix index with value 1. The generated\n\t// namespace prefix index is used to generate a new unique prefix value when no suitable\n\t// existing namespace prefix is available to serialize a node's namespaceURI (or the\n\t// namespaceURI of one of node's attributes). See the generate a prefix algorithm.\n\tconst prefixIndex: PrefixIndex = { value: 1 };\n\n\t// 5. Return the result of running the XML serialization algorithm on node passing the context\n\t// namespace namespace, namespace prefix map prefix map, generated namespace prefix index\n\t// reference to prefix index, and the flag require well-formed. If an exception occurs during\n\t// the execution of the algorithm, then catch that exception and throw an \"InvalidStateError\"\n\t// DOMException.\n\ttry {\n\t\trunXmlSerializationAlgorithm(node, prefixMap, prefixIndex, requireWellFormed, result);\n\t} catch (error) {\n\t\treturn throwInvalidStateError((error as Error).message);\n\t}\n}\n\n/**\n * The XML serialization algorithm produces an XML serialization of an arbitrary DOM node node based\n * on the node's interface type. Each referenced algorithm is to be passed the arguments as they\n * were recieved by the caller and return their result to the caller. Re-throw any exceptions.\n *\n * @param node              - The node to serialize\n * @param prefixMap         - The namespace prefix map\n * @param prefixIndex       - A reference to the generated namespace prefix index\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n *\n * @returns The serialization of node\n */\nfunction runXmlSerializationAlgorithm(\n\tnode: Node,\n\tprefixMap: NamespacePrefixMap,\n\tprefixIndex: PrefixIndex,\n\trequireWellFormed: boolean,\n\tresult: string[]\n): void {\n\t// If node's interface is:\n\tswitch (node.nodeType) {\n\t\t// Element: Run the algorithm for XML serializing an Element node node.\n\t\tcase NodeType.ELEMENT_NODE:\n\t\t\tserializeElementNode(node, prefixMap, prefixIndex, requireWellFormed, result);\n\t\t\treturn;\n\n\t\t// Document: Run the algorithm for XML serializing a Document node node.\n\t\tcase NodeType.DOCUMENT_NODE:\n\t\t\tserializeDocumentNode(node, prefixMap, prefixIndex, requireWellFormed, result);\n\t\t\treturn;\n\n\t\t// Comment: Run the algorithm for XML serializing a Comment node node.\n\t\tcase NodeType.COMMENT_NODE:\n\t\t\tserializeCommentNode(node, requireWellFormed, result);\n\t\t\treturn;\n\n\t\t// CDATASection: Run the algorithm for XML serializing a CDATASection node node.\n\t\t// Note: this is currently commented out in the DOM parsing spec, as it is based on the DOM4\n\t\t// spec which removed the CDATASection interface. It seems the interface has been restored\n\t\t// in the DOM living standard, so we'll implement its serialization as specced previously.\n\t\tcase NodeType.CDATA_SECTION_NODE:\n\t\t\tserializeCDATASectionNode(node, requireWellFormed, result);\n\t\t\treturn;\n\n\t\t// Text: Run the algorithm for XML serializing a Text node node.\n\t\tcase NodeType.TEXT_NODE:\n\t\t\tserializeTextNode(node, requireWellFormed, result);\n\t\t\treturn;\n\n\t\t// DocumentFragment: Run the algorithm for XML serializing a DocumentFragment node node.\n\t\tcase NodeType.DOCUMENT_FRAGMENT_NODE:\n\t\t\tserializeDocumentFragmentNode(node, prefixMap, prefixIndex, requireWellFormed, result);\n\t\t\treturn;\n\n\t\t// DocumentType: Run the algorithm for XML serializing a DocumentType node node.\n\t\tcase NodeType.DOCUMENT_TYPE_NODE:\n\t\t\tserializeDocumentTypeNode(node, requireWellFormed, result);\n\t\t\treturn;\n\n\t\t// ProcessingInstruction: Run the algorithm for XML serializing a ProcessingInstruction node\n\t\t// node.\n\t\tcase NodeType.PROCESSING_INSTRUCTION_NODE:\n\t\t\tserializeProcessingInstructionNode(node, requireWellFormed, result);\n\t\t\treturn;\n\n\t\t// An Attr object: Return an empty string.\n\t\tcase NodeType.ATTRIBUTE_NODE:\n\t\t\treturn;\n\n\t\t// Anything else: Throw a TypeError. Only Nodes and Attr objects can be serialized by this\n\t\t// algorithm.\n\t\t// (not reachable from public API)\n\t\t/* istanbul ignore next */\n\t\tdefault:\n\t\t\tthrow new TypeError('Only Nodes and Attr objects can be serialized by this algorithm.');\n\t}\n}\n\n/**\n * 3.2.1.1 XML serializing an Element node\n *\n * @param node              - The node to serialize\n * @param prefixMap         - The namespace prefix map\n * @param prefixIndex       - A reference to the generated namespace prefix index\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n */\nfunction serializeElementNode(\n\tnode: Node,\n\tprefixMap: NamespacePrefixMap,\n\tprefixIndex: PrefixIndex,\n\trequireWellFormed: boolean,\n\tresult: string[]\n): void {\n\tconst element = node as Element;\n\t// If the require well-formed flag is set (its value is true), and this node's localName\n\t// attribute contains the character \":\" (U+003A COLON) or does not match the XML Name\n\t// production, then throw an exception; the serialization of this node would not be a\n\t// well-formed element.\n\tif (\n\t\trequireWellFormed &&\n\t\t(element.localName.indexOf(':') >= 0 || !matchesNameProduction(element.localName))\n\t) {\n\t\tthrow new Error(\n\t\t\t`Can not serialize an element because the localName \"${element.localName}\" is not allowed.`\n\t\t);\n\t}\n\n\t// 2. Let markup be the string \"<\" (U+003C LESS-THAN SIGN).\n\tresult.push('<');\n\n\t// 3. Let qualified name be an empty string.\n\tlet qualifiedName = '';\n\n\t// 4. Let skip end tag be a boolean flag with value false.\n\tlet skipEndTag = false;\n\n\t// 5. Let ignore namespace definition attribute be a boolean flag with value false.\n\t// (alternate approach used to determine if declarations should be omitted)\n\n\t// 6. Given prefix map, copy a namespace prefix map and let map be the result.\n\tconst map = prefixMap.recordNamespaceInformation(element);\n\n\t// 7. Let local prefixes map be an empty map. The map has unique Node prefix strings as its\n\t// keys, with corresponding namespaceURI Node values as the map's key values (in this map, the\n\t// null namespace is represented by the empty string).\n\t// NOTE: This map is local to each element. It is used to ensure there are no conflicting\n\t// prefixes should a new namespace prefix attribute need to be generated. It is also used to\n\t// enable skipping of duplicate prefix definitions when writing an element's attributes: the map\n\t// allows the algorithm to distinguish between a prefix in the namespace prefix map that might\n\t// be locally-defined (to the current Element) and one that is not.\n\t// (local prefixes tracked in prefixMap)\n\n\t// 8. Let local default namespace be the result of recording the namespace information for node\n\t// given map and local prefixes map.\n\t// NOTE: The above step will update map with any found namespace prefix definitions, add the\n\t// found prefix definitions to the local prefixes map and return a local default namespace value\n\t// defined by a default namespace attribute if one exists. Otherwise it returns null.\n\t// (default namespace tracked in prefixMap)\n\n\t// 9. Let inherited ns be a copy of namespace.\n\t// (inherited namespace tracked in prefixMap)\n\n\t// 10. Let ns be the value of node's namespaceURI attribute.\n\t// (unnecessary alias)\n\n\t// (various branches omitted as the specification contains bugs)\n\n\t// 12.3. If the value of prefix matches \"xmlns\", then run the following steps:\n\t// 12.3.1. If the require well-formed flag is set, then throw an error. An Element with\n\t// prefix \"xmlns\" will not legally round-trip in a conforming XML parser.\n\tif (element.prefix === 'xmlns' && requireWellFormed) {\n\t\tthrow new Error(\n\t\t\t'Can not serialize an element with prefix \"xmlns\" because it will ' +\n\t\t\t\t'not legally round-trip in a conforming XML parser.'\n\t\t);\n\t}\n\n\tconst prefix = map.getPreferredPrefix(element, prefixIndex);\n\n\tif (prefix !== null) {\n\t\tqualifiedName += `${prefix}:`;\n\t}\n\tqualifiedName += element.localName;\n\tresult.push(qualifiedName);\n\n\tif (map.prefixToNamespace(prefix) !== element.namespaceURI) {\n\t\t// We may have redeclared this prefix or default namespace\n\t\tmap.add(prefix, element.namespaceURI);\n\n\t\tif (prefix === null) {\n\t\t\tresult.push(' xmlns=\"');\n\t\t} else {\n\t\t\tresult.push(' xmlns:', prefix, '=\"');\n\t\t}\n\t\tresult.push(serializeAttributeValue(element.namespaceURI, requireWellFormed), '\"');\n\t}\n\n\t// 13. Append to markup the result of the XML serialization of node's attributes given map,\n\t// prefix index, local prefixes map, ignore namespace definition attribute flag, and require\n\t// well-formed flag.\n\tserializeAttributes(element, map, prefixIndex, requireWellFormed, result);\n\n\t// 14. If ns is the HTML namespace, and the node's list of children is empty, and the node's\n\t// localName matches any one of the following void elements: \"area\", \"base\", \"basefont\",\n\t// \"bgsound\", \"br\", \"col\", \"embed\", \"frame\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"menuitem\",\n\t// \"meta\", \"param\", \"source\", \"track\", \"wbr\"; then append the following to markup, in the order\n\t// listed:\n\tif (\n\t\telement.namespaceURI === HTML_NAMESPACE &&\n\t\t!element.hasChildNodes() &&\n\t\tHTML_VOID_ELEMENTS.indexOf(element.localName) >= 0\n\t) {\n\t\t// 14.1. \" \" (U+0020 SPACE);\n\t\t// 14.2. \"/\" (U+002F SOLIDUS).\n\t\tresult.push(' /');\n\n\t\t// and set the skip end tag flag to true.\n\t\tskipEndTag = true;\n\t}\n\n\t// 15. If ns is not the HTML namespace, and the node's list of children is empty, then append\n\t// \"/\" (U+002F SOLIDUS) to markup and set the skip end tag flag to true.\n\tif (element.namespaceURI !== HTML_NAMESPACE && !element.hasChildNodes()) {\n\t\tresult.push('/');\n\t\tskipEndTag = true;\n\t}\n\n\t// 16. Append \">\" (U+003E GREATER-THAN SIGN) to markup.\n\tresult.push('>');\n\n\t// 17. If the value of skip end tag is true, then return the value of markup and skip the\n\t// remaining steps. The node is a leaf-node.\n\tif (skipEndTag) {\n\t\treturn;\n\t}\n\n\t// 18. If ns is the HTML namespace, and the node's localName matches the string \"template\", then\n\t// this is a template element. Append to markup the result of XML serializing a DocumentFragment\n\t// node given the template element's template contents (a DocumentFragment), providing inherited\n\t// ns, map, prefix index, and the require well-formed flag.\n\t// NOTE: This allows template content to round-trip , given the rules for parsing XHTML\n\t// documents.\n\t// (HTML documents not implemented)\n\n\t// 19. Otherwise, append to markup the result of running the XML serialization algorithm on each\n\t// of node's children, in tree order, providing inherited ns, map, prefix index, and the require\n\t// well-formed flag.\n\tfor (const child of node.childNodes) {\n\t\trunXmlSerializationAlgorithm(child, map, prefixIndex, requireWellFormed, result);\n\t}\n\n\t// 20. Append the following to markup, in the order listed:\n\t// 20.1. \"</\" (U+003C LESS-THAN SIGN, U+002F SOLIDUS);\n\t// 20.2. The value of qualified name;\n\t// 20.3. \">\" (U+003E GREATER-THAN SIGN).\n\tresult.push('</', qualifiedName, '>');\n\n\t// 21. Return the value of markup.\n}\n\n// 3.2.1.1.3 Serializing an Element's attributes\n\n/**\n * The XML serialization of the attributes of an Element element together with a namespace prefix\n * map map, a generated namespace prefix index prefix index reference, a local prefixes map, a\n * ignore namespace definition attribute flag, and a require well-formed flag, is the result of the\n * following algorithm:\n *\n * @param element                            - The element for which to serialize attributes\n * @param prefixMap                          - The namespace prefix map\n * @param prefixIndex                        - The generated namespace prefix index, by reference\n * @param localPrefixesMap                   - The local prefixes map\n * @param ignoreNamespaceDefinitionAttribute - The ignore namespace definition attribute flag\n * @param requireWellFormed                  - The require well-formed flag\n * @param result                             - Array of strings in which to construct the result\n */\nfunction serializeAttributes(\n\telement: Element,\n\tmap: NamespacePrefixMap,\n\tprefixIndex: PrefixIndex,\n\trequireWellFormed: boolean,\n\tresult: string[]\n): void {\n\t// 1. Let result be the empty string.\n\t// (result constructed in-place in argument)\n\n\t// 2. Let localname set be a new empty namespace localname set. This localname set will contain\n\t// tuples of unique attribute namespaceURI and localName pairs, and is populated as each attr is\n\t// processed. This set is used to [optionally] enforce the well-formed constraint that an\n\t// element cannot have two attributes with the same namespaceURI and localName. This can occur\n\t// when two otherwise identical attributes on the same element differ only by their prefix\n\t// values.\n\tconst localNameSet: { namespaceURI: string | null; localName: string }[] = [];\n\n\t// 3. Loop: For each attribute attr in element's attributes, in the order they are specified in\n\t// the element's attribute list:\n\tfor (const attr of element.attributes) {\n\t\t// (various branches omitted as the specification contains bugs)\n\t\tlet prefix = map.getPreferredPrefix(attr, prefixIndex);\n\n\t\tif (attr.namespaceURI === XMLNS_NAMESPACE) {\n\t\t\t// Namespace declaration attribute\n\t\t\tconst declaredNamespaceUri = attr.value === '' ? null : attr.value;\n\n\t\t\t// 3.5.2.2. If the require well-formed flag is set (its value is\n\t\t\t// true), and the value of attr's value attribute matches the XMLNS\n\t\t\t// namespace, then throw an exception; the serialization of this\n\t\t\t// attribute would produce invalid XML because the XMLNS namespace\n\t\t\t// is reserved and cannot be applied as an element's namespace via\n\t\t\t// XML parsing.\n\t\t\t// NOTE: DOM APIs do allow creation of elements in the XMLNS\n\t\t\t// namespace but with strict qualifications.\n\t\t\tif (requireWellFormed && declaredNamespaceUri === XMLNS_NAMESPACE) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'The serialization of this attribute would produce invalid XML because ' +\n\t\t\t\t\t\t'the XMLNS namespace is reserved and cannot be applied as an ' +\n\t\t\t\t\t\t\"element's namespace via XML parsing.\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Don't declare the XML or XMLNS namespaces\n\t\t\tif (\n\t\t\t\tdeclaredNamespaceUri === XML_NAMESPACE ||\n\t\t\t\tdeclaredNamespaceUri === XMLNS_NAMESPACE\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst declaredPrefix = attr.prefix === null ? null : attr.localName;\n\t\t\t// 3.5.2.3. If the require well-formed flag is set (its value is\n\t\t\t// true), and the value of attr's value attribute is the empty\n\t\t\t// string, then throw an exception; namespace prefix declarations\n\t\t\t// cannot be used to undeclare a namespace (use a default namespace\n\t\t\t// declaration instead).\n\t\t\t// (we deviate from the spec here by only throwing for prefix\n\t\t\t// declarations, the implementations of this in browsers and the\n\t\t\t// spec text suggest that default namespace declarations should be\n\t\t\t// allowed to reset the default namespace to null)\n\t\t\tif (requireWellFormed && attr.prefix !== null && attr.value === '') {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Namespace prefix declarations cannot be used to undeclare a namespace. ' +\n\t\t\t\t\t\t'Use a default namespace declaration instead.'\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// The following does not cause an ordering issue as prefixes\n\t\t\t// determined for attributes on the current element will not cause\n\t\t\t// this to change.\n\t\t\tif (!map.shouldSerializeDeclaration(declaredPrefix, declaredNamespaceUri)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// 3.1. If the require well-formed flag is set (its value is true), and the localname set\n\t\t// contains a tuple whose values match those of a new tuple consisting of attr's\n\t\t// namespaceURI attribute and localName attribute, then throw an exception; the\n\t\t// serialization of this attr would fail to produce a well-formed element serialization.\n\t\tif (\n\t\t\trequireWellFormed &&\n\t\t\tlocalNameSet.find(\n\t\t\t\t(tuple) =>\n\t\t\t\t\ttuple.localName === attr.localName && tuple.namespaceURI === attr.namespaceURI\n\t\t\t)\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\t`Can not serialize a duplicate attribute for namespaceURI \"${attr.namespaceURI}\", localName \"${attr.localName}\".`\n\t\t\t);\n\t\t}\n\n\t\t// 3.2. Create a new tuple consisting of attr's namespaceURI attribute and localName\n\t\t// attribute, and add it to the localname set.\n\t\tlocalNameSet.push({ namespaceURI: attr.namespaceURI, localName: attr.localName });\n\n\t\t// 3.8. If the require well-formed flag is set (its value is true), and this attr's\n\t\t// localName attribute contains the character \":\" (U+003A COLON) or does not match the XML\n\t\t// Name production or equals \"xmlns\" and attribute namespace is null, then throw an\n\t\t// exception; the serialization of this attr would not be a well-formed attribute.\n\t\tif (\n\t\t\trequireWellFormed &&\n\t\t\t(attr.localName.indexOf(':') >= 0 ||\n\t\t\t\t!matchesNameProduction(attr.localName) ||\n\t\t\t\t(attr.localName === 'xmlns' && attr.namespaceURI === null))\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\t`Can not serialize an attribute because the localName \"${attr.localName}\" is not allowed.`\n\t\t\t);\n\t\t}\n\n\t\t// Do we need a declaration?\n\t\tif (prefix !== null && map.prefixToNamespace(prefix) !== attr.namespaceURI) {\n\t\t\tresult.push(\n\t\t\t\t' xmlns:',\n\t\t\t\tprefix,\n\t\t\t\t'=\"',\n\t\t\t\tserializeAttributeValue(attr.namespaceURI, requireWellFormed),\n\t\t\t\t'\"'\n\t\t\t);\n\t\t\tmap.add(prefix, attr.namespaceURI);\n\t\t}\n\n\t\tresult.push(' ');\n\t\tif (prefix !== null) {\n\t\t\tresult.push(prefix, ':');\n\t\t}\n\t\tresult.push(\n\t\t\tattr.localName,\n\t\t\t'=\"',\n\t\t\tserializeAttributeValue(attr.value, requireWellFormed),\n\t\t\t'\"'\n\t\t);\n\t}\n\n\t// 4. Return the value of result.\n}\n\n/**\n * When serializing an attribute value given an attribute value and require well-formed flag, the\n * user agent must run the following steps:\n *\n * @param attributeValue    - The attribute value to serialize\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n *\n * @returns The serialized attribute value\n */\nfunction serializeAttributeValue(\n\tattributeValue: string | null,\n\trequireWellFormed: boolean\n): string {\n\t// 1. If the require well-formed flag is set (its value is true), and attribute value contains\n\t// characters that are not matched by the XML Char production, then throw an exception; the\n\t// serialization of this attribute value would fail to produce a well-formed element\n\t// serialization.\n\tif (requireWellFormed && attributeValue !== null && !matchesCharProduction(attributeValue)) {\n\t\tthrow new Error(\n\t\t\t'Can not serialize an attribute value because it contains invalid characters.'\n\t\t);\n\t}\n\n\t// 2. If attribute value is null, then return the empty string.\n\tif (attributeValue === null) {\n\t\treturn '';\n\t}\n\n\t// 3. Otherwise, attribute value is a string. Return the value of attribute value, first\n\t// replacing any occurrences of the following:\n\treturn (\n\t\tattributeValue\n\t\t\t// 3.1. \"&\" with \"&amp;\"\n\t\t\t.replace(/&/g, '&amp;')\n\t\t\t// 3.2. \"\"\" with \"&quot;\"\n\t\t\t.replace(/\"/g, '&quot;')\n\t\t\t// 3.3. \"<\" with \"&lt;\"\n\t\t\t.replace(/</g, '&lt;')\n\t\t\t// 3.4. \">\" with \"&gt;\"\n\t\t\t.replace(/>/g, '&gt;')\n\t\t\t// (we deviate from the spec here to also escape whitespace characters, this matches\n\t\t\t// the behavior of Chrome, Firefox and Edge, although the specific encoding varies\n\t\t\t// between those browsers)\n\t\t\t.replace(/\\t/g, '&#9;')\n\t\t\t.replace(/\\n/g, '&#10;')\n\t\t\t.replace(/\\r/g, '&#13;')\n\t);\n\n\t// NOTE: This matches behavior present in browsers, and goes above and beyond the grammar\n\t// requirement in the XML specification's AttValue production by also replacing \">\" characters.\n}\n\n/**\n * 3.2.1.2 XML serializing a Document node\n *\n * @param node              - The node to serialize\n * @param prefixMap         - The namespace prefix map\n * @param prefixIndex       - A reference to the generated namespace prefix index\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n */\nfunction serializeDocumentNode(\n\tnode: Node,\n\tprefixMap: NamespacePrefixMap,\n\tprefixIndex: PrefixIndex,\n\trequireWellFormed: boolean,\n\tresult: string[]\n): void {\n\tconst document = node as Document;\n\t// 1. If the require well-formed flag is set (its value is true), and this node has no\n\t// documentElement (the documentElement attribute's value is null), then throw an exception; the\n\t// serialization of this node would not be a well-formed document.\n\tif (requireWellFormed && document.documentElement === null) {\n\t\tthrow new Error('Can not serialize a document with no documentElement.');\n\t}\n\n\t// 2. Otherwise, run the following steps:\n\n\t// 2.1. Let serialized document be an empty string.\n\t// (constructed in-place in result argument)\n\n\t// 2.2. For each child child of node, in tree order, run the XML serialization algorithm on the\n\t// child passing along the provided arguments, and append the result to serialized document.\n\t// NOTE: This will serialize any number of ProcessingInstruction and Comment nodes both before\n\t// and after the Document's documentElement node, including at most one DocumentType node. (Text\n\t// nodes are not allowed as children of the Document.)\n\tfor (const child of document.childNodes) {\n\t\trunXmlSerializationAlgorithm(child, prefixMap, prefixIndex, requireWellFormed, result);\n\t}\n\n\t// 2.3. Return the value of serialized document.\n}\n\n/**\n * 3.2.1.3 XML serializing a Comment node\n *\n * @param node              - The node to serialize\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n */\nfunction serializeCommentNode(node: Node, requireWellFormed: boolean, result: string[]): void {\n\tconst comment = node as Comment;\n\t// 1. If the require well-formed flag is set (its value is true), and node's data contains\n\t// characters that are not matched by the XML Char production or contains \"--\" (two adjacent\n\t// U+002D HYPHEN-MINUS characters) or that ends with a \"-\" (U+002D HYPHEN-MINUS) character, then\n\t// throw an exception; the serialization of this node's data would not be well-formed.\n\tif (\n\t\trequireWellFormed &&\n\t\t(!matchesCharProduction(comment.data) ||\n\t\t\tcomment.data.indexOf('--') >= 0 ||\n\t\t\tcomment.data.endsWith('-'))\n\t) {\n\t\tthrow new Error('Can not serialize a comment because it contains invalid characters.');\n\t}\n\n\t// 2. Otherwise, return the concatenation of \"<!--\", node's data, and \"-->\".\n\tresult.push('<!--', comment.data, '-->');\n}\n\n/**\n * (not currently in spec) XML serializing a CDATASection node\n *\n * @param node              - The node to serialize\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n */\nfunction serializeCDATASectionNode(node: Node, requireWellFormed: boolean, result: string[]): void {\n\tconst cs = node as CDATASection;\n\n\t// 1. Let markup be the concatenation of \"<![CDATA[\", node's data, and \"]]>\".\n\tresult.push('<![CDATA[', cs.data, ']]>');\n\n\t// 2. Return the value of markup.\n}\n\n/**\n * 3.2.1.4 XML serializing a Text node\n *\n * @param node              - The node to serialize\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n */\nfunction serializeTextNode(node: Node, requireWellFormed: boolean, result: string[]): void {\n\tconst text = node as Text;\n\t// 1. If the require well-formed flag is set (its value is true), and node's data contains\n\t// characters that are not matched by the XML Char production, then throw an exception; the\n\t// serialization of this node's data would not be well-formed.\n\tif (requireWellFormed && !matchesCharProduction(text.data)) {\n\t\tthrow new Error('Can not serialize a text node because it contains invalid characters.');\n\t}\n\n\t// 2. Let markup be the value of node's data.\n\tlet markup = text.data;\n\n\t// 3. Replace any occurrences of \"&\" in markup by \"&amp;\".\n\tmarkup = markup.replace(/&/g, '&amp;');\n\n\t// 4. Replace any occurrences of \"<\" in markup by \"&lt;\".\n\tmarkup = markup.replace(/</g, '&lt;');\n\n\t// 5. Replace any occurrences of \">\" in markup by \"&gt;\".\n\tmarkup = markup.replace(/>/g, '&gt;');\n\n\t// 6. Return the value of markup.\n\tresult.push(markup);\n}\n\n/**\n * 3.2.1.5 XML serializing a DocumentFragment node\n *\n * @param node              - The node to serialize\n * @param prefixMap         - The namespace prefix map\n * @param prefixIndex       - A reference to the generated namespace prefix index\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n */\nfunction serializeDocumentFragmentNode(\n\tnode: Node,\n\tprefixMap: NamespacePrefixMap,\n\tprefixIndex: PrefixIndex,\n\trequireWellFormed: boolean,\n\tresult: string[]\n): void {\n\t// 1. Let markup the empty string.\n\t// (constructed in-place in result argument)\n\n\t// 2. For each child child of node, in tree order, run the XML serialization algorithm on the\n\t// child given namespace, prefix map, a reference to prefix index, and flag require well-formed.\n\t// Concatenate the result to markup.\n\tfor (const child of node.childNodes) {\n\t\trunXmlSerializationAlgorithm(child, prefixMap, prefixIndex, requireWellFormed, result);\n\t}\n\n\t// 3. Return the value of markup.\n}\n\n/**\n * 3.2.1.6 XML serializing a DocumentType node\n *\n * @param node              - The node to serialize\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n */\nfunction serializeDocumentTypeNode(node: Node, requireWellFormed: boolean, result: string[]): void {\n\tconst dt = node as DocumentType;\n\t// 1. If the require well-formed flag is true and the node's publicId attribute contains\n\t// characters that are not matched by the XML PubidChar production, then throw an exception; the\n\t// serialization of this node would not be a well-formed document type declaration.\n\tif (requireWellFormed && !matchesPubidCharProduction(dt.publicId)) {\n\t\tthrow new Error(\n\t\t\t'Can not serialize a document type because the publicId contains invalid characters.'\n\t\t);\n\t}\n\n\t// 2. If the require well-formed flag is true and the node's systemId attribute contains\n\t// characters that are not matched by the XML Char production or that contains both a \"\"\"\n\t// (U+0022 QUOTATION MARK) and a \"'\" (U+0027 APOSTROPHE), then throw an exception; the\n\t// serialization of this node would not be a well-formed document type declaration.\n\tif (\n\t\trequireWellFormed &&\n\t\t(!matchesCharProduction(dt.systemId) ||\n\t\t\t(dt.systemId.indexOf('\"') >= 0 && dt.systemId.indexOf(\"'\") >= 0))\n\t) {\n\t\tthrow new Error(\n\t\t\t'Can not serialize a document type because the systemId contains invalid characters.'\n\t\t);\n\t}\n\n\t// 3. Let markup be an empty string.\n\t// (constructed in-place in result argument)\n\n\t// 4. Append the string \"<!DOCTYPE\" to markup.\n\tresult.push('<!DOCTYPE');\n\n\t// 5. Append \" \" (U+0020 SPACE) to markup.\n\tresult.push(' ');\n\n\t// 6. Append the value of the node's name attribute to markup. For a node belonging to an HTML\n\t// document, the value will be all lowercase.\n\t// (HTML documents not implemented)\n\tresult.push(dt.name);\n\n\t// 7. If the node's publicId is not the empty string then append the following, in the order\n\t// listed, to markup:\n\tif (dt.publicId !== '') {\n\t\t// 7.1. \" \" (U+0020 SPACE);\n\t\t// 7.2. The string \"PUBLIC\";\n\t\t// 7.3. \" \" (U+0020 SPACE);\n\t\t// 7.4. \"\"\" (U+0022 QUOTATION MARK);\n\t\t// 7.5. The value of the node's publicId attribute;\n\t\t// 7.6. \"\"\" (U+0022 QUOTATION MARK).\n\t\tresult.push(' PUBLIC \"', dt.publicId, '\"');\n\t}\n\n\t// 8. If the node's systemId is not the empty string and the node's publicId is set to the empty\n\t// string, then append the following, in the order listed, to markup:\n\tif (dt.systemId !== '' && dt.publicId === '') {\n\t\t// 8.1. \" \" (U+0020 SPACE);\n\t\t// 8.2. The string \"SYSTEM\".\n\t\tresult.push(' SYSTEM');\n\t}\n\n\t// 9. If the node's systemId is not the empty string then append the following, in the order\n\t// listed, to markup:\n\tif (dt.systemId !== '') {\n\t\t// 9.1. \" \" (U+0020 SPACE);\n\t\t// 9.2. \"\"\" (U+0022 QUOTATION MARK);\n\t\t// 9.3. The value of the node's systemId attribute;\n\t\t// 9.4. \"\"\" (U+0022 QUOTATION MARK).\n\t\tresult.push(' \"', dt.systemId, '\"');\n\t}\n\n\t// 10. Append \">\" (U+003E GREATER-THAN SIGN) to markup.\n\tresult.push('>');\n\n\t// 11. Return the value of markup.\n}\n\n/**\n * 3.2.1.7 XML serializing a ProcessingInstruction node\n *\n * @param node              - The node to serialize\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n */\nfunction serializeProcessingInstructionNode(\n\tnode: Node,\n\trequireWellFormed: boolean,\n\tresult: string[]\n): void {\n\tconst pi = node as ProcessingInstruction;\n\t// 1. If the require well-formed flag is set (its value is true), and node's target contains a\n\t// \":\" (U+003A COLON) character or is an ASCII case-insensitive match for the string \"xml\", then\n\t// throw an exception; the serialization of this node's target would not be well-formed.\n\tif (requireWellFormed) {\n\t\tif (pi.target.indexOf(':') >= 0) {\n\t\t\tthrow new Error(\n\t\t\t\t`Can not serialize a processing instruction because the target \"${pi.target}\" may not contain \":\".`\n\t\t\t);\n\t\t}\n\t\tif (pi.target.toLowerCase() === 'xml') {\n\t\t\tthrow new Error(\n\t\t\t\t'Can not serialize a processing instruction because \"xml\" may not be used as target.'\n\t\t\t);\n\t\t}\n\t}\n\n\t// 2. If the require well-formed flag is set (its value is true), and node's data contains\n\t// characters that are not matched by the XML Char production or contains the string \"?>\"\n\t// (U+003F QUESTION MARK, U+003E GREATER-THAN SIGN), then throw an exception; the serialization\n\t// of this node's data would not be well-formed.\n\tif (requireWellFormed && (!matchesCharProduction(pi.data) || pi.data.indexOf('?>') >= 0)) {\n\t\tthrow new Error(\n\t\t\t'Can not serialize a processing instruction because the data contains invalid characters.'\n\t\t);\n\t}\n\n\t// 3. Let markup be the concatenation of the following, in the order listed:\n\t// 3.1. \"<?\" (U+003C LESS-THAN SIGN, U+003F QUESTION MARK);\n\t// 3.2. The value of node's target;\n\t// 3.3. \" \" (U+0020 SPACE);\n\t// 3.4. The value of node's data;\n\t// 3.5. \"?>\" (U+003F QUESTION MARK, U+003E GREATER-THAN SIGN).\n\tresult.push('<?', pi.target, ' ', pi.data, '?>');\n\n\t// 4. Return the value of markup.\n}\n","import { ParentNode, NonDocumentTypeChildNode, ChildNode } from './mixins';\nimport { getChildren, getPreviousElementSibling, getNextElementSibling } from './mixins';\nimport Attr from './Attr';\nimport Document from './Document';\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport { matchesNameProduction } from './dom-parsing/parsingAlgorithms';\nimport { serializeFragment } from './dom-parsing/serializationAlgorithms';\nimport {\n\tappendNodes,\n\tgetDescendantTextContent,\n\tinsertNodesAfter,\n\tinsertNodesBefore,\n\tprependNodes,\n\tremoveFromParent,\n\treplaceChildren,\n\treplaceWithNodes,\n\tstringReplaceAll,\n} from './util/mutationAlgorithms';\nimport {\n\tappendAttribute,\n\tchangeAttribute,\n\tremoveAttribute,\n\treplaceAttribute,\n} from './util/attrMutations';\nimport {\n\texpectArity,\n\tthrowInUseAttributeError,\n\tthrowInvalidCharacterError,\n\tthrowNotFoundError,\n} from './util/errorHelpers';\nimport {\n\tvalidateAndExtract,\n\tlocateNamespacePrefix,\n\tXMLNS_NAMESPACE,\n} from './util/namespaceHelpers';\nimport { NodeType } from './util/NodeType';\nimport { asNullableString, asObject, ifNullActAsIfEmptyString } from './util/typeHelpers';\nimport {\n\tgetListOfElementsWithNamespaceAndLocalName,\n\tgetListOfElementsWithQualifiedName,\n} from './util/treeHelpers';\n\n/**\n * 3.9. Interface Element\n *\n * @public\n */\nexport default class Element\n\textends Node\n\timplements ParentNode, NonDocumentTypeChildNode, ChildNode\n{\n\t// Node\n\n\tpublic get nodeType(): number {\n\t\treturn NodeType.ELEMENT_NODE;\n\t}\n\n\tpublic get nodeName(): string {\n\t\treturn this.tagName;\n\t}\n\n\tpublic get nodeValue(): string | null {\n\t\treturn null;\n\t}\n\n\tpublic set nodeValue(newValue: string | null) {\n\t\t// Do nothing.\n\t}\n\n\tpublic get textContent(): string | null {\n\t\t// Return the descendant text content of this\n\t\treturn getDescendantTextContent(this);\n\t}\n\n\tpublic set textContent(newValue: string | null) {\n\t\tnewValue = ifNullActAsIfEmptyString(newValue);\n\t\tstringReplaceAll(this, newValue);\n\t}\n\n\tpublic lookupPrefix(namespace: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\t\tnamespace = asNullableString(namespace);\n\n\t\t// 1. If namespace is null or the empty string, then return null.\n\t\tif (namespace === null || namespace === '') {\n\t\t\treturn null;\n\t\t}\n\n\t\t// 2. Switch on this:\n\t\t// Element - Return the result of locating a namespace prefix for it using namespace.\n\t\treturn locateNamespacePrefix(this, namespace);\n\t}\n\n\tpublic lookupNamespaceURI(prefix: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\t\tprefix = asNullableString(prefix);\n\n\t\t// 1. If prefix is the empty string, then set it to null.\n\t\tif (prefix === '') {\n\t\t\tprefix = null;\n\t\t}\n\n\t\t// 2. Return the result of running locate a namespace for this using prefix.\n\n\t\t// To locate a namespace for a node using prefix, switch on node: Element\n\t\t// 1. If its namespace is non-null and its namespace prefix is prefix, then return\n\t\t// namespace.\n\t\tif (this.namespaceURI !== null && this.prefix === prefix) {\n\t\t\treturn this.namespaceURI;\n\t\t}\n\n\t\t// 2. If it has an attribute whose namespace is the XMLNS namespace, namespace prefix is\n\t\t// \"xmlns\", and local name is prefix, or if prefix is null and it has an attribute whose\n\t\t// namespace is the XMLNS namespace, namespace prefix is null, and local name is \"xmlns\",\n\t\t// then return its value if it is not the empty string, and null otherwise.\n\t\tlet ns = null;\n\t\tif (prefix !== null) {\n\t\t\tconst attr = this.getAttributeNodeNS(XMLNS_NAMESPACE, prefix);\n\t\t\tif (attr && attr.prefix === 'xmlns') {\n\t\t\t\tns = attr.value;\n\t\t\t}\n\t\t} else {\n\t\t\tconst attr = this.getAttributeNodeNS(XMLNS_NAMESPACE, 'xmlns');\n\t\t\tif (attr && attr.prefix === null) {\n\t\t\t\tns = attr.value;\n\t\t\t}\n\t\t}\n\t\tif (ns !== null) {\n\t\t\treturn ns !== '' ? ns : null;\n\t\t}\n\n\t\t// 3. If its parent element is null, then return null.\n\t\tconst parentElement = this.parentElement;\n\t\tif (parentElement === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// 4. Return the result of running locate a namespace on its parent element using prefix.\n\t\treturn parentElement.lookupNamespaceURI(prefix);\n\t}\n\n\t// ChildNode\n\n\tpublic before(...nodes: (Node | string)[]): void {\n\t\tinsertNodesBefore(this, nodes);\n\t}\n\n\tpublic after(...nodes: (Node | string)[]): void {\n\t\tinsertNodesAfter(this, nodes);\n\t}\n\n\tpublic replaceWith(...nodes: (Node | string)[]): void {\n\t\treplaceWithNodes(this, nodes);\n\t}\n\n\tpublic remove(): void {\n\t\tremoveFromParent(this);\n\t}\n\n\t// ParentNode\n\n\tpublic get children(): Element[] {\n\t\treturn getChildren(this);\n\t}\n\n\tpublic firstElementChild: Element | null = null;\n\tpublic lastElementChild: Element | null = null;\n\tpublic childElementCount: number = 0;\n\n\tpublic prepend(...nodes: (Node | string)[]): void {\n\t\tprependNodes(this, nodes);\n\t}\n\n\tpublic append(...nodes: (Node | string)[]): void {\n\t\tappendNodes(this, nodes);\n\t}\n\n\tpublic replaceChildren(...nodes: (Node | string)[]): void {\n\t\treplaceChildren(this, nodes);\n\t}\n\n\t// NonDocumentTypeChildNode\n\n\tpublic get previousElementSibling(): Element | null {\n\t\treturn getPreviousElementSibling(this);\n\t}\n\n\tpublic get nextElementSibling(): Element | null {\n\t\treturn getNextElementSibling(this);\n\t}\n\n\t// Element\n\n\tpublic readonly namespaceURI: string | null;\n\tpublic readonly prefix: string | null;\n\tpublic readonly localName: string;\n\tpublic readonly tagName: string;\n\n\t/**\n\t * (non-standard) Use Document#createElement or Document#createElementNS to create an Element.\n\t *\n\t * @param namespace - Namespace for the element\n\t * @param prefix    - Prefix for the element\n\t * @param localName - Local name for the element\n\t */\n\tconstructor(namespace: string | null, prefix: string | null, localName: string) {\n\t\tsuper();\n\n\t\tthis.namespaceURI = namespace;\n\t\tthis.prefix = prefix;\n\t\tthis.localName = localName;\n\t\tthis.tagName = prefix === null ? localName : `${prefix}:${localName}`;\n\t}\n\n\t/**\n\t * Returns whether the element has any attributes.\n\t *\n\t * @returns True if the element has attributes, otherwise false\n\t */\n\tpublic hasAttributes(): boolean {\n\t\treturn this.attributes.length > 0;\n\t}\n\n\t/**\n\t * The attributes for the element.\n\t *\n\t * Non-standard: the spec defines this as a NamedNodeMap, while this implementation uses an\n\t * array.\n\t */\n\tpublic readonly attributes: Attr[] = [];\n\n\t/**\n\t * Get the value of the specified attribute.\n\t *\n\t * @param qualifiedName - The qualified name of the attribute\n\t *\n\t * @returns The value of the attribute, or null if no such attribute exists\n\t */\n\tpublic getAttribute(qualifiedName: string): string | null {\n\t\texpectArity(arguments, 1);\n\t\tqualifiedName = String(qualifiedName);\n\n\t\t// 1. Let attr be the result of getting an attribute given qualifiedName and the context\n\t\t// object.\n\t\tconst attr = getAttributeByName(qualifiedName, this);\n\n\t\t// 2. If attr is null, return null.\n\t\tif (attr === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// 3. Return attr’s value.\n\t\treturn attr.value;\n\t}\n\n\t/**\n\t * Get the value of the specified attribute.\n\t *\n\t * @param namespace - The namespace of the attribute\n\t * @param localName - The local name of the attribute\n\t *\n\t * @returns The value of the attribute, or null if no such attribute exists\n\t */\n\tpublic getAttributeNS(namespace: string | null, localName: string): string | null {\n\t\texpectArity(arguments, 2);\n\t\tnamespace = asNullableString(namespace);\n\t\tlocalName = String(localName);\n\n\t\t// 1. Let attr be the result of getting an attribute given namespace, localName, and the\n\t\t// this.\n\t\tconst attr = getAttributeByNamespaceAndLocalName(namespace, localName, this);\n\n\t\t// 2. If attr is null, return null.\n\t\tif (attr === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// 3. Return attr’s value.\n\t\treturn attr.value;\n\t}\n\n\t/**\n\t * Sets the value of the specified attribute.\n\t *\n\t * @param qualifiedName - The qualified name of the attribute\n\t * @param value         - The new value for the attribute\n\t */\n\tpublic setAttribute(qualifiedName: string, value: string): void {\n\t\texpectArity(arguments, 2);\n\t\tqualifiedName = String(qualifiedName);\n\t\tvalue = String(value);\n\n\t\t// 1. If qualifiedName does not match the Name production in XML, then throw an\n\t\t// InvalidCharacterError.\n\t\tif (!matchesNameProduction(qualifiedName)) {\n\t\t\tthrowInvalidCharacterError('The qualified name does not match the Name production');\n\t\t}\n\n\t\t// 2. If this is in the HTML namespace and its node document is an HTML\n\t\t// document, then set qualifiedName to qualifiedName in ASCII lowercase.\n\t\t// (html documents not implemented)\n\n\t\t// 3. Let attribute be the first attribute in this’s attribute list whose\n\t\t// qualified name is qualifiedName, and null otherwise.\n\t\tconst attribute = getAttributeByName(qualifiedName, this);\n\n\t\t// 4. If attribute is null, create an attribute whose local name is qualifiedName, value is\n\t\t// value, and node document is this’s node document, then append this attribute to\n\t\t// this, and then return.\n\t\tif (attribute === null) {\n\t\t\tconst context = getContext(this);\n\t\t\tconst attribute = new context.Attr(null, null, qualifiedName, value, this);\n\t\t\tattribute.ownerDocument = this.ownerDocument;\n\t\t\tappendAttribute(attribute, this);\n\t\t\treturn;\n\t\t}\n\n\t\t// 5. Change attribute to value.\n\t\tchangeAttribute(attribute, value);\n\t}\n\n\t/**\n\t * Sets the value of the specified attribute.\n\t *\n\t * @param namespace     - The namespace of the attribute\n\t * @param qualifiedName - The qualified name of the attribute\n\t * @param value         - The value for the attribute\n\t */\n\tpublic setAttributeNS(namespace: string | null, qualifiedName: string, value: string): void {\n\t\texpectArity(arguments, 3);\n\t\tnamespace = asNullableString(namespace);\n\t\tqualifiedName = String(qualifiedName);\n\t\tvalue = String(value);\n\n\t\t// 1. Let namespace, prefix, and localName be the result of passing namespace and\n\t\t// qualifiedName to validate and extract.\n\t\tconst {\n\t\t\tnamespace: validatedNamespace,\n\t\t\tprefix,\n\t\t\tlocalName,\n\t\t} = validateAndExtract(namespace, qualifiedName);\n\n\t\t// 2. Set an attribute value for this using localName, value, and also prefix\n\t\t// and namespace.\n\t\tsetAttributeValue(this, localName, value, prefix, validatedNamespace);\n\t}\n\n\t/**\n\t * Removes the specified attribute.\n\t *\n\t * @param qualifiedName - The qualified name of the attribute\n\t */\n\tpublic removeAttribute(qualifiedName: string): void {\n\t\texpectArity(arguments, 1);\n\t\tqualifiedName = String(qualifiedName);\n\n\t\tremoveAttributeByName(qualifiedName, this);\n\t}\n\n\t/**\n\t * Removes the specified attribute.\n\t *\n\t * @param namespace - The namespace of the attribute\n\t * @param localName - The local name of the attribute\n\t */\n\tpublic removeAttributeNS(namespace: string | null, localName: string): void {\n\t\texpectArity(arguments, 2);\n\t\tnamespace = asNullableString(namespace);\n\t\tlocalName = String(localName);\n\n\t\tremoveAttributeByNamespaceAndLocalName(namespace, localName, this);\n\t}\n\n\t/**\n\t * If force is not given, \"toggles\" qualifiedName, removing it if it is present and adding it if\n\t * it is not present. If force is true, adds qualifiedName. If force is false, removes\n\t * qualifiedName.\n\t *\n\t * Returns true if qualifiedName is now present, and false otherwise.\n\t *\n\t * @param qualifiedName - The qualified name of the attribute to toggle\n\t * @param force         - If true, adds the attribute, if false removes it\n\t */\n\tpublic toggleAttribute(qualifiedName: string, force?: boolean): boolean {\n\t\t// 1. If qualifiedName does not match the Name production in XML, then throw an\n\t\t// \"InvalidCharacterError\" DOMException.\n\t\tif (!matchesNameProduction(qualifiedName)) {\n\t\t\tthrowInvalidCharacterError('The qualified name does not match the Name production');\n\t\t}\n\n\t\t// 2. If this is in the HTML namespace and its node document is an HTML\n\t\t// document, then set qualifiedName to qualifiedName in ASCII lowercase.\n\t\t// (html documents not implemented)\n\n\t\t// 3. Let attribute be the first attribute in this’s attribute list whose\n\t\t// qualified name is qualifiedName, and null otherwise.\n\t\tconst attribute = getAttributeByName(qualifiedName, this);\n\n\t\t// 4. If attribute is null, then:\n\t\tif (attribute === null) {\n\t\t\t// 4.1. If force is not given or is true,\n\t\t\tif (force === undefined || force === true) {\n\t\t\t\t// ...create an attribute whose local name is qualifiedName, value is the empty\n\t\t\t\t// string, and node document is this’s node document,\n\t\t\t\tconst context = getContext(this);\n\t\t\t\tconst attribute = new context.Attr(null, null, qualifiedName, '', this);\n\t\t\t\tattribute.ownerDocument = this.ownerDocument;\n\t\t\t\t// ...then append this attribute to this,\n\t\t\t\tappendAttribute(attribute, this);\n\t\t\t\t// ...and then return true.\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// 4.2. Return false.\n\t\t\treturn false;\n\t\t}\n\n\t\t// 5. Otherwise, if force is not given or is false,\n\t\tif (force === undefined || force === false) {\n\t\t\t// ...remove an attribute given qualifiedName and this,\n\t\t\tremoveAttributeByName(qualifiedName, this);\n\t\t\t// ...and then return false.\n\t\t\treturn false;\n\t\t}\n\n\t\t// 6. Return true.\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns true if the specified attribute exists and false otherwise.\n\t *\n\t * @param qualifiedName - The qualified name of the attribute\n\t */\n\tpublic hasAttribute(qualifiedName: string): boolean {\n\t\texpectArity(arguments, 1);\n\t\tqualifiedName = String(qualifiedName);\n\n\t\t// 1. If this is in the HTML namespace and its node document is an HTML\n\t\t// document, then set qualifiedName to qualifiedName in ASCII lowercase.\n\t\t// (html documents not implemented)\n\n\t\t// 2. Return true if this has an attribute whose qualified name is\n\t\t// qualifiedName, and false otherwise.\n\t\treturn getAttributeByName(qualifiedName, this) !== null;\n\t}\n\n\t/**\n\t * Returns true if the specified attribute exists and false otherwise.\n\t *\n\t * @param namespace - The namespace of the attribute\n\t * @param localName - The local name of the attribute\n\t */\n\tpublic hasAttributeNS(namespace: string | null, localName: string): boolean {\n\t\texpectArity(arguments, 2);\n\t\tnamespace = asNullableString(namespace);\n\t\tlocalName = String(localName);\n\n\t\t// 1. If namespace is the empty string, set it to null.\n\t\t// (handled by getAttributeByNamespaceAndLocalName, called below)\n\t\t// 2. Return true if this has an attribute whose namespace is namespace and\n\t\t// local name is localName, and false otherwise.\n\t\treturn getAttributeByNamespaceAndLocalName(namespace, localName, this) !== null;\n\t}\n\n\t/**\n\t * Returns the specified attribute node, or null if no such attribute exists.\n\t *\n\t * @param qualifiedName - The qualified name of the attribute\n\t *\n\t * @returns The attribute, or null if no such attribute exists\n\t */\n\tpublic getAttributeNode(qualifiedName: string): Attr | null {\n\t\texpectArity(arguments, 1);\n\t\tqualifiedName = String(qualifiedName);\n\n\t\treturn getAttributeByName(qualifiedName, this);\n\t}\n\n\t/**\n\t * Returns the specified attribute node, or null if no such attribute exists.\n\t *\n\t * @param namespace - The namespace of the attribute\n\t * @param localName - The local name of the attribute\n\t *\n\t * @returns The attribute, or null if no such attribute exists\n\t */\n\tpublic getAttributeNodeNS(namespace: string | null, localName: string): Attr | null {\n\t\texpectArity(arguments, 2);\n\t\tnamespace = asNullableString(namespace);\n\t\tlocalName = String(localName);\n\n\t\treturn getAttributeByNamespaceAndLocalName(namespace, localName, this);\n\t}\n\n\t/**\n\t * Sets an attribute given its node\n\t *\n\t * @param attr - The attribute node to set\n\t *\n\t * @returns The previous attribute node for the attribute\n\t */\n\tpublic setAttributeNode(attr: Attr): Attr | null {\n\t\texpectArity(arguments, 1);\n\t\tattr = asObject(attr, Attr);\n\n\t\treturn setAttribute(attr, this);\n\t}\n\n\t/**\n\t * Sets an attribute given its node\n\t *\n\t * @param attr - The attribute node to set\n\t *\n\t * @returns The previous attribute node for the attribute\n\t */\n\tpublic setAttributeNodeNS(attr: Attr): Attr | null {\n\t\texpectArity(arguments, 1);\n\t\tattr = asObject(attr, Attr);\n\n\t\treturn setAttribute(attr, this);\n\t}\n\n\t/**\n\t * Removes an attribute given its node\n\t *\n\t * @param attr - The attribute node to remove\n\t *\n\t * @returns The removed attribute node\n\t */\n\tpublic removeAttributeNode(attr: Attr): Attr {\n\t\texpectArity(arguments, 1);\n\t\tattr = asObject(attr, Attr);\n\n\t\t// 1. If this’s attribute list does not contain attr, then throw a NotFoundError.\n\t\tif (this.attributes.indexOf(attr) < 0) {\n\t\t\tthrowNotFoundError('the specified attribute does not exist');\n\t\t}\n\n\t\t// 2. Remove attr.\n\t\tremoveAttribute(attr);\n\n\t\t// 3. Return attr.\n\t\treturn attr;\n\t}\n\n\t/**\n\t * Returns the list of elements with the given qualified name.\n\t *\n\t * @param qualifiedName - Qualified name of the elements to collect.\n\t *\n\t * @returns  The list of elements with matching qualified name.\n\t */\n\tpublic getElementsByTagName(qualifiedName: string): Element[] {\n\t\texpectArity(arguments, 1);\n\t\tqualifiedName = String(qualifiedName);\n\n\t\treturn getListOfElementsWithQualifiedName(qualifiedName, this);\n\t}\n\n\t/**\n\t * Returns the list of elements with the given namespace and local name.\n\t *\n\t * @param namespace - Namespace URI of the elements to collect.\n\t * @param localName - Local name of the elements to collect\n\t *\n\t * @returns  The list of elements with matching namespace and local name.\n\t */\n\tpublic getElementsByTagNameNS(namespace: string | null, localName: string): Element[] {\n\t\texpectArity(arguments, 2);\n\t\tnamespace = asNullableString(namespace);\n\t\tlocalName = String(localName);\n\n\t\treturn getListOfElementsWithNamespaceAndLocalName(namespace, localName, this);\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of the given node\n\t *\n\t * @param document - The node document to associate with the copy\n\t * @param other    - The node to copy\n\t *\n\t * @returns A shallow copy of the node\n\t */\n\tpublic _copy(document: Document): Element {\n\t\t// 2.1. Let copy be the result of creating an element, given document, node’s local name,\n\t\t// node’s namespace, node’s namespace prefix, and the value of node’s is attribute if\n\t\t// present (or null if not). The synchronous custom elements flag should be unset.\n\t\tconst copyElement = createElement(document, this.localName, this.namespaceURI, this.prefix);\n\n\t\t// 2.2. For each attribute in node’s attribute list:\n\t\tfor (const attr of this.attributes) {\n\t\t\t// 2.2.1. Let copyAttribute be a clone of attribute.\n\t\t\tconst copyAttribute = attr._copy(document);\n\n\t\t\t// 2.2.2. Append copyAttribute to copy.\n\t\t\tcopyElement.setAttributeNode(copyAttribute);\n\t\t}\n\n\t\treturn copyElement;\n\t}\n\n\t// From the DOM Parsing and Serialization spec\n\n\t/**\n\t * Returns a fragment of HTML or XML that represents the element's contents.\n\t */\n\tpublic get innerHTML() {\n\t\t// Return the result of invoking the fragment serializing algorithm on this\n\t\t// providing true for the require well-formed flag (this might throw an exception instead of\n\t\t// returning a string).\n\t\treturn serializeFragment(this, true);\n\t}\n\n\t/**\n\t * Returns a fragment of HTML or XML that represents the element and its contents.\n\t */\n\tpublic get outerHTML() {\n\t\t// Return the result of invoking the fragment serializing algorithm on a fictional node\n\t\t// whose only child is this providing true for the require well-formed flag\n\t\t// (this might throw an exception instead of returning a string).\n\t\treturn serializeFragment(this, true, true);\n\t}\n}\n\n/**\n * To create an element, given a document, localName, namespace, and optional prefix, is, and\n * synchronous custom elements flag, run these steps:\n *\n * @param document  - The node document for the new element\n * @param localName - The local name for the new element\n * @param namespace - The namespace URI for the new element, or null for the null namespace\n * @param prefix    - The prefix for the new element, or null for no prefix\n *\n * @returns The new element\n */\nexport function createElement(\n\tdocument: Document,\n\tlocalName: string,\n\tnamespace: string | null,\n\tprefix: string | null = null\n): Element {\n\t// 1. If prefix was not given, let prefix be null.\n\t// (handled by default)\n\n\t// 2. If is was not given, let is be null.\n\t// (custom elements not implemented)\n\n\t// 3. Let result be null.\n\tlet result = null;\n\n\t// 4. Let definition be the result of looking up a custom element definition given document,\n\t// namespace, localName, and is.\n\t// (custom elements not implemented)\n\n\t// 5. If definition is non-null, and definition’s name is not equal to its local name (i.e.,\n\t// definition represents a customized built-in element), then:\n\t// 5.1. Let interface be the element interface for localName and the HTML namespace.\n\t// 5.2. Set result to a new element that implements interface, with no attributes, namespace set\n\t// to the HTML namespace, namespace prefix set to prefix, local name set to localName, custom\n\t// element state set to \"undefined\", custom element definition set to null, is value set to is,\n\t// and node document set to document.\n\t// 5.3. If the synchronous custom elements flag is set, then run this step while catching any\n\t// exceptions:\n\t// 5.3.1. Upgrade element using definition.\n\t// 5.3.catch. If this step threw an exception, then:\n\t// 5.3.catch.1. Report the exception.\n\t// 5.3.catch.2. Set result's custom element state to \"failed\".\n\t// 5.4. Otherwise, enqueue a custom element upgrade reaction given result and definition.\n\t// (custom elements not implemented)\n\n\t// 6. Otherwise, if definition is non-null, then:\n\t// 6.1. If the synchronous custom elements flag is set, then run these steps while catching any\n\t// exceptions:\n\t// 6.1.1. Let C be definition’s constructor.\n\t// 6.1.2. Set result to the result of constructing C, with no arguments.\n\t// 6.1.3. Assert: result’s custom element state and custom element definition are initialized.\n\t// 6.1.4. Assert: result’s namespace is the HTML namespace.\n\t// IDL enforces that result is an HTMLElement object, which all use the HTML namespace.\n\t// 6.1.5. If result’s attribute list is not empty, then throw a NotSupportedError.\n\t// 6.1.6. If result has children, then throw a NotSupportedError.\n\t// 6.1.7. If result’s parent is non-null, then throw a NotSupportedError.\n\t// 6.1.8. If result’s node document is not document, then throw a NotSupportedError.\n\t// 6.1.9. If result’s local name is not equal to localName, then throw a NotSupportedError.\n\t// 6.1.10. Set result’s namespace prefix to prefix.\n\t// 6.1.11. Set result’s is value to null.\n\t// If any of these steps threw an exception, then:\n\t// 6.1.catch.1. Report the exception.\n\t// 6.1.catch.2. Set result to a new element that implements the HTMLUnknownElement interface,\n\t// with no attributes, namespace set to the HTML namespace, namespace prefix set to prefix,\n\t// local name set to localName, custom element state set to \"failed\", custom element definition\n\t// set to null, is value set to null, and node document set to document.\n\t// 6.2. Otherwise:\n\t// 6.2.1. Set result to a new element that implements the HTMLElement interface, with no\n\t// attributes, namespace set to the HTML namespace, namespace prefix set to prefix, local name\n\t// set to localName, custom element state set to \"undefined\", custom element definition set to\n\t// null, is value set to null, and node document set to document.\n\t// 6.2.2. Enqueue a custom element upgrade reaction given result and definition.\n\t// (custom elements not implemented)\n\n\t// 7. Otherwise:\n\t// 7.1. Let interface be the element interface for localName and namespace.\n\t// (interfaces other than Element not implemented)\n\n\t// 7.2. Set result to a new element that implements interface, with no attributes, namespace set\n\t// to namespace, namespace prefix set to prefix, local name set to localName, custom element\n\t// state set to \"uncustomized\", custom element definition set to null, is value set to is, and\n\t// node document set to document.\n\tconst context = getContext(document);\n\tresult = new context.Element(namespace, prefix, localName);\n\tresult.ownerDocument = document;\n\n\t// If namespace is the HTML namespace, and either localName is a valid custom element name or is\n\t// is non-null, then set result’s custom element state to \"undefined\".\n\t// (custom elements not implemented)\n\n\t// Return result.\n\treturn result;\n}\n\n/**\n * To get an attribute by name given a qualifiedName and element element, run these steps:\n *\n * @param qualifiedName - The qualified name of the attribute to get\n * @param element       - The element to get the attribute on\n *\n * @returns The first matching attribute, or null otherwise\n */\nfunction getAttributeByName(qualifiedName: string, element: Element): Attr | null {\n\t// 1. If element is in the HTML namespace and its node document is an HTML document, then set\n\t// qualifiedName to qualifiedName in ASCII lowercase.\n\t// (html documents not implemented)\n\n\t// 2. Return the first attribute in element’s attribute list whose qualified name is\n\t// qualifiedName, and null otherwise.\n\treturn element.attributes.find((attr) => attr.name === qualifiedName) || null;\n}\n\n/**\n * To get an attribute by namespace and local name given a namespace, localName, and element\n * element, run these steps:\n *\n * @param namespace - Namespace for the attribute\n * @param localName - Local name for the attribute\n * @param element   - The element to get the attribute on\n *\n * @returns The first matching attribute, or null otherwise\n */\nfunction getAttributeByNamespaceAndLocalName(\n\tnamespace: string | null,\n\tlocalName: string,\n\telement: Element\n): Attr | null {\n\t// 1. If namespace is the empty string, set it to null.\n\tif (namespace === '') {\n\t\tnamespace = null;\n\t}\n\n\t// 2. Return the attribute in element’s attribute list whose namespace is namespace and local\n\t// name is localName, if any, and null otherwise.\n\treturn (\n\t\telement.attributes.find(\n\t\t\t(attr) => attr.namespaceURI === namespace && attr.localName === localName\n\t\t) || null\n\t);\n}\n\n/**\n * To set an attribute given an attr and element, run these steps:\n *\n * @param attr    - The new attribute to set\n * @param element - The element to set attr on\n *\n * @returns The previous attribute with attr's namespace and local name, or null if there was no such\n *         attribute\n */\nfunction setAttribute(attr: Attr, element: Element): Attr | null {\n\t// 1. If attr’s element is neither null nor element, throw an InUseAttributeError.\n\tif (attr.ownerElement !== null && attr.ownerElement !== element) {\n\t\tthrowInUseAttributeError('attribute is in use by another element');\n\t}\n\n\t// 2. Let oldAttr be the result of getting an attribute given attr’s namespace, attr’s local\n\t// name, and element.\n\tconst oldAttr = getAttributeByNamespaceAndLocalName(attr.namespaceURI, attr.localName, element);\n\n\t// 3. If oldAttr is attr, return attr.\n\tif (oldAttr === attr) {\n\t\treturn attr;\n\t}\n\n\t// 4. If oldAttr is non-null, then replace oldAttr with attr.\n\tif (oldAttr !== null) {\n\t\treplaceAttribute(oldAttr, attr);\n\t} else {\n\t\t// 5. Otherwise, append attr to element.\n\t\tappendAttribute(attr, element);\n\t}\n\n\t// 6. Return oldAttr.\n\treturn oldAttr;\n}\n\n/**\n * To set an attribute value for an element element using a localName and value, and an optional\n * prefix, and namespace, run these steps:\n *\n * @param element   - Element to set the attribute value on\n * @param localName - Local name of the attribute\n * @param value     - New value of the attribute\n * @param prefix    - Prefix of the attribute\n * @param namespace - Namespace of the attribute\n */\nfunction setAttributeValue(\n\telement: Element,\n\tlocalName: string,\n\tvalue: string,\n\tprefix: string | null,\n\tnamespace: string | null\n): void {\n\t// 1. If prefix is not given, set it to null.\n\t// 2. If namespace is not given, set it to null.\n\t// (handled by default values)\n\n\t// 3. Let attribute be the result of getting an attribute given namespace, localName, and\n\t// element.\n\tconst attribute = getAttributeByNamespaceAndLocalName(namespace, localName, element);\n\n\t// 4. If attribute is null, create an attribute whose namespace is namespace, namespace prefix\n\t// is prefix, local name is localName, value is value, and node document is element’s node\n\t// document, then append this attribute to element, and then return.\n\tif (attribute === null) {\n\t\tconst context = getContext(element);\n\t\tconst attribute = new context.Attr(namespace, prefix, localName, value, element);\n\t\tattribute.ownerDocument = element.ownerDocument;\n\t\tappendAttribute(attribute, element);\n\t\treturn;\n\t}\n\n\t// 5. Change attribute to value.\n\tchangeAttribute(attribute, value);\n}\n\n/**\n * To remove an attribute by name given a qualifiedName and element element, run these steps:\n *\n * @param qualifiedName - Qualified name of the attribute\n * @param element       - The element to remove the attribute from\n *\n * @returns The removed attribute, or null if no matching attribute exists\n */\nfunction removeAttributeByName(qualifiedName: string, element: Element): Attr | null {\n\t// 1. Let attr be the result of getting an attribute given qualifiedName and element.\n\tconst attr = getAttributeByName(qualifiedName, element);\n\n\t// 2. If attr is non-null, then remove attr.\n\tif (attr !== null) {\n\t\tremoveAttribute(attr);\n\t}\n\n\t// 3. Return attr.\n\treturn attr;\n}\n\n/**\n * To remove an attribute by namespace and local name given a namespace, localName, and element\n * element, run these steps:\n *\n * @param namespace - The namespace of the attribute\n * @param localName - The local name of the attribute\n * @param element   - The element to remove the attribute from\n *\n * @returns The removed attribute, or null if no matching attribute exists\n */\nfunction removeAttributeByNamespaceAndLocalName(\n\tnamespace: string | null,\n\tlocalName: string,\n\telement: Element\n): Attr | null {\n\t// 1. Let attr be the result of getting an attribute given namespace, localName, and element.\n\tconst attr = getAttributeByNamespaceAndLocalName(namespace, localName, element);\n\n\t// 2. If attr is non-null, then remove attr.\n\tif (attr !== null) {\n\t\tremoveAttribute(attr);\n\t}\n\n\t// 3. Return attr.\n\treturn attr;\n}\n","import Document from '../Document';\nimport { createElement, default as Element } from '../Element';\nimport { validateAndExtract } from './namespaceHelpers';\n\n// 3.5. Interface Document\n\n/**\n * The internal createElementNS steps, given document, namespace, qualifiedName, and options, are as\n * follows:\n *\n * @param document      - The node document for the new element\n * @param namespace     - The namespace for the new element\n * @param qualifiedName - The qualified name for the new element\n *\n * @returns The new element\n */\nexport default function createElementNS(\n\tdocument: Document,\n\tnamespace: string | null,\n\tqualifiedName: string\n): Element {\n\t// 1. Let namespace, prefix, and localName be the result of passing namespace and qualifiedName\n\t// to validate and extract.\n\tconst {\n\t\tnamespace: validatedNamespace,\n\t\tprefix,\n\t\tlocalName,\n\t} = validateAndExtract(namespace, qualifiedName);\n\n\t// 2. Let is be the value of is member of options, or null if no such member exists.\n\t// (custom elements not implemented)\n\n\t// 3. Let element be the result of creating an element given document, localName, namespace,\n\t// prefix, is, and with the synchronous custom elements flag set.\n\tconst element = createElement(document, localName, validatedNamespace, prefix);\n\n\t// 4. If is is non-null, then set an attribute value for element using \"is\" and is.\n\t// (custom elements not implemented)\n\n\t// 5. Return element.\n\treturn element;\n}\n","import Document from './Document';\nimport DocumentType from './DocumentType';\nimport { createElement } from './Element';\nimport XMLDocument from './XMLDocument';\nimport { getContext } from './context/Context';\nimport createElementNS from './util/createElementNS';\nimport { expectArity } from './util/errorHelpers';\nimport { HTML_NAMESPACE, validateQualifiedName } from './util/namespaceHelpers';\nimport { asNullableObject, asNullableString, legacyNullToEmptyString } from './util/typeHelpers';\n\n/**\n * @public\n */\nexport default class DOMImplementation {\n\tprivate _document: Document;\n\n\t/**\n\t * (non-standard) Use Document#implementation to access instances of this class\n\t *\n\t * @param document - The document to associate with this instance\n\t */\n\tconstructor(document: Document) {\n\t\tthis._document = document;\n\t}\n\n\t/**\n\t * Returns a doctype, with the given qualifiedName, publicId, and systemId.\n\t *\n\t * @param qualifiedName - Qualified name for the doctype\n\t * @param publicId      - Public ID for the doctype\n\t * @param systemId      - System ID for the doctype\n\t *\n\t * @returns The new doctype node\n\t */\n\tcreateDocumentType(qualifiedName: string, publicId: string, systemId: string): DocumentType {\n\t\texpectArity(arguments, 3);\n\t\tqualifiedName = String(qualifiedName);\n\t\tpublicId = String(publicId);\n\t\tsystemId = String(systemId);\n\n\t\t// 1. Validate qualifiedName.\n\t\tvalidateQualifiedName(qualifiedName);\n\n\t\t// 2. Return a new doctype, with qualifiedName as its name, publicId as its public ID, and\n\t\t// systemId as its system ID, and with its node document set to the associated document of\n\t\t// this.\n\t\tconst context = getContext(this._document);\n\t\tconst doctype = new context.DocumentType(qualifiedName, publicId, systemId);\n\t\tdoctype.ownerDocument = this._document;\n\t\treturn doctype;\n\t}\n\n\t/**\n\t * Returns an XMLDocument, with a document element whose local name is qualifiedName and whose\n\t * namespace is namespace (unless qualifiedName is the empty string), and with doctype, if it is\n\t * given, as its doctype.\n\t *\n\t * @param namespace     - The namespace for the root element\n\t * @param qualifiedName - The qualified name for the root element, or empty string to not create\n\t *                        a root element\n\t * @param doctype       - The doctype for the new document, or null to not add a doctype\n\t *\n\t * @returns The new XMLDocument\n\t */\n\tcreateDocument(\n\t\tnamespace: string | null,\n\t\tqualifiedName: string | null,\n\t\tdoctype: DocumentType | null = null\n\t): XMLDocument {\n\t\texpectArity(arguments, 2);\n\t\tnamespace = asNullableString(namespace);\n\t\t// [LegacyNullToEmptyString] for qualifiedName\n\t\tqualifiedName = legacyNullToEmptyString(qualifiedName);\n\t\tdoctype = asNullableObject(doctype, DocumentType);\n\n\t\t// 1. Let document be a new XMLDocument.\n\t\tconst context = getContext(this._document);\n\t\tconst document = new context.XMLDocument();\n\n\t\t// 2. Let element be null.\n\t\tlet element = null;\n\n\t\t// 3. If qualifiedName is not the empty string, then set element to the result of running\n\t\t// the internal createElementNS steps, given document, namespace, qualifiedName, and an\n\t\t// empty dictionary.\n\t\tif (qualifiedName !== '') {\n\t\t\telement = createElementNS(document, namespace, qualifiedName);\n\t\t}\n\n\t\t// 4. If doctype is non-null, append doctype to document.\n\t\tif (doctype) {\n\t\t\tdocument.appendChild(doctype);\n\t\t}\n\n\t\t// 5. If element is non-null, append element to document.\n\t\tif (element) {\n\t\t\tdocument.appendChild(element);\n\t\t}\n\n\t\t// 6. document’s origin is this’s associated document’s origin.\n\t\t// (origin not implemented)\n\n\t\t// 7. document’s content type is determined by namespace:\n\t\t// HTML namespace: application/xhtml+xml\n\t\t// SVG namespace: image/svg+xml\n\t\t// Any other namespace: application/xml\n\t\t// (content type not implemented)\n\n\t\t// 8. Return document.\n\t\treturn document;\n\t}\n\n\t/**\n\t * Returns a HTML document with a basic tree already constructed.\n\t *\n\t * @param title - Optional title for the new HTML document\n\t *\n\t * @returns The new document\n\t */\n\tcreateHTMLDocument(title?: string | null): Document {\n\t\ttitle = asNullableString(title);\n\n\t\t// 1. Let doc be a new document that is an HTML document.\n\t\tconst context = getContext(this._document);\n\t\tconst doc = new context.Document();\n\n\t\t// 2. Set doc’s content type to \"text/html\".\n\t\t// (content type not implemented)\n\n\t\t// 3. Append a new doctype, with \"html\" as its name and with its node document set to doc,\n\t\t// to doc.\n\t\tconst doctype = new context.DocumentType('html');\n\t\tdoctype.ownerDocument = doc;\n\t\tdoc.appendChild(doctype);\n\n\t\t// 4. Append the result of creating an element given doc, html, and the HTML namespace, to\n\t\t// doc.\n\t\tconst htmlElement = createElement(doc, 'html', HTML_NAMESPACE);\n\t\tdoc.appendChild(htmlElement);\n\n\t\t// 5. Append the result of creating an element given doc, head, and the HTML namespace, to\n\t\t// the html element created earlier.\n\t\tconst headElement = createElement(doc, 'head', HTML_NAMESPACE);\n\t\thtmlElement.appendChild(headElement);\n\n\t\t// 6. If title is given:\n\t\tif (title !== null) {\n\t\t\t// 6.1. Append the result of creating an element given doc, title, and the HTML\n\t\t\t// namespace, to the head element created earlier.\n\t\t\tconst titleElement = createElement(doc, 'title', HTML_NAMESPACE);\n\t\t\theadElement.appendChild(titleElement);\n\n\t\t\t// 6.2. Append a new Text node, with its data set to title (which could be the empty\n\t\t\t// string) and its node document set to doc, to the title element created earlier.\n\t\t\ttitleElement.appendChild(doc.createTextNode(title));\n\t\t}\n\n\t\t// 7. Append the result of creating an element given doc, body, and the HTML namespace, to\n\t\t// the html element created earlier.\n\t\thtmlElement.appendChild(createElement(doc, 'body', HTML_NAMESPACE));\n\n\t\t// 8. doc’s origin is this’s associated document’s origin.\n\t\t// (origin not implemented)\n\n\t\t// 9. Return doc.\n\t\treturn doc;\n\t}\n}\n","import { NonElementParentNode, ParentNode, getChildren } from './mixins';\nimport Attr from './Attr';\nimport CDATASection from './CDATASection';\nimport Comment from './Comment';\nimport DocumentFragment from './DocumentFragment';\nimport DocumentType from './DocumentType';\nimport DOMImplementation from './DOMImplementation';\nimport { createElement, default as Element } from './Element';\nimport Node from './Node';\nimport ProcessingInstruction from './ProcessingInstruction';\nimport Text from './Text';\nimport Range from './Range';\nimport { getContext } from './context/Context';\nimport { matchesNameProduction } from './dom-parsing/parsingAlgorithms';\nimport cloneNode from './util/cloneNode';\nimport createElementNS from './util/createElementNS';\nimport {\n\texpectArity,\n\tthrowInvalidCharacterError,\n\tthrowNotSupportedError,\n} from './util/errorHelpers';\nimport { adoptNode, appendNodes, prependNodes, replaceChildren } from './util/mutationAlgorithms';\nimport { NodeType, isNodeOfType } from './util/NodeType';\nimport { validateAndExtract } from './util/namespaceHelpers';\nimport { asNullableString, asObject } from './util/typeHelpers';\nimport {\n\tgetListOfElementsWithNamespaceAndLocalName,\n\tgetListOfElementsWithQualifiedName,\n} from './util/treeHelpers';\n\n/**\n * 3.5. Interface Document\n *\n * @public\n */\nexport default class Document extends Node implements NonElementParentNode, ParentNode {\n\t// Node\n\n\tpublic get nodeType(): number {\n\t\treturn NodeType.DOCUMENT_NODE;\n\t}\n\n\tpublic get nodeName(): string {\n\t\treturn '#document';\n\t}\n\n\tpublic get nodeValue(): string | null {\n\t\treturn null;\n\t}\n\n\tpublic set nodeValue(_newValue: string | null) {\n\t\t// Do nothing.\n\t}\n\n\tpublic get textContent(): string | null {\n\t\treturn null;\n\t}\n\n\tpublic set textContent(_newValue: string | null) {\n\t\t// Do nothing.\n\t}\n\n\tpublic lookupPrefix(namespace: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If namespace is null or the empty string, then return null.\n\t\t// (not necessary due to recursion)\n\n\t\t// 2. Switch on this:\n\t\t// Document - Return the result of locating a namespace prefix for its document element, if\n\t\t// its document element is non-null, and null otherwise.\n\t\tif (this.documentElement !== null) {\n\t\t\treturn this.documentElement.lookupPrefix(namespace);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic lookupNamespaceURI(prefix: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If prefix is the empty string, then set it to null.\n\t\t// (not necessary due to recursion)\n\n\t\t// 2. Return the result of running locate a namespace for this using prefix.\n\n\t\t// To locate a namespace for a node using prefix, switch on node: Document\n\t\t// 1. If its document element is null, then return null.\n\t\tif (this.documentElement === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// 2. Return the result of running locate a namespace on its document element using prefix.\n\t\treturn this.documentElement.lookupNamespaceURI(prefix);\n\t}\n\n\t// ParentNode\n\n\tpublic get children(): Element[] {\n\t\treturn getChildren(this);\n\t}\n\n\tpublic firstElementChild: Element | null = null;\n\tpublic lastElementChild: Element | null = null;\n\tpublic childElementCount: number = 0;\n\n\tpublic prepend(...nodes: (Node | string)[]): void {\n\t\tprependNodes(this, nodes);\n\t}\n\n\tpublic append(...nodes: (Node | string)[]): void {\n\t\tappendNodes(this, nodes);\n\t}\n\n\tpublic replaceChildren(...nodes: (Node | string)[]): void {\n\t\treplaceChildren(this, nodes);\n\t}\n\n\t// Document\n\n\t/**\n\t * Returns a reference to the DOMImplementation object associated with the document.\n\t */\n\tpublic readonly implementation: DOMImplementation = new DOMImplementation(this);\n\n\t/**\n\t * The doctype, or null if there is none.\n\t */\n\tpublic doctype: DocumentType | null = null;\n\n\t/**\n\t * The document element, or null if there is none.\n\t */\n\tpublic documentElement: Element | null = null;\n\n\t/**\n\t * Creates a new Document.\n\t *\n\t * Note: Unlike DOMImplementation#createDocument(), this constructor does not return an\n\t * XMLDocument object, but a document (Document object).\n\t */\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Returns the list of elements with the given qualified name.\n\t *\n\t * @param qualifiedName - Qualified name of the elements to collect.\n\t *\n\t * @returns  The list of elements with matching qualified name.\n\t */\n\tpublic getElementsByTagName(qualifiedName: string): Element[] {\n\t\texpectArity(arguments, 1);\n\t\tqualifiedName = String(qualifiedName);\n\n\t\treturn getListOfElementsWithQualifiedName(qualifiedName, this);\n\t}\n\n\t/**\n\t * Returns the list of elements with the given namespace and local name.\n\t *\n\t * @param namespace - Namespace URI of the elements to collect.\n\t * @param localName - Local name of the elements to collect\n\t *\n\t * @returns  The list of elements with matching namespace and local name.\n\t */\n\tpublic getElementsByTagNameNS(namespace: string | null, localName: string): Element[] {\n\t\texpectArity(arguments, 2);\n\t\tnamespace = asNullableString(namespace);\n\t\tlocalName = String(localName);\n\n\t\treturn getListOfElementsWithNamespaceAndLocalName(namespace, localName, this);\n\t}\n\n\t/**\n\t * Creates a new element in the null namespace.\n\t *\n\t * @param localName - Local name of the element\n\t *\n\t * @returns The new element\n\t */\n\tpublic createElement(localName: string): Element {\n\t\texpectArity(arguments, 1);\n\t\tlocalName = String(localName);\n\n\t\t// 1. If localName does not match the Name production, then throw an InvalidCharacterError.\n\t\tif (!matchesNameProduction(localName)) {\n\t\t\tthrowInvalidCharacterError('The local name is not a valid Name');\n\t\t}\n\n\t\t// 2. If this is an HTML document, then set localName to localName in ASCII\n\t\t// lowercase.\n\t\t// (html documents not implemented)\n\n\t\t// 3. Let is be the value of is member of options, or null if no such member exists.\n\t\t// (custom elements not implemented)\n\n\t\t// 4. Let namespace be the HTML namespace, if this is an HTML document or\n\t\t// this’s content type is \"application/xhtml+xml\", and null otherwise.\n\t\t// (html documents not implemented)\n\t\tconst namespace: string | null = null;\n\n\t\t// 5. Let element be the result of creating an element given this, localName,\n\t\t// namespace, null, is, and with the synchronous custom elements flag set.\n\t\tconst element = createElement(this, localName, namespace, null);\n\n\t\t// 6. If is is non-null, then set an attribute value for element using \"is\" and is.\n\t\t// (custom elements not implemented)\n\n\t\t// 7. Return element.\n\t\treturn element;\n\t}\n\n\t/**\n\t * Creates a new element in the given namespace.\n\t *\n\t * @param namespace     - Namespace URI for the new element\n\t * @param qualifiedName - Qualified name for the new element\n\t *\n\t * @returns The new element\n\t */\n\tpublic createElementNS(namespace: string | null, qualifiedName: string): Element {\n\t\texpectArity(arguments, 2);\n\t\tnamespace = asNullableString(namespace);\n\t\tqualifiedName = String(qualifiedName);\n\n\t\t// return the result of running the internal createElementNS steps, given this,\n\t\t// namespace, qualifiedName, and options.\n\t\treturn createElementNS(this, namespace, qualifiedName);\n\t}\n\n\t/**\n\t * Returns a new DocumentFragment node with its node document set to this.\n\t *\n\t * @returns The new document fragment\n\t */\n\tpublic createDocumentFragment(): DocumentFragment {\n\t\tconst context = getContext(this);\n\t\tconst documentFragment = new context.DocumentFragment();\n\t\tdocumentFragment.ownerDocument = this;\n\t\treturn documentFragment;\n\t}\n\n\t/**\n\t * Returns a new Text node with its data set to data and node document set to this.\n\t *\n\t * @param data - Data for the new text node\n\t *\n\t * @returns The new text node\n\t */\n\tpublic createTextNode(data: string): Text {\n\t\texpectArity(arguments, 1);\n\t\tdata = String(data);\n\n\t\tconst context = getContext(this);\n\t\tconst text = new context.Text(data);\n\t\ttext.ownerDocument = this;\n\t\treturn text;\n\t}\n\n\t/**\n\t * Returns a new CDATA section with the given data and node document set to this.\n\t *\n\t * @param data - Data for the new CDATA section\n\t *\n\t * @returns The new CDATA section\n\t */\n\tpublic createCDATASection(data: string): CDATASection {\n\t\texpectArity(arguments, 1);\n\t\tdata = String(data);\n\n\t\t// 1. If this is an HTML document, then throw a NotSupportedError.\n\t\t// (html documents not implemented)\n\n\t\t// 2. If data contains the string \"]]>\", then throw an InvalidCharacterError.\n\t\tif (data.indexOf(']]>') >= 0) {\n\t\t\tthrowInvalidCharacterError('Data must not contain the string \"]]>\"');\n\t\t}\n\n\t\t// 3. Return a new CDATASection node with its data set to data and node document set to the\n\t\t// this.\n\t\tconst context = getContext(this);\n\t\tconst cdataSection = new context.CDATASection(data);\n\t\tcdataSection.ownerDocument = this;\n\t\treturn cdataSection;\n\t}\n\n\t/**\n\t * Returns a new Comment node with its data set to data and node document set to this.\n\t *\n\t * @param data - Data for the new comment\n\t *\n\t * @returns The new comment node\n\t */\n\tpublic createComment(data: string): Comment {\n\t\texpectArity(arguments, 1);\n\t\tdata = String(data);\n\n\t\tconst context = getContext(this);\n\t\tconst comment = new context.Comment(data);\n\t\tcomment.ownerDocument = this;\n\t\treturn comment;\n\t}\n\n\t/**\n\t * Creates a new processing instruction node, with target set to target, data set to data, and\n\t * node document set to this.\n\t *\n\t * @param target - Target for the new processing instruction\n\t * @param data   - Data for the new processing instruction\n\t *\n\t * @returns The new processing instruction\n\t */\n\tpublic createProcessingInstruction(target: string, data: string): ProcessingInstruction {\n\t\texpectArity(arguments, 2);\n\t\ttarget = String(target);\n\t\tdata = String(data);\n\n\t\t// 1. If target does not match the Name production, then throw an InvalidCharacterError.\n\t\tif (!matchesNameProduction(target)) {\n\t\t\tthrowInvalidCharacterError('The target is not a valid Name');\n\t\t}\n\n\t\t// 2. If data contains the string \"?>\", then throw an InvalidCharacterError.\n\t\tif (data.indexOf('?>') >= 0) {\n\t\t\tthrowInvalidCharacterError('Data must not contain the string \"?>\"');\n\t\t}\n\n\t\t// 3. Return a new ProcessingInstruction node, with target set to target, data set to data,\n\t\t// and node document set to this.\n\t\tconst context = getContext(this);\n\t\tconst pi = new context.ProcessingInstruction(target, data);\n\t\tpi.ownerDocument = this;\n\t\treturn pi;\n\n\t\t// Note: No check is performed that target contains \"xml\" or \":\", or that data contains\n\t\t// characters that match the Char production.\n\t}\n\n\t/**\n\t * Creates a copy of a node from an external document that can be inserted into the current\n\t * document.\n\t *\n\t * @param node - The node to import\n\t * @param deep - Whether to also import node's children\n\t */\n\tpublic importNode<TNode extends Node>(node: TNode, deep: boolean = false): TNode {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\t// 1. If node is a document or shadow root, then throw a NotSupportedError.\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_NODE)) {\n\t\t\tthrowNotSupportedError('importing a Document node is not supported');\n\t\t}\n\n\t\t// 2. Return a clone of node, with this and the clone children flag set if deep is\n\t\t// true.\n\t\treturn cloneNode(node, deep, this);\n\t}\n\n\t/**\n\t * Adopts a node. The node and its subtree is removed from the document it's in (if any), and\n\t * its ownerDocument is changed to the current document. The node can then be inserted into the\n\t * current document.\n\t *\n\t * @param node - The node to adopt\n\t */\n\tpublic adoptNode<TNode extends Node>(node: TNode): TNode {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\t// 1. If node is a document, then throw a NotSupportedError.\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_NODE)) {\n\t\t\tthrowNotSupportedError('adopting a Document node is not supported');\n\t\t}\n\n\t\t// 2. If node is a shadow root, then throw a HierarchyRequestError.\n\t\t// 3. If node is a DocumentFragment node and its host is non-null, then return node.\n\t\t// Note: unfortunately this does not throw for web compatibility.\n\t\t// (shadow dom and HTML templates not implemented)\n\n\t\t// 4. Adopt node into this.\n\t\tadoptNode(node, this);\n\n\t\t// 5. Return node.\n\t\treturn node;\n\t}\n\n\t/**\n\t * Creates a new attribute node with the null namespace and given local name.\n\t *\n\t * @param localName - The local name of the attribute\n\t *\n\t * @returns The new attribute node\n\t */\n\tpublic createAttribute(localName: string): Attr {\n\t\texpectArity(arguments, 1);\n\t\tlocalName = String(localName);\n\n\t\t// 1. If localName does not match the Name production in XML, then throw an\n\t\t// InvalidCharacterError.\n\t\tif (!matchesNameProduction(localName)) {\n\t\t\tthrowInvalidCharacterError('The local name is not a valid Name');\n\t\t}\n\n\t\t// 2. If this is an HTML document, then set localName to localName in ASCII\n\t\t// lowercase.\n\t\t// (html documents not implemented)\n\n\t\t// 3. Return a new attribute whose local name is localName and node document is context\n\t\t// object.\n\t\tconst context = getContext(this);\n\t\tconst attr = new context.Attr(null, null, localName, '', null);\n\t\tattr.ownerDocument = this;\n\t\treturn attr;\n\t}\n\n\t/**\n\t * Creates a new attribute node with the given namespace and qualified name.\n\t *\n\t * @param namespace     - Namespace URI for the new attribute, or null for the null namespace\n\t * @param qualifiedName - Qualified name for the new attribute\n\t *\n\t * @returns The new attribute node\n\t */\n\tpublic createAttributeNS(namespace: string | null, qualifiedName: string): Attr {\n\t\texpectArity(arguments, 2);\n\t\tnamespace = asNullableString(namespace);\n\t\tqualifiedName = String(qualifiedName);\n\n\t\t// 1. Let namespace, prefix, and localName be the result of passing namespace and\n\t\t// qualifiedName to validate and extract.\n\t\tconst {\n\t\t\tnamespace: validatedNamespace,\n\t\t\tprefix,\n\t\t\tlocalName,\n\t\t} = validateAndExtract(namespace, qualifiedName);\n\n\t\t// 2. Return a new attribute whose namespace is namespace, namespace prefix is prefix, local\n\t\t// name is localName, and node document is this.\n\t\tconst context = getContext(this);\n\t\tconst attr = new context.Attr(validatedNamespace, prefix, localName, '', null);\n\t\tattr.ownerDocument = this;\n\t\treturn attr;\n\t}\n\n\t/**\n\t * Creates a new live Range, initially positioned at the root of this document.\n\t *\n\t * @returns The new Range\n\t */\n\tpublic createRange(): Range {\n\t\tconst context = getContext(this);\n\t\tconst range = new context.Range();\n\t\trange.startContainer = this;\n\t\trange.startOffset = 0;\n\t\trange.endContainer = this;\n\t\trange.endOffset = 0;\n\t\treturn range;\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic _copy(document: Document): Document {\n\t\t// Set copy’s encoding, content type, URL, origin, type, and mode, to those of node.\n\t\t// (properties not implemented)\n\n\t\tconst context = getContext(document);\n\t\treturn new context.Document();\n\t}\n}\n","import { NonElementParentNode, ParentNode, getChildren } from './mixins';\nimport Document from './Document';\nimport Element from './Element';\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport { expectArity } from './util/errorHelpers';\nimport {\n\tappendNodes,\n\tprependNodes,\n\tgetDescendantTextContent,\n\tstringReplaceAll,\n\treplaceChildren,\n} from './util/mutationAlgorithms';\nimport { NodeType } from './util/NodeType';\nimport { ifNullActAsIfEmptyString } from './util/typeHelpers';\n\n/**\n * @public\n */\nexport default class DocumentFragment extends Node implements NonElementParentNode, ParentNode {\n\t// Node\n\n\tpublic get nodeType(): number {\n\t\treturn NodeType.DOCUMENT_FRAGMENT_NODE;\n\t}\n\n\tpublic get nodeName(): string {\n\t\treturn '#document-fragment';\n\t}\n\n\tpublic get nodeValue(): string | null {\n\t\treturn null;\n\t}\n\n\tpublic set nodeValue(newValue: string | null) {\n\t\t// Do nothing.\n\t}\n\n\tpublic get textContent(): string | null {\n\t\t// Return the descendant text content of this\n\t\treturn getDescendantTextContent(this);\n\t}\n\n\tpublic set textContent(newValue: string | null) {\n\t\tnewValue = ifNullActAsIfEmptyString(newValue);\n\t\tstringReplaceAll(this, newValue);\n\t}\n\n\tpublic lookupPrefix(namespace: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If namespace is null or the empty string, then return null.\n\t\t// (not necessary due to return value)\n\n\t\t// 2. Switch on this:\n\t\t// DocumentFragment - Return null\n\t\treturn null;\n\t}\n\n\tpublic lookupNamespaceURI(prefix: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If prefix is the empty string, then set it to null.\n\t\t// (not necessary due to return value)\n\n\t\t// 2. Return the result of running locate a namespace for this using prefix.\n\n\t\t// To locate a namespace for a node using prefix, switch on node: DocumentFragment\n\t\t// Return null.\n\t\treturn null;\n\t}\n\n\t// ParentNode\n\n\tpublic get children(): Element[] {\n\t\treturn getChildren(this);\n\t}\n\n\tpublic firstElementChild: Element | null = null;\n\tpublic lastElementChild: Element | null = null;\n\tpublic childElementCount: number = 0;\n\n\tpublic prepend(...nodes: (Node | string)[]): void {\n\t\tprependNodes(this, nodes);\n\t}\n\n\tpublic append(...nodes: (Node | string)[]): void {\n\t\tappendNodes(this, nodes);\n\t}\n\n\tpublic replaceChildren(...nodes: (Node | string)[]): void {\n\t\treplaceChildren(this, nodes);\n\t}\n\n\t/**\n\t * Return a new DocumentFragment node whose node document is current global object’s associated\n\t * Document.\n\t */\n\tconstructor() {\n\t\tsuper();\n\n\t\tconst context = getContext(this);\n\t\tthis.ownerDocument = context.document;\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic _copy(document: Document): DocumentFragment {\n\t\tconst context = getContext(document);\n\t\tconst copy = new context.DocumentFragment();\n\t\tcopy.ownerDocument = document;\n\t\treturn copy;\n\t}\n}\n","import CharacterData from './CharacterData';\nimport Document from './Document';\nimport { getContext } from './context/Context';\nimport { NodeType } from './util/NodeType';\n\n/**\n * 3.13. Interface ProcessingInstruction\n *\n * @public\n */\nexport default class ProcessingInstruction extends CharacterData {\n\t// Node\n\n\tpublic get nodeType(): number {\n\t\treturn NodeType.PROCESSING_INSTRUCTION_NODE;\n\t}\n\n\tpublic get nodeName(): string {\n\t\treturn this.target;\n\t}\n\n\t// ProcessingInstruction\n\n\tpublic target: string;\n\n\t/**\n\t * (non-standard) Use Document#createProcessingInstruction to create a processing instruction.\n\t *\n\t * @param target - The target of the processing instruction\n\t * @param data   - The data of the processing instruction\n\t */\n\tconstructor(target: string, data: string) {\n\t\tsuper(data);\n\n\t\tthis.target = target;\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic _copy(document: Document): ProcessingInstruction {\n\t\t// Set copy’s target and data to those of node.\n\t\tconst context = getContext(document);\n\t\tconst copy = new context.ProcessingInstruction(this.target, this.data);\n\t\tcopy.ownerDocument = document;\n\t\treturn copy;\n\t}\n}\n","import DocumentFragment from './DocumentFragment';\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport {\n\texpectArity,\n\tthrowHierarchyRequestError,\n\tthrowIndexSizeError,\n\tthrowInvalidNodeTypeError,\n\tthrowInvalidStateError,\n\tthrowNotSupportedError,\n\tthrowWrongDocumentError,\n} from './util/errorHelpers';\nimport { NodeType, isNodeOfType, isTextNode, isCharacterDataNode } from './util/NodeType';\nimport {\n\tdetermineLengthOfNode,\n\tforEachInclusiveDescendant,\n\tgetInclusiveAncestors,\n\tgetNodeDocument,\n\tgetNodeIndex,\n\tgetRootOfNode,\n} from './util/treeHelpers';\nimport { asObject, asUnsignedLong } from './util/typeHelpers';\nimport {\n\tappendNode,\n\tinsertNodeIntoRange,\n\tremoveNode,\n\treplaceAllWithNode,\n} from './util/mutationAlgorithms';\n\n/**\n * Interface AbstractRange\n *\n * Objects implementing the AbstractRange interface are known as ranges.\n *\n * @public\n */\nexport interface AbstractRange {\n\treadonly startContainer: Node;\n\treadonly startOffset: number;\n\treadonly endContainer: Node;\n\treadonly endOffset: number;\n\treadonly collapsed: boolean;\n}\n\ninterface StaticRangeInit {\n\tstartContainer: Node;\n\tstartOffset: number;\n\tendContainer: Node;\n\tendOffset: number;\n}\n\n/**\n * Interface StaticRange\n *\n * Updating live ranges in response to node tree mutations can be expensive. For every node tree\n * change, all affected Range objects need to be updated. Even if the application is uninterested in\n * some live ranges, it still has to pay the cost of keeping them up-to-date when a mutation occurs.\n *\n * A StaticRange object is a lightweight range that does not update when the node tree mutates. It\n * is therefore not subject to the same maintenance cost as live ranges.\n *\n * @public\n */\nexport class StaticRange implements AbstractRange {\n\tpublic readonly startContainer: Node;\n\tpublic readonly startOffset: number;\n\tpublic readonly endContainer: Node;\n\tpublic readonly endOffset: number;\n\tpublic readonly collapsed: boolean;\n\n\t/**\n\t * The StaticRange(init) constructor, when invoked, must run these steps:\n\t *\n\t * @param init - Dictionary representing the properties to set on the StaticRange\n\t */\n\tconstructor(init: StaticRangeInit) {\n\t\t// 1. If init’s startContainer or endContainer is a DocumentType or Attr node, then throw an\n\t\t// \"InvalidNodeTypeError\" DOMException.\n\t\tif (\n\t\t\tisNodeOfType(init.startContainer, NodeType.DOCUMENT_TYPE_NODE, NodeType.ATTRIBUTE_NODE)\n\t\t) {\n\t\t\tthrowInvalidNodeTypeError(\n\t\t\t\t'StaticRange startContainer must not be a doctype or attribute node'\n\t\t\t);\n\t\t}\n\t\tif (isNodeOfType(init.endContainer, NodeType.DOCUMENT_TYPE_NODE, NodeType.ATTRIBUTE_NODE)) {\n\t\t\tthrowInvalidNodeTypeError(\n\t\t\t\t'StaticRange endContainer must not be a doctype or attribute node'\n\t\t\t);\n\t\t}\n\n\t\t// 2. Let staticRange be a new StaticRange object.\n\t\t// 3. Set staticRange’s start to (init’s startContainer, init’s startOffset) and end to\n\t\t// (init’s endContainer, init’s endOffset).\n\t\tthis.startContainer = init.startContainer;\n\t\tthis.startOffset = init.startOffset;\n\t\tthis.endContainer = init.endContainer;\n\t\tthis.endOffset = init.endOffset;\n\t\tthis.collapsed =\n\t\t\tthis.startContainer === this.endContainer && this.startOffset === this.endOffset;\n\n\t\t// 4. Return staticRange.\n\t}\n}\n\n/**\n * A range is collapsed if its start node is its end node and its start offset is its end offset.\n *\n * @param range - The range to check\n */\nfunction isCollapsed(range: AbstractRange): boolean {\n\treturn range.startContainer === range.endContainer && range.startOffset === range.endOffset;\n}\n\n/**\n * Invokes callback on each node contained in range, in tree order, omitting any node whose parent\n * is also contained in range.\n *\n * @param range    - Range to traverse\n * @param callback - Callback to invoke for each contained node, should not modify node's position\n *                   in the tree\n */\nfunction forEachNodeContainedInRange(range: AbstractRange, callback: (node: Node) => void): void {\n\tif (range.collapsed) {\n\t\treturn;\n\t}\n\t// Determine common ancestors\n\tconst ancestors1 = getInclusiveAncestors(range.startContainer);\n\tconst ancestors2 = getInclusiveAncestors(range.endContainer);\n\tlet firstDistinctAncestorIndex = 0;\n\twhile (\n\t\tfirstDistinctAncestorIndex < ancestors1.length &&\n\t\tfirstDistinctAncestorIndex < ancestors2.length\n\t) {\n\t\tif (ancestors1[firstDistinctAncestorIndex] !== ancestors2[firstDistinctAncestorIndex]) {\n\t\t\tbreak;\n\t\t}\n\n\t\t++firstDistinctAncestorIndex;\n\t}\n\tconst firstChildOutside = range.endContainer.childNodes[range.endOffset] || null;\n\t// Walk along children of startContainer\n\tfor (\n\t\tlet child: Node | null = range.startContainer.childNodes[range.startOffset] || null;\n\t\tchild && child !== firstChildOutside && child !== ancestors2[ancestors1.length];\n\t\tchild = child.nextSibling\n\t) {\n\t\tcallback(child);\n\t}\n\t// Walk along siblings from startContainer to common ancestor\n\tfor (let i = ancestors1.length - 1; i >= firstDistinctAncestorIndex; --i) {\n\t\tfor (\n\t\t\tlet sibling = ancestors1[i].nextSibling;\n\t\t\tsibling && sibling !== firstChildOutside && sibling !== ancestors2[i];\n\t\t\tsibling = sibling.nextSibling\n\t\t) {\n\t\t\tcallback(sibling);\n\t\t}\n\t}\n\t// Walk back down to the endContainer, including its children\n\tfor (let i = firstDistinctAncestorIndex; i < ancestors2.length; ++i) {\n\t\tfor (\n\t\t\tlet child = ancestors2[i].firstChild;\n\t\t\tchild && child !== firstChildOutside && child !== ancestors2[i + 1];\n\t\t\tchild = child.nextSibling\n\t\t) {\n\t\t\tcallback(child);\n\t\t}\n\t}\n}\n\n/**\n * To extract a live range range, run these steps:\n * To clone the contents of a live range range, run these steps:\n * (algorithms merged as they are very similar)\n *\n * @param range   - the live range to extract (or clone) contents of\n * @param isClone - whether to clone the contents of the range or extract them\n *\n * @returns a DocumentFragment with the extracted or cloned contents\n */\nfunction extractRange(range: Range, isClone: boolean): DocumentFragment {\n\t// 1. Let fragment be a new DocumentFragment node whose node document is range's start node's\n\t// node document.\n\tconst document = getNodeDocument(range.startContainer);\n\tconst fragment = document.createDocumentFragment();\n\n\t// 2. If range is collapsed, then return fragment.\n\tif (range.collapsed) {\n\t\treturn fragment;\n\t}\n\n\t// 3. Let original start node, original start offset, original end node, and original end offset\n\t// be range's start node, start offset, end node, and end offset, respectively.\n\tconst originalStartNode = range.startContainer;\n\tconst originalStartOffset = range.startOffset;\n\tconst originalEndNode = range.endContainer;\n\tconst originalEndOffset = range.endOffset;\n\n\t// 4. If original start node is original end node and it is a CharacterData node, then:\n\tif (originalStartNode === originalEndNode && isCharacterDataNode(originalStartNode)) {\n\t\t// 4.1. Let clone be a clone of original start node.\n\t\tconst clone = originalStartNode.cloneNode();\n\n\t\t// 4.2. Set the data of clone to the result of substringing data with node original start\n\t\t// node, offset original start offset, and count original end offset minus original start\n\t\t// offset.\n\t\tclone.data = originalStartNode.substringData(\n\t\t\toriginalStartOffset,\n\t\t\toriginalEndOffset - originalStartOffset\n\t\t);\n\n\t\t// 4.3. Append clone to fragment.\n\t\tappendNode(clone, fragment);\n\n\t\tif (!isClone) {\n\t\t\t// 4.4. Replace data with node original start node, offset original start offset, count\n\t\t\t// original end offset minus original start offset, and data the empty string.\n\t\t\t// (step not used when cloning contents)\n\t\t\toriginalStartNode.replaceData(\n\t\t\t\toriginalStartOffset,\n\t\t\t\toriginalEndOffset - originalStartOffset,\n\t\t\t\t''\n\t\t\t);\n\t\t}\n\n\t\t// 4.5. Return fragment.\n\t\treturn fragment;\n\t}\n\n\t// 5. Let common ancestor be original start node.\n\t// 6. While common ancestor is not an inclusive ancestor of original end node, set common\n\t// ancestor to its own parent.\n\t// (implemented differently for performance reasons)\n\tconst ancestors1 = getInclusiveAncestors(range.startContainer);\n\tconst ancestors2 = getInclusiveAncestors(range.endContainer);\n\tlet firstDistinctAncestorIndex = 0;\n\twhile (\n\t\tfirstDistinctAncestorIndex < ancestors1.length &&\n\t\tfirstDistinctAncestorIndex < ancestors2.length\n\t) {\n\t\tif (ancestors1[firstDistinctAncestorIndex] !== ancestors2[firstDistinctAncestorIndex]) {\n\t\t\tbreak;\n\t\t}\n\n\t\t++firstDistinctAncestorIndex;\n\t}\n\tconst startContainsEnd = firstDistinctAncestorIndex === ancestors1.length;\n\tconst endContainsStart = firstDistinctAncestorIndex === ancestors2.length;\n\n\t// 7. Let first partially contained child be null.\n\tlet firstPartiallyContainedChild: Node | null = null;\n\n\t// 8. If original start node is not an inclusive ancestor of original end node, set first\n\t// partially contained child to the first child of common ancestor that is partially contained\n\t// in range.\n\tif (!startContainsEnd) {\n\t\tfirstPartiallyContainedChild = ancestors1[firstDistinctAncestorIndex];\n\t}\n\n\t// 9. Let last partially contained child be null.\n\tlet lastPartiallyContainedChild: Node | null = null;\n\n\t// 10. If original end node is not an inclusive ancestor of original start node, set last\n\t// partially contained child to the last child of common ancestor that is partially contained in\n\t// range.\n\tif (!endContainsStart) {\n\t\tlastPartiallyContainedChild = ancestors2[firstDistinctAncestorIndex];\n\t}\n\n\t// Note: These variable assignments do actually always make sense. For instance, if original\n\t// start node is not an inclusive ancestor of original end node, original start node is itself\n\t// partially contained in range, and so are all its ancestors up until a child of common\n\t// ancestor. common ancestor cannot be original start node, because it has to be an inclusive\n\t// ancestor of original end node. The other case is similar. Also, notice that the two children\n\t// will never be equal if both are defined.\n\n\t// 11. Let contained children be a list of all children of common ancestor that are contained in\n\t// range, in tree order.\n\t// (if firstPartiallyContainedChild is null, originalStartNode contains originalEndNode, so\n\t// there has to be a child at originalStartOffset)\n\tconst containedChildren: Node[] = [];\n\tconst firstChildAfterStart = firstPartiallyContainedChild\n\t\t? firstPartiallyContainedChild.nextSibling\n\t\t: originalStartNode.childNodes[originalStartOffset];\n\tconst firstChildAfterEnd =\n\t\tlastPartiallyContainedChild || originalEndNode.childNodes[originalEndOffset] || null;\n\tfor (\n\t\tvar child = firstChildAfterStart;\n\t\tchild && child !== firstChildAfterEnd;\n\t\tchild = child!.nextSibling\n\t) {\n\t\t// 12. If any member of contained children is a doctype, then throw a \"HierarchyRequestError\"\n\t\t// DOMException.\n\t\t// Note: We do not have to worry about the first or last partially contained node, because a\n\t\t// doctype can never be partially contained. It cannot be a boundary point of a range, and\n\t\t// it cannot be the ancestor of anything.\n\t\tif (isNodeOfType(child, NodeType.DOCUMENT_TYPE_NODE)) {\n\t\t\tthrowHierarchyRequestError(\n\t\t\t\tisClone\n\t\t\t\t\t? 'Can not clone a doctype using cloneContents'\n\t\t\t\t\t: 'Can not extract a doctype using extractContents'\n\t\t\t);\n\t\t}\n\t\tcontainedChildren.push(child);\n\t}\n\n\t// 13. If original start node is an inclusive ancestor of original end node, set new node to\n\t// original start node and new offset to original start offset.\n\t// (variables not used when cloning contents, as the range does not move)\n\tlet newNode: Node;\n\tlet newOffset: number;\n\tif (startContainsEnd || isClone) {\n\t\tnewNode = originalStartNode;\n\t\tnewOffset = originalStartOffset;\n\t} else {\n\t\t// 14. Otherwise:\n\t\t// (steps not used when cloning contents)\n\n\t\t// 14.1. Let reference node equal original start node.\n\t\t// 14.2. While reference node's parent is not null and is not an inclusive ancestor of\n\t\t// original end node, set reference node to its parent.\n\t\tconst referenceNode = ancestors1[firstDistinctAncestorIndex];\n\n\t\t// 14.3. Set new node to the parent of reference node, and new offset to one plus reference\n\t\t// node’s index.\n\t\t// Note: If reference node's parent is null, it would be the root of range, so would be an\n\t\t// inclusive ancestor of original end node, and we could not reach this point.\n\t\tnewNode = referenceNode.parentNode!;\n\t\tnewOffset = 1 + getNodeIndex(referenceNode);\n\t}\n\n\t// 15. If first partially contained child is a CharacterData node, then:\n\tif (\n\t\tfirstPartiallyContainedChild !== null &&\n\t\tisCharacterDataNode(firstPartiallyContainedChild)\n\t) {\n\t\t// Note: In this case, first partially contained child is original start node.\n\t\t// 15.1. Let clone be a clone of original start node.\n\t\tconst clone = firstPartiallyContainedChild.cloneNode();\n\n\t\t// 15.2. Set the data of clone to the result of substringing data with node original start\n\t\t// node, offset original start offset, and count original start node’s length minus original\n\t\t// start offset.\n\t\tclone.data = firstPartiallyContainedChild.substringData(\n\t\t\toriginalStartOffset,\n\t\t\tfirstPartiallyContainedChild.length - originalStartOffset\n\t\t);\n\n\t\t// 15.3. Append clone to fragment.\n\t\tappendNode(clone, fragment);\n\n\t\tif (!isClone) {\n\t\t\t// 15.4 Replace data with node original start node, offset original start offset, count\n\t\t\t// original start node's length minus original start offset, and data the empty string.\n\t\t\t// (step not used when cloning contents)\n\t\t\tfirstPartiallyContainedChild.replaceData(\n\t\t\t\toriginalStartOffset,\n\t\t\t\tfirstPartiallyContainedChild.length - originalStartOffset,\n\t\t\t\t''\n\t\t\t);\n\t\t}\n\t} else if (firstPartiallyContainedChild !== null) {\n\t\t// 16. Otherwise, if first partially contained child is not null:\n\n\t\t// 16.1. Let clone be a clone of first partially contained child.\n\t\tconst clone = firstPartiallyContainedChild.cloneNode();\n\n\t\t// 16.2. Append clone to fragment.\n\t\tappendNode(clone, fragment);\n\n\t\t// 16.3. Let subrange be a new live range whose start is (original start node, original\n\t\t// start offset) and whose end is (first partially contained child, first partially\n\t\t// contained child’s length).\n\t\tconst subrange = document.createRange();\n\t\tsubrange.setStart(originalStartNode, originalStartOffset);\n\t\tsubrange.setEnd(\n\t\t\tfirstPartiallyContainedChild,\n\t\t\tdetermineLengthOfNode(firstPartiallyContainedChild)\n\t\t);\n\n\t\t// 16.4. Let subfragment be the result of extracting / cloning the contents of subrange.\n\t\tconst subfragment = extractRange(subrange, isClone);\n\t\tsubrange.detach();\n\n\t\t// 16.5. Append subfragment to clone.\n\t\tappendNode(subfragment, clone);\n\t}\n\n\t// 17. For each contained child in contained children\n\tcontainedChildren.forEach((containedChild) => {\n\t\tif (isClone) {\n\t\t\t// 17.1. Let clone be a clone of contained child with the clone children flag set.\n\t\t\tconst clone = containedChild.cloneNode(true);\n\n\t\t\t// 17.2. Append clone to fragment.\n\t\t\tappendNode(clone, fragment);\n\t\t} else {\n\t\t\t// append contained child to fragment.\n\t\t\tappendNode(containedChild, fragment);\n\t\t}\n\t});\n\n\t// 18. If last partially contained child is a CharacterData node, then:\n\tif (lastPartiallyContainedChild && isCharacterDataNode(lastPartiallyContainedChild)) {\n\t\t// Note: In this case, last partially contained child is original end node.\n\n\t\t// 18.1 Let clone be a clone of original end node.\n\t\tconst clone = lastPartiallyContainedChild.cloneNode();\n\n\t\t// 18.2. Set the data of clone to the result of substringing data with node original end\n\t\t// node, offset 0, and count original end offset.\n\t\tclone.data = lastPartiallyContainedChild.substringData(0, originalEndOffset);\n\n\t\t// 18.3. Append clone to fragment.\n\t\tappendNode(clone, fragment);\n\n\t\tif (!isClone) {\n\t\t\t// 18.4. Replace data with node original end node, offset 0, count original end offset,\n\t\t\t// and data the empty string.\n\t\t\t// (step not used when cloning contents)\n\t\t\tlastPartiallyContainedChild.replaceData(0, originalEndOffset, '');\n\t\t}\n\t} else if (lastPartiallyContainedChild !== null) {\n\t\t// 19. Otherwise, if last partially contained child is not null:\n\n\t\t// 19.1. Let clone be a clone of last partially contained child.\n\t\tconst clone = lastPartiallyContainedChild.cloneNode();\n\n\t\t// 19.2. Append clone to fragment.\n\t\tappendNode(clone, fragment);\n\n\t\t// 19.3. Let subrange be a new live range whose start is (last partially contained child, 0)\n\t\t// and whose end is (original end node, original end offset).\n\t\tconst subrange = document.createRange();\n\t\tsubrange.setStart(lastPartiallyContainedChild, 0);\n\t\tsubrange.setEnd(originalEndNode, originalEndOffset);\n\n\t\t// 19.4. Let subfragment be the result of extracting / cloning the contents of subrange.\n\t\tconst subfragment = extractRange(subrange, isClone);\n\t\tsubrange.detach();\n\n\t\t// 19.5. Append subfragment to clone.\n\t\tappendNode(subfragment, clone);\n\t}\n\n\tif (!isClone) {\n\t\t// 20. Set range’s start and end to (new node, new offset).\n\t\t// (step not used when cloning contents)\n\t\trange.setStart(newNode, newOffset);\n\t\trange.collapse(true);\n\t}\n\n\t// 21. Return fragment.\n\treturn fragment;\n}\n\n/**\n * Interface Range\n *\n * Objects implementing the Range interface are known as live ranges.\n *\n * @public\n */\nexport default class Range implements AbstractRange {\n\tpublic startContainer: Node;\n\tpublic startOffset: number;\n\tpublic endContainer: Node;\n\tpublic endOffset: number;\n\n\tpublic get collapsed(): boolean {\n\t\treturn isCollapsed(this);\n\t}\n\n\t/**\n\t * The Range() constructor, when invoked, must return a new live range with (current global\n\t * object’s associated Document, 0) as its start and end.\n\t */\n\tconstructor() {\n\t\tconst context = getContext(this);\n\t\tthis.startContainer = context.document;\n\t\tthis.startOffset = 0;\n\t\tthis.endContainer = context.document;\n\t\tthis.endOffset = 0;\n\t\tcontext.addRange(this);\n\t}\n\n\t/**\n\t * Get the common ancestor of the range's boundary position nodes.\n\t *\n\t * Note: for efficiency reasons, this implementation deviates from the algorithm given in 4.2.\n\t */\n\tpublic get commonAncestorContainer(): Node {\n\t\tconst ancestors1 = getInclusiveAncestors(this.startContainer);\n\t\tconst ancestors2 = getInclusiveAncestors(this.endContainer);\n\t\tlet commonAncestorContainer = ancestors1[0];\n\t\tlet i = 0;\n\t\twhile (i < ancestors1.length && i < ancestors2.length) {\n\t\t\tif (ancestors1[i] !== ancestors2[i]) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcommonAncestorContainer = ancestors1[i];\n\t\t\t++i;\n\t\t}\n\n\t\treturn commonAncestorContainer;\n\t}\n\n\t/**\n\t * Sets the start boundary point of the range.\n\t *\n\t * @param node   - The new start container\n\t * @param offset - The new start offset\n\t */\n\tsetStart(node: Node, offset: number): void {\n\t\texpectArity(arguments, 2);\n\t\tnode = asObject(node, Node);\n\t\toffset = asUnsignedLong(offset);\n\n\t\t// 1. If node is a doctype, then throw an InvalidNodeTypeError.\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE)) {\n\t\t\tthrowInvalidNodeTypeError('Can not set a range under a doctype node');\n\t\t}\n\n\t\t// 2. If offset is greater than node’s length, then throw an IndexSizeError.\n\t\tif (offset > determineLengthOfNode(node)) {\n\t\t\tthrowIndexSizeError('Can not set a range past the end of the node');\n\t\t}\n\n\t\t// 3. Let bp be the boundary point (node, offset).\n\t\t// 4.a. If these steps were invoked as \"set the start\"\n\t\t// 4.a.1. If range’s root is not equal to node’s root, or if bp is after the range’s end,\n\t\t// set range’s end to bp.\n\t\tconst rootOfRange = getRootOfRange(this);\n\t\tconst rootOfNode = getRootOfNode(node);\n\t\tif (\n\t\t\trootOfRange !== rootOfNode ||\n\t\t\tcompareBoundaryPointPositions(node, offset, this.endContainer, this.endOffset) ===\n\t\t\t\tPOSITION_AFTER\n\t\t) {\n\t\t\tthis.endContainer = node;\n\t\t\tthis.endOffset = offset;\n\t\t}\n\t\t// 4.a.2. Set range’s start to bp.\n\t\tthis.startContainer = node;\n\t\tthis.startOffset = offset;\n\n\t\t// 4.b. If these steps were invoked as \"set the end\"\n\t\t// 4.b.1. If range’s root is not equal to node’s root, or if bp is before the range’s start,\n\t\t// set range’s start to bp.\n\t\t// 4.b.2. Set range’s end to bp.\n\t\t// (see Range#setEnd for this branch)\n\t}\n\n\t/**\n\t * Sets the end boundary point of the range.\n\t *\n\t * @param node   - The new end container\n\t * @param offset - The new end offset\n\t */\n\tsetEnd(node: Node, offset: number): void {\n\t\texpectArity(arguments, 2);\n\t\tnode = asObject(node, Node);\n\t\toffset = asUnsignedLong(offset);\n\n\t\t// 1. If node is a doctype, then throw an InvalidNodeTypeError.\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE)) {\n\t\t\tthrowInvalidNodeTypeError('Can not set a range under a doctype node');\n\t\t}\n\n\t\t// 2. If offset is greater than node’s length, then throw an IndexSizeError.\n\t\tif (offset > determineLengthOfNode(node)) {\n\t\t\tthrowIndexSizeError('Can not set a range past the end of the node');\n\t\t}\n\n\t\t// 3. Let bp be the boundary point (node, offset).\n\t\t// 4.a. If these steps were invoked as \"set the start\"\n\t\t// 4.a.1. If range’s root is not equal to node’s root, or if bp is after the range’s end,\n\t\t// set range’s end to bp.\n\t\t// 4.a.2. Set range’s start to bp.\n\t\t// (see Range#setStart for this branch)\n\n\t\t// 4.b. If these steps were invoked as \"set the end\"\n\t\t// 4.b.1. If range’s root is not equal to node’s root, or if bp is before the range’s start,\n\t\t// set range’s start to bp.\n\t\tconst rootOfRange = getRootOfRange(this);\n\t\tconst rootOfNode = getRootOfNode(node);\n\t\tif (\n\t\t\trootOfRange !== rootOfNode ||\n\t\t\tcompareBoundaryPointPositions(node, offset, this.startContainer, this.startOffset) ===\n\t\t\t\tPOSITION_BEFORE\n\t\t) {\n\t\t\tthis.startContainer = node;\n\t\t\tthis.startOffset = offset;\n\t\t}\n\t\t// 4.b.2. Set range’s end to bp.\n\t\tthis.endContainer = node;\n\t\tthis.endOffset = offset;\n\t}\n\n\t/**\n\t * Sets the start boundary point of the range to the position just before the given node.\n\t *\n\t * @param node - The node to set the range's start before\n\t */\n\tsetStartBefore(node: Node): void {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\t// 1. Let parent be node’s parent.\n\t\tconst parent = node.parentNode;\n\n\t\t// 2. If parent is null, then throw an InvalidNodeTypeError.\n\t\tif (parent === null) {\n\t\t\treturn throwInvalidNodeTypeError('Can not set range before node without a parent');\n\t\t}\n\n\t\t// 3. Set the start of this to boundary point (parent, node’s index).\n\t\tthis.setStart(parent, getNodeIndex(node));\n\t}\n\n\t/**\n\t * Sets the start boundary point of the range to the position just after the given node.\n\t *\n\t * @param node - The node to set the range's start before\n\t */\n\tsetStartAfter(node: Node): void {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\t// 1. Let parent be node’s parent.\n\t\tconst parent = node.parentNode;\n\n\t\t// 2. If parent is null, then throw an InvalidNodeTypeError.\n\t\tif (parent === null) {\n\t\t\treturn throwInvalidNodeTypeError('Can not set range before node without a parent');\n\t\t}\n\n\t\t// 3. Set the start of this to boundary point (parent, node’s index plus one).\n\t\tthis.setStart(parent, getNodeIndex(node) + 1);\n\t}\n\n\t/**\n\t * Sets the end boundary point of the range to the position just before the given node.\n\t *\n\t * @param node - The node to set the range's end before\n\t */\n\tsetEndBefore(node: Node): void {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\t// 1. Let parent be node’s parent.\n\t\tconst parent = node.parentNode;\n\n\t\t// 2. If parent is null, then throw an InvalidNodeTypeError.\n\t\tif (parent === null) {\n\t\t\treturn throwInvalidNodeTypeError('Can not set range before node without a parent');\n\t\t}\n\n\t\t// 3. Set the end of this to boundary point (parent, node’s index).\n\t\tthis.setEnd(parent, getNodeIndex(node));\n\t}\n\n\t/**\n\t * Sets the end boundary point of the range to the position just after the given node.\n\t *\n\t * @param node - The node to set the range's end before\n\t */\n\tsetEndAfter(node: Node): void {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\t// 1. Let parent be node’s parent.\n\t\tconst parent = node.parentNode;\n\n\t\t// 2. If parent is null, then throw an InvalidNodeTypeError.\n\t\tif (parent === null) {\n\t\t\treturn throwInvalidNodeTypeError('Can not set range before node without a parent');\n\t\t}\n\n\t\t// 3. Set the end of this to boundary point (parent, node’s index plus one).\n\t\tthis.setEnd(parent, getNodeIndex(node) + 1);\n\t}\n\n\t/**\n\t * Sets the range's boundary points to the same position.\n\t *\n\t * @param toStart - If true, set both points to the start of the range, otherwise set them to\n\t *                  the end\n\t */\n\tcollapse(toStart: boolean = false): void {\n\t\tif (toStart) {\n\t\t\tthis.endContainer = this.startContainer;\n\t\t\tthis.endOffset = this.startOffset;\n\t\t} else {\n\t\t\tthis.startContainer = this.endContainer;\n\t\t\tthis.startOffset = this.endOffset;\n\t\t}\n\t}\n\n\tselectNode(node: Node): void {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\t// 1. Let parent be node’s parent.\n\t\tlet parent = node.parentNode;\n\n\t\t// 2. If parent is null, then throw an InvalidNodeTypeError.\n\t\tif (parent === null) {\n\t\t\treturn throwInvalidNodeTypeError('Can not select node with null parent');\n\t\t}\n\n\t\t// 3. Let index be node’s index.\n\t\tconst index = getNodeIndex(node);\n\n\t\t// 4. Set range’s start to boundary point (parent, index).\n\t\tthis.startContainer = parent;\n\t\tthis.startOffset = index;\n\n\t\t// 5. Set range’s end to boundary point (parent, index plus one).\n\t\tthis.endContainer = parent;\n\t\tthis.endOffset = index + 1;\n\t}\n\n\tselectNodeContents(node: Node): void {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\t// 1. If node is a doctype, then throw an InvalidNodeTypeError.\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE)) {\n\t\t\tthrowInvalidNodeTypeError('Can not place range inside a doctype node');\n\t\t}\n\n\t\t// 2. Let length be the length of node.\n\t\tconst length = determineLengthOfNode(node);\n\n\t\t// 3. Set start to the boundary point (node, 0).\n\t\tthis.startContainer = node;\n\t\tthis.startOffset = 0;\n\n\t\t// 4. Set end to the boundary point (node, length).\n\t\tthis.endContainer = node;\n\t\tthis.endOffset = length;\n\t}\n\n\tstatic START_TO_START = 0;\n\tstatic START_TO_END = 1;\n\tstatic END_TO_END = 2;\n\tstatic END_TO_START = 3;\n\n\tcompareBoundaryPoints(how: number, sourceRange: Range): number {\n\t\texpectArity(arguments, 2);\n\t\tsourceRange = asObject(sourceRange, Range);\n\n\t\t// 1. If how is not one of START_TO_START, START_TO_END, END_TO_END, and END_TO_START, then\n\t\t// throw a NotSupportedError.\n\t\tif (\n\t\t\thow !== Range.START_TO_START &&\n\t\t\thow !== Range.START_TO_END &&\n\t\t\thow !== Range.END_TO_END &&\n\t\t\thow !== Range.END_TO_START\n\t\t) {\n\t\t\tthrowNotSupportedError('Unsupported comparison type');\n\t\t}\n\n\t\t// 2. If this’s root is not the same as sourceRange’s root, then throw a\n\t\t// WrongDocumentError.\n\t\tif (getRootOfRange(this) !== getRootOfRange(sourceRange)) {\n\t\t\tthrowWrongDocumentError('Can not compare positions of ranges in different trees');\n\t\t}\n\n\t\t// 3. If how is:\n\t\tswitch (how) {\n\t\t\t// START_TO_START:\n\t\t\tcase Range.START_TO_START:\n\t\t\t\t// Let this point be this’s start. Let other point be sourceRange’s\n\t\t\t\t// start.\n\t\t\t\treturn compareBoundaryPointPositions(\n\t\t\t\t\t// this point\n\t\t\t\t\tthis.startContainer,\n\t\t\t\t\tthis.startOffset,\n\t\t\t\t\t// other point\n\t\t\t\t\tsourceRange.startContainer,\n\t\t\t\t\tsourceRange.startOffset\n\t\t\t\t);\n\n\t\t\t// START_TO_END:\n\t\t\tcase Range.START_TO_END:\n\t\t\t\t// Let this point be this’s end. Let other point be sourceRange’s\n\t\t\t\t// start.\n\t\t\t\treturn compareBoundaryPointPositions(\n\t\t\t\t\t// this point\n\t\t\t\t\tthis.endContainer,\n\t\t\t\t\tthis.endOffset,\n\t\t\t\t\t// other point\n\t\t\t\t\tsourceRange.startContainer,\n\t\t\t\t\tsourceRange.startOffset\n\t\t\t\t);\n\n\t\t\t// END_TO_END:\n\t\t\tcase Range.END_TO_END:\n\t\t\t\t// Let this point be this’s end. Let other point be sourceRange’s end.\n\t\t\t\treturn compareBoundaryPointPositions(\n\t\t\t\t\t// this point\n\t\t\t\t\tthis.endContainer,\n\t\t\t\t\tthis.endOffset,\n\t\t\t\t\t// other point\n\t\t\t\t\tsourceRange.endContainer,\n\t\t\t\t\tsourceRange.endOffset\n\t\t\t\t);\n\n\t\t\t// END_TO_START:\n\t\t\tdefault:\n\t\t\t\t// Let this point be this’s start. Let other point be sourceRange’s\n\t\t\t\t// end.\n\t\t\t\treturn compareBoundaryPointPositions(\n\t\t\t\t\t// this point\n\t\t\t\t\tthis.startContainer,\n\t\t\t\t\tthis.startOffset,\n\t\t\t\t\t// other point,\n\t\t\t\t\tsourceRange.endContainer,\n\t\t\t\t\tsourceRange.endOffset\n\t\t\t\t);\n\t\t}\n\n\t\t// 4. If the position of this point relative to other point is\n\t\t// before: Return −1.\n\t\t// equal: Return 0.\n\t\t// after: Return 1.\n\t\t// (handled in switch above)\n\t}\n\n\t/**\n\t * Removes the contents of the range\n\t */\n\tdeleteContents(): void {\n\t\t// 1.  If this is collapsed, then return.\n\t\tif (this.collapsed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// 2. Let original start node, original start offset, original end node, and original end\n\t\t// offset be this's start node, start offset, end node, and end offset, respectively.\n\t\tconst originalStartNode = this.startContainer;\n\t\tconst originalStartOffset = this.startOffset;\n\t\tconst originalEndNode = this.endContainer;\n\t\tconst originalEndOffset = this.endOffset;\n\n\t\t// 3. If original start node is original end node and it is a CharacterData node, then\n\t\t// replace data with node original start node, offset original start offset, count original\n\t\t// end offset minus original start offset, and data the empty string, and then return.\n\t\tif (originalStartNode === originalEndNode && isCharacterDataNode(originalStartNode)) {\n\t\t\toriginalStartNode.replaceData(\n\t\t\t\toriginalStartOffset,\n\t\t\t\toriginalEndOffset - originalStartOffset,\n\t\t\t\t''\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// 4. Let nodes to remove be a list of all the nodes that are contained in this, in tree\n\t\t// order, omitting any node whose parent is also contained in this.\n\t\tconst nodesToRemove: Node[] = [];\n\t\tforEachNodeContainedInRange(this, (node) => {\n\t\t\tnodesToRemove.push(node);\n\t\t});\n\n\t\t// 5. If original start node is an inclusive ancestor of original end node, set new node to\n\t\t// original start node and new offset to original start offset.\n\t\tlet newNode: Node;\n\t\tlet newOffset: number;\n\t\tif (originalStartNode.contains(originalEndNode)) {\n\t\t\tnewNode = originalStartNode;\n\t\t\tnewOffset = originalStartOffset;\n\t\t} else {\n\t\t\t// 6. Otherwise:\n\t\t\t// 6.1. Let reference node equal original start node.\n\t\t\tlet referenceNode = originalStartNode;\n\n\t\t\t// 6.2. While reference node's parent is not null and is not an inclusive ancestor of\n\t\t\t// original end node, set reference node to its parent.\n\t\t\twhile (\n\t\t\t\treferenceNode.parentNode !== null &&\n\t\t\t\t!referenceNode.parentNode.contains(originalEndNode)\n\t\t\t) {\n\t\t\t\treferenceNode = referenceNode.parentNode;\n\t\t\t}\n\n\t\t\t// 6.3. Set new node to the parent of reference node, and new offset to one plus the\n\t\t\t// index of reference node.\n\t\t\t// Note: If reference node’s parent were null, it would be the root of this, so would be\n\t\t\t// an inclusive ancestor of original end node, and we could not reach this point.\n\t\t\tnewNode = referenceNode.parentNode!;\n\t\t\tnewOffset = 1 + getNodeIndex(referenceNode);\n\t\t}\n\n\t\t// 7. If original start node is a CharacterData node, then replace data with node original\n\t\t// start node, offset original start offset, count original start node's length minus\n\t\t// original start offset, data the empty string.\n\t\tif (isCharacterDataNode(originalStartNode)) {\n\t\t\toriginalStartNode.replaceData(\n\t\t\t\toriginalStartOffset,\n\t\t\t\toriginalStartNode.length - originalStartOffset,\n\t\t\t\t''\n\t\t\t);\n\t\t}\n\n\t\t// 8. For each node in nodes to remove, in tree order, remove node.\n\t\tnodesToRemove.forEach((node) => {\n\t\t\tremoveNode(node);\n\t\t});\n\n\t\t// 9. If original end node is a CharacterData node, then replace data with node original end\n\t\t// node, offset 0, count original end offset and data the empty string.\n\t\tif (isCharacterDataNode(originalEndNode)) {\n\t\t\toriginalEndNode.replaceData(0, originalEndOffset, '');\n\t\t}\n\n\t\t// 10. Set start and end to (new node, new offset).\n\t\tthis.setStart(newNode, newOffset);\n\t\tthis.collapse(true);\n\t}\n\n\t/**\n\t * Move the contents of this range into a new DocumentFragment\n\t *\n\t * @returns DocumentFragment containing the Range's previous contents\n\t */\n\textractContents(): DocumentFragment {\n\t\treturn extractRange(this, false);\n\t}\n\n\t/**\n\t * Clone the contents of this range into a new DocumentFragment\n\t *\n\t * @returns DocumentFragment containing a copy of the Range's contents\n\t */\n\tcloneContents(): DocumentFragment {\n\t\treturn extractRange(this, true);\n\t}\n\n\t/**\n\t * Insert node at the start of this range\n\t *\n\t * @param node - Node to insert\n\t */\n\tinsertNode(node: Node): void {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\tinsertNodeIntoRange(node, this);\n\t}\n\n\t/**\n\t * Wraps the contents of this range in the given new parent\n\t *\n\t * This only works if the only partially contained nodes are text nodes. Any existing children\n\t * of newParent will be removed.\n\t *\n\t * @param newParent - Node to insert\n\t */\n\tsurroundContents(newParent: Node): void {\n\t\texpectArity(arguments, 1);\n\t\tnewParent = asObject(newParent, Node);\n\n\t\t// 1. If a non-Text node is partially contained in this, then throw an \"InvalidStateError\"\n\t\t// DOMException.\n\t\tconst startNonTextNode = isTextNode(this.startContainer)\n\t\t\t? this.startContainer.parentNode\n\t\t\t: this.startContainer;\n\t\tconst endNonTextNode = isTextNode(this.endContainer)\n\t\t\t? this.endContainer.parentNode\n\t\t\t: this.endContainer;\n\t\tif (startNonTextNode !== endNonTextNode) {\n\t\t\tthrowInvalidStateError(\n\t\t\t\t'Can not use surroundContents on a range that has partially selected a non-Text node'\n\t\t\t);\n\t\t}\n\n\t\t// 2. If newParent is a Document, DocumentType, or DocumentFragment node, then throw an\n\t\t// \"InvalidNodeTypeError\" DOMException.\n\t\t// Note: For historical reasons CharacterData nodes are not checked here and end up throwing\n\t\t// later on as a side effect.\n\t\tif (\n\t\t\tisNodeOfType(\n\t\t\t\tnewParent,\n\t\t\t\tNodeType.DOCUMENT_NODE,\n\t\t\t\tNodeType.DOCUMENT_TYPE_NODE,\n\t\t\t\tNodeType.DOCUMENT_FRAGMENT_NODE\n\t\t\t)\n\t\t) {\n\t\t\tthrowInvalidNodeTypeError(\n\t\t\t\t'Can not use Document, DocumentType, or DocumentFragment as a parent node in surroundContents'\n\t\t\t);\n\t\t}\n\n\t\t// 3. Let fragment be the result of extracting this.\n\t\tconst fragment = extractRange(this, false);\n\n\t\t// 4. If newParent has children, then replace all with null within newParent.\n\t\tif (newParent.firstChild) {\n\t\t\treplaceAllWithNode(null, newParent);\n\t\t}\n\n\t\t// 5. Insert newParent into this.\n\t\tinsertNodeIntoRange(newParent, this);\n\n\t\t// 6. Append fragment to newParent.\n\t\tappendNode(fragment, newParent);\n\n\t\t// 7. Select newParent within this.\n\t\tthis.selectNode(newParent);\n\t}\n\n\t/**\n\t * Returns a range with the same start and end as this.\n\t *\n\t * @returns A copy of this\n\t */\n\tcloneRange(): Range {\n\t\tconst context = getContext(this);\n\t\tconst range = new context.Range();\n\t\trange.startContainer = this.startContainer;\n\t\trange.startOffset = this.startOffset;\n\t\trange.endContainer = this.endContainer;\n\t\trange.endOffset = this.endOffset;\n\t\treturn range;\n\t}\n\n\t/**\n\t * Stops tracking the range.\n\t *\n\t * (non-standard) According to the spec, this method must do nothing. However, it is not yet\n\t * possible in all browsers to allow garbage collection while keeping track of active ranges to\n\t * be updated by mutations. Therefore, unless your code will only run in environments that\n\t * implement the WeakRef proposal (https://github.com/tc39/proposal-weakrefs), make sure to call\n\t * this method to stop updating the range and free up its resources.\n\t */\n\tdetach(): void {\n\t\tconst context = getContext(this);\n\t\tcontext.removeRange(this);\n\t}\n\n\t/**\n\t * Returns true if the given point is after or equal to the start point and before or equal to\n\t * the end point of this.\n\t *\n\t * @param node   - Node of point to check\n\t * @param offset - Offset of point to check\n\t *\n\t * @returns Whether the point is in the range\n\t */\n\tisPointInRange(node: Node, offset: number): boolean {\n\t\texpectArity(arguments, 2);\n\t\tnode = asObject(node, Node);\n\t\toffset = asUnsignedLong(offset);\n\n\t\t// 1. If node’s root is different from this’s root, return false.\n\t\tif (getRootOfNode(node) !== getRootOfRange(this)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// 2. If node is a doctype, then throw an InvalidNodeTypeError.\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE)) {\n\t\t\tthrowInvalidNodeTypeError('Point can not be under a doctype');\n\t\t}\n\n\t\t// 3. If offset is greater than node’s length, then throw an IndexSizeError.\n\t\tif (offset > determineLengthOfNode(node)) {\n\t\t\tthrowIndexSizeError('Offset should not be past the end of node');\n\t\t}\n\n\t\t// 4. If (node, offset) is before start or after end, return false.\n\t\tif (\n\t\t\tcompareBoundaryPointPositions(node, offset, this.startContainer, this.startOffset) ===\n\t\t\t\tPOSITION_BEFORE ||\n\t\t\tcompareBoundaryPointPositions(node, offset, this.endContainer, this.endOffset) ===\n\t\t\t\tPOSITION_AFTER\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// 5. Return true.\n\t\treturn true;\n\t}\n\n\t/**\n\t * Compares the given point to the range's boundary points.\n\t *\n\t * @param node   - Node of point to check\n\t * @param offset - Offset of point to check\n\t *\n\t * @returns -1, 0 or 1 depending on whether the point is before, inside or after the range,\n\t *         respectively\n\t */\n\tcomparePoint(node: Node, offset: number): number {\n\t\texpectArity(arguments, 2);\n\t\tnode = asObject(node, Node);\n\t\toffset = asUnsignedLong(offset);\n\n\t\t// 1. If node’s root is different from this’s root, then throw a\n\t\t// WrongDocumentError.\n\t\tif (getRootOfNode(node) !== getRootOfRange(this)) {\n\t\t\tthrowWrongDocumentError('Can not compare point to range in different trees');\n\t\t}\n\n\t\t// 2. If node is a doctype, then throw an InvalidNodeTypeError.\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE)) {\n\t\t\tthrowInvalidNodeTypeError('Point can not be under a doctype');\n\t\t}\n\n\t\t// 3. If offset is greater than node’s length, then throw an IndexSizeError.\n\t\tif (offset > determineLengthOfNode(node)) {\n\t\t\tthrowIndexSizeError('Offset should not be past the end of node');\n\t\t}\n\n\t\t// 4. If (node, offset) is before start, return −1.\n\t\tif (\n\t\t\tcompareBoundaryPointPositions(node, offset, this.startContainer, this.startOffset) ===\n\t\t\tPOSITION_BEFORE\n\t\t) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t// 5. If (node, offset) is after end, return 1.\n\t\tif (\n\t\t\tcompareBoundaryPointPositions(node, offset, this.endContainer, this.endOffset) ===\n\t\t\tPOSITION_AFTER\n\t\t) {\n\t\t\treturn 1;\n\t\t}\n\n\t\t// 6. Return 0.\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Returns true if range overlaps the range from before node to after node.\n\t *\n\t * @param node - The node to check\n\t *\n\t * @returns Whether the range intersects node\n\t */\n\tintersectsNode(node: Node): boolean {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\t// 1. If node’s root is different from this’s root, return false.\n\t\tif (getRootOfNode(node) !== getRootOfRange(this)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// 2. Let parent be node’s parent.\n\t\tconst parent = node.parentNode;\n\n\t\t// 3. If parent is null, return true.\n\t\tif (parent === null) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// 4. Let offset be node’s index.\n\t\tconst offset = getNodeIndex(node);\n\n\t\t// 5. If (parent, offset) is before end and (parent, offset + 1) is after start, return\n\t\t// true.\n\t\t// 6. Return false.\n\t\treturn (\n\t\t\tcompareBoundaryPointPositions(parent, offset, this.endContainer, this.endOffset) ===\n\t\t\t\tPOSITION_BEFORE &&\n\t\t\tcompareBoundaryPointPositions(\n\t\t\t\tparent,\n\t\t\t\toffset + 1,\n\t\t\t\tthis.startContainer,\n\t\t\t\tthis.startOffset\n\t\t\t) === POSITION_AFTER\n\t\t);\n\t}\n\n\t/**\n\t * The stringification behavior must run these steps:\n\t */\n\ttoString(): string {\n\t\t// 1. Let s be the empty string.\n\t\tlet s: string[] = [];\n\n\t\t// 2. If this's start node is this's end node and it is a Text node, then return the\n\t\t// substring of that Text node's data beginning at this's start offset and ending at this's\n\t\t// end offset.\n\t\tconst startContainer = this.startContainer;\n\t\tif (isTextNode(startContainer)) {\n\t\t\tif (this.startContainer === this.endContainer) {\n\t\t\t\treturn startContainer.substringData(\n\t\t\t\t\tthis.startOffset,\n\t\t\t\t\tthis.endOffset - this.startOffset\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// 3. If this's start node is a Text node, then append the substring of that node's data\n\t\t\t// from this's start offset until the end to s.\n\t\t\ts.push(\n\t\t\t\tstartContainer.substringData(\n\t\t\t\t\tthis.startOffset,\n\t\t\t\t\tstartContainer.length - this.startOffset\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t// 4. Append the concatenation of the data of all Text nodes that are contained in this, in\n\t\t// tree order, to s.\n\t\tforEachNodeContainedInRange(this, (node) => {\n\t\t\tforEachInclusiveDescendant(node, (node) => {\n\t\t\t\tif (isTextNode(node)) {\n\t\t\t\t\ts.push(node.data);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\t// 5. If this's end node is a Text node, then append the substring of that node's data from\n\t\t// its start until this’s end offset to s.\n\t\tconst endContainer = this.endContainer;\n\t\tif (isTextNode(endContainer)) {\n\t\t\ts.push(endContainer.substringData(0, this.endOffset));\n\t\t}\n\n\t\t// 6. Return s.\n\t\treturn s.join('');\n\t}\n}\n\nconst POSITION_BEFORE = -1;\nconst POSITION_EQUAL = 0;\nconst POSITION_AFTER = 1;\n\n/**\n * If the two nodes of boundary points (node A, offset A) and (node B, offset B) have the same root,\n * the position of the first relative to the second is either before, equal, or after.\n *\n * Note: for efficiency reasons, this implementation deviates from the algorithm given in 4.2.\n *\n * This implementation assumes it is called on nodes under the same root.\n *\n * @param nodeA   - First boundary point's node\n * @param offsetA - First boundary point's offset\n * @param nodeB   - Second boundary point's node\n * @param offsetB - Second boundary point's offset\n *\n * @returns -1, 0 or 1, depending on the boundary points' relative positions\n */\nfunction compareBoundaryPointPositions(\n\tnodeA: Node,\n\toffsetA: number,\n\tnodeB: Node,\n\toffsetB: number\n): number {\n\tif (nodeA !== nodeB) {\n\t\tconst ancestors1 = getInclusiveAncestors(nodeA);\n\t\tconst ancestors2 = getInclusiveAncestors(nodeB);\n\n\t\t// Skip common parents\n\t\twhile (ancestors1[0] && ancestors2[0] && ancestors1[0] === ancestors2[0]) {\n\t\t\tancestors1.shift();\n\t\t\tancestors2.shift();\n\t\t}\n\n\t\t// Compute offsets at the level under the last common parent. Add 0.5 to bias positions\n\t\t// inside the parent vs. those before or after.\n\t\tif (ancestors1.length) {\n\t\t\toffsetA = getNodeIndex(ancestors1[0]) + 0.5;\n\t\t}\n\t\tif (ancestors2.length) {\n\t\t\toffsetB = getNodeIndex(ancestors2[0]) + 0.5;\n\t\t}\n\t}\n\n\t// Compare positions at this level\n\tif (offsetA === offsetB) {\n\t\treturn POSITION_EQUAL;\n\t}\n\treturn offsetA < offsetB ? POSITION_BEFORE : POSITION_AFTER;\n}\n\n/**\n * The root of a range is the root of its start node.\n *\n * @param range - The range to get the root of\n *\n * @returns The root of range\n */\nfunction getRootOfRange(range: Range): Node {\n\treturn getRootOfNode(range.startContainer);\n}\n","import Document from './Document';\nimport { getContext } from './context/Context';\n\n/**\n * @public\n */\nexport default class XMLDocument extends Document {\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic _copy(document: Document): XMLDocument {\n\t\t// Set copy’s encoding, content type, URL, origin, type, and mode, to those of node.\n\t\t// (properties not implemented)\n\n\t\tconst context = getContext(document);\n\t\treturn new context.XMLDocument();\n\t}\n}\n","import Document from '../Document';\nimport { parseXmlDocument } from './parsingAlgorithms';\n\n/**\n * Interface DOMParser\n *\n * @public\n */\nexport default class DOMParser {\n\t/**\n\t * Constructs a new DOMParser object.\n\t */\n\tpublic constructor() {}\n\n\t/**\n\t * Parse str using a parser that matches type's supported MIME types (either XML or HTML), and\n\t * return a Document object containing the parsed content if successful. If not successful,\n\t * returns a Document describing the error.\n\t *\n\t * @param str  - The string to parse\n\t * @param type - The mime type to parse the string as\n\t *\n\t * @returns  Either the document resulting from successfully parsing str, or a document\n\t *           describing the error.\n\t */\n\tpublic parseFromString(str: string, type: string): Document {\n\t\tswitch (type) {\n\t\t\tcase 'text/html':\n\t\t\t\t// Parse str with an HTML parser, and return the newly created Document.\n\t\t\t\t// The scripting flag must be set to \"disabled\".\n\t\t\t\t// NOTE: meta elements are not taken into account for the encoding used, as a\n\t\t\t\t// Unicode stream is passed into the parser.\n\t\t\t\t// NOTE: script elements get marked unexecutable and the contents of noscript get\n\t\t\t\t// parsed as markup.\n\t\t\t\tthrow new Error('HTML parsing is not implemented');\n\n\t\t\tcase 'text/xml':\n\t\t\tcase 'application/xml':\n\t\t\tcase 'application/xhtml+xml':\n\t\t\tcase 'image/svg+xml':\n\t\t\t\ttry {\n\t\t\t\t\t// 1. Parse str with a namespace-enabled XML parser.\n\t\t\t\t\t// NOTE: For all XHTML script elements parsed using the XML parser, the\n\t\t\t\t\t// equivalent of the scripting flag must be set to \"disabled\".\n\t\t\t\t\tconst doc = parseXmlDocument(str);\n\n\t\t\t\t\t// 2. If the previous step didn't return an error, return the newly created\n\t\t\t\t\t// Document.\n\t\t\t\t\treturn doc;\n\t\t\t\t} catch (error: unknown) {\n\t\t\t\t\t// 3. Let document be a newly-created XML Document. The document will use the\n\t\t\t\t\t// Document interface rather than the XMLDocument interface.\n\t\t\t\t\tconst document = new Document();\n\n\t\t\t\t\t// 4. Let root be a new Element, with its local name set to \"parsererror\" and\n\t\t\t\t\t// its namespace set to \"http://www.mozilla.org/newlayout/xml/parsererror.xml\".\n\t\t\t\t\tconst root = document.createElementNS(\n\t\t\t\t\t\t'http://www.mozilla.org/newlayout/xml/parsererror.xml',\n\t\t\t\t\t\t'parsererror'\n\t\t\t\t\t);\n\n\t\t\t\t\t// At this point user agents may append nodes to root, for example to describe\n\t\t\t\t\t// the nature of the error.\n\t\t\t\t\troot.appendChild(document.createTextNode(`${error}`));\n\n\t\t\t\t\t// 5. Append root to document.\n\t\t\t\t\tdocument.appendChild(root);\n\n\t\t\t\t\t// 6. Return the value of document.\n\t\t\t\t\treturn document;\n\t\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`The type \"${type}\" is not a valid value in the SupportedType enumeration.`\n\t\t\t\t);\n\t\t}\n\t}\n}\n","import Node from '../Node';\nimport { asObject } from '../util/typeHelpers';\nimport { produceXmlSerialization } from './serializationAlgorithms';\n\n/**\n * 2.2 The XMLSerializer interface\n *\n * @public\n */\nexport default class XMLSerializer {\n\t/**\n\t * Constructs a new XMLSerializer object.\n\t */\n\tpublic constructor() {}\n\n\t/**\n\t * Serializes root into a string using an XML serialization. Throws a TypeError exception if\n\t * root is not a Node.\n\t *\n\t * @param root - The node to serialize\n\t *\n\t * @returns The XML resulting from serialization\n\t */\n\tpublic serializeToString(root: Node): string {\n\t\troot = asObject(root, Node);\n\n\t\t// Produce an XML serialization of root passing a value of false for the require well-formed\n\t\t// parameter, and return the result.\n\t\tconst result: string[] = [];\n\t\tproduceXmlSerialization(root, false, result);\n\t\treturn result.join('');\n\t}\n}\n\n/**\n * Serializes root into a string using an XML serialization. Throws if the result would not be\n * well-formed XML.\n *\n * Non-standard: the dom-parsing spec does not provide a way to serialize arbitrary nodes while\n * enforcing well-formedness.\n *\n * @public\n *\n * @param root - The node to serialize\n *\n * @returns The XML resulting from serialization\n */\nexport function serializeToWellFormedString(root: Node): string {\n\troot = asObject(root, Node);\n\n\t// Produce an XML serialization of root passing a value of true for the require well-formed\n\t// parameter, and return the result.\n\tconst result: string[] = [];\n\tproduceXmlSerialization(root, true, result);\n\treturn result.join('');\n}\n","import MutationRecord from './MutationRecord';\nimport NotifySet from './NotifyList';\nimport RegisteredObserver from './RegisteredObserver';\nimport Node from '../Node';\nimport { expectArity } from '../util/errorHelpers';\nimport { asObject } from '../util/typeHelpers';\n\n/**\n * @public\n */\nexport interface MutationObserverInit {\n\t/**\n\t * Whether to observe childList mutations.\n\t */\n\tchildList?: boolean;\n\n\t/**\n\t * Whether to observe attribute mutations.\n\t */\n\tattributes?: boolean;\n\n\t/**\n\t * Whether to observe character data mutations.\n\t */\n\tcharacterData?: boolean;\n\n\t/**\n\t * Whether to observe mutations on any descendant in addition to those on the target.\n\t */\n\tsubtree?: boolean;\n\n\t/**\n\t * Whether to record the previous value of attributes.\n\t */\n\tattributeOldValue?: boolean;\n\n\t/**\n\t * Whether to record the previous value of character data nodes.\n\t */\n\tcharacterDataOldValue?: boolean;\n}\n\nexport type MutationCallback = (records: MutationRecord[], observer: MutationObserver) => void;\n\n/**\n * 3.3.1. Interface MutationObserver\n *\n * A MutationObserver object can be used to observe mutations to the tree of nodes.\n *\n * @public\n */\nexport default class MutationObserver {\n\t/**\n\t * The function that will be called when control returns to the event loop, if there are any\n\t * queued records. The function is passed the MutationRecords and the observer instance that\n\t * collected them.\n\t */\n\tpublic _callback: MutationCallback;\n\n\t/**\n\t * The list of nodes on which this observer is a RegisteredObserver's observer.\n\t */\n\tpublic _nodes: Node[] = [];\n\n\t/**\n\t * The list of MutationRecord objects collected so far.\n\t */\n\tpublic _recordQueue: MutationRecord[] = [];\n\n\t/**\n\t * Tracks transient registered observers created for this observer, to simplify their removal.\n\t */\n\tpublic _transients: RegisteredObserver[] = [];\n\n\t/**\n\t * Constructs a MutationObserver object and sets its callback to callback. The callback is\n\t * invoked with a list of MutationRecord objects as first argument and the constructed\n\t * MutationObserver object as second argument. It is invoked after nodes registered with the\n\t * observe() method, are mutated.\n\t *\n\t * @param callback - Function called after mutations have been observed.\n\t */\n\tconstructor(callback: MutationCallback) {\n\t\texpectArity(arguments, 1);\n\t\tcallback = asObject(callback, Function);\n\n\t\t// 1. Let mo be a new MutationObserver object whose callback is callback.\n\t\tthis._callback = callback;\n\n\t\t// 2. Append mo to mo's relevant agent's mutation observers.\n\t\t// (for efficiency, this implementation only tracks MutationObserver objects that have\n\t\t// records queued)\n\n\t\t// 3. Return mo.\n\t}\n\n\t/**\n\t * Instructs the user agent to observe a given target (a node) and report any mutations based on\n\t * the criteria given by options (an object).\n\t *\n\t * NOTE: Adding an observer to an element is just like addEventListener, if you observe the\n\t * element multiple times it does not make a difference. Meaning if you observe element twice,\n\t * the observe callback does not fire twice, nor will you have to run disconnect() twice. In\n\t * other words, once an element is observed, observing it again with the same will do nothing.\n\t * However if the callback object is different it will of course add another observer to it.\n\t *\n\t * @param target  - Node (or root of subtree) to observe\n\t * @param options - Determines which types of mutations to observe\n\t */\n\tobserve(target: Node, options: MutationObserverInit) {\n\t\texpectArity(arguments, 2);\n\t\ttarget = asObject(target, Node);\n\n\t\t// Defaults from IDL\n\t\toptions.childList = !!options.childList;\n\t\toptions.subtree = !!options.subtree;\n\n\t\t// 1. If either options[\"attributeOldValue\"] or options[\"attributeFilter\"] exists, and\n\t\t// options[\"attributes\"] does not exist, then set options[\"attributes\"] to true.\n\t\tif (options.attributeOldValue !== undefined && options.attributes === undefined) {\n\t\t\toptions.attributes = true;\n\t\t}\n\n\t\t// 2. If options[\"characterDataOldValue\"] exists and options[\"characterData\"] does not\n\t\t// exist, then set options[\"characterData\"] to true.\n\t\tif (options.characterDataOldValue !== undefined && options.characterData === undefined) {\n\t\t\toptions.characterData = true;\n\t\t}\n\t\t// 3. If none of options[\"childList\"], options[\"attributes\"], and options[\"characterData\"]\n\t\t// is true, then throw a TypeError.\n\t\tif (!(options.childList || options.attributes || options.characterData)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'The options object must set at least one of \"attributes\", \"characterData\", or ' +\n\t\t\t\t\t'\"childList\" to true.'\n\t\t\t);\n\t\t}\n\n\t\t// 4. If options[\"attributeOldValue\"] is true and options[\"attributes\"] is false, then throw\n\t\t// a TypeError.\n\t\tif (options.attributeOldValue && !options.attributes) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'The options object may only set \"attributeOldValue\" to true when \"attributes\" ' +\n\t\t\t\t\t'is true or not present.'\n\t\t\t);\n\t\t}\n\n\t\t// 5. If options[\"attributeFilter\"] exists and options[\"attributes\"] is false, then throw a\n\t\t// TypeError. (attributeFilter not yet implemented)\n\n\t\t// 6. If options[\"characterDataOldValue\"] is true and options[\"characterData\"] is false,\n\t\t// then throw a TypeError.\n\t\tif (options.characterDataOldValue && !options.characterData) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'The options object may only set \"characterDataOldValue\" to true when ' +\n\t\t\t\t\t'\"characterData\" is true or not present.'\n\t\t\t);\n\t\t}\n\n\t\t// 7. For each registered registered of target’s registered observer list, if registered's\n\t\t// observer is this:\n\t\t// 7.1. For each node of this's node list, remove all transient registered\n\t\t// observers whose source is registered from node's registered observer list.\n\t\t// 7.2. Set registered’s options to options.\n\t\t// 8. Otherwise:\n\t\t// 8.1. Append a new registered observer whose observer is this and options is\n\t\t// options to target's registered observer list.\n\t\t// 8.2. Append target to this's node list.\n\t\ttarget._registeredObservers.register(this, options);\n\t}\n\n\t/**\n\t * Stops the MutationObserver instance from receiving notifications of DOM mutations. Until the\n\t * observe() method is used again, observer's callback will not be invoked.\n\t */\n\tdisconnect() {\n\t\t// 1. For each node of this’s node list, remove any registered observer from\n\t\t// node's registered observer list for which this is the observer.\n\t\tthis._nodes.forEach((node) => node._registeredObservers.removeForObserver(this));\n\t\tthis._nodes.length = 0;\n\n\t\t// 2. Empty this’s record queue.\n\t\tthis._recordQueue.length = 0;\n\t}\n\n\t/**\n\t * Empties the MutationObserver instance's record queue and returns what was in there.\n\t *\n\t * @returns An Array of MutationRecord objects that were recorded.\n\t */\n\ttakeRecords(): MutationRecord[] {\n\t\t// 1. Let records be a clone of this's record queue.\n\t\tconst records = this._recordQueue.concat();\n\t\t// 2. Empty this's record queue\n\t\tthis._recordQueue.length = 0;\n\t\t// 3. Return records\n\t\treturn records;\n\t}\n}\n","export { default as Attr } from './Attr';\nexport { default as CDATASection } from './CDATASection';\nexport { default as CharacterData } from './CharacterData';\nexport { default as Comment } from './Comment';\nexport { default as Document } from './Document';\nexport { default as DocumentFragment } from './DocumentFragment';\nexport { default as DocumentType } from './DocumentType';\nexport { default as DOMImplementation } from './DOMImplementation';\nexport { default as Element } from './Element';\nexport { default as Node } from './Node';\nexport { default as ProcessingInstruction } from './ProcessingInstruction';\nexport { default as Range } from './Range';\nexport { StaticRange } from './Range';\nexport { default as Text } from './Text';\nexport { default as XMLDocument } from './XMLDocument';\nexport { default as DOMParser } from './dom-parsing/DOMParser';\nexport { default as XMLSerializer } from './dom-parsing/XMLSerializer';\nexport { default as MutationObserver } from './mutation-observer/MutationObserver';\nexport { default as MutationRecord } from './mutation-observer/MutationRecord';\nexport { DOMException } from './util/errorHelpers';\n\nexport { parseXmlDocument, parseXmlFragment } from './dom-parsing/parsingAlgorithms';\nexport type { ParseOptions } from './dom-parsing/parsingAlgorithms';\n\n// Standard DOM does not expose a way to serialize arbitrary nodes as well-formed XML\nexport { serializeToWellFormedString } from './dom-parsing/XMLSerializer';\n\n// Unsafe exports, required for connecting a HTML parser\nexport { unsafeCreateAttribute, unsafeCreateElement, unsafeAppendAttribute } from './unsafe';\n\n// To avoid cyclic dependencies and enable multiple contexts with their own constructors later,\n// inject all constructors as well as the global document into the default context (i.e., global\n// object) here.\nimport { defaultContext } from './context/Context';\n\nimport Attr from './Attr';\nimport CDATASection from './CDATASection';\nimport Comment from './Comment';\nimport Document from './Document';\nimport DocumentFragment from './DocumentFragment';\nimport DocumentType from './DocumentType';\nimport DOMImplementation from './DOMImplementation';\nimport Element from './Element';\nimport ProcessingInstruction from './ProcessingInstruction';\nimport Range from './Range';\nimport Text from './Text';\nimport XMLDocument from './XMLDocument';\n\n/**\n * The document associated with the global object. Used when calling constructors directly.\n *\n * Do not mutate this instance. When possible, it is recommended to use `new slimdom.Document` to\n * create a new document, and then use the factory methods on that instance to create other nodes.\n *\n * @public\n */\nexport const document = new Document();\ndefaultContext.document = document;\n\ndefaultContext.Attr = Attr;\ndefaultContext.CDATASection = CDATASection;\ndefaultContext.Comment = Comment;\ndefaultContext.Document = Document;\ndefaultContext.DocumentFragment = DocumentFragment;\ndefaultContext.DocumentType = DocumentType;\ndefaultContext.DOMImplementation = DOMImplementation;\ndefaultContext.Element = Element;\ndefaultContext.ProcessingInstruction = ProcessingInstruction;\ndefaultContext.Range = Range;\ndefaultContext.Text = Text;\ndefaultContext.XMLDocument = XMLDocument;\n"],"names":["RegisteredObserver","constructor","observer","node","options","source","this","_transients","push","collectInterestedObservers","type","target","data","interestedObservers","pairedStrings","subtree","attributes","characterData","childList","index","indexOf","length","undefined","attributeOldValue","characterDataOldValue","oldValue","RegisteredObservers","_registeredObservers","_node","register","registeredObservers","hasRegisteredObserverForObserver","forEach","registered","i","transientRegisteredObserver","removeTransientRegisteredObserver","splice","removeTransientRegisteredObserversForSource","_nodes","removeForObserver","write","read","l","registeredObserver","appendTransientRegisteredObservers","registerTransient","queueMicrotaskWithAppropriateApi","callback","thisArg","args","queueMicrotask","Promise","resolve","then","apply","NotifySet","_notifySet","Set","_mutationObserverMicrotaskQueued","appendRecord","record","_recordQueue","add","queueMutationObserverMicrotask","_notifyMutationObservers","notifySet","Array","from","clear","mo","records","takeRecords","_callback","FakeWeakRef","_target","deref","defaultContext","_ranges","_weakRangeSet","WeakSet","forEachRange","cb","numRanges","r","isLost","isManuallyRemoved","has","pop","addRange","range","weakref","WeakRef","removeRange","delete","getContext","_instance","isNodeOfType","types","some","t","nodeType","isAttrNode","isCharacterDataNode","isTextNode","isElement","isDocumentType","determineLengthOfNode","childNodes","getInclusiveAncestors","ancestor","ancestors","unshift","parentNode","getNodeDocument","ownerDocument","getNodeIndex","getRootOfNode","forEachInclusiveDescendant","child","firstChild","nextSibling","getListOfElementsWithQualifiedName","qualifiedName","root","elements","element","nodeName","getListOfElementsWithNamespaceAndLocalName","namespace","localName","namespaceURI","cloneNode","cloneChildren","document","copy","_copy","appendChild","expectArity","minArity","TypeError","codeByName","IndexSizeError","HierarchyRequestError","WrongDocumentError","InvalidCharacterError","NotFoundError","NotSupportedError","InUseAttributeError","InvalidStateError","NamespaceError","InvalidNodeTypeError","DOMException","Error","message","name","super","code","stack","createDOMException","throwHierarchyRequestError","throwIndexSizeError","throwInvalidCharacterError","throwInvalidNodeTypeError","throwInvalidStateError","throwNamespaceError","throwNotFoundError","throwNotSupportedError","throwWrongDocumentError","MutationRecord","addedNodes","removedNodes","previousSibling","attributeName","attributeNamespace","queueMutationRecord","context","mappedOldValue","getChildren","firstElementChild","nextElementSibling","getPreviousElementSibling","sibling","getNextElementSibling","removeFromChildren","parent","previousElementSibling","lastChild","asParentNode","lastElementChild","childElementCount","parentDocument","documentElement","doctype","ensurePreInsertionValidity","contains","fragment","preInsertNode","referenceChild","adoptNode","insertNode","suppressObservers","isFragment","isDocumentFragment","nodes","count","n","removeNode","childIndex","startContainer","startOffset","endContainer","endOffset","siblingNonDocumentTypeChildNode","isDocument","insertIntoChildren","appendNode","replaceChildWithNode","replaceAllWithNode","oldPreviousSibling","oldNextSibling","inclusiveAncestor","oldDocument","inclusiveDescendant","attr","getDescendantTextContent","descendant","join","stringReplaceAll","newValue","Text","convertNodesIntoNode","actualNodes","map","nodeOrString","Node","createTextNode","String","createDocumentFragment","prependNodes","thisObject","appendNodes","replaceChildren","insertNodesBefore","viablePreviousSibling","insertNodesAfter","viableNextSibling","replaceWithNodes","removeFromParent","insertNodeIntoRange","referenceNode","splitText","newOffset","collapsed","setEnd","asUnsignedLong","number","legacyNullToEmptyString","value","ifNullActAsIfEmptyString","asObject","Constructor","expectObject","asNullableObject","asNullableString","orderKeyByNode","WeakMap","getOrderKey","orderKey","get","Math","random","set","parentElement","hasChildNodes","normalize","nextNode","textNode","siblingsToRemove","replaceData","currentNode","currentNodeIndex","shift","deep","compareDocumentPosition","other","arguments","node1","node2","attr1","attr2","ownerElement","DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_DISCONNECTED","ancestors1","ancestors2","firstDistinctAncestorIndex","node1ContainsNode2","node2ContainsNode1","DOCUMENT_POSITION_CONTAINS","DOCUMENT_POSITION_CONTAINED_BY","isDefaultNamespace","lookupNamespaceURI","insertBefore","replaceChild","removeChild","preRemoveChild","handleAttributeChanges","attribute","changeAttribute","_value","appendAttribute","removeAttribute","attributeElement","ELEMENT_NODE","ATTRIBUTE_NODE","TEXT_NODE","CDATA_SECTION_NODE","ENTITY_REFERENCE_NODE","ENTITY_NODE","PROCESSING_INSTRUCTION_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_TYPE_NODE","DOCUMENT_FRAGMENT_NODE","NOTATION_NODE","prototype","Attr","nodeValue","setExistingAttributeValue","textContent","lookupPrefix","prefix","CharacterData","_data","before","after","replaceWith","remove","substringData","offset","appendData","insertData","deleteData","nodeData","newData","substring","newNode","indexOfNodePlusOne","wholeText","allData","CDATASection","Comment","DocumentType","_newValue","publicId","systemId","unsafeCreateAttribute","unsafeCreateElement","createElement","unsafeAppendAttribute","HTML_NAMESPACE","XML_NAMESPACE","XMLNS_NAMESPACE","validateQualifiedName","parts","split","every","part","matchesNameProduction","isValidQName","validateAndExtract","locateNamespacePrefix","find","okWithValue","success","ok","error","expected","fatal","token","input","offsetAfter","slice","codepoint","isMatch","cp","codePointAt","lengthFromCodePoint","codepoints","firstCodePoint","lastCodePoint","fromCodePoint","parser","res","consume","filter","or","parsers","lastError","concat","optional","star","ts","nextOffset","starConsumed","parser1","parser2","r1","r2","sequence","values","sequenceConsumed","first","x","y","second","plusConsumed","preceded","followed","delimited","open","inner","close","cutAfterOpen","cut","recognize","peek","not","except","match","dispatch","mapping","otherwise","extraOffset","start","end","complete","ParserStateMachine","states","_state","_offset","_input","_states","next","done","withPosition","Object","assign","UNDERSCORE","DASH","PERIOD","DOUBLE_QUOTE","SINGLE_QUOTE","ANGLE_BRACKET_OPEN","ANGLE_BRACKET_CLOSE","AMPERSAND","EQUALS","SQUARE_BRACKET_OPEN","SQUARE_BRACKET_CLOSE","SEMICOLON","PERCENT","PARENTHESIS_OPEN","PARENTHESIS_CLOSE","PLUS","COMMA","QUESTION_MARK","ASTERISK","VERTICAL_BAR","SECT_END","COMMENT_START","COMMENT_END","PI_START","PI_END","ONE_POINT","VERSION","ENCODING","STANDALONE","YES","NO","XML_DECL_START","DOCTYPE_START","SYSTEM","PUBLIC","ETAG_START","EMPTY_ELEMENT_END","CHARREF_START","CHARREF_HEX_START","ELEMENT_DECL_START","EMPTY","ANY","PCDATA","ATTLIST_DECL_START","NOTATION","REQUIRED","IMPLIED","FIXED","ENTITY_DECL_START","NDATA","NOTATION_DECL_START","UPPER_A_CP","UPPER_Z_CP","UPPER_ALPHA","LOWER_A_CP","LOWER_Z_CP","LOWER_ALPHA","DIGIT","HEX_DIGIT","isValidChar","CompleteChars","isValidWhitespace","S","CompleteWhitespace","COLON_CP","UNDERSCORE_CP","isValidNameStartChar","NameStartChar","isValidNameChar","Name","CompleteName","NCName","includes","Nmtoken","CharRef","parseInt","Reference","PEReference","AMPERSAND_CP","EntityValue","DOUBLE_QUOTE_CP","SINGLE_QUOTE_CP","AttValue","ANGLE_BRACKET_OPEN_CP","EntityReplacementTextInLiteral","SystemLiteral","isValidPubidChar","CompletePubidChars","PubidLiteral","CharData","PITarget","toLowerCase","PI","CDStart","CData","CDSect","Eq","VersionNum","VersionInfo","EncName","EncodingDecl","YesOrNo","SDDecl","XMLDecl","e","s","version","encoding","standalone","NameWithPosition","Attribute","STagOrEmptyElemTag","_","isEmpty","ETag","Multiplicity","choice","seq","children","Mixed","elementdecl","StringType","TokenizedType","EnumeratedType","AttType","DefaultDecl","v","fixed","AttDef","isCData","def","AttlistDecl","attdefs","ExternalID","EntityDef","ids","ndata","GEDecl","PEDef","PEDecl","EntityDecl","TextDecl","PublicID","NotationDecl","markupdecl","DeclSep","intSubset","vs","filterUndefined","doctypedecl","_1","_2","_3","content","parseContent","Misc","parseDocument","extParsedEnt","parseFragment","replaceInvalidCharacters","char","matchesCharProduction","truncate","side","max","chars","halfLength","min","throwErrorWithContext","event","line","offsetToCoords","inside","newlineIndexBefore","lastIndexOf","lineBefore","newlineIndexAfter","lineAfter","indent","c","isWhitespace","repeat","highlightError","throwParseError","what","quoted","str","actual","constructReplacementText","replacementText","Dtd","dtd","_attlistByName","Map","_entityReplacementTextByName","_externalEntityNames","_unparsedEntityNames","decl","defByName","isArray","getAttlist","nameEvent","getEntityReplacementText","allowExternal","predefinedEntitiesReplacementText","normalizeAndIncludeEntities","normalized","ancestorEntities","replace","result","normalizeAttributeValue","attDef","splitQualifiedName","cache","fromCache","Namespaces","_byPrefix","_resolve","_parent","_a","getForElement","ns","getForAttribute","fromAttrs","attlist","qualifiedNameCache","hasDeclarations","checkAttr","ROOT_NAMESPACES","default","appendParsedNode","DEFAULT_ENTITY_EXPANSION_MAX_AMPLIFICATION","DEFAULT_ENTITY_EXPANSION_THRESHOLD","parseXml","generator","namespaces","into","entityExpansionMaxAmplification","entityExpansionThreshold","treatCDataAsText","doc","domContext","entityRoot","collectedText","flushCollectedText","text","initialInputLength","normalizeLineEndings","expandedInputLength","topLevelEntityRef","entityContext","entity","iterator","it","ctx","createCDATASection","createComment","implementation","createDocumentType","_b","createProcessingInstruction","hasAttributeNS","parseXmlFragment","Document","resolveNamespacePrefix","parseXmlDocument","NamespacePrefixMap","_nsByPrefix","_prefixCandidatesByNs","candidatesList","recordNamespaceInformation","namespaceUri","definedPrefix","_localPrefixToNamespace","_inheritedPrefixToNamespace","prefixToNamespace","shouldSerializeDeclaration","_getCandidatePrefix","allowDefault","candidates","candidate","getPreferredPrefix","prefixIndex","isAttr","inheritedNs","candidatePrefix","namespaceForPrefix","generatedPrefix","HTML_VOID_ELEMENTS","serializeFragment","requireWellFormed","withFictionalParent","produceXmlSerialization","prefixMap","new","runXmlSerializationAlgorithm","skipEndTag","serializeAttributeValue","localNameSet","declaredNamespaceUri","declaredPrefix","tuple","serializeAttributes","serializeElementNode","serializeDocumentNode","comment","endsWith","serializeCommentNode","cs","serializeCDATASectionNode","markup","serializeTextNode","serializeDocumentFragmentNode","dt","serializeDocumentTypeNode","pi","serializeProcessingInstructionNode","attributeValue","Element","tagName","getAttributeNodeNS","prepend","append","hasAttributes","getAttribute","getAttributeByName","getAttributeNS","getAttributeByNamespaceAndLocalName","setAttribute","setAttributeNS","validatedNamespace","setAttributeValue","removeAttributeByName","removeAttributeNS","removeAttributeByNamespaceAndLocalName","toggleAttribute","force","hasAttribute","getAttributeNode","setAttributeNode","setAttributeNodeNS","removeAttributeNode","getElementsByTagName","getElementsByTagNameNS","copyElement","copyAttribute","innerHTML","outerHTML","throwInUseAttributeError","oldAttr","newAttr","oldAttrElement","replaceAttribute","createElementNS","DOMImplementation","_document","createDocument","XMLDocument","createHTMLDocument","title","htmlElement","headElement","titleElement","documentFragment","DocumentFragment","cdataSection","ProcessingInstruction","importNode","createAttribute","createAttributeNS","createRange","Range","StaticRange","init","forEachNodeContainedInRange","firstChildOutside","extractRange","isClone","originalStartNode","originalStartOffset","originalEndNode","originalEndOffset","clone","startContainsEnd","endContainsStart","firstPartiallyContainedChild","lastPartiallyContainedChild","containedChildren","firstChildAfterStart","firstChildAfterEnd","subrange","setStart","subfragment","detach","containedChild","collapse","commonAncestorContainer","getRootOfRange","compareBoundaryPointPositions","POSITION_AFTER","POSITION_BEFORE","setStartBefore","setStartAfter","setEndBefore","setEndAfter","toStart","selectNode","selectNodeContents","compareBoundaryPoints","how","sourceRange","START_TO_START","START_TO_END","END_TO_END","END_TO_START","deleteContents","nodesToRemove","extractContents","cloneContents","surroundContents","newParent","cloneRange","isPointInRange","comparePoint","intersectsNode","toString","POSITION_EQUAL","nodeA","offsetA","nodeB","offsetB","DOMParser","parseFromString","XMLSerializer","serializeToString","serializeToWellFormedString","MutationObserver","Function","observe","disconnect"],"mappings":"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"}